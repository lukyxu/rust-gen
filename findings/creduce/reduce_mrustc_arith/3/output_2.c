/*
 * AUTOGENERATED by mrustc
 */
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <assert.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <setjmp.h>
typedef uint32_t RUST_CHAR;
typedef uint8_t RUST_BOOL;
typedef struct { void* PTR; size_t META; } SLICE_PTR;
typedef struct { void* PTR; void* META; } TRAITOBJ_PTR;
typedef struct { void (*drop)(void*); size_t size; size_t align; } VTABLE_HDR;
typedef struct { char _d; } tUNIT;
typedef char tBANG;
typedef struct { char _d; } tTYPEID;
static inline size_t ALIGN_TO(size_t s, size_t a) { return (s + a-1) / a * a; }

extern void _Unwind_Resume(void) __attribute__((noreturn));
#define ALIGNOF(t) __alignof__(t)
extern __thread jmp_buf*    mrustc_panic_target;
extern __thread void* mrustc_panic_value;
static inline uint64_t __builtin_clz64(uint64_t v) {
	return ( (v >> 32) != 0 ? __builtin_clz(v>>32) : 32 + __builtin_clz(v));
}
static inline uint64_t __builtin_ctz64(uint64_t v) {
	return ((v&0xFFFFFFFF) == 0 ? __builtin_ctz(v>>32) + 32 : __builtin_ctz(v));
}
static inline uint8_t __mrustc_atomicloop8(volatile uint8_t* slot, uint8_t param, int ordering, uint8_t (*cb)(uint8_t, uint8_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint8_t v = atomic_load_explicit((_Atomic uint8_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint8_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint16_t __mrustc_atomicloop16(volatile uint16_t* slot, uint16_t param, int ordering, uint16_t (*cb)(uint16_t, uint16_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint16_t v = atomic_load_explicit((_Atomic uint16_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint16_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint32_t __mrustc_atomicloop32(volatile uint32_t* slot, uint32_t param, int ordering, uint32_t (*cb)(uint32_t, uint32_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint32_t v = atomic_load_explicit((_Atomic uint32_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint32_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint64_t __mrustc_atomicloop64(volatile uint64_t* slot, uint64_t param, int ordering, uint64_t (*cb)(uint64_t, uint64_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint64_t v = atomic_load_explicit((_Atomic uint64_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint64_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
typedef struct { uint64_t lo, hi; } uint128_t;
typedef struct { uint64_t lo, hi; } int128_t;
static inline float make_float(int is_neg, int exp, uint32_t mantissa_bits) { float rv; uint32_t vi=(mantissa_bits&((1<<23)-1))|((exp+127)<<23);if(is_neg)vi|=1<<31; memcpy(&rv, &vi, 4); return rv; }
static inline double make_double(int is_neg, int exp, uint32_t mantissa_bits) { double rv; uint64_t vi=(mantissa_bits&((1ull<<52)-1))|((uint64_t)(exp+1023)<<52);if(is_neg)vi|=1ull<<63; memcpy(&rv, &vi, 4); return rv; }
static inline uint128_t make128_raw(uint64_t hi, uint64_t lo) { uint128_t rv = { lo, hi }; return rv; }
static inline uint128_t make128(uint64_t v) { uint128_t rv = { v, 0 }; return rv; }
static inline float cast128_float(uint128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint32_t mant = 0; return make_float(0, exp, mant); }
static inline double cast128_double(uint128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint64_t mant = 0; return make_double(0, exp, mant); }
static inline int cmp128(uint128_t a, uint128_t b) { if(a.hi != b.hi) return a.hi < b.hi ? -1 : 1; if(a.lo != b.lo) return a.lo < b.lo ? -1 : 1; return 0; }
static inline bool add128_o(uint128_t a, uint128_t b, uint128_t* o) { o->lo = a.lo + b.lo; o->hi = a.hi + b.hi + (o->lo < a.lo ? 1 : 0); return (o->hi < a.hi); }
static inline bool sub128_o(uint128_t a, uint128_t b, uint128_t* o) { o->lo = a.lo - b.lo; o->hi = a.hi - b.hi - (a.lo < b.lo ? 1 : 0); return (o->hi > a.hi); }
static inline bool mul128_o(uint128_t a, uint128_t b, uint128_t* o) { bool of = false; o->hi = 0; o->lo = 0; for(int i=0;i<128;i++){ uint64_t m = (1ull << (i % 64)); if(a.hi==0&&a.lo<m)   break; if(i>=64&&a.hi<m) break; if( m & (i >= 64 ? a.hi : a.lo) ) of |= add128_o(*o, b, o); b.hi = (b.hi << 1) | (b.lo >> 63); b.lo = (b.lo << 1); } return of;}
static inline bool div128_o(uint128_t a, uint128_t b, uint128_t* q, uint128_t* r) { if(a.hi == 0 && b.hi == 0) { if(q) { q->hi=0; q->lo = a.lo / b.lo; } if(r) { r->hi=0; r->lo = a.lo % b.lo; } return false; } if(cmp128(a, b) < 0) { if(q) { q->hi=0; q->lo=0; } if(r) *r = a; return false; } uint128_t a_div_2 = {(a.lo>>1)|(a.hi << 63), a.hi>>1}; int shift = 0; while( cmp128(a_div_2, b) >= 0 && shift < 128 ) { shift += 1; b.hi = (b.hi<<1)|(b.lo>>63); b.lo <<= 1; } if(shift == 128) return true; uint128_t mask = { /*lo=*/(shift >= 64 ? 0 : (1ull << shift)), /*hi=*/(shift < 64 ? 0 : 1ull << (shift-64)) }; shift ++; if(q) { q->hi = 0; q->lo = 0; } while(shift--) { if( cmp128(a, b) >= 0 ) { if(q) add128_o(*q, mask, q); sub128_o(a, b, &a); } mask.lo = (mask.lo >> 1) | (mask.hi << 63); mask.hi >>= 1; b.lo = (b.lo >> 1) | (b.hi << 63); b.hi >>= 1; } if(r) *r = a; return false;}
static inline uint128_t add128(uint128_t a, uint128_t b) { uint128_t v; add128_o(a, b, &v); return v; }
static inline uint128_t sub128(uint128_t a, uint128_t b) { uint128_t v; sub128_o(a, b, &v); return v; }
static inline uint128_t mul128(uint128_t a, uint128_t b) { uint128_t v; mul128_o(a, b, &v); return v; }
static inline uint128_t div128(uint128_t a, uint128_t b) { uint128_t v; div128_o(a, b, &v, NULL); return v; }
static inline uint128_t mod128(uint128_t a, uint128_t b) { uint128_t v; div128_o(a, b, NULL, &v); return v;}
static inline uint128_t and128(uint128_t a, uint128_t b) { uint128_t v = { a.lo & b.lo, a.hi & b.hi }; return v; }
static inline uint128_t or128 (uint128_t a, uint128_t b) { uint128_t v = { a.lo | b.lo, a.hi | b.hi }; return v; }
static inline uint128_t xor128(uint128_t a, uint128_t b) { uint128_t v = { a.lo ^ b.lo, a.hi ^ b.hi }; return v; }
static inline uint128_t shl128(uint128_t a, uint32_t b) { uint128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = a.lo << b; v.hi = (a.hi << b) | (a.lo >> (64 - b)); } else { v.hi = a.lo << (b - 64); v.lo = 0; } return v; }
static inline uint128_t shr128(uint128_t a, uint32_t b) { uint128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = (a.lo >> b)|(a.hi << (64 - b)); v.hi = a.hi >> b; } else { v.lo = a.hi >> (b - 64); v.hi = 0; } return v; }
static inline uint128_t popcount128(uint128_t a) { uint128_t v = { __builtin_popcountll(a.lo) + __builtin_popcountll(a.hi), 0 }; return v; }
static inline uint128_t __builtin_bswap128(uint128_t v) { uint128_t rv = { __builtin_bswap64(v.hi), __builtin_bswap64(v.lo) }; return rv; }
static inline uint128_t intrinsic_ctlz_u128(uint128_t v) {
	uint128_t rv = { (v.hi != 0 ? __builtin_clz64(v.hi) : (v.lo != 0 ? 64 + __builtin_clz64(v.lo) : 128)), 0 };
	return rv;
}
static inline uint128_t intrinsic_cttz_u128(uint128_t v) {
	uint128_t rv = { (v.lo == 0 ? (v.hi == 0 ? 128 : __builtin_ctz64(v.hi) + 64) : __builtin_ctz64(v.lo)), 0 };
	return rv;
}
static inline int128_t make128s_raw(uint64_t hi, uint64_t lo) { int128_t rv = { lo, hi }; return rv; }
static inline int128_t make128s(int64_t v) { int128_t rv = { v, (v < 0 ? -1 : 0) }; return rv; }
static inline int128_t neg128s(int128_t v) { int128_t rv = { ~v.lo+1, ~v.hi + (v.lo == 0) }; return rv; }
static inline float cast128s_float(int128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint32_t mant = 0; return make_float(0, exp, mant); }
static inline double cast128s_double(int128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint64_t mant = 0; return make_double(0, exp, mant); }
static inline int cmp128s(int128_t a, int128_t b) { if(a.hi != b.hi) return (int64_t)a.hi < (int64_t)b.hi ? -1 : 1; if(a.lo != b.lo) return a.lo < b.lo ? -1 : 1; return 0; }
static inline bool add128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna=a.hi>>63; bool sgnb=b.hi>>63; add128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); bool sgno = o->hi>>63; return (sgna==sgnb && sgno != sgna); }
static inline bool sub128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna=a.hi>>63; bool sgnb=b.hi>>63; sub128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); bool sgno = o->hi>>63; return (sgna!=sgnb && sgno != sgna); }
static inline bool mul128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna = (a.hi >> 63); bool sgnb = (b.hi >> 63); if(sgna) a = neg128s(a); if(sgnb) b = neg128s(b); bool rv = mul128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); if(sgnb != sgnb) *o = neg128s(*o); return rv; }
static inline bool div128s_o(int128_t a, int128_t b, int128_t* q, int128_t* r) { bool sgna = a.hi & (1ull<<63); bool sgnb = b.hi & (1ull<<63); if(sgna) { a.hi = ~a.hi; a.lo = ~a.lo; a.lo += 1; if(a.lo == 0) a.hi += 1; } if(sgnb) { b.hi = ~b.hi; b.lo = ~b.lo; b.lo += 1; if(b.lo == 0) b.hi += 1; } bool rv = div128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)q, (uint128_t*)r); if(sgnb != sgnb) { r->hi = ~r->hi; r->lo = ~r->lo; r->lo += 1; if(r->lo == 0) r->hi += 1; } return rv; }
static inline int128_t add128s(int128_t a, int128_t b) { int128_t v; add128s_o(a, b, &v); return v; }
static inline int128_t sub128s(int128_t a, int128_t b) { int128_t v; sub128s_o(a, b, &v); return v; }
static inline int128_t mul128s(int128_t a, int128_t b) { int128_t v; mul128s_o(a, b, &v); return v; }
static inline int128_t div128s(int128_t a, int128_t b) { int128_t v; div128s_o(a, b, &v, NULL); return v; }
static inline int128_t mod128s(int128_t a, int128_t b) { int128_t v; div128s_o(a, b, NULL, &v); return v; }
static inline int128_t and128s(int128_t a, int128_t b) { int128_t v = { a.lo & b.lo, a.hi & b.hi }; return v; }
static inline int128_t or128s (int128_t a, int128_t b) { int128_t v = { a.lo | b.lo, a.hi | b.hi }; return v; }
static inline int128_t xor128s(int128_t a, int128_t b) { int128_t v = { a.lo ^ b.lo, a.hi ^ b.hi }; return v; }
static inline int128_t shl128s(int128_t a, uint32_t b) { int128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = a.lo << b; v.hi = (a.hi << b) | (a.lo >> (64 - b)); } else { v.hi = a.lo << (b - 64); v.lo = 0; } return v; }
static inline int128_t shr128s(int128_t a, uint32_t b) { int128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = (a.lo >> b)|(a.hi << (64 - b)); v.hi = (int64_t)a.hi >> b; } else { v.lo = (int64_t)a.hi >> (b - 64); v.hi = (int64_t)a.hi < 0 ? -1 : 0; } return v; }

static inline int slice_cmp(SLICE_PTR l, SLICE_PTR r) {
	int rv = memcmp(l.PTR, r.PTR, l.META < r.META ? l.META : r.META);
	if(rv != 0) return rv;
	if(l.META < r.META) return -1;
	if(l.META > r.META) return 1;
	return 0;
}
static inline SLICE_PTR make_sliceptr(void* ptr, size_t s) { SLICE_PTR rv = { ptr, s }; return rv; }
static inline TRAITOBJ_PTR make_traitobjptr(void* ptr, void* vt) { TRAITOBJ_PTR rv = { ptr, vt }; return rv; }

static inline size_t mrustc_max(size_t a, size_t b) { return a < b ? b : a; }
static inline void noop_drop(tUNIT *p) { }

static inline size_t mrustc_string_search_linear(SLICE_PTR val, size_t count, SLICE_PTR* options) {
	for(size_t i = 0; i < count; i ++) {
		int cmp = slice_cmp(val, options[i]);
		if(cmp < 0) break;
		if(cmp == 0) return i;
	}
	return SIZE_MAX;
}
static const uint8_t __mrustc_revmap[16] = { 0, 8, 4,12, 2,10, 6,14,  1, 9, 5,13, 3, 7,15};
static inline uint8_t __mrustc_bitrev8(uint8_t v) { if(v==0||v==0xFF) return v; return __mrustc_revmap[v>>4]|(__mrustc_revmap[v&15]<<4); }
static inline uint16_t __mrustc_bitrev16(uint16_t v) { if(v==0) return 0; return ((uint16_t)__mrustc_bitrev8(v>>8))|((uint16_t)__mrustc_bitrev8(v)<<8); }
static inline uint32_t __mrustc_bitrev32(uint32_t v) { if(v==0) return 0; return ((uint32_t)__mrustc_bitrev16(v>>16))|((uint32_t)__mrustc_bitrev16(v)<<16); }
static inline uint64_t __mrustc_bitrev64(uint64_t v) { if(v==0) return 0; return ((uint64_t)__mrustc_bitrev32(v>>32))|((uint64_t)__mrustc_bitrev32(v)<<32); }
static inline uint128_t __mrustc_bitrev128(uint128_t v) { uint128_t rv = { __mrustc_bitrev64(v.hi), __mrustc_bitrev64(v.lo) }; return rv; }
static inline uint8_t __mrustc_op_umax8(uint8_t a, uint8_t b) { return (a > b ? a : b); }
static inline uint8_t __mrustc_op_umin8(uint8_t a, uint8_t b) { return (a < b ? a : b); }
static inline uint8_t __mrustc_op_imax8(uint8_t a, uint8_t b) { return ((int8_t)a > (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_imin8(uint8_t a, uint8_t b) { return ((int8_t)a < (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_and_not8(uint8_t a, uint8_t b) { return ~(a & b); }
static inline uint16_t __mrustc_op_umax16(uint16_t a, uint16_t b) { return (a > b ? a : b); }
static inline uint16_t __mrustc_op_umin16(uint16_t a, uint16_t b) { return (a < b ? a : b); }
static inline uint16_t __mrustc_op_imax16(uint16_t a, uint16_t b) { return ((int16_t)a > (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_imin16(uint16_t a, uint16_t b) { return ((int16_t)a < (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_and_not16(uint16_t a, uint16_t b) { return ~(a & b); }
static inline uint32_t __mrustc_op_umax32(uint32_t a, uint32_t b) { return (a > b ? a : b); }
static inline uint32_t __mrustc_op_umin32(uint32_t a, uint32_t b) { return (a < b ? a : b); }
static inline uint32_t __mrustc_op_imax32(uint32_t a, uint32_t b) { return ((int32_t)a > (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_imin32(uint32_t a, uint32_t b) { return ((int32_t)a < (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_and_not32(uint32_t a, uint32_t b) { return ~(a & b); }
static inline uint64_t __mrustc_op_umax64(uint64_t a, uint64_t b) { return (a > b ? a : b); }
static inline uint64_t __mrustc_op_umin64(uint64_t a, uint64_t b) { return (a < b ? a : b); }
static inline uint64_t __mrustc_op_imax64(uint64_t a, uint64_t b) { return ((int64_t)a > (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_imin64(uint64_t a, uint64_t b) { return ((int64_t)a < (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_and_not64(uint64_t a, uint64_t b) { return ~(a & b); }
struct s_ZRG2cE9core0_0_03fmt4Void0g;
struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g;
struct s_ZRG2cE9core0_0_03fmt9Formatter0g;
typedef struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  (*t_ZRTF2BsG2cE9core0_0_03fmt4Void0gBuG2c_A_B9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g )( struct s_ZRG2cE9core0_0_03fmt4Void0g *, struct s_ZRG2cE9core0_0_03fmt9Formatter0g * ); // extern "Rust" fn(&::"core-0_0_0"::fmt::Void/*S*/, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
// struct ::"core-0_0_0"::fmt::ArgumentV1
struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  {
	struct s_ZRG2cE9core0_0_03fmt4Void0g *_0; // &::"core-0_0_0"::fmt::Void/*S*/
	t_ZRTF2BsG2cE9core0_0_03fmt4Void0gBuG2c_A_B9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g _1; // extern "Rust" fn(&::"core-0_0_0"::fmt::Void/*S*/, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_03fmt10ArgumentV10g[ (sizeof(struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_03fmt10ArgumentV10g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g) == 8) ? 1 : -1 ];
typedef struct t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g  { struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  DATA[1]; } t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g ; // [::"core-0_0_0"::fmt::ArgumentV1/*S*/; 1]
 // (i16, bool, )
typedef struct TUP_2_ZRTCd_ZRTCw  {
	RUST_BOOL _1; // bool
	int16_t _0; // i16
} TUP_2_ZRTCd_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCd_ZRTCw [ (sizeof(TUP_2_ZRTCd_ZRTCw ) == 4) ? 1 : -1 ];
 // (i64, bool, )
typedef struct TUP_2_ZRTCh_ZRTCw  {
	RUST_BOOL _1; // bool
	int64_t _0; // i64
} TUP_2_ZRTCh_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCh_ZRTCw [ (sizeof(TUP_2_ZRTCh_ZRTCw ) == 16) ? 1 : -1 ];
 // (i8, bool, )
typedef struct TUP_2_ZRTCb_ZRTCw  {
	int8_t _0; // i8
	RUST_BOOL _1; // bool
} TUP_2_ZRTCb_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCb_ZRTCw [ (sizeof(TUP_2_ZRTCb_ZRTCw ) == 2) ? 1 : -1 ];
 // (i32, bool, )
typedef struct TUP_2_ZRTCf_ZRTCw  {
	RUST_BOOL _1; // bool
	int32_t _0; // i32
} TUP_2_ZRTCf_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCf_ZRTCw [ (sizeof(TUP_2_ZRTCf_ZRTCw ) == 8) ? 1 : -1 ];
 // (i128, bool, )
typedef struct TUP_2_ZRTCj_ZRTCw  {
	RUST_BOOL _1; // bool
	int128_t _0; // i128
} TUP_2_ZRTCj_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCj_ZRTCw [ (sizeof(TUP_2_ZRTCj_ZRTCw ) == 24) ? 1 : -1 ];
 // (isize, bool, )
typedef struct TUP_2_ZRTCv_ZRTCw  {
	RUST_BOOL _1; // bool
	intptr_t _0; // isize
} TUP_2_ZRTCv_ZRTCw ;
typedef char sizeof_assert_TUP_2_ZRTCv_ZRTCw [ (sizeof(TUP_2_ZRTCv_ZRTCw ) == 16) ? 1 : -1 ];
// struct ::"core-0_0_0"::option::Option#Some<&[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g  {
	SLICE_PTR _0; // &[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/]
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<&[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>
struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g {
	struct {
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g var_1;
	} DATA;};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g) == 16) ? 1 : -1 ];
// struct ::"core-0_0_0"::fmt::Arguments
struct s_ZRG2cE9core0_0_03fmt9Arguments0g  {
	SLICE_PTR _0; // &[&str]
	struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g _1; // ::"core-0_0_0"::option::Option<&[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>/*E*/
	SLICE_PTR _2; // &[::"core-0_0_0"::fmt::ArgumentV1/*S*/]
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_03fmt9Arguments0g[ (sizeof(struct s_ZRG2cE9core0_0_03fmt9Arguments0g) == 48) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_03fmt9Arguments0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt9Arguments0g) == 8) ? 1 : -1 ];
typedef void (*t_ZRTF0T0 )(void); // extern "Rust" fn() -> ()
// struct ::"std-0_0_0"::rt::closure#lang_start_0<(),>
struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0  {
	t_ZRTF0T0 _0; // extern "Rust" fn() -> ()
} ;
typedef char sizeof_assert_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0[ (sizeof(struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0) == 8) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0[ (ALIGNOF(struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0) == 8) ? 1 : -1 ];
typedef struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  (*t_ZRTF2BsCiBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g )( uint128_t *, struct s_ZRG2cE9core0_0_03fmt9Formatter0g * ); // extern "Rust" fn(&u128, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
// struct ::"core-0_0_0"::result::Result#Ok<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g  {
	uint8_t _1; // u8
	// ZST; // ()
} __attribute__((__aligned__(1),)) ;
typedef char sizeof_assert_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g[ (sizeof(struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
// struct ::"core-0_0_0"::fmt::Error
struct s_ZRG2cE9core0_0_03fmt5Error0g  {
	char _d;
} __attribute__((__aligned__(1),)) ;
typedef char alignof_assert_ZRG2cE9core0_0_03fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt5Error0g) == 1) ? 1 : -1 ];
// struct ::"core-0_0_0"::result::Result#Err<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g  {
	uint8_t _1; // u8
	// ZST; // ::"core-0_0_0"::fmt::Error/*S*/
} __attribute__((__aligned__(1),)) ;
typedef char sizeof_assert_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g[ (sizeof(struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
// enum ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g {
	union {
		struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g var_0;
		struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g[ (sizeof(struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef struct t_ZRTA2BsCy  { SLICE_PTR  DATA[2]; } t_ZRTA2BsCy ; // [&str; 2]
typedef void (*t_ZRTF1PoT0T0 )( tUNIT * ); // extern "Rust" fn(*move (), ) -> ()
typedef int32_t  (*t_ZRTFeE8rustcall2BsT0T0Cf )( tUNIT *, tUNIT  ); // extern "rust-call" fn(&(), (), ) -> i32
typedef int32_t  (*t_ZRTFeE8rustcall2BuT0T0Cf )( tUNIT *, tUNIT  ); // extern "rust-call" fn(&mut (), (), ) -> i32
// struct ::"core-0_0_0"::ops::function::Fn#vtable<(),i32,>
struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf  {
	t_ZRTF1PoT0T0 _0; // extern "Rust" fn(*move (), ) -> ()
	uintptr_t _1; // usize
	uintptr_t _2; // usize
	t_ZRTFeE8rustcall2BsT0T0Cf _3; // extern "rust-call" fn(&(), (), ) -> i32
	t_ZRTFeE8rustcall2BuT0T0Cf _4; // extern "rust-call" fn(&mut (), (), ) -> i32
} ;
typedef char sizeof_assert_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf[ (sizeof(struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf) == 40) ? 1 : -1 ];
typedef char alignof_assert_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf[ (ALIGNOF(struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf) == 8) ? 1 : -1 ];
// PROTO extern "Rust" ::"bin#"::main
void  ZRG1cD3bin4main0g(void);
// PROTO extern "Rust" ::"std-0_0_0"::rt::lang_start
static intptr_t  ZRG2cD8std0_0_02rt10lang_start0g(
		t_ZRTF0T0 arg0,
		intptr_t arg1,
		uint8_t **arg2
		);
// PROTO extern "Rust" <isize /*- */>::overflowing_div
static TUP_2_ZRTCv_ZRTCw  ZRICv15overflowing_div0g(
		intptr_t arg0,
		intptr_t arg1
		);
// PROTO extern "Rust" <isize /*- */>::overflowing_rem
static TUP_2_ZRTCv_ZRTCw  ZRICv15overflowing_rem0g(
		intptr_t arg0,
		intptr_t arg1
		);
// PROTO extern "Rust" <i8 /*- */>::overflowing_div
static TUP_2_ZRTCb_ZRTCw  ZRICb15overflowing_div0g(
		int8_t arg0,
		int8_t arg1
		);
// PROTO extern "Rust" <i8 /*- */>::overflowing_rem
static TUP_2_ZRTCb_ZRTCw  ZRICb15overflowing_rem0g(
		int8_t arg0,
		int8_t arg1
		);
// PROTO extern "Rust" <i16 /*- */>::overflowing_div
static TUP_2_ZRTCd_ZRTCw  ZRICd15overflowing_div0g(
		int16_t arg0,
		int16_t arg1
		);
// PROTO extern "Rust" <i16 /*- */>::overflowing_rem
static TUP_2_ZRTCd_ZRTCw  ZRICd15overflowing_rem0g(
		int16_t arg0,
		int16_t arg1
		);
// PROTO extern "Rust" <i32 /*- */>::overflowing_div
static TUP_2_ZRTCf_ZRTCw  ZRICf15overflowing_div0g(
		int32_t arg0,
		int32_t arg1
		);
// PROTO extern "Rust" <i32 /*- */>::overflowing_rem
static TUP_2_ZRTCf_ZRTCw  ZRICf15overflowing_rem0g(
		int32_t arg0,
		int32_t arg1
		);
// PROTO extern "Rust" <i64 /*- */>::overflowing_div
static TUP_2_ZRTCh_ZRTCw  ZRICh15overflowing_div0g(
		int64_t arg0,
		int64_t arg1
		);
// PROTO extern "Rust" <i64 /*- */>::overflowing_rem
static TUP_2_ZRTCh_ZRTCw  ZRICh15overflowing_rem0g(
		int64_t arg0,
		int64_t arg1
		);
// PROTO extern "Rust" <i128 /*- */>::overflowing_div
static TUP_2_ZRTCj_ZRTCw  ZRICj15overflowing_div0g(
		int128_t arg0,
		int128_t arg1
		);
// PROTO extern "Rust" <i128 /*- */>::overflowing_rem
static TUP_2_ZRTCj_ZRTCw  ZRICj15overflowing_rem0g(
		int128_t arg0,
		int128_t arg1
		);
// PROTO extern "Rust" <::"core-0_0_0"::fmt::ArgumentV1/*S*/ /*- */>::new<u128,>
static struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gCi(
		uint128_t *arg0,
		t_ZRTF2BsCiBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g arg1
		);
// PROTO extern "Rust" <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ /*- */>::#drop_glue
static void  ZRIG2cD8std0_0_02rtH19closurelang_start_01gT0A9drop_glue0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0
		);
// PROTO extern "Rust" <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::call
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT04call0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		);
// PROTO extern "Rust" <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(),>>::call_mut
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function5FnMut1gT08call_mut0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		);
// PROTO extern "Rust" <() as ::"std-0_0_0"::process::Termination>::report
static int32_t  ZRQT02cD8std0_0_07process11Termination0g6report0g(
		tUNIT arg0
		);
// EXTERN extern "Rust" ::"std-0_0_0"::io::stdio::_print
extern void  ZRG3cD8std0_0_02io5stdio6_print0g(
		struct s_ZRG2cE9core0_0_03fmt9Arguments0g arg0
		);
// EXTERN extern "Rust" ::"std-0_0_0"::rt::lang_start_internal
extern intptr_t  ZRG2cD8std0_0_02rt19lang_start_internal0g(
		TRAITOBJ_PTR arg0,
		intptr_t arg1,
		uint8_t **arg2
		);
// EXTERN extern "Rust" <u128 as ::"core-0_0_0"::fmt::Display>::fmt
extern struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  ZRQCi2cE9core0_0_03fmt7Display0g_B0g(
		uint128_t *arg0,
		struct s_ZRG2cE9core0_0_03fmt9Formatter0g *arg1
		);
union u_static_ZRG2cD3binB_09FRAGMENTS0g{ t_ZRTA2BsCy val; uintptr_t raw[4]; } ZRG2cD3binB_09FRAGMENTS0g;	// static ::"bin#"::#0::FRAGMENTS : [&str; 2]
__attribute__((weak)) union u_static_ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g{ struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf val; uintptr_t raw[5]; } ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g;	// static <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::vtable# : ::"core-0_0_0"::ops::function::Fn#vtable<(),i32,>/*S*/
union u_static_ZRG2cD3binB_09FRAGMENTS0g ZRG2cD3binB_09FRAGMENTS0g = { .raw = {(uintptr_t)"",0x0ull,(uintptr_t)"\n",0x1ull} };	// static ::"bin#"::#0::FRAGMENTS : [&str; 2] = 0010000000000000 0000000000000000 0010000000000000 0100000000000000{@0x0+8 = "", @0x10+8 = "\n"}
union u_static_ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g = { .raw = {(uintptr_t)&ZRIG2cD8std0_0_02rtH19closurelang_start_01gT0A9drop_glue0g,0x8ull,0x8ull,(uintptr_t)&ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT04call0g,(uintptr_t)&ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function5FnMut1gT08call_mut0g} };	// static <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::vtable# : ::"core-0_0_0"::ops::function::Fn#vtable<(),i32,>/*S*/ = 0010000000000000 0800000000000000 0800000000000000 0010000000000000 0010000000000000{@0x0+8 = &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ /*- */>::#drop_glue, @0x18+8 = &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::call, @0x20+8 = &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(),>>::call_mut}
// ::"bin#"::main
void  ZRG1cD3bin4main0g(void)
{
	tUNIT rv;
	uint128_t var0;	// u128
	int32_t var1;	// i32
	uint32_t var2;	// u32
	uint128_t var3;	// u128
	int8_t var4;	// i8
	int32_t var5;	// i32
	uint32_t var6;	// u32
	uint8_t var7;	// u8
	int8_t var8;	// i8
	uint128_t var9;	// u128
	int16_t var10;	// i16
	uint16_t var11;	// u16
	int8_t var12;	// i8
	int16_t var13;	// i16
	uint128_t var14;	// u128
	int32_t var15;	// i32
	int16_t var16;	// i16
	uint16_t var17;	// u16
	uint16_t var18;	// u16
	int8_t var19;	// i8
	int128_t var20;	// i128
	int8_t var21;	// i8
	uint32_t var22;	// u32
	uint16_t var23;	// u16
	uint16_t var24;	// u16
	uint32_t var25;	// u32
	int32_t var26;	// i32
	uintptr_t var27;	// usize
	int128_t var28;	// i128
	int128_t var29;	// i128
	int16_t var30;	// i16
	uint64_t var31;	// u64
	intptr_t var32;	// isize
	int32_t var33;	// i32
	uint32_t var34;	// u32
	int128_t var35;	// i128
	uint64_t var36;	// u64
	int8_t var37;	// i8
	int16_t var38;	// i16
	uint16_t var39;	// u16
	int8_t var40;	// i8
	uint32_t var41;	// u32
	int8_t var42;	// i8
	int16_t var43;	// i16
	int16_t var44;	// i16
	uint16_t var45;	// u16
	uint16_t var46;	// u16
	uint32_t var47;	// u32
	int128_t var48;	// i128
	uint32_t var49;	// u32
	int16_t var50;	// i16
	uint32_t var51;	// u32
	int16_t var52;	// i16
	uintptr_t var53;	// usize
	uint8_t var54;	// u8
	intptr_t var55;	// isize
	int32_t var56;	// i32
	uint128_t var57;	// u128
	RUST_BOOL var58;	// bool
	int8_t var59;	// i8
	int16_t var60;	// i16
	uint32_t var61;	// u32
	int8_t var62;	// i8
	uint8_t var63;	// u8
	intptr_t var64;	// isize
	int128_t var65;	// i128
	uint16_t var66;	// u16
	uint32_t var67;	// u32
	uint16_t var68;	// u16
	uint8_t var69;	// u8
	int16_t var70;	// i16
	uint32_t var71;	// u32
	int16_t var72;	// i16
	int8_t var73;	// i8
	uint64_t var74;	// u64
	int16_t var75;	// i16
	uintptr_t var76;	// usize
	uint8_t var77;	// u8
	uint8_t var78;	// u8
	uint32_t var79;	// u32
	int8_t var80;	// i8
	uint8_t var81;	// u8
	uint128_t var82;	// u128
	int32_t var83;	// i32
	int32_t var84;	// i32
	int8_t var85;	// i8
	int32_t var86;	// i32
	uint8_t var87;	// u8
	int32_t var88;	// i32
	int32_t var89;	// i32
	int32_t var90;	// i32
	int8_t var91;	// i8
	uint32_t var92;	// u32
	int8_t var93;	// i8
	int32_t var94;	// i32
	uint32_t var95;	// u32
	uint8_t var96;	// u8
	uint8_t var97;	// u8
	uint16_t var98;	// u16
	uint8_t var99;	// u8
	int8_t var100;	// i8
	uint64_t var101;	// u64
	uint64_t var102;	// u64
	uint8_t var103;	// u8
	int16_t var104;	// i16
	uint16_t var105;	// u16
	uint16_t var106;	// u16
	int128_t var107;	// i128
	uint32_t var108;	// u32
	intptr_t var109;	// isize
	uint8_t var110;	// u8
	int8_t var111;	// i8
	uintptr_t var112;	// usize
	intptr_t var113;	// isize
	uintptr_t var114;	// usize
	int128_t var115;	// i128
	uint16_t var116;	// u16
	uint8_t var117;	// u8
	uint8_t var118;	// u8
	int8_t var119;	// i8
	uint8_t var120;	// u8
	uint16_t var121;	// u16
	int32_t var122;	// i32
	int8_t var123;	// i8
	uint16_t var124;	// u16
	int32_t var125;	// i32
	uint8_t var126;	// u8
	uint32_t var127;	// u32
	int8_t var128;	// i8
	uint8_t var129;	// u8
	uint8_t var130;	// u8
	uint16_t var131;	// u16
	uint128_t var132;	// u128
	uint64_t var133;	// u64
	uint16_t var134;	// u16
	uint16_t var135;	// u16
	int128_t var136;	// i128
	uint64_t var137;	// u64
	uint64_t var138;	// u64
	int64_t var139;	// i64
	int8_t var140;	// i8
	uint32_t var141;	// u32
	int16_t var142;	// i16
	int8_t var143;	// i8
	uint128_t var144;	// u128
	int32_t var145;	// i32
	int8_t var146;	// i8
	uint8_t var147;	// u8
	int64_t var148;	// i64
	uint16_t var149;	// u16
	uint64_t var150;	// u64
	uint8_t var151;	// u8
	uint32_t var152;	// u32
	uint16_t var153;	// u16
	uint16_t var154;	// u16
	uint64_t var155;	// u64
	uint64_t var156;	// u64
	uint32_t var157;	// u32
	int32_t var158;	// i32
	uint8_t var159;	// u8
	uint128_t var160;	// u128
	uintptr_t var161;	// usize
	uint16_t var162;	// u16
	uint32_t var163;	// u32
	int64_t var164;	// i64
	int128_t var165;	// i128
	uint16_t var166;	// u16
	uint16_t var167;	// u16
	uint32_t var168;	// u32
	uint16_t var169;	// u16
	int8_t var170;	// i8
	int8_t var171;	// i8
	int8_t var172;	// i8
	int32_t var173;	// i32
	intptr_t var174;	// isize
	uint8_t var175;	// u8
	uint32_t var176;	// u32
	uint32_t var177;	// u32
	uint8_t var178;	// u8
	int32_t var179;	// i32
	uint8_t var180;	// u8
	int16_t var181;	// i16
	int8_t var182;	// i8
	int64_t var183;	// i64
	int8_t var184;	// i8
	int16_t var185;	// i16
	uint64_t var186;	// u64
	uint8_t var187;	// u8
	int32_t var188;	// i32
	uint16_t var189;	// u16
	int16_t var190;	// i16
	uint16_t var191;	// u16
	uint64_t var192;	// u64
	uint32_t var193;	// u32
	int128_t var194;	// i128
	int64_t var195;	// i64
	uint64_t var196;	// u64
	uint8_t var197;	// u8
	uint8_t var198;	// u8
	uint128_t var199;	// u128
	uint8_t var200;	// u8
	uint8_t var201;	// u8
	uint8_t var202;	// u8
	int128_t var203;	// i128
	RUST_BOOL var204;	// bool
	uintptr_t var205;	// usize
	int8_t var206;	// i8
	int16_t var207;	// i16
	uint32_t var208;	// u32
	uint32_t var209;	// u32
	int16_t var210;	// i16
	int8_t var211;	// i8
	uint8_t var212;	// u8
	uint16_t var213;	// u16
	uint16_t var214;	// u16
	RUST_BOOL var215;	// bool
	uint8_t var216;	// u8
	int32_t var217;	// i32
	int8_t var218;	// i8
	int8_t var219;	// i8
	uint32_t var220;	// u32
	uint16_t var221;	// u16
	uint16_t var222;	// u16
	uint8_t var223;	// u8
	int8_t var224;	// i8
	uint32_t var225;	// u32
	uint8_t var226;	// u8
	int16_t var227;	// i16
	intptr_t var228;	// isize
	int32_t var229;	// i32
	int32_t var230;	// i32
	uint16_t var231;	// u16
	uintptr_t var232;	// usize
	int8_t var233;	// i8
	uintptr_t var234;	// usize
	int128_t var235;	// i128
	uint16_t var236;	// u16
	intptr_t var237;	// isize
	int32_t var238;	// i32
	intptr_t var239;	// isize
	int32_t var240;	// i32
	uint32_t var241;	// u32
	int8_t var242;	// i8
	uint32_t var243;	// u32
	int32_t var244;	// i32
	intptr_t var245;	// isize
	int16_t var246;	// i16
	uint32_t var247;	// u32
	int32_t var248;	// i32
	uint16_t var249;	// u16
	int128_t var250;	// i128
	int8_t var251;	// i8
	int8_t var252;	// i8
	uint16_t var253;	// u16
	int16_t var254;	// i16
	int16_t var255;	// i16
	int32_t var256;	// i32
	uint8_t var257;	// u8
	uint16_t var258;	// u16
	uint8_t var259;	// u8
	uint32_t var260;	// u32
	uint32_t var261;	// u32
	intptr_t var262;	// isize
	uint16_t var263;	// u16
	int8_t var264;	// i8
	uint32_t var265;	// u32
	uint32_t var266;	// u32
	uintptr_t var267;	// usize
	uint16_t var268;	// u16
	int32_t var269;	// i32
	int8_t var270;	// i8
	uint64_t var271;	// u64
	int16_t var272;	// i16
	uintptr_t var273;	// usize
	uint16_t var274;	// u16
	uint8_t var275;	// u8
	uint32_t var276;	// u32
	uint32_t var277;	// u32
	uint16_t var278;	// u16
	uint16_t var279;	// u16
	uint128_t var280;	// u128
	int32_t var281;	// i32
	int8_t var282;	// i8
	uint8_t var283;	// u8
	uintptr_t var284;	// usize
	uint32_t var285;	// u32
	int16_t var286;	// i16
	int8_t var287;	// i8
	uint16_t var288;	// u16
	uintptr_t var289;	// usize
	int16_t var290;	// i16
	int16_t var291;	// i16
	uint128_t var292;	// u128
	int16_t var293;	// i16
	int8_t var294;	// i8
	uint32_t var295;	// u32
	int16_t var296;	// i16
	uint8_t var297;	// u8
	intptr_t var298;	// isize
	uint16_t var299;	// u16
	uint8_t var300;	// u8
	uint32_t var301;	// u32
	int16_t var302;	// i16
	uint64_t var303;	// u64
	int8_t var304;	// i8
	uint16_t var305;	// u16
	uint32_t var306;	// u32
	int128_t var307;	// i128
	uint128_t var308;	// u128
	int32_t var309;	// i32
	int16_t var310;	// i16
	uint16_t var311;	// u16
	int32_t var312;	// i32
	int128_t var313;	// i128
	uint32_t var314;	// u32
	int32_t var315;	// i32
	int32_t var316;	// i32
	int16_t var317;	// i16
	int16_t var318;	// i16
	int16_t var319;	// i16
	int16_t var320;	// i16
	int32_t var321;	// i32
	intptr_t var322;	// isize
	uint16_t var323;	// u16
	uint128_t var324;	// u128
	uint8_t var325;	// u8
	int8_t var326;	// i8
	uint8_t var327;	// u8
	int8_t var328;	// i8
	int8_t var329;	// i8
	uint32_t var330;	// u32
	int64_t var331;	// i64
	uint32_t var332;	// u32
	uint16_t var333;	// u16
	uint8_t var334;	// u8
	uint32_t var335;	// u32
	uint64_t var336;	// u64
	uint32_t var337;	// u32
	uint8_t var338;	// u8
	uint128_t var339;	// u128
	uint8_t var340;	// u8
	uint32_t var341;	// u32
	int8_t var342;	// i8
	int64_t var343;	// i64
	uint8_t var344;	// u8
	uint32_t var345;	// u32
	uintptr_t var346;	// usize
	uint32_t var347;	// u32
	uint16_t var348;	// u16
	int8_t var349;	// i8
	uint16_t var350;	// u16
	uint16_t var351;	// u16
	uint16_t var352;	// u16
	uint32_t var353;	// u32
	uint16_t var354;	// u16
	int64_t var355;	// i64
	intptr_t var356;	// isize
	int16_t var357;	// i16
	RUST_BOOL var358;	// bool
	uint128_t var359;	// u128
	uint128_t var360;	// u128
	int128_t var361;	// i128
	int32_t var362;	// i32
	uint8_t var363;	// u8
	int32_t var364;	// i32
	uint8_t var365;	// u8
	uint16_t var366;	// u16
	int64_t var367;	// i64
	uint16_t var368;	// u16
	int32_t var369;	// i32
	int16_t var370;	// i16
	int32_t var371;	// i32
	uintptr_t var372;	// usize
	int8_t var373;	// i8
	uint16_t var374;	// u16
	uint16_t var375;	// u16
	uint128_t var376;	// u128
	int16_t var377;	// i16
	uint16_t var378;	// u16
	uint8_t var379;	// u8
	uintptr_t var380;	// usize
	int32_t var381;	// i32
	uint16_t var382;	// u16
	int32_t var383;	// i32
	int8_t var384;	// i8
	int32_t var385;	// i32
	uint8_t var386;	// u8
	uint128_t var387;	// u128
	uint128_t var388;	// u128
	uint128_t var389;	// u128
	int16_t var390;	// i16
	uint16_t var391;	// u16
	RUST_BOOL var392;	// bool
	int64_t var393;	// i64
	uintptr_t var394;	// usize
	int16_t var395;	// i16
	int32_t var396;	// i32
	uint32_t var397;	// u32
	int16_t var398;	// i16
	uint8_t var399;	// u8
	uint32_t var400;	// u32
	uint128_t var401;	// u128
	int8_t var402;	// i8
	uint16_t var403;	// u16
	uint128_t var404;	// u128
	int8_t var405;	// i8
	uint64_t var406;	// u64
	int32_t var407;	// i32
	uint128_t var408;	// u128
	uint64_t var409;	// u64
	int16_t var410;	// i16
	uint8_t var411;	// u8
	intptr_t var412;	// isize
	int64_t var413;	// i64
	uint32_t var414;	// u32
	int16_t var415;	// i16
	int16_t var416;	// i16
	uint16_t var417;	// u16
	uint32_t var418;	// u32
	uint8_t var419;	// u8
	uint32_t var420;	// u32
	int32_t var421;	// i32
	int32_t var422;	// i32
	uint8_t var423;	// u8
	int32_t var424;	// i32
	int16_t var425;	// i16
	int8_t var426;	// i8
	uint128_t var427;	// u128
	uint8_t var428;	// u8
	int32_t var429;	// i32
	int64_t var430;	// i64
	int32_t var431;	// i32
	uint16_t var432;	// u16
	uint64_t var433;	// u64
	int8_t var434;	// i8
	int16_t var435;	// i16
	uint32_t var436;	// u32
	int8_t var437;	// i8
	int8_t var438;	// i8
	uint32_t var439;	// u32
	uint32_t var440;	// u32
	int8_t var441;	// i8
	int16_t var442;	// i16
	uint8_t var443;	// u8
	intptr_t var444;	// isize
	int8_t var445;	// i8
	uintptr_t var446;	// usize
	int128_t var447;	// i128
	int32_t var448;	// i32
	uint8_t var449;	// u8
	RUST_BOOL var450;	// bool
	uint8_t var451;	// u8
	uint128_t var452;	// u128
	uint16_t var453;	// u16
	int8_t var454;	// i8
	int32_t var455;	// i32
	uint32_t var456;	// u32
	uint8_t var457;	// u8
	intptr_t var458;	// isize
	int64_t var459;	// i64
	RUST_BOOL var460;	// bool
	int16_t var461;	// i16
	int32_t var462;	// i32
	int32_t var463;	// i32
	int32_t var464;	// i32
	int16_t var465;	// i16
	int32_t var466;	// i32
	int32_t var467;	// i32
	int64_t var468;	// i64
	uint32_t var469;	// u32
	uint16_t var470;	// u16
	int8_t var471;	// i8
	uint8_t var472;	// u8
	int128_t var473;	// i128
	int128_t var474;	// i128
	uint32_t var475;	// u32
	uint128_t var476;	// u128
	int8_t var477;	// i8
	uint16_t var478;	// u16
	int8_t var479;	// i8
	int32_t var480;	// i32
	int16_t var481;	// i16
	int16_t var482;	// i16
	uint8_t var483;	// u8
	int8_t var484;	// i8
	uint8_t var485;	// u8
	int128_t var486;	// i128
	int16_t var487;	// i16
	int128_t var488;	// i128
	int32_t var489;	// i32
	uint8_t var490;	// u8
	int16_t var491;	// i16
	int16_t var492;	// i16
	int8_t var493;	// i8
	int8_t var494;	// i8
	int8_t var495;	// i8
	uint16_t var496;	// u16
	int32_t var497;	// i32
	uint32_t var498;	// u32
	uint8_t var499;	// u8
	uint8_t var500;	// u8
	intptr_t var501;	// isize
	int8_t var502;	// i8
	int8_t var503;	// i8
	uint64_t var504;	// u64
	uintptr_t var505;	// usize
	uint16_t var506;	// u16
	int32_t var507;	// i32
	uint32_t var508;	// u32
	int128_t var509;	// i128
	uint16_t var510;	// u16
	uint32_t var511;	// u32
	int16_t var512;	// i16
	intptr_t var513;	// isize
	int32_t var514;	// i32
	int16_t var515;	// i16
	int32_t var516;	// i32
	intptr_t var517;	// isize
	uint8_t var518;	// u8
	uint32_t var519;	// u32
	int128_t var520;	// i128
	int128_t var521;	// i128
	uint32_t var522;	// u32
	uint16_t var523;	// u16
	uint8_t var524;	// u8
	intptr_t var525;	// isize
	uint8_t var526;	// u8
	uint32_t var527;	// u32
	int32_t var528;	// i32
	int128_t var529;	// i128
	uint16_t var530;	// u16
	uint128_t var531;	// u128
	int64_t var532;	// i64
	uint32_t var533;	// u32
	uint8_t var534;	// u8
	uint16_t var535;	// u16
	int8_t var536;	// i8
	intptr_t var537;	// isize
	int16_t var538;	// i16
	int16_t var539;	// i16
	uintptr_t var540;	// usize
	uint32_t var541;	// u32
	uint32_t var542;	// u32
	int32_t var543;	// i32
	int32_t var544;	// i32
	uint8_t var545;	// u8
	int32_t var546;	// i32
	intptr_t var547;	// isize
	int32_t var548;	// i32
	int32_t var549;	// i32
	int32_t var550;	// i32
	uint16_t var551;	// u16
	int32_t var552;	// i32
	int32_t var553;	// i32
	int8_t var554;	// i8
	int8_t var555;	// i8
	uint16_t var556;	// u16
	uint16_t var557;	// u16
	uint16_t var558;	// u16
	int32_t var559;	// i32
	int8_t var560;	// i8
	uint8_t var561;	// u8
	int16_t var562;	// i16
	uint32_t var563;	// u32
	uint32_t var564;	// u32
	uint32_t var565;	// u32
	uint32_t var566;	// u32
	uint32_t var567;	// u32
	int16_t var568;	// i16
	uint32_t var569;	// u32
	uint8_t var570;	// u8
	uint32_t var571;	// u32
	uint16_t var572;	// u16
	uint16_t var573;	// u16
	uint16_t var574;	// u16
	uint32_t var575;	// u32
	uint16_t var576;	// u16
	int8_t var577;	// i8
	int8_t var578;	// i8
	int8_t var579;	// i8
	int8_t var580;	// i8
	uint16_t var581;	// u16
	int32_t var582;	// i32
	int32_t var583;	// i32
	uint8_t var584;	// u8
	uint32_t var585;	// u32
	uint32_t var586;	// u32
	uint32_t var587;	// u32
	int32_t var588;	// i32
	uint8_t var589;	// u8
	uint8_t var590;	// u8
	uint8_t var591;	// u8
	uint8_t var592;	// u8
	uint16_t var593;	// u16
	int8_t var594;	// i8
	uint64_t var595;	// u64
	uint32_t var596;	// u32
	uint32_t var597;	// u32
	uint32_t var598;	// u32
	uint32_t var599;	// u32
	int16_t var600;	// i16
	uint32_t var601;	// u32
	uint32_t var602;	// u32
	int8_t var603;	// i8
	int8_t var604;	// i8
	int8_t var605;	// i8
	uint16_t var606;	// u16
	uint16_t var607;	// u16
	uint16_t var608;	// u16
	uint16_t var609;	// u16
	int32_t var610;	// i32
	int32_t var611;	// i32
	int32_t var612;	// i32
	int32_t var613;	// i32
	int32_t var614;	// i32
	int32_t var615;	// i32
	int32_t var616;	// i32
	int32_t var617;	// i32
	int32_t var618;	// i32
	uint64_t var619;	// u64
	int32_t var620;	// i32
	int32_t var621;	// i32
	uint16_t var622;	// u16
	uint32_t var623;	// u32
	uint32_t var624;	// u32
	int32_t var625;	// i32
	int16_t var626;	// i16
	int16_t var627;	// i16
	uint32_t var628;	// u32
	int16_t var629;	// i16
	int16_t var630;	// i16
	int16_t var631;	// i16
	uint32_t var632;	// u32
	uint32_t var633;	// u32
	uint32_t var634;	// u32
	uint32_t var635;	// u32
	uint16_t var636;	// u16
	uint16_t var637;	// u16
	uint16_t var638;	// u16
	uint16_t var639;	// u16
	uint16_t var640;	// u16
	uint16_t var641;	// u16
	int8_t var642;	// i8
	int8_t var643;	// i8
	int8_t var644;	// i8
	int8_t var645;	// i8
	int8_t var646;	// i8
	uint32_t var647;	// u32
	int16_t var648;	// i16
	uint32_t var649;	// u32
	uint32_t var650;	// u32
	uint32_t var651;	// u32
	uint32_t var652;	// u32
	uint32_t var653;	// u32
	uint32_t var654;	// u32
	uint32_t var655;	// u32
	int8_t var656;	// i8
	int8_t var657;	// i8
	uint32_t var658;	// u32
	uint32_t var659;	// u32
	int8_t var660;	// i8
	int128_t var661;	// i128
	int128_t var662;	// i128
	int128_t var663;	// i128
	int32_t var664;	// i32
	int128_t var665;	// i128
	int128_t var666;	// i128
	int128_t var667;	// i128
	int128_t var668;	// i128
	int128_t var669;	// i128
	int128_t var670;	// i128
	uint32_t var671;	// u32
	uint16_t var672;	// u16
	uint16_t var673;	// u16
	uint16_t var674;	// u16
	uint16_t var675;	// u16
	int8_t var676;	// i8
	int8_t var677;	// i8
	int8_t var678;	// i8
	int8_t var679;	// i8
	int8_t var680;	// i8
	int8_t var681;	// i8
	int8_t var682;	// i8
	int8_t var683;	// i8
	uint32_t var684;	// u32
	int8_t var685;	// i8
	uint32_t var686;	// u32
	uint32_t var687;	// u32
	uintptr_t var688;	// usize
	uintptr_t var689;	// usize
	int16_t var690;	// i16
	uint64_t var691;	// u64
	uint64_t var692;	// u64
	uint8_t var693;	// u8
	uint8_t var694;	// u8
	uint8_t var695;	// u8
	uint8_t var696;	// u8
	uint8_t var697;	// u8
	uint16_t var698;	// u16
	int128_t var699;	// i128
	uint32_t var700;	// u32
	uint32_t var701;	// u32
	uint8_t var702;	// u8
	int128_t var703;	// i128
	int128_t var704;	// i128
	uint64_t var705;	// u64
	uint64_t var706;	// u64
	uint64_t var707;	// u64
	int16_t var708;	// i16
	uint32_t var709;	// u32
	uint32_t var710;	// u32
	intptr_t var711;	// isize
	intptr_t var712;	// isize
	intptr_t var713;	// isize
	intptr_t var714;	// isize
	uint32_t var715;	// u32
	uint32_t var716;	// u32
	uint32_t var717;	// u32
	intptr_t var718;	// isize
	intptr_t var719;	// isize
	int32_t var720;	// i32
	int32_t var721;	// i32
	int32_t var722;	// i32
	int32_t var723;	// i32
	uint16_t var724;	// u16
	uint16_t var725;	// u16
	uint16_t var726;	// u16
	uint32_t var727;	// u32
	uint32_t var728;	// u32
	uint32_t var729;	// u32
	uint32_t var730;	// u32
	uint32_t var731;	// u32
	uint32_t var732;	// u32
	uint64_t var733;	// u64
	uint64_t var734;	// u64
	int32_t var735;	// i32
	uint64_t var736;	// u64
	uint64_t var737;	// u64
	uint8_t var738;	// u8
	uint8_t var739;	// u8
	uint8_t var740;	// u8
	uint8_t var741;	// u8
	int8_t var742;	// i8
	int8_t var743;	// i8
	int8_t var744;	// i8
	int8_t var745;	// i8
	int8_t var746;	// i8
	int8_t var747;	// i8
	int16_t var748;	// i16
	uint16_t var749;	// u16
	uint16_t var750;	// u16
	uint16_t var751;	// u16
	uint16_t var752;	// u16
	uint16_t var753;	// u16
	uint16_t var754;	// u16
	intptr_t var755;	// isize
	intptr_t var756;	// isize
	intptr_t var757;	// isize
	uintptr_t var758;	// usize
	uintptr_t var759;	// usize
	int32_t var760;	// i32
	int8_t var761;	// i8
	int8_t var762;	// i8
	uint16_t var763;	// u16
	uint16_t var764;	// u16
	uint16_t var765;	// u16
	uint16_t var766;	// u16
	uint16_t var767;	// u16
	int8_t var768;	// i8
	uint16_t var769;	// u16
	int16_t var770;	// i16
	int16_t var771;	// i16
	int16_t var772;	// i16
	int16_t var773;	// i16
	int16_t var774;	// i16
	int16_t var775;	// i16
	int16_t var776;	// i16
	int16_t var777;	// i16
	uint16_t var778;	// u16
	uint16_t var779;	// u16
	uint128_t var780;	// u128
	int8_t var781;	// i8
	int8_t var782;	// i8
	int128_t var783;	// i128
	int128_t var784;	// i128
	int128_t var785;	// i128
	int128_t var786;	// i128
	int128_t var787;	// i128
	int8_t var788;	// i8
	int8_t var789;	// i8
	int8_t var790;	// i8
	int8_t var791;	// i8
	int8_t var792;	// i8
	int8_t var793;	// i8
	uint32_t var794;	// u32
	int16_t var795;	// i16
	int16_t var796;	// i16
	int16_t var797;	// i16
	uint32_t var798;	// u32
	int8_t var799;	// i8
	uint32_t var800;	// u32
	uint16_t var801;	// u16
	uint16_t var802;	// u16
	uint16_t var803;	// u16
	uint32_t var804;	// u32
	uint32_t var805;	// u32
	uint32_t var806;	// u32
	uint32_t var807;	// u32
	uint32_t var808;	// u32
	uint16_t var809;	// u16
	uint8_t var810;	// u8
	uint8_t var811;	// u8
	uint8_t var812;	// u8
	uint8_t var813;	// u8
	uint8_t var814;	// u8
	int32_t var815;	// i32
	uint64_t var816;	// u64
	uint128_t var817;	// u128
	uint128_t var818;	// u128
	uint128_t var819;	// u128
	uint128_t var820;	// u128
	intptr_t var821;	// isize
	intptr_t var822;	// isize
	intptr_t var823;	// isize
	intptr_t var824;	// isize
	intptr_t var825;	// isize
	int16_t var826;	// i16
	intptr_t var827;	// isize
	intptr_t var828;	// isize
	RUST_BOOL var829;	// bool
	uintptr_t var830;	// usize
	uint128_t var831;	// u128
	uint128_t var832;	// u128
	uint128_t var833;	// u128
	uint32_t var834;	// u32
	uint8_t var835;	// u8
	intptr_t var836;	// isize
	intptr_t var837;	// isize
	intptr_t var838;	// isize
	uint32_t var839;	// u32
	int8_t var840;	// i8
	int8_t var841;	// i8
	int8_t var842;	// i8
	int8_t var843;	// i8
	int8_t var844;	// i8
	int8_t var845;	// i8
	int8_t var846;	// i8
	intptr_t var847;	// isize
	intptr_t var848;	// isize
	uint32_t var849;	// u32
	uint32_t var850;	// u32
	uint32_t var851;	// u32
	intptr_t var852;	// isize
	int128_t var853;	// i128
	int128_t var854;	// i128
	int128_t var855;	// i128
	int128_t var856;	// i128
	int128_t var857;	// i128
	int128_t var858;	// i128
	uint32_t var859;	// u32
	uint128_t var860;	// u128
	uint32_t var861;	// u32
	uint32_t var862;	// u32
	uint32_t var863;	// u32
	uint32_t var864;	// u32
	uint32_t var865;	// u32
	uint32_t var866;	// u32
	uint8_t var867;	// u8
	uint32_t var868;	// u32
	uint8_t var869;	// u8
	uint16_t var870;	// u16
	uint16_t var871;	// u16
	uint16_t var872;	// u16
	uint16_t var873;	// u16
	uint32_t var874;	// u32
	uint32_t var875;	// u32
	uint32_t var876;	// u32
	uint16_t var877;	// u16
	uint16_t var878;	// u16
	uint16_t var879;	// u16
	uint16_t var880;	// u16
	uint32_t var881;	// u32
	uint16_t var882;	// u16
	uint16_t var883;	// u16
	int16_t var884;	// i16
	int16_t var885;	// i16
	int16_t var886;	// i16
	int16_t var887;	// i16
	int16_t var888;	// i16
	int16_t var889;	// i16
	uint32_t var890;	// u32
	uintptr_t var891;	// usize
	int32_t var892;	// i32
	uintptr_t var893;	// usize
	uintptr_t var894;	// usize
	uintptr_t var895;	// usize
	uint32_t var896;	// u32
	uint32_t var897;	// u32
	uint32_t var898;	// u32
	uint32_t var899;	// u32
	uint32_t var900;	// u32
	int8_t var901;	// i8
	int8_t var902;	// i8
	int8_t var903;	// i8
	int8_t var904;	// i8
	uintptr_t var905;	// usize
	uint32_t var906;	// u32
	uint32_t var907;	// u32
	uint32_t var908;	// u32
	uint32_t var909;	// u32
	int16_t var910;	// i16
	int16_t var911;	// i16
	int16_t var912;	// i16
	uint32_t var913;	// u32
	int64_t var914;	// i64
	int64_t var915;	// i64
	uint32_t var916;	// u32
	int64_t var917;	// i64
	uintptr_t var918;	// usize
	uintptr_t var919;	// usize
	uintptr_t var920;	// usize
	uintptr_t var921;	// usize
	uint16_t var922;	// u16
	int128_t var923;	// i128
	uint16_t var924;	// u16
	uint16_t var925;	// u16
	uint16_t var926;	// u16
	uint16_t var927;	// u16
	uint16_t var928;	// u16
	uint32_t var929;	// u32
	uint16_t var930;	// u16
	int64_t var931;	// i64
	int64_t var932;	// i64
	int64_t var933;	// i64
	uint32_t var934;	// u32
	uint32_t var935;	// u32
	int8_t var936;	// i8
	int8_t var937;	// i8
	int8_t var938;	// i8
	uint32_t var939;	// u32
	uint32_t var940;	// u32
	uint8_t var941;	// u8
	uint64_t var942;	// u64
	uint8_t var943;	// u8
	int32_t var944;	// i32
	int32_t var945;	// i32
	int32_t var946;	// i32
	int32_t var947;	// i32
	int32_t var948;	// i32
	int32_t var949;	// i32
	int32_t var950;	// i32
	int32_t var951;	// i32
	int32_t var952;	// i32
	int32_t var953;	// i32
	int32_t var954;	// i32
	int32_t var955;	// i32
	uint8_t var956;	// u8
	uint16_t var957;	// u16
	uint8_t var958;	// u8
	uint128_t var959;	// u128
	uint128_t var960;	// u128
	uint128_t var961;	// u128
	uint16_t var962;	// u16
	uint16_t var963;	// u16
	uint16_t var964;	// u16
	uint16_t var965;	// u16
	uint16_t var966;	// u16
	uint8_t var967;	// u8
	uint128_t var968;	// u128
	uint8_t var969;	// u8
	int8_t var970;	// i8
	int8_t var971;	// i8
	uint128_t var972;	// u128
	uint128_t var973;	// u128
	uint32_t var974;	// u32
	int16_t var975;	// i16
	uint128_t var976;	// u128
	int16_t var977;	// i16
	int16_t var978;	// i16
	int16_t var979;	// i16
	uint8_t var980;	// u8
	int32_t var981;	// i32
	int32_t var982;	// i32
	int32_t var983;	// i32
	int32_t var984;	// i32
	int32_t var985;	// i32
	uint32_t var986;	// u32
	int32_t var987;	// i32
	int32_t var988;	// i32
	int32_t var989;	// i32
	int32_t var990;	// i32
	int32_t var991;	// i32
	int32_t var992;	// i32
	int32_t var993;	// i32
	int32_t var994;	// i32
	int32_t var995;	// i32
	int8_t var996;	// i8
	uint8_t var997;	// u8
	uint8_t var998;	// u8
	uint8_t var999;	// u8
	uint8_t var1000;	// u8
	RUST_BOOL var1001;	// bool
	uint64_t var1002;	// u64
	uint64_t var1003;	// u64
	uint32_t var1004;	// u32
	uint32_t var1005;	// u32
	uint32_t var1006;	// u32
	uint32_t var1007;	// u32
	uint32_t var1008;	// u32
	int16_t var1009;	// i16
	int16_t var1010;	// i16
	int16_t var1011;	// i16
	uint32_t var1012;	// u32
	int8_t var1013;	// i8
	int8_t var1014;	// i8
	int8_t var1015;	// i8
	int8_t var1016;	// i8
	int8_t var1017;	// i8
	int8_t var1018;	// i8
	int8_t var1019;	// i8
	int8_t var1020;	// i8
	int8_t var1021;	// i8
	int8_t var1022;	// i8
	int8_t var1023;	// i8
	int128_t var1024;	// i128
	int8_t var1025;	// i8
	uint8_t var1026;	// u8
	uint8_t var1027;	// u8
	uint32_t var1028;	// u32
	uint32_t var1029;	// u32
	uint8_t var1030;	// u8
	int128_t var1031;	// i128
	int128_t var1032;	// i128
	int128_t var1033;	// i128
	int8_t var1034;	// i8
	int8_t var1035;	// i8
	int8_t var1036;	// i8
	int8_t var1037;	// i8
	int8_t var1038;	// i8
	int8_t var1039;	// i8
	int8_t var1040;	// i8
	int8_t var1041;	// i8
	int8_t var1042;	// i8
	uint8_t var1043;	// u8
	uint16_t var1044;	// u16
	uint32_t var1045;	// u32
	uint32_t var1046;	// u32
	uint32_t var1047;	// u32
	uint32_t var1048;	// u32
	uint32_t var1049;	// u32
	uint32_t var1050;	// u32
	uint16_t var1051;	// u16
	uint64_t var1052;	// u64
	uint64_t var1053;	// u64
	int16_t var1054;	// i16
	uint64_t var1055;	// u64
	uint32_t var1056;	// u32
	uint32_t var1057;	// u32
	uint8_t var1058;	// u8
	uint8_t var1059;	// u8
	uint8_t var1060;	// u8
	uint8_t var1061;	// u8
	uint8_t var1062;	// u8
	uint8_t var1063;	// u8
	uint8_t var1064;	// u8
	uint8_t var1065;	// u8
	uint8_t var1066;	// u8
	uint8_t var1067;	// u8
	uint8_t var1068;	// u8
	uint8_t var1069;	// u8
	int16_t var1070;	// i16
	int16_t var1071;	// i16
	int16_t var1072;	// i16
	int16_t var1073;	// i16
	int16_t var1074;	// i16
	int8_t var1075;	// i8
	uint8_t var1076;	// u8
	intptr_t var1077;	// isize
	intptr_t var1078;	// isize
	intptr_t var1079;	// isize
	intptr_t var1080;	// isize
	uint128_t var1081;	// u128
	uint16_t var1082;	// u16
	uint16_t var1083;	// u16
	uint16_t var1084;	// u16
	uint16_t var1085;	// u16
	int128_t var1086;	// i128
	int128_t var1087;	// i128
	int128_t var1088;	// i128
	int128_t var1089;	// i128
	int128_t var1090;	// i128
	uint32_t var1091;	// u32
	uint8_t var1092;	// u8
	intptr_t var1093;	// isize
	intptr_t var1094;	// isize
	int32_t var1095;	// i32
	int32_t var1096;	// i32
	uint16_t var1097;	// u16
	int8_t var1098;	// i8
	int8_t var1099;	// i8
	int8_t var1100;	// i8
	int8_t var1101;	// i8
	int8_t var1102;	// i8
	intptr_t var1103;	// isize
	intptr_t var1104;	// isize
	uint32_t var1105;	// u32
	uint32_t var1106;	// u32
	uint32_t var1107;	// u32
	int32_t var1108;	// i32
	int32_t var1109;	// i32
	uint32_t var1110;	// u32
	uint32_t var1111;	// u32
	int32_t var1112;	// i32
	uint32_t var1113;	// u32
	uint32_t var1114;	// u32
	uint32_t var1115;	// u32
	uint32_t var1116;	// u32
	uintptr_t var1117;	// usize
	uintptr_t var1118;	// usize
	uintptr_t var1119;	// usize
	uintptr_t var1120;	// usize
	uintptr_t var1121;	// usize
	uintptr_t var1122;	// usize
	uintptr_t var1123;	// usize
	uintptr_t var1124;	// usize
	uint32_t var1125;	// u32
	uint32_t var1126;	// u32
	int16_t var1127;	// i16
	uint32_t var1128;	// u32
	uint32_t var1129;	// u32
	int128_t var1130;	// i128
	int128_t var1131;	// i128
	int8_t var1132;	// i8
	int8_t var1133;	// i8
	int8_t var1134;	// i8
	uint16_t var1135;	// u16
	uint16_t var1136;	// u16
	uint16_t var1137;	// u16
	uint16_t var1138;	// u16
	uint16_t var1139;	// u16
	uint16_t var1140;	// u16
	uint16_t var1141;	// u16
	uint16_t var1142;	// u16
	uint16_t var1143;	// u16
	uint8_t var1144;	// u8
	uint8_t var1145;	// u8
	uint8_t var1146;	// u8
	uint8_t var1147;	// u8
	uint32_t var1148;	// u32
	int64_t var1149;	// i64
	uint16_t var1150;	// u16
	uint16_t var1151;	// u16
	uint8_t var1152;	// u8
	uint8_t var1153;	// u8
	uint8_t var1154;	// u8
	uint8_t var1155;	// u8
	int32_t var1156;	// i32
	int32_t var1157;	// i32
	int32_t var1158;	// i32
	int32_t var1159;	// i32
	int8_t var1160;	// i8
	uint16_t var1161;	// u16
	uint16_t var1162;	// u16
	uint16_t var1163;	// u16
	uint16_t var1164;	// u16
	uint64_t var1165;	// u64
	uint64_t var1166;	// u64
	uint32_t var1167;	// u32
	uint32_t var1168;	// u32
	uint32_t var1169;	// u32
	uint32_t var1170;	// u32
	uint32_t var1171;	// u32
	uint64_t var1172;	// u64
	uint64_t var1173;	// u64
	uint64_t var1174;	// u64
	uint8_t var1175;	// u8
	uint8_t var1176;	// u8
	uint8_t var1177;	// u8
	uint8_t var1178;	// u8
	uint8_t var1179;	// u8
	uint8_t var1180;	// u8
	int16_t var1181;	// i16
	uint8_t var1182;	// u8
	uint32_t var1183;	// u32
	uint32_t var1184;	// u32
	int8_t var1185;	// i8
	int8_t var1186;	// i8
	int8_t var1187;	// i8
	uint32_t var1188;	// u32
	uint32_t var1189;	// u32
	uint32_t var1190;	// u32
	int8_t var1191;	// i8
	uint8_t var1192;	// u8
	uint8_t var1193;	// u8
	uint8_t var1194;	// u8
	uint8_t var1195;	// u8
	uint8_t var1196;	// u8
	uint8_t var1197;	// u8
	uint8_t var1198;	// u8
	uint8_t var1199;	// u8
	uint8_t var1200;	// u8
	uint8_t var1201;	// u8
	uint128_t var1202;	// u128
	uint128_t var1203;	// u128
	uint128_t var1204;	// u128
	uint128_t var1205;	// u128
	uint128_t var1206;	// u128
	uint128_t var1207;	// u128
	uint8_t var1208;	// u8
	uint8_t var1209;	// u8
	uint8_t var1210;	// u8
	uint8_t var1211;	// u8
	int16_t var1212;	// i16
	int16_t var1213;	// i16
	int16_t var1214;	// i16
	int16_t var1215;	// i16
	int128_t var1216;	// i128
	int128_t var1217;	// i128
	uint8_t var1218;	// u8
	uint8_t var1219;	// u8
	uint8_t var1220;	// u8
	uint8_t var1221;	// u8
	uint8_t var1222;	// u8
	uint8_t var1223;	// u8
	uint8_t var1224;	// u8
	uint16_t var1225;	// u16
	uint16_t var1226;	// u16
	uint16_t var1227;	// u16
	uint16_t var1228;	// u16
	uint32_t var1229;	// u32
	uint32_t var1230;	// u32
	uint32_t var1231;	// u32
	uint64_t var1232;	// u64
	int32_t var1233;	// i32
	int32_t var1234;	// i32
	uint64_t var1235;	// u64
	uintptr_t var1236;	// usize
	uint16_t var1237;	// u16
	uint64_t var1238;	// u64
	uint64_t var1239;	// u64
	uint64_t var1240;	// u64
	uint128_t var1241;	// u128
	uint64_t var1242;	// u64
	uint64_t var1243;	// u64
	uint64_t var1244;	// u64
	int32_t var1245;	// i32
	int32_t var1246;	// i32
	int32_t var1247;	// i32
	uint16_t var1248;	// u16
	uint16_t var1249;	// u16
	uint16_t var1250;	// u16
	uint16_t var1251;	// u16
	uint16_t var1252;	// u16
	int16_t var1253;	// i16
	int16_t var1254;	// i16
	int16_t var1255;	// i16
	int16_t var1256;	// i16
	int32_t var1257;	// i32
	int16_t var1258;	// i16
	int16_t var1259;	// i16
	int64_t var1260;	// i64
	int64_t var1261;	// i64
	int64_t var1262;	// i64
	uint8_t var1263;	// u8
	uint8_t var1264;	// u8
	uint8_t var1265;	// u8
	int8_t var1266;	// i8
	int8_t var1267;	// i8
	int8_t var1268;	// i8
	int8_t var1269;	// i8
	uint32_t var1270;	// u32
	uint32_t var1271;	// u32
	uint32_t var1272;	// u32
	int16_t var1273;	// i16
	int128_t var1274;	// i128
	int128_t var1275;	// i128
	int128_t var1276;	// i128
	int128_t var1277;	// i128
	int128_t var1278;	// i128
	int128_t var1279;	// i128
	int128_t var1280;	// i128
	int8_t var1281;	// i8
	int8_t var1282;	// i8
	int8_t var1283;	// i8
	int8_t var1284;	// i8
	int8_t var1285;	// i8
	int8_t var1286;	// i8
	int8_t var1287;	// i8
	int8_t var1288;	// i8
	int8_t var1289;	// i8
	int8_t var1290;	// i8
	int64_t var1291;	// i64
	uint8_t var1292;	// u8
	uint8_t var1293;	// u8
	uint8_t var1294;	// u8
	uint8_t var1295;	// u8
	uint8_t var1296;	// u8
	uint8_t var1297;	// u8
	uint16_t var1298;	// u16
	uint64_t var1299;	// u64
	uint64_t var1300;	// u64
	uint64_t var1301;	// u64
	uint64_t var1302;	// u64
	uint64_t var1303;	// u64
	uint64_t var1304;	// u64
	RUST_BOOL var1305;	// bool
	RUST_BOOL var1306;	// bool
	RUST_BOOL var1307;	// bool
	RUST_BOOL var1308;	// bool
	int16_t var1309;	// i16
	int16_t var1310;	// i16
	int16_t var1311;	// i16
	int16_t var1312;	// i16
	int16_t var1313;	// i16
	int16_t var1314;	// i16
	uint8_t var1315;	// u8
	uint16_t var1316;	// u16
	uint8_t var1317;	// u8
	int8_t var1318;	// i8
	uint32_t var1319;	// u32
	intptr_t var1320;	// isize
	uint32_t var1321;	// u32
	uint32_t var1322;	// u32
	uint32_t var1323;	// u32
	uint32_t var1324;	// u32
	uint32_t var1325;	// u32
	uint32_t var1326;	// u32
	uint16_t var1327;	// u16
	uint16_t var1328;	// u16
	uint16_t var1329;	// u16
	uint16_t var1330;	// u16
	uint16_t var1331;	// u16
	uint16_t var1332;	// u16
	uint16_t var1333;	// u16
	uint16_t var1334;	// u16
	uint16_t var1335;	// u16
	uint16_t var1336;	// u16
	uint8_t var1337;	// u8
	uint8_t var1338;	// u8
	uint8_t var1339;	// u8
	uint8_t var1340;	// u8
	uint8_t var1341;	// u8
	uint64_t var1342;	// u64
	uint64_t var1343;	// u64
	uint64_t var1344;	// u64
	int64_t var1345;	// i64
	uint64_t var1346;	// u64
	uint64_t var1347;	// u64
	uint32_t var1348;	// u32
	uint32_t var1349;	// u32
	uint32_t var1350;	// u32
	uint32_t var1351;	// u32
	uint16_t var1352;	// u16
	int32_t var1353;	// i32
	int32_t var1354;	// i32
	uint16_t var1355;	// u16
	uint8_t var1356;	// u8
	uint8_t var1357;	// u8
	uint8_t var1358;	// u8
	uint8_t var1359;	// u8
	uint8_t var1360;	// u8
	uint8_t var1361;	// u8
	uint8_t var1362;	// u8
	uint8_t var1363;	// u8
	int32_t var1364;	// i32
	int16_t var1365;	// i16
	int16_t var1366;	// i16
	uint8_t var1367;	// u8
	uint8_t var1368;	// u8
	uint32_t var1369;	// u32
	uint32_t var1370;	// u32
	uint32_t var1371;	// u32
	int64_t var1372;	// i64
	uint16_t var1373;	// u16
	uint32_t var1374;	// u32
	uint128_t var1375;	// u128
	uint32_t var1376;	// u32
	uint32_t var1377;	// u32
	uint32_t var1378;	// u32
	uint32_t var1379;	// u32
	uint32_t var1380;	// u32
	uint32_t var1381;	// u32
	int16_t var1382;	// i16
	int16_t var1383;	// i16
	int16_t var1384;	// i16
	int16_t var1385;	// i16
	int16_t var1386;	// i16
	int16_t var1387;	// i16
	int16_t var1388;	// i16
	intptr_t var1389;	// isize
	int8_t var1390;	// i8
	int8_t var1391;	// i8
	uint32_t var1392;	// u32
	int64_t var1393;	// i64
	uint32_t var1394;	// u32
	uint32_t var1395;	// u32
	int64_t var1396;	// i64
	int8_t var1397;	// i8
	int64_t var1398;	// i64
	uint64_t var1399;	// u64
	uint64_t var1400;	// u64
	int32_t var1401;	// i32
	int128_t var1402;	// i128
	int128_t var1403;	// i128
	int8_t var1404;	// i8
	int128_t var1405;	// i128
	int128_t var1406;	// i128
	int128_t var1407;	// i128
	int128_t var1408;	// i128
	uint16_t var1409;	// u16
	uint16_t var1410;	// u16
	uint16_t var1411;	// u16
	uint16_t var1412;	// u16
	uint16_t var1413;	// u16
	uint16_t var1414;	// u16
	uint16_t var1415;	// u16
	uint16_t var1416;	// u16
	uint16_t var1417;	// u16
	uint16_t var1418;	// u16
	uint16_t var1419;	// u16
	int16_t var1420;	// i16
	int16_t var1421;	// i16
	uint16_t var1422;	// u16
	uint16_t var1423;	// u16
	uint16_t var1424;	// u16
	uint16_t var1425;	// u16
	uint16_t var1426;	// u16
	uint16_t var1427;	// u16
	uint16_t var1428;	// u16
	uint16_t var1429;	// u16
	uint16_t var1430;	// u16
	uint16_t var1431;	// u16
	uint16_t var1432;	// u16
	uint16_t var1433;	// u16
	int8_t var1434;	// i8
	int8_t var1435;	// i8
	int8_t var1436;	// i8
	int8_t var1437;	// i8
	RUST_BOOL var1438;	// bool
	uintptr_t var1439;	// usize
	RUST_BOOL var1440;	// bool
	RUST_BOOL var1441;	// bool
	uint16_t var1442;	// u16
	uint16_t var1443;	// u16
	uint8_t var1444;	// u8
	uint8_t var1445;	// u8
	int32_t var1446;	// i32
	int32_t var1447;	// i32
	int32_t var1448;	// i32
	int32_t var1449;	// i32
	int32_t var1450;	// i32
	int32_t var1451;	// i32
	int32_t var1452;	// i32
	int32_t var1453;	// i32
	int32_t var1454;	// i32
	int32_t var1455;	// i32
	int32_t var1456;	// i32
	uint32_t var1457;	// u32
	uint32_t var1458;	// u32
	uint32_t var1459;	// u32
	uint32_t var1460;	// u32
	uintptr_t var1461;	// usize
	int128_t var1462;	// i128
	int32_t var1463;	// i32
	int32_t var1464;	// i32
	int32_t var1465;	// i32
	intptr_t var1466;	// isize
	intptr_t var1467;	// isize
	intptr_t var1468;	// isize
	intptr_t var1469;	// isize
	intptr_t var1470;	// isize
	intptr_t var1471;	// isize
	intptr_t var1472;	// isize
	intptr_t var1473;	// isize
	intptr_t var1474;	// isize
	int32_t var1475;	// i32
	intptr_t var1476;	// isize
	uint8_t var1477;	// u8
	uint8_t var1478;	// u8
	uint8_t var1479;	// u8
	uint32_t var1480;	// u32
	uint32_t var1481;	// u32
	uint32_t var1482;	// u32
	uint32_t var1483;	// u32
	RUST_BOOL var1484;	// bool
	uint16_t var1485;	// u16
	uintptr_t var1486;	// usize
	uintptr_t var1487;	// usize
	uintptr_t var1488;	// usize
	uintptr_t var1489;	// usize
	RUST_BOOL var1490;	// bool
	uint32_t var1491;	// u32
	uint32_t var1492;	// u32
	uint32_t var1493;	// u32
	uint32_t var1494;	// u32
	uint32_t var1495;	// u32
	uint32_t var1496;	// u32
	uint32_t var1497;	// u32
	uint32_t var1498;	// u32
	intptr_t var1499;	// isize
	uint32_t var1500;	// u32
	uint32_t var1501;	// u32
	uint32_t var1502;	// u32
	uint32_t var1503;	// u32
	uint32_t var1504;	// u32
	uint32_t var1505;	// u32
	uint8_t var1506;	// u8
	uint8_t var1507;	// u8
	uint8_t var1508;	// u8
	uint8_t var1509;	// u8
	uint8_t var1510;	// u8
	uint8_t var1511;	// u8
	uint8_t var1512;	// u8
	uint8_t var1513;	// u8
	uint8_t var1514;	// u8
	int32_t var1515;	// i32
	int32_t var1516;	// i32
	int32_t var1517;	// i32
	int32_t var1518;	// i32
	int32_t var1519;	// i32
	int32_t var1520;	// i32
	int32_t var1521;	// i32
	int32_t var1522;	// i32
	int32_t var1523;	// i32
	int16_t var1524;	// i16
	int16_t var1525;	// i16
	int16_t var1526;	// i16
	int16_t var1527;	// i16
	int16_t var1528;	// i16
	int16_t var1529;	// i16
	int16_t var1530;	// i16
	int16_t var1531;	// i16
	uint32_t var1532;	// u32
	uint32_t var1533;	// u32
	uint32_t var1534;	// u32
	uint32_t var1535;	// u32
	uint32_t var1536;	// u32
	uint32_t var1537;	// u32
	uint16_t var1538;	// u16
	uint32_t var1539;	// u32
	uint32_t var1540;	// u32
	uint32_t var1541;	// u32
	uint32_t var1542;	// u32
	int8_t var1543;	// i8
	int8_t var1544;	// i8
	uint32_t var1545;	// u32
	int64_t var1546;	// i64
	int64_t var1547;	// i64
	int64_t var1548;	// i64
	int8_t var1549;	// i8
	uint8_t var1550;	// u8
	int32_t var1551;	// i32
	int8_t var1552;	// i8
	uint8_t var1553;	// u8
	uint8_t var1554;	// u8
	uint8_t var1555;	// u8
	uint32_t var1556;	// u32
	uint32_t var1557;	// u32
	uint32_t var1558;	// u32
	uint32_t var1559;	// u32
	int32_t var1560;	// i32
	uint128_t var1561;	// u128
	uint128_t var1562;	// u128
	uint32_t var1563;	// u32
	uint32_t var1564;	// u32
	int16_t var1565;	// i16
	uint128_t var1566;	// u128
	uint128_t var1567;	// u128
	uint128_t var1568;	// u128
	int16_t var1569;	// i16
	int16_t var1570;	// i16
	int32_t var1571;	// i32
	int8_t var1572;	// i8
	int8_t var1573;	// i8
	uint16_t var1574;	// u16
	uint64_t var1575;	// u64
	uint64_t var1576;	// u64
	uint64_t var1577;	// u64
	uint16_t var1578;	// u16
	uint16_t var1579;	// u16
	uint64_t var1580;	// u64
	int16_t var1581;	// i16
	intptr_t var1582;	// isize
	int16_t var1583;	// i16
	uint64_t var1584;	// u64
	int128_t var1585;	// i128
	int128_t var1586;	// i128
	int128_t var1587;	// i128
	int16_t var1588;	// i16
	int16_t var1589;	// i16
	int16_t var1590;	// i16
	uint32_t var1591;	// u32
	uint32_t var1592;	// u32
	uint32_t var1593;	// u32
	int16_t var1594;	// i16
	uint16_t var1595;	// u16
	uint16_t var1596;	// u16
	uint16_t var1597;	// u16
	uint16_t var1598;	// u16
	uint16_t var1599;	// u16
	uint16_t var1600;	// u16
	int32_t var1601;	// i32
	uint16_t var1602;	// u16
	uint16_t var1603;	// u16
	int64_t var1604;	// i64
	int64_t var1605;	// i64
	int64_t var1606;	// i64
	int64_t var1607;	// i64
	uint8_t var1608;	// u8
	uint8_t var1609;	// u8
	uint8_t var1610;	// u8
	uint64_t var1611;	// u64
	uintptr_t var1612;	// usize
	uint64_t var1613;	// u64
	int32_t var1614;	// i32
	int32_t var1615;	// i32
	int16_t var1616;	// i16
	int16_t var1617;	// i16
	int16_t var1618;	// i16
	uint128_t var1619;	// u128
	uint128_t var1620;	// u128
	uint128_t var1621;	// u128
	uint128_t var1622;	// u128
	uint128_t var1623;	// u128
	uintptr_t var1624;	// usize
	uint32_t var1625;	// u32
	uintptr_t var1626;	// usize
	uint8_t var1627;	// u8
	uint8_t var1628;	// u8
	uint8_t var1629;	// u8
	uint8_t var1630;	// u8
	uint8_t var1631;	// u8
	uint8_t var1632;	// u8
	uint8_t var1633;	// u8
	uint32_t var1634;	// u32
	uint32_t var1635;	// u32
	uint8_t var1636;	// u8
	int8_t var1637;	// i8
	int8_t var1638;	// i8
	int8_t var1639;	// i8
	uint32_t var1640;	// u32
	uint32_t var1641;	// u32
	uint32_t var1642;	// u32
	int8_t var1643;	// i8
	int8_t var1644;	// i8
	int8_t var1645;	// i8
	int8_t var1646;	// i8
	int8_t var1647;	// i8
	RUST_BOOL var1648;	// bool
	uint32_t var1649;	// u32
	uintptr_t var1650;	// usize
	uintptr_t var1651;	// usize
	int32_t var1652;	// i32
	int32_t var1653;	// i32
	int8_t var1654;	// i8
	int8_t var1655;	// i8
	int8_t var1656;	// i8
	int8_t var1657;	// i8
	int16_t var1658;	// i16
	int16_t var1659;	// i16
	uint8_t var1660;	// u8
	uint16_t var1661;	// u16
	uint16_t var1662;	// u16
	uint16_t var1663;	// u16
	uint8_t var1664;	// u8
	uint8_t var1665;	// u8
	uint8_t var1666;	// u8
	uint8_t var1667;	// u8
	int16_t var1668;	// i16
	int16_t var1669;	// i16
	uint16_t var1670;	// u16
	int16_t var1671;	// i16
	int16_t var1672;	// i16
	int16_t var1673;	// i16
	int16_t var1674;	// i16
	uint32_t var1675;	// u32
	uint32_t var1676;	// u32
	uint32_t var1677;	// u32
	int8_t var1678;	// i8
	uint32_t var1679;	// u32
	uint8_t var1680;	// u8
	int16_t var1681;	// i16
	int32_t var1682;	// i32
	uint32_t var1683;	// u32
	uint32_t var1684;	// u32
	uint32_t var1685;	// u32
	uint32_t var1686;	// u32
	uint32_t var1687;	// u32
	uint16_t var1688;	// u16
	RUST_BOOL var1689;	// bool
	int8_t var1690;	// i8
	int64_t var1691;	// i64
	int64_t var1692;	// i64
	int64_t var1693;	// i64
	int64_t var1694;	// i64
	int64_t var1695;	// i64
	int64_t var1696;	// i64
	uint8_t var1697;	// u8
	uint8_t var1698;	// u8
	int8_t var1699;	// i8
	int8_t var1700;	// i8
	int8_t var1701;	// i8
	int8_t var1702;	// i8
	int8_t var1703;	// i8
	int8_t var1704;	// i8
	int8_t var1705;	// i8
	int8_t var1706;	// i8
	int8_t var1707;	// i8
	int8_t var1708;	// i8
	int16_t var1709;	// i16
	int16_t var1710;	// i16
	uint32_t var1711;	// u32
	uint32_t var1712;	// u32
	uint32_t var1713;	// u32
	RUST_BOOL var1714;	// bool
	int16_t var1715;	// i16
	int16_t var1716;	// i16
	int16_t var1717;	// i16
	int16_t var1718;	// i16
	RUST_BOOL var1719;	// bool
	RUST_BOOL var1720;	// bool
	int64_t var1721;	// i64
	int64_t var1722;	// i64
	int64_t var1723;	// i64
	intptr_t var1724;	// isize
	intptr_t var1725;	// isize
	intptr_t var1726;	// isize
	intptr_t var1727;	// isize
	intptr_t var1728;	// isize
	intptr_t var1729;	// isize
	uint8_t var1730;	// u8
	uint8_t var1731;	// u8
	uint8_t var1732;	// u8
	uint8_t var1733;	// u8
	uint8_t var1734;	// u8
	uint32_t var1735;	// u32
	uint32_t var1736;	// u32
	uint16_t var1737;	// u16
	uint32_t var1738;	// u32
	uint32_t var1739;	// u32
	uint16_t var1740;	// u16
	uint16_t var1741;	// u16
	uint16_t var1742;	// u16
	uint16_t var1743;	// u16
	uint16_t var1744;	// u16
	int32_t var1745;	// i32
	int32_t var1746;	// i32
	int8_t var1747;	// i8
	int8_t var1748;	// i8
	int8_t var1749;	// i8
	int8_t var1750;	// i8
	int8_t var1751;	// i8
	uint16_t var1752;	// u16
	uint16_t var1753;	// u16
	uint128_t var1754;	// u128
	uint16_t var1755;	// u16
	uint32_t var1756;	// u32
	int8_t var1757;	// i8
	int8_t var1758;	// i8
	int8_t var1759;	// i8
	int8_t var1760;	// i8
	int8_t var1761;	// i8
	int8_t var1762;	// i8
	uint16_t var1763;	// u16
	uint16_t var1764;	// u16
	uint16_t var1765;	// u16
	uint16_t var1766;	// u16
	uint16_t var1767;	// u16
	uint16_t var1768;	// u16
	uint16_t var1769;	// u16
	int32_t var1770;	// i32
	int32_t var1771;	// i32
	int32_t var1772;	// i32
	int32_t var1773;	// i32
	uint16_t var1774;	// u16
	uint16_t var1775;	// u16
	uint8_t var1776;	// u8
	intptr_t var1777;	// isize
	intptr_t var1778;	// isize
	intptr_t var1779;	// isize
	intptr_t var1780;	// isize
	intptr_t var1781;	// isize
	intptr_t var1782;	// isize
	intptr_t var1783;	// isize
	int64_t var1784;	// i64
	int32_t var1785;	// i32
	int32_t var1786;	// i32
	int32_t var1787;	// i32
	int32_t var1788;	// i32
	int32_t var1789;	// i32
	int8_t var1790;	// i8
	int32_t var1791;	// i32
	int64_t var1792;	// i64
	uintptr_t var1793;	// usize
	int16_t var1794;	// i16
	uintptr_t var1795;	// usize
	uintptr_t var1796;	// usize
	int8_t var1797;	// i8
	int8_t var1798;	// i8
	int32_t var1799;	// i32
	int8_t var1800;	// i8
	uint32_t var1801;	// u32
	uint32_t var1802;	// u32
	uint32_t var1803;	// u32
	int8_t var1804;	// i8
	int128_t var1805;	// i128
	int128_t var1806;	// i128
	int128_t var1807;	// i128
	int128_t var1808;	// i128
	int128_t var1809;	// i128
	int128_t var1810;	// i128
	int128_t var1811;	// i128
	uint32_t var1812;	// u32
	intptr_t var1813;	// isize
	intptr_t var1814;	// isize
	int32_t var1815;	// i32
	int32_t var1816;	// i32
	intptr_t var1817;	// isize
	intptr_t var1818;	// isize
	intptr_t var1819;	// isize
	uint32_t var1820;	// u32
	uint32_t var1821;	// u32
	uint32_t var1822;	// u32
	uint32_t var1823;	// u32
	uint32_t var1824;	// u32
	uint32_t var1825;	// u32
	uint32_t var1826;	// u32
	intptr_t var1827;	// isize
	intptr_t var1828;	// isize
	intptr_t var1829;	// isize
	intptr_t var1830;	// isize
	intptr_t var1831;	// isize
	intptr_t var1832;	// isize
	int128_t var1833;	// i128
	int128_t var1834;	// i128
	int128_t var1835;	// i128
	int128_t var1836;	// i128
	int128_t var1837;	// i128
	int128_t var1838;	// i128
	uint128_t var1839;	// u128
	uint16_t var1840;	// u16
	uint32_t var1841;	// u32
	intptr_t var1842;	// isize
	intptr_t var1843;	// isize
	intptr_t var1844;	// isize
	uint32_t var1845;	// u32
	uint32_t var1846;	// u32
	uint32_t var1847;	// u32
	uint32_t var1848;	// u32
	int16_t var1849;	// i16
	uint32_t var1850;	// u32
	uint32_t var1851;	// u32
	uint32_t var1852;	// u32
	uint32_t var1853;	// u32
	uint32_t var1854;	// u32
	uint32_t var1855;	// u32
	uint32_t var1856;	// u32
	uint8_t var1857;	// u8
	uint8_t var1858;	// u8
	uint8_t var1859;	// u8
	uint8_t var1860;	// u8
	uint8_t var1861;	// u8
	uint8_t var1862;	// u8
	uint8_t var1863;	// u8
	int8_t var1864;	// i8
	int32_t var1865;	// i32
	int32_t var1866;	// i32
	int32_t var1867;	// i32
	int16_t var1868;	// i16
	int16_t var1869;	// i16
	intptr_t var1870;	// isize
	int16_t var1871;	// i16
	int16_t var1872;	// i16
	int16_t var1873;	// i16
	int16_t var1874;	// i16
	uint32_t var1875;	// u32
	uintptr_t var1876;	// usize
	int8_t var1877;	// i8
	int8_t var1878;	// i8
	int8_t var1879;	// i8
	int8_t var1880;	// i8
	uint16_t var1881;	// u16
	int8_t var1882;	// i8
	int8_t var1883;	// i8
	int8_t var1884;	// i8
	int32_t var1885;	// i32
	int32_t var1886;	// i32
	int32_t var1887;	// i32
	int32_t var1888;	// i32
	int32_t var1889;	// i32
	int32_t var1890;	// i32
	int32_t var1891;	// i32
	int32_t var1892;	// i32
	int32_t var1893;	// i32
	uint16_t var1894;	// u16
	uint16_t var1895;	// u16
	uint16_t var1896;	// u16
	uint32_t var1897;	// u32
	uint32_t var1898;	// u32
	uint16_t var1899;	// u16
	uint16_t var1900;	// u16
	uint16_t var1901;	// u16
	uint16_t var1902;	// u16
	uint16_t var1903;	// u16
	int16_t var1904;	// i16
	uint16_t var1905;	// u16
	uint16_t var1906;	// u16
	uint8_t var1907;	// u8
	uint8_t var1908;	// u8
	uint8_t var1909;	// u8
	intptr_t var1910;	// isize
	intptr_t var1911;	// isize
	int64_t var1912;	// i64
	int64_t var1913;	// i64
	uint128_t var1914;	// u128
	uint32_t var1915;	// u32
	uint8_t var1916;	// u8
	int16_t var1917;	// i16
	uint16_t var1918;	// u16
	int16_t var1919;	// i16
	uint32_t var1920;	// u32
	uint8_t var1921;	// u8
	uint8_t var1922;	// u8
	int32_t var1923;	// i32
	int32_t var1924;	// i32
	int32_t var1925;	// i32
	int32_t var1926;	// i32
	int32_t var1927;	// i32
	uint16_t var1928;	// u16
	uint32_t var1929;	// u32
	uintptr_t var1930;	// usize
	uint32_t var1931;	// u32
	uint16_t var1932;	// u16
	uint32_t var1933;	// u32
	uintptr_t var1934;	// usize
	uint32_t var1935;	// u32
	uint32_t var1936;	// u32
	int16_t var1937;	// i16
	int16_t var1938;	// i16
	uint8_t var1939;	// u8
	int16_t var1940;	// i16
	int16_t var1941;	// i16
	int16_t var1942;	// i16
	int16_t var1943;	// i16
	int64_t var1944;	// i64
	int64_t var1945;	// i64
	int16_t var1946;	// i16
	int64_t var1947;	// i64
	int64_t var1948;	// i64
	int64_t var1949;	// i64
	int64_t var1950;	// i64
	intptr_t var1951;	// isize
	intptr_t var1952;	// isize
	intptr_t var1953;	// isize
	uint32_t var1954;	// u32
	int8_t var1955;	// i8
	uint32_t var1956;	// u32
	uint128_t var1957;	// u128
	uint128_t var1958;	// u128
	uint128_t var1959;	// u128
	uint32_t var1960;	// u32
	uint32_t var1961;	// u32
	uint32_t var1962;	// u32
	uint32_t var1963;	// u32
	uint32_t var1964;	// u32
	uint64_t var1965;	// u64
	uint32_t var1966;	// u32
	uint32_t var1967;	// u32
	uint32_t var1968;	// u32
	int128_t var1969;	// i128
	int128_t var1970;	// i128
	int128_t var1971;	// i128
	int128_t var1972;	// i128
	int8_t var1973;	// i8
	int8_t var1974;	// i8
	uint8_t var1975;	// u8
	uint8_t var1976;	// u8
	uint8_t var1977;	// u8
	uint32_t var1978;	// u32
	uint32_t var1979;	// u32
	uint32_t var1980;	// u32
	uint32_t var1981;	// u32
	uint32_t var1982;	// u32
	int32_t var1983;	// i32
	int128_t var1984;	// i128
	int128_t var1985;	// i128
	int128_t var1986;	// i128
	int128_t var1987;	// i128
	int128_t var1988;	// i128
	int128_t var1989;	// i128
	uint32_t var1990;	// u32
	intptr_t var1991;	// isize
	intptr_t var1992;	// isize
	intptr_t var1993;	// isize
	uintptr_t var1994;	// usize
	uintptr_t var1995;	// usize
	uintptr_t var1996;	// usize
	uintptr_t var1997;	// usize
	uintptr_t var1998;	// usize
	uintptr_t var1999;	// usize
	uintptr_t var2000;	// usize
	uint8_t var2001;	// u8
	uint8_t var2002;	// u8
	uint8_t var2003;	// u8
	uint8_t var2004;	// u8
	uint8_t var2005;	// u8
	uint8_t var2006;	// u8
	int32_t var2007;	// i32
	int32_t var2008;	// i32
	int32_t var2009;	// i32
	int32_t var2010;	// i32
	int32_t var2011;	// i32
	int32_t var2012;	// i32
	uint8_t var2013;	// u8
	int16_t var2014;	// i16
	int16_t var2015;	// i16
	uint32_t var2016;	// u32
	uint32_t var2017;	// u32
	int16_t var2018;	// i16
	uint32_t var2019;	// u32
	uint16_t var2020;	// u16
	uint16_t var2021;	// u16
	uint16_t var2022;	// u16
	uint16_t var2023;	// u16
	uint16_t var2024;	// u16
	uint16_t var2025;	// u16
	uint8_t var2026;	// u8
	int8_t var2027;	// i8
	int8_t var2028;	// i8
	int8_t var2029;	// i8
	uint16_t var2030;	// u16
	int8_t var2031;	// i8
	uint32_t var2032;	// u32
	uint32_t var2033;	// u32
	uint64_t var2034;	// u64
	uint128_t var2035;	// u128
	uint128_t var2036;	// u128
	uint128_t var2037;	// u128
	uint128_t var2038;	// u128
	uint128_t var2039;	// u128
	uint128_t var2040;	// u128
	uint128_t var2041;	// u128
	uint128_t var2042;	// u128
	uint128_t var2043;	// u128
	uint128_t var2044;	// u128
	uint128_t var2045;	// u128
	uintptr_t var2046;	// usize
	uint16_t var2047;	// u16
	uint64_t var2048;	// u64
	uint64_t var2049;	// u64
	uint64_t var2050;	// u64
	uint32_t var2051;	// u32
	uint32_t var2052;	// u32
	uint32_t var2053;	// u32
	uint64_t var2054;	// u64
	uint32_t var2055;	// u32
	uint32_t var2056;	// u32
	intptr_t var2057;	// isize
	intptr_t var2058;	// isize
	intptr_t var2059;	// isize
	int32_t var2060;	// i32
	int32_t var2061;	// i32
	int32_t var2062;	// i32
	int32_t var2063;	// i32
	int8_t var2064;	// i8
	int8_t var2065;	// i8
	int8_t var2066;	// i8
	int8_t var2067;	// i8
	int8_t var2068;	// i8
	uint8_t var2069;	// u8
	uint8_t var2070;	// u8
	uint8_t var2071;	// u8
	uint8_t var2072;	// u8
	uint8_t var2073;	// u8
	uint8_t var2074;	// u8
	uint8_t var2075;	// u8
	uint8_t var2076;	// u8
	uint8_t var2077;	// u8
	uint8_t var2078;	// u8
	uintptr_t var2079;	// usize
	uintptr_t var2080;	// usize
	uintptr_t var2081;	// usize
	int8_t var2082;	// i8
	uint32_t var2083;	// u32
	uint32_t var2084;	// u32
	uint32_t var2085;	// u32
	intptr_t var2086;	// isize
	int16_t var2087;	// i16
	int16_t var2088;	// i16
	int16_t var2089;	// i16
	int16_t var2090;	// i16
	int8_t var2091;	// i8
	int32_t var2092;	// i32
	int32_t var2093;	// i32
	uint16_t var2094;	// u16
	uint16_t var2095;	// u16
	uint16_t var2096;	// u16
	uint32_t var2097;	// u32
	uint16_t var2098;	// u16
	uint16_t var2099;	// u16
	uint16_t var2100;	// u16
	uint16_t var2101;	// u16
	uint16_t var2102;	// u16
	uint16_t var2103;	// u16
	uint16_t var2104;	// u16
	uint16_t var2105;	// u16
	uint16_t var2106;	// u16
	uint16_t var2107;	// u16
	uint16_t var2108;	// u16
	uint16_t var2109;	// u16
	uint16_t var2110;	// u16
	uint16_t var2111;	// u16
	uint16_t var2112;	// u16
	int64_t var2113;	// i64
	int64_t var2114;	// i64
	int64_t var2115;	// i64
	int64_t var2116;	// i64
	int64_t var2117;	// i64
	uint64_t var2118;	// u64
	uint64_t var2119;	// u64
	uint64_t var2120;	// u64
	int64_t var2121;	// i64
	uint16_t var2122;	// u16
	uint16_t var2123;	// u16
	int128_t var2124;	// i128
	int16_t var2125;	// i16
	int16_t var2126;	// i16
	int16_t var2127;	// i16
	int16_t var2128;	// i16
	int32_t var2129;	// i32
	int32_t var2130;	// i32
	uint8_t var2131;	// u8
	int8_t var2132;	// i8
	int8_t var2133;	// i8
	int8_t var2134;	// i8
	int64_t var2135;	// i64
	int64_t var2136;	// i64
	int64_t var2137;	// i64
	int64_t var2138;	// i64
	int8_t var2139;	// i8
	int16_t var2140;	// i16
	uint32_t var2141;	// u32
	int16_t var2142;	// i16
	int16_t var2143;	// i16
	int16_t var2144;	// i16
	uint8_t var2145;	// u8
	uint8_t var2146;	// u8
	uint64_t var2147;	// u64
	uint32_t var2148;	// u32
	uint32_t var2149;	// u32
	uint8_t var2150;	// u8
	uint8_t var2151;	// u8
	intptr_t var2152;	// isize
	intptr_t var2153;	// isize
	intptr_t var2154;	// isize
	intptr_t var2155;	// isize
	intptr_t var2156;	// isize
	intptr_t var2157;	// isize
	intptr_t var2158;	// isize
	intptr_t var2159;	// isize
	uint16_t var2160;	// u16
	uint128_t var2161;	// u128
	uint128_t var2162;	// u128
	uint16_t var2163;	// u16
	uint8_t var2164;	// u8
	uint32_t var2165;	// u32
	uint32_t var2166;	// u32
	uint16_t var2167;	// u16
	uint32_t var2168;	// u32
	int32_t var2169;	// i32
	uint16_t var2170;	// u16
	uint8_t var2171;	// u8
	uint8_t var2172;	// u8
	uint32_t var2173;	// u32
	int16_t var2174;	// i16
	int16_t var2175;	// i16
	int16_t var2176;	// i16
	int16_t var2177;	// i16
	int16_t var2178;	// i16
	int16_t var2179;	// i16
	int16_t var2180;	// i16
	int8_t var2181;	// i8
	int8_t var2182;	// i8
	uint32_t var2183;	// u32
	uint32_t var2184;	// u32
	uint32_t var2185;	// u32
	uint32_t var2186;	// u32
	uint32_t var2187;	// u32
	uint32_t var2188;	// u32
	uint32_t var2189;	// u32
	int8_t var2190;	// i8
	RUST_BOOL var2191;	// bool
	int16_t var2192;	// i16
	int16_t var2193;	// i16
	int16_t var2194;	// i16
	int16_t var2195;	// i16
	int16_t var2196;	// i16
	int16_t var2197;	// i16
	uint16_t var2198;	// u16
	uint16_t var2199;	// u16
	uint16_t var2200;	// u16
	uint16_t var2201;	// u16
	uint16_t var2202;	// u16
	uint16_t var2203;	// u16
	uint16_t var2204;	// u16
	uint16_t var2205;	// u16
	uint16_t var2206;	// u16
	uint16_t var2207;	// u16
	uint16_t var2208;	// u16
	uint16_t var2209;	// u16
	uint16_t var2210;	// u16
	uint16_t var2211;	// u16
	uint16_t var2212;	// u16
	uint64_t var2213;	// u64
	uint64_t var2214;	// u64
	uint64_t var2215;	// u64
	uint64_t var2216;	// u64
	uint32_t var2217;	// u32
	uint64_t var2218;	// u64
	uint32_t var2219;	// u32
	uint32_t var2220;	// u32
	int32_t var2221;	// i32
	int64_t var2222;	// i64
	uint32_t var2223;	// u32
	uint8_t var2224;	// u8
	uint32_t var2225;	// u32
	int64_t var2226;	// i64
	int32_t var2227;	// i32
	int32_t var2228;	// i32
	int32_t var2229;	// i32
	int32_t var2230;	// i32
	int32_t var2231;	// i32
	int32_t var2232;	// i32
	int32_t var2233;	// i32
	int32_t var2234;	// i32
	int16_t var2235;	// i16
	int16_t var2236;	// i16
	int16_t var2237;	// i16
	int16_t var2238;	// i16
	int16_t var2239;	// i16
	int16_t var2240;	// i16
	uint16_t var2241;	// u16
	uint16_t var2242;	// u16
	uint16_t var2243;	// u16
	int32_t var2244;	// i32
	int32_t var2245;	// i32
	int32_t var2246;	// i32
	uint16_t var2247;	// u16
	int16_t var2248;	// i16
	int16_t var2249;	// i16
	int16_t var2250;	// i16
	uint32_t var2251;	// u32
	int16_t var2252;	// i16
	uint32_t var2253;	// u32
	int16_t var2254;	// i16
	int16_t var2255;	// i16
	int16_t var2256;	// i16
	int16_t var2257;	// i16
	int16_t var2258;	// i16
	int16_t var2259;	// i16
	int16_t var2260;	// i16
	uint32_t var2261;	// u32
	uint32_t var2262;	// u32
	uint32_t var2263;	// u32
	uint32_t var2264;	// u32
	int128_t var2265;	// i128
	uint16_t var2266;	// u16
	uint16_t var2267;	// u16
	uint16_t var2268;	// u16
	uint16_t var2269;	// u16
	uint16_t var2270;	// u16
	uint16_t var2271;	// u16
	uint16_t var2272;	// u16
	uint16_t var2273;	// u16
	uint16_t var2274;	// u16
	uint32_t var2275;	// u32
	uint32_t var2276;	// u32
	uint32_t var2277;	// u32
	uint64_t var2278;	// u64
	uint128_t var2279;	// u128
	uint128_t var2280;	// u128
	uint16_t var2281;	// u16
	uint128_t var2282;	// u128
	uint128_t var2283;	// u128
	uint128_t var2284;	// u128
	uint128_t var2285;	// u128
	uint128_t var2286;	// u128
	uint128_t var2287;	// u128
	uint8_t var2288;	// u8
	uint32_t var2289;	// u32
	uint8_t var2290;	// u8
	int8_t var2291;	// i8
	uint8_t var2292;	// u8
	uint8_t var2293;	// u8
	uint32_t var2294;	// u32
	uint8_t var2295;	// u8
	uint8_t var2296;	// u8
	uint8_t var2297;	// u8
	uint32_t var2298;	// u32
	uint32_t var2299;	// u32
	uint32_t var2300;	// u32
	uint32_t var2301;	// u32
	int8_t var2302;	// i8
	int8_t var2303;	// i8
	int16_t var2304;	// i16
	int8_t var2305;	// i8
	uintptr_t var2306;	// usize
	uint64_t var2307;	// u64
	uint32_t var2308;	// u32
	int8_t var2309;	// i8
	int8_t var2310;	// i8
	int8_t var2311;	// i8
	uint32_t var2312;	// u32
	uint32_t var2313;	// u32
	uint32_t var2314;	// u32
	uint32_t var2315;	// u32
	uint32_t var2316;	// u32
	int16_t var2317;	// i16
	int16_t var2318;	// i16
	int16_t var2319;	// i16
	int16_t var2320;	// i16
	uint32_t var2321;	// u32
	uint8_t var2322;	// u8
	uint8_t var2323;	// u8
	uint8_t var2324;	// u8
	uint8_t var2325;	// u8
	uint8_t var2326;	// u8
	uint8_t var2327;	// u8
	uint8_t var2328;	// u8
	uint8_t var2329;	// u8
	int64_t var2330;	// i64
	int64_t var2331;	// i64
	int64_t var2332;	// i64
	int64_t var2333;	// i64
	int64_t var2334;	// i64
	uint8_t var2335;	// u8
	uint8_t var2336;	// u8
	uint128_t var2337;	// u128
	int128_t var2338;	// i128
	int128_t var2339;	// i128
	int128_t var2340;	// i128
	uint32_t var2341;	// u32
	int128_t var2342;	// i128
	int128_t var2343;	// i128
	int128_t var2344;	// i128
	uint8_t var2345;	// u8
	uint128_t var2346;	// u128
	uint128_t var2347;	// u128
	uint128_t var2348;	// u128
	uint32_t var2349;	// u32
	uint32_t var2350;	// u32
	uint128_t var2351;	// u128
	uint128_t var2352;	// u128
	uint8_t var2353;	// u8
	uint32_t var2354;	// u32
	uint32_t var2355;	// u32
	uint32_t var2356;	// u32
	uint32_t var2357;	// u32
	uint32_t var2358;	// u32
	uint32_t var2359;	// u32
	uint32_t var2360;	// u32
	uint32_t var2361;	// u32
	uint32_t var2362;	// u32
	uint32_t var2363;	// u32
	uint32_t var2364;	// u32
	uint32_t var2365;	// u32
	uint32_t var2366;	// u32
	uint32_t var2367;	// u32
	uint32_t var2368;	// u32
	uint32_t var2369;	// u32
	int128_t var2370;	// i128
	int128_t var2371;	// i128
	int128_t var2372;	// i128
	int128_t var2373;	// i128
	int128_t var2374;	// i128
	int128_t var2375;	// i128
	int128_t var2376;	// i128
	int128_t var2377;	// i128
	int128_t var2378;	// i128
	int128_t var2379;	// i128
	int128_t var2380;	// i128
	int128_t var2381;	// i128
	int128_t var2382;	// i128
	int128_t var2383;	// i128
	uintptr_t var2384;	// usize
	uintptr_t var2385;	// usize
	uint32_t var2386;	// u32
	uint16_t var2387;	// u16
	uint16_t var2388;	// u16
	uint16_t var2389;	// u16
	uint16_t var2390;	// u16
	uint16_t var2391;	// u16
	uint16_t var2392;	// u16
	uintptr_t var2393;	// usize
	uintptr_t var2394;	// usize
	int64_t var2395;	// i64
	int64_t var2396;	// i64
	int64_t var2397;	// i64
	int64_t var2398;	// i64
	uintptr_t var2399;	// usize
	uintptr_t var2400;	// usize
	uintptr_t var2401;	// usize
	uintptr_t var2402;	// usize
	uintptr_t var2403;	// usize
	uintptr_t var2404;	// usize
	int32_t var2405;	// i32
	uint32_t var2406;	// u32
	uint32_t var2407;	// u32
	int8_t var2408;	// i8
	uint32_t var2409;	// u32
	uint32_t var2410;	// u32
	int8_t var2411;	// i8
	uint32_t var2412;	// u32
	uint32_t var2413;	// u32
	uint16_t var2414;	// u16
	uint8_t var2415;	// u8
	int8_t var2416;	// i8
	int8_t var2417;	// i8
	int8_t var2418;	// i8
	int8_t var2419;	// i8
	uint16_t var2420;	// u16
	uint16_t var2421;	// u16
	uint16_t var2422;	// u16
	uint16_t var2423;	// u16
	uint16_t var2424;	// u16
	uint16_t var2425;	// u16
	uint16_t var2426;	// u16
	uint32_t var2427;	// u32
	uint32_t var2428;	// u32
	uint32_t var2429;	// u32
	uintptr_t var2430;	// usize
	int16_t var2431;	// i16
	int16_t var2432;	// i16
	uint16_t var2433;	// u16
	uint16_t var2434;	// u16
	uint16_t var2435;	// u16
	uint16_t var2436;	// u16
	uint16_t var2437;	// u16
	uint16_t var2438;	// u16
	uint8_t var2439;	// u8
	uint16_t var2440;	// u16
	uint16_t var2441;	// u16
	uint32_t var2442;	// u32
	uint32_t var2443;	// u32
	uint32_t var2444;	// u32
	uint32_t var2445;	// u32
	uint32_t var2446;	// u32
	uint16_t var2447;	// u16
	uint32_t var2448;	// u32
	int64_t var2449;	// i64
	int64_t var2450;	// i64
	uint16_t var2451;	// u16
	uint32_t var2452;	// u32
	uint16_t var2453;	// u16
	uint16_t var2454;	// u16
	uint16_t var2455;	// u16
	int8_t var2456;	// i8
	int8_t var2457;	// i8
	uint16_t var2458;	// u16
	uint16_t var2459;	// u16
	uint16_t var2460;	// u16
	uint16_t var2461;	// u16
	uint16_t var2462;	// u16
	uint16_t var2463;	// u16
	intptr_t var2464;	// isize
	int64_t var2465;	// i64
	int16_t var2466;	// i16
	int16_t var2467;	// i16
	int16_t var2468;	// i16
	int16_t var2469;	// i16
	int16_t var2470;	// i16
	int16_t var2471;	// i16
	int16_t var2472;	// i16
	int16_t var2473;	// i16
	uint128_t var2474;	// u128
	uint128_t var2475;	// u128
	uint128_t var2476;	// u128
	uint128_t var2477;	// u128
	uint128_t var2478;	// u128
	uint128_t var2479;	// u128
	uint128_t var2480;	// u128
	int16_t var2481;	// i16
	int16_t var2482;	// i16
	int16_t var2483;	// i16
	uint32_t var2484;	// u32
	uint16_t var2485;	// u16
	uint128_t var2486;	// u128
	uint128_t var2487;	// u128
	uint128_t var2488;	// u128
	uint128_t var2489;	// u128
	uint128_t var2490;	// u128
	uint128_t var2491;	// u128
	uint128_t var2492;	// u128
	uint32_t var2493;	// u32
	uint32_t var2494;	// u32
	uint32_t var2495;	// u32
	uint32_t var2496;	// u32
	int16_t var2497;	// i16
	uint32_t var2498;	// u32
	intptr_t var2499;	// isize
	intptr_t var2500;	// isize
	intptr_t var2501;	// isize
	intptr_t var2502;	// isize
	uint64_t var2503;	// u64
	uint64_t var2504;	// u64
	uint64_t var2505;	// u64
	uint64_t var2506;	// u64
	int32_t var2507;	// i32
	int32_t var2508;	// i32
	int32_t var2509;	// i32
	int32_t var2510;	// i32
	int32_t var2511;	// i32
	uint8_t var2512;	// u8
	uint8_t var2513;	// u8
	uint16_t var2514;	// u16
	uint16_t var2515;	// u16
	uint16_t var2516;	// u16
	uint128_t var2517;	// u128
	int16_t var2518;	// i16
	uint8_t var2519;	// u8
	uint8_t var2520;	// u8
	uint8_t var2521;	// u8
	uint8_t var2522;	// u8
	int32_t var2523;	// i32
	int32_t var2524;	// i32
	int32_t var2525;	// i32
	uint8_t var2526;	// u8
	uint32_t var2527;	// u32
	uint16_t var2528;	// u16
	uint16_t var2529;	// u16
	uint32_t var2530;	// u32
	uint16_t var2531;	// u16
	uint16_t var2532;	// u16
	uint16_t var2533;	// u16
	uint16_t var2534;	// u16
	uint32_t var2535;	// u32
	uint32_t var2536;	// u32
	uint32_t var2537;	// u32
	uint32_t var2538;	// u32
	uintptr_t var2539;	// usize
	int32_t var2540;	// i32
	uint32_t var2541;	// u32
	uint32_t var2542;	// u32
	uint8_t var2543;	// u8
	uint16_t var2544;	// u16
	uint32_t var2545;	// u32
	uint16_t var2546;	// u16
	uint16_t var2547;	// u16
	uint16_t var2548;	// u16
	uint8_t var2549;	// u8
	int32_t var2550;	// i32
	int32_t var2551;	// i32
	int32_t var2552;	// i32
	int32_t var2553;	// i32
	int32_t var2554;	// i32
	uint8_t var2555;	// u8
	uint32_t var2556;	// u32
	uint32_t var2557;	// u32
	uint32_t var2558;	// u32
	uint32_t var2559;	// u32
	uint32_t var2560;	// u32
	uint32_t var2561;	// u32
	uint32_t var2562;	// u32
	int32_t var2563;	// i32
	uint32_t var2564;	// u32
	uint32_t var2565;	// u32
	uint32_t var2566;	// u32
	uint32_t var2567;	// u32
	uint32_t var2568;	// u32
	uint16_t var2569;	// u16
	int64_t var2570;	// i64
	int64_t var2571;	// i64
	int64_t var2572;	// i64
	uint16_t var2573;	// u16
	uint32_t var2574;	// u32
	uint32_t var2575;	// u32
	uint128_t var2576;	// u128
	uint128_t var2577;	// u128
	int8_t var2578;	// i8
	int8_t var2579;	// i8
	int8_t var2580;	// i8
	int16_t var2581;	// i16
	int16_t var2582;	// i16
	int16_t var2583;	// i16
	int16_t var2584;	// i16
	int16_t var2585;	// i16
	int16_t var2586;	// i16
	int16_t var2587;	// i16
	int16_t var2588;	// i16
	int16_t var2589;	// i16
	int16_t var2590;	// i16
	int16_t var2591;	// i16
	int16_t var2592;	// i16
	uint128_t var2593;	// u128
	uint32_t var2594;	// u32
	uint32_t var2595;	// u32
	uint128_t var2596;	// u128
	int32_t var2597;	// i32
	int16_t var2598;	// i16
	int16_t var2599;	// i16
	int16_t var2600;	// i16
	int16_t var2601;	// i16
	uint16_t var2602;	// u16
	uint16_t var2603;	// u16
	uint16_t var2604;	// u16
	uint16_t var2605;	// u16
	uint16_t var2606;	// u16
	uint16_t var2607;	// u16
	uint8_t var2608;	// u8
	uint16_t var2609;	// u16
	uint8_t var2610;	// u8
	uint16_t var2611;	// u16
	uint8_t var2612;	// u8
	uint8_t var2613;	// u8
	uint8_t var2614;	// u8
	int16_t var2615;	// i16
	int16_t var2616;	// i16
	int16_t var2617;	// i16
	int16_t var2618;	// i16
	int16_t var2619;	// i16
	int32_t var2620;	// i32
	int32_t var2621;	// i32
	int32_t var2622;	// i32
	int32_t var2623;	// i32
	int32_t var2624;	// i32
	uint32_t var2625;	// u32
	uint32_t var2626;	// u32
	uint32_t var2627;	// u32
	uint16_t var2628;	// u16
	uint16_t var2629;	// u16
	uint16_t var2630;	// u16
	uint16_t var2631;	// u16
	uint16_t var2632;	// u16
	uint16_t var2633;	// u16
	int8_t var2634;	// i8
	int8_t var2635;	// i8
	int32_t var2636;	// i32
	uint32_t var2637;	// u32
	uint32_t var2638;	// u32
	int32_t var2639;	// i32
	intptr_t var2640;	// isize
	intptr_t var2641;	// isize
	int16_t var2642;	// i16
	int16_t var2643;	// i16
	int8_t var2644;	// i8
	uint64_t var2645;	// u64
	uint64_t var2646;	// u64
	uint8_t var2647;	// u8
	uint8_t var2648;	// u8
	uint8_t var2649;	// u8
	uint8_t var2650;	// u8
	int16_t var2651;	// i16
	uint16_t var2652;	// u16
	int8_t var2653;	// i8
	uint128_t var2654;	// u128
	uint128_t var2655;	// u128
	uint128_t var2656;	// u128
	uint128_t var2657;	// u128
	uint128_t var2658;	// u128
	int16_t var2659;	// i16
	int16_t var2660;	// i16
	uint8_t var2661;	// u8
	int16_t var2662;	// i16
	int16_t var2663;	// i16
	int32_t var2664;	// i32
	uint128_t var2665;	// u128
	uint128_t var2666;	// u128
	uint128_t var2667;	// u128
	uint128_t var2668;	// u128
	int32_t var2669;	// i32
	int64_t var2670;	// i64
	int64_t var2671;	// i64
	int64_t var2672;	// i64
	int64_t var2673;	// i64
	int64_t var2674;	// i64
	int64_t var2675;	// i64
	uint8_t var2676;	// u8
	uint8_t var2677;	// u8
	uintptr_t var2678;	// usize
	uintptr_t var2679;	// usize
	uint32_t var2680;	// u32
	uint32_t var2681;	// u32
	uintptr_t var2682;	// usize
	uint8_t var2683;	// u8
	int16_t var2684;	// i16
	int32_t var2685;	// i32
	int16_t var2686;	// i16
	int16_t var2687;	// i16
	int16_t var2688;	// i16
	uint32_t var2689;	// u32
	uint32_t var2690;	// u32
	uint32_t var2691;	// u32
	uint32_t var2692;	// u32
	int16_t var2693;	// i16
	int16_t var2694;	// i16
	uint128_t var2695;	// u128
	uint8_t var2696;	// u8
	uint8_t var2697;	// u8
	uint32_t var2698;	// u32
	uint32_t var2699;	// u32
	uint32_t var2700;	// u32
	uint8_t var2701;	// u8
	int32_t var2702;	// i32
	int32_t var2703;	// i32
	int32_t var2704;	// i32
	int32_t var2705;	// i32
	int32_t var2706;	// i32
	int32_t var2707;	// i32
	int32_t var2708;	// i32
	int32_t var2709;	// i32
	int32_t var2710;	// i32
	int32_t var2711;	// i32
	int32_t var2712;	// i32
	int32_t var2713;	// i32
	int8_t var2714;	// i8
	int8_t var2715;	// i8
	int8_t var2716;	// i8
	uint128_t var2717;	// u128
	uint128_t var2718;	// u128
	uint128_t var2719;	// u128
	uint128_t var2720;	// u128
	uint128_t var2721;	// u128
	uint16_t var2722;	// u16
	uint16_t var2723;	// u16
	uint16_t var2724;	// u16
	uint16_t var2725;	// u16
	uint16_t var2726;	// u16
	uint16_t var2727;	// u16
	uint16_t var2728;	// u16
	uint16_t var2729;	// u16
	uint16_t var2730;	// u16
	int8_t var2731;	// i8
	int8_t var2732;	// i8
	int32_t var2733;	// i32
	uint16_t var2734;	// u16
	uint16_t var2735;	// u16
	int16_t var2736;	// i16
	int16_t var2737;	// i16
	uint64_t var2738;	// u64
	uint64_t var2739;	// u64
	uint64_t var2740;	// u64
	uint64_t var2741;	// u64
	int32_t var2742;	// i32
	int32_t var2743;	// i32
	int64_t var2744;	// i64
	int64_t var2745;	// i64
	int64_t var2746;	// i64
	int64_t var2747;	// i64
	uint32_t var2748;	// u32
	uint32_t var2749;	// u32
	int64_t var2750;	// i64
	uint128_t var2751;	// u128
	uint128_t var2752;	// u128
	uint128_t var2753;	// u128
	uint16_t var2754;	// u16
	int8_t var2755;	// i8
	int8_t var2756;	// i8
	int8_t var2757;	// i8
	uint32_t var2758;	// u32
	uint32_t var2759;	// u32
	int16_t var2760;	// i16
	int16_t var2761;	// i16
	int16_t var2762;	// i16
	int16_t var2763;	// i16
	int16_t var2764;	// i16
	uint128_t var2765;	// u128
	uint128_t var2766;	// u128
	uint128_t var2767;	// u128
	uint128_t var2768;	// u128
	uint128_t var2769;	// u128
	uint128_t var2770;	// u128
	uint128_t var2771;	// u128
	uint128_t var2772;	// u128
	uint128_t var2773;	// u128
	uint128_t var2774;	// u128
	uint128_t var2775;	// u128
	uint128_t var2776;	// u128
	uint128_t var2777;	// u128
	uint128_t var2778;	// u128
	uint128_t var2779;	// u128
	uint128_t var2780;	// u128
	int16_t var2781;	// i16
	int16_t var2782;	// i16
	int16_t var2783;	// i16
	uint16_t var2784;	// u16
	uint16_t var2785;	// u16
	uint16_t var2786;	// u16
	uint16_t var2787;	// u16
	uint16_t var2788;	// u16
	uint16_t var2789;	// u16
	uint16_t var2790;	// u16
	uint8_t var2791;	// u8
	int64_t var2792;	// i64
	uint8_t var2793;	// u8
	uint8_t var2794;	// u8
	uint8_t var2795;	// u8
	uint8_t var2796;	// u8
	uint8_t var2797;	// u8
	uint128_t var2798;	// u128
	uint16_t var2799;	// u16
	uint16_t var2800;	// u16
	uint16_t var2801;	// u16
	uint16_t var2802;	// u16
	uint16_t var2803;	// u16
	uint8_t var2804;	// u8
	uint32_t var2805;	// u32
	uint8_t var2806;	// u8
	RUST_BOOL var2807;	// bool
	uint8_t var2808;	// u8
	uint8_t var2809;	// u8
	uint8_t var2810;	// u8
	int16_t var2811;	// i16
	int16_t var2812;	// i16
	int16_t var2813;	// i16
	int8_t var2814;	// i8
	int8_t var2815;	// i8
	int8_t var2816;	// i8
	int8_t var2817;	// i8
	int8_t var2818;	// i8
	uint128_t var2819;	// u128
	int8_t var2820;	// i8
	int8_t var2821;	// i8
	int8_t var2822;	// i8
	int8_t var2823;	// i8
	int8_t var2824;	// i8
	int8_t var2825;	// i8
	int8_t var2826;	// i8
	int8_t var2827;	// i8
	int8_t var2828;	// i8
	int8_t var2829;	// i8
	int8_t var2830;	// i8
	uint16_t var2831;	// u16
	uint128_t var2832;	// u128
	int16_t var2833;	// i16
	int16_t var2834;	// i16
	int16_t var2835;	// i16
	int32_t var2836;	// i32
	uint32_t var2837;	// u32
	uint32_t var2838;	// u32
	uint32_t var2839;	// u32
	uint32_t var2840;	// u32
	int64_t var2841;	// i64
	int64_t var2842;	// i64
	int64_t var2843;	// i64
	int64_t var2844;	// i64
	int64_t var2845;	// i64
	int64_t var2846;	// i64
	int32_t var2847;	// i32
	int32_t var2848;	// i32
	int32_t var2849;	// i32
	int32_t var2850;	// i32
	int128_t var2851;	// i128
	uint16_t var2852;	// u16
	uint16_t var2853;	// u16
	uint16_t var2854;	// u16
	uint64_t var2855;	// u64
	uintptr_t var2856;	// usize
	uint32_t var2857;	// u32
	intptr_t var2858;	// isize
	uint32_t var2859;	// u32
	int8_t var2860;	// i8
	int16_t var2861;	// i16
	int8_t var2862;	// i8
	int8_t var2863;	// i8
	int8_t var2864;	// i8
	uint32_t var2865;	// u32
	uint32_t var2866;	// u32
	int8_t var2867;	// i8
	int8_t var2868;	// i8
	int8_t var2869;	// i8
	int8_t var2870;	// i8
	int8_t var2871;	// i8
	int8_t var2872;	// i8
	int8_t var2873;	// i8
	int8_t var2874;	// i8
	uint8_t var2875;	// u8
	uint8_t var2876;	// u8
	uint16_t var2877;	// u16
	uint8_t var2878;	// u8
	int64_t var2879;	// i64
	int64_t var2880;	// i64
	int64_t var2881;	// i64
	int64_t var2882;	// i64
	int64_t var2883;	// i64
	int64_t var2884;	// i64
	int64_t var2885;	// i64
	uint32_t var2886;	// u32
	uint32_t var2887;	// u32
	uint32_t var2888;	// u32
	uint32_t var2889;	// u32
	uint32_t var2890;	// u32
	uint32_t var2891;	// u32
	int64_t var2892;	// i64
	uintptr_t var2893;	// usize
	uintptr_t var2894;	// usize
	uintptr_t var2895;	// usize
	uintptr_t var2896;	// usize
	int128_t var2897;	// i128
	int128_t var2898;	// i128
	int128_t var2899;	// i128
	int128_t var2900;	// i128
	int128_t var2901;	// i128
	int128_t var2902;	// i128
	int128_t var2903;	// i128
	int128_t var2904;	// i128
	int32_t var2905;	// i32
	RUST_BOOL var2906;	// bool
	uint16_t var2907;	// u16
	int128_t var2908;	// i128
	RUST_BOOL var2909;	// bool
	uint128_t var2910;	// u128
	uint128_t var2911;	// u128
	uint128_t var2912;	// u128
	uint128_t var2913;	// u128
	uint128_t var2914;	// u128
	uint128_t var2915;	// u128
	int8_t var2916;	// i8
	int8_t var2917;	// i8
	int8_t var2918;	// i8
	int8_t var2919;	// i8
	uint128_t var2920;	// u128
	int8_t var2921;	// i8
	int8_t var2922;	// i8
	int8_t var2923;	// i8
	int8_t var2924;	// i8
	int8_t var2925;	// i8
	int8_t var2926;	// i8
	int8_t var2927;	// i8
	uint64_t var2928;	// u64
	uint64_t var2929;	// u64
	uint128_t var2930;	// u128
	uint16_t var2931;	// u16
	uint16_t var2932;	// u16
	uint128_t var2933;	// u128
	uint16_t var2934;	// u16
	uint16_t var2935;	// u16
	uint16_t var2936;	// u16
	uint16_t var2937;	// u16
	int64_t var2938;	// i64
	int64_t var2939;	// i64
	int64_t var2940;	// i64
	int64_t var2941;	// i64
	int64_t var2942;	// i64
	int64_t var2943;	// i64
	int64_t var2944;	// i64
	int16_t var2945;	// i16
	int16_t var2946;	// i16
	int16_t var2947;	// i16
	int16_t var2948;	// i16
	intptr_t var2949;	// isize
	intptr_t var2950;	// isize
	intptr_t var2951;	// isize
	intptr_t var2952;	// isize
	intptr_t var2953;	// isize
	intptr_t var2954;	// isize
	intptr_t var2955;	// isize
	intptr_t var2956;	// isize
	intptr_t var2957;	// isize
	intptr_t var2958;	// isize
	intptr_t var2959;	// isize
	intptr_t var2960;	// isize
	int16_t var2961;	// i16
	int16_t var2962;	// i16
	int16_t var2963;	// i16
	int32_t var2964;	// i32
	int32_t var2965;	// i32
	int32_t var2966;	// i32
	int32_t var2967;	// i32
	int16_t var2968;	// i16
	int16_t var2969;	// i16
	int16_t var2970;	// i16
	int32_t var2971;	// i32
	int64_t var2972;	// i64
	uint32_t var2973;	// u32
	uint32_t var2974;	// u32
	uint32_t var2975;	// u32
	uint32_t var2976;	// u32
	int64_t var2977;	// i64
	int16_t var2978;	// i16
	int16_t var2979;	// i16
	int16_t var2980;	// i16
	int16_t var2981;	// i16
	intptr_t var2982;	// isize
	intptr_t var2983;	// isize
	int16_t var2984;	// i16
	int16_t var2985;	// i16
	int64_t var2986;	// i64
	int16_t var2987;	// i16
	int16_t var2988;	// i16
	uint8_t var2989;	// u8
	uint8_t var2990;	// u8
	uint8_t var2991;	// u8
	uint8_t var2992;	// u8
	int64_t var2993;	// i64
	int8_t var2994;	// i8
	int8_t var2995;	// i8
	int8_t var2996;	// i8
	int8_t var2997;	// i8
	int8_t var2998;	// i8
	uintptr_t var2999;	// usize
	uintptr_t var3000;	// usize
	int128_t var3001;	// i128
	int128_t var3002;	// i128
	int128_t var3003;	// i128
	int128_t var3004;	// i128
	int128_t var3005;	// i128
	uint32_t var3006;	// u32
	uint32_t var3007;	// u32
	uint32_t var3008;	// u32
	uint32_t var3009;	// u32
	uint8_t var3010;	// u8
	uint32_t var3011;	// u32
	int32_t var3012;	// i32
	int32_t var3013;	// i32
	uint16_t var3014;	// u16
	uint16_t var3015;	// u16
	int16_t var3016;	// i16
	int16_t var3017;	// i16
	int16_t var3018;	// i16
	RUST_BOOL var3019;	// bool
	intptr_t var3020;	// isize
	intptr_t var3021;	// isize
	RUST_BOOL var3022;	// bool
	RUST_BOOL var3023;	// bool
	uint16_t var3024;	// u16
	int16_t var3025;	// i16
	uint32_t var3026;	// u32
	uint16_t var3027;	// u16
	uint16_t var3028;	// u16
	uint16_t var3029;	// u16
	uint32_t var3030;	// u32
	int8_t var3031;	// i8
	int16_t var3032;	// i16
	int16_t var3033;	// i16
	int16_t var3034;	// i16
	int16_t var3035;	// i16
	int8_t var3036;	// i8
	int8_t var3037;	// i8
	int8_t var3038;	// i8
	uint16_t var3039;	// u16
	int16_t var3040;	// i16
	int16_t var3041;	// i16
	int16_t var3042;	// i16
	uint16_t var3043;	// u16
	int16_t var3044;	// i16
	uint16_t var3045;	// u16
	uint32_t var3046;	// u32
	uint32_t var3047;	// u32
	uint16_t var3048;	// u16
	uint16_t var3049;	// u16
	uint16_t var3050;	// u16
	uint16_t var3051;	// u16
	uint16_t var3052;	// u16
	uint32_t var3053;	// u32
	uint32_t var3054;	// u32
	uint16_t var3055;	// u16
	uint32_t var3056;	// u32
	intptr_t var3057;	// isize
	uint32_t var3058;	// u32
	uint32_t var3059;	// u32
	uint32_t var3060;	// u32
	uint32_t var3061;	// u32
	uint32_t var3062;	// u32
	uint8_t var3063;	// u8
	uint8_t var3064;	// u8
	uint8_t var3065;	// u8
	uint8_t var3066;	// u8
	uint8_t var3067;	// u8
	int128_t var3068;	// i128
	uint16_t var3069;	// u16
	int32_t var3070;	// i32
	int128_t var3071;	// i128
	int128_t var3072;	// i128
	int16_t var3073;	// i16
	int128_t var3074;	// i128
	int128_t var3075;	// i128
	int128_t var3076;	// i128
	intptr_t var3077;	// isize
	uint128_t var3078;	// u128
	uint8_t var3079;	// u8
	uint8_t var3080;	// u8
	int16_t var3081;	// i16
	uint8_t var3082;	// u8
	uint8_t var3083;	// u8
	int16_t var3084;	// i16
	int16_t var3085;	// i16
	uint16_t var3086;	// u16
	uint16_t var3087;	// u16
	uint16_t var3088;	// u16
	uint32_t var3089;	// u32
	uint32_t var3090;	// u32
	uint32_t var3091;	// u32
	int8_t var3092;	// i8
	int8_t var3093;	// i8
	int8_t var3094;	// i8
	int8_t var3095;	// i8
	int8_t var3096;	// i8
	int8_t var3097;	// i8
	int8_t var3098;	// i8
	uint8_t var3099;	// u8
	int8_t var3100;	// i8
	int8_t var3101;	// i8
	int8_t var3102;	// i8
	int8_t var3103;	// i8
	int8_t var3104;	// i8
	int8_t var3105;	// i8
	uint32_t var3106;	// u32
	int8_t var3107;	// i8
	int8_t var3108;	// i8
	int8_t var3109;	// i8
	intptr_t var3110;	// isize
	uint16_t var3111;	// u16
	uint16_t var3112;	// u16
	uint16_t var3113;	// u16
	uintptr_t var3114;	// usize
	uint16_t var3115;	// u16
	uint16_t var3116;	// u16
	uint16_t var3117;	// u16
	uint16_t var3118;	// u16
	uint16_t var3119;	// u16
	uint16_t var3120;	// u16
	int32_t var3121;	// i32
	int64_t var3122;	// i64
	uint8_t var3123;	// u8
	uint8_t var3124;	// u8
	uint8_t var3125;	// u8
	uint8_t var3126;	// u8
	uint8_t var3127;	// u8
	int128_t var3128;	// i128
	uint8_t var3129;	// u8
	uint32_t var3130;	// u32
	uint32_t var3131;	// u32
	intptr_t var3132;	// isize
	intptr_t var3133;	// isize
	intptr_t var3134;	// isize
	intptr_t var3135;	// isize
	intptr_t var3136;	// isize
	intptr_t var3137;	// isize
	intptr_t var3138;	// isize
	intptr_t var3139;	// isize
	int8_t var3140;	// i8
	int8_t var3141;	// i8
	int8_t var3142;	// i8
	int8_t var3143;	// i8
	int8_t var3144;	// i8
	int8_t var3145;	// i8
	uint64_t var3146;	// u64
	uint64_t var3147;	// u64
	uint64_t var3148;	// u64
	uint64_t var3149;	// u64
	uint64_t var3150;	// u64
	uint64_t var3151;	// u64
	uintptr_t var3152;	// usize
	uintptr_t var3153;	// usize
	uintptr_t var3154;	// usize
	uintptr_t var3155;	// usize
	uintptr_t var3156;	// usize
	uintptr_t var3157;	// usize
	uintptr_t var3158;	// usize
	uintptr_t var3159;	// usize
	uintptr_t var3160;	// usize
	uintptr_t var3161;	// usize
	uintptr_t var3162;	// usize
	int16_t var3163;	// i16
	int16_t var3164;	// i16
	int16_t var3165;	// i16
	uintptr_t var3166;	// usize
	intptr_t var3167;	// isize
	uint16_t var3168;	// u16
	int32_t var3169;	// i32
	uint32_t var3170;	// u32
	uint32_t var3171;	// u32
	int32_t var3172;	// i32
	int8_t var3173;	// i8
	int8_t var3174;	// i8
	int8_t var3175;	// i8
	int8_t var3176;	// i8
	int8_t var3177;	// i8
	int16_t var3178;	// i16
	uint16_t var3179;	// u16
	uint32_t var3180;	// u32
	uint32_t var3181;	// u32
	uint32_t var3182;	// u32
	uint32_t var3183;	// u32
	int64_t var3184;	// i64
	int16_t var3185;	// i16
	int16_t var3186;	// i16
	int16_t var3187;	// i16
	int8_t var3188;	// i8
	int128_t var3189;	// i128
	intptr_t var3190;	// isize
	uint128_t var3191;	// u128
	uint8_t var3192;	// u8
	uint8_t var3193;	// u8
	uint8_t var3194;	// u8
	uint8_t var3195;	// u8
	int16_t var3196;	// i16
	uint8_t var3197;	// u8
	uintptr_t var3198;	// usize
	uintptr_t var3199;	// usize
	uintptr_t var3200;	// usize
	uintptr_t var3201;	// usize
	uintptr_t var3202;	// usize
	uintptr_t var3203;	// usize
	uintptr_t var3204;	// usize
	uintptr_t var3205;	// usize
	uintptr_t var3206;	// usize
	uintptr_t var3207;	// usize
	int128_t var3208;	// i128
	int128_t var3209;	// i128
	int128_t var3210;	// i128
	int128_t var3211;	// i128
	int128_t var3212;	// i128
	int128_t var3213;	// i128
	int128_t var3214;	// i128
	int128_t var3215;	// i128
	int128_t var3216;	// i128
	uint16_t var3217;	// u16
	uint16_t var3218;	// u16
	uint16_t var3219;	// u16
	intptr_t var3220;	// isize
	uint16_t var3221;	// u16
	uint16_t var3222;	// u16
	uint16_t var3223;	// u16
	uint32_t var3224;	// u32
	uint16_t var3225;	// u16
	uint8_t var3226;	// u8
	uint16_t var3227;	// u16
	uint16_t var3228;	// u16
	intptr_t var3229;	// isize
	intptr_t var3230;	// isize
	uint64_t var3231;	// u64
	uint64_t var3232;	// u64
	uint8_t var3233;	// u8
	uint32_t var3234;	// u32
	uint32_t var3235;	// u32
	uint32_t var3236;	// u32
	uint8_t var3237;	// u8
	uint16_t var3238;	// u16
	uint32_t var3239;	// u32
	uint32_t var3240;	// u32
	uint32_t var3241;	// u32
	uint32_t var3242;	// u32
	int64_t var3243;	// i64
	uint32_t var3244;	// u32
	uint32_t var3245;	// u32
	int32_t var3246;	// i32
	int32_t var3247;	// i32
	int32_t var3248;	// i32
	int128_t var3249;	// i128
	int128_t var3250;	// i128
	int128_t var3251;	// i128
	uint16_t var3252;	// u16
	uint16_t var3253;	// u16
	uint16_t var3254;	// u16
	int8_t var3255;	// i8
	int8_t var3256;	// i8
	uint16_t var3257;	// u16
	uint32_t var3258;	// u32
	uint32_t var3259;	// u32
	uint32_t var3260;	// u32
	intptr_t var3261;	// isize
	uint32_t var3262;	// u32
	uint128_t var3263;	// u128
	uint32_t var3264;	// u32
	uint32_t var3265;	// u32
	uint8_t var3266;	// u8
	uint8_t var3267;	// u8
	int16_t var3268;	// i16
	int16_t var3269;	// i16
	int16_t var3270;	// i16
	uint16_t var3271;	// u16
	uint128_t var3272;	// u128
	uint16_t var3273;	// u16
	uint16_t var3274;	// u16
	RUST_BOOL var3275;	// bool
	RUST_BOOL var3276;	// bool
	RUST_BOOL var3277;	// bool
	RUST_BOOL var3278;	// bool
	RUST_BOOL var3279;	// bool
	uint128_t var3280;	// u128
	int32_t var3281;	// i32
	uint128_t var3282;	// u128
	int32_t var3283;	// i32
	int32_t var3284;	// i32
	uint32_t var3285;	// u32
	uint32_t var3286;	// u32
	uint32_t var3287;	// u32
	uintptr_t var3288;	// usize
	uint32_t var3289;	// u32
	uint32_t var3290;	// u32
	uint32_t var3291;	// u32
	uint8_t var3292;	// u8
	uint32_t var3293;	// u32
	uint32_t var3294;	// u32
	uint128_t var3295;	// u128
	uint32_t var3296;	// u32
	uint32_t var3297;	// u32
	uint32_t var3298;	// u32
	uint32_t var3299;	// u32
	uint128_t var3300;	// u128
	int32_t var3301;	// i32
	int32_t var3302;	// i32
	int32_t var3303;	// i32
	uint8_t var3304;	// u8
	uint32_t var3305;	// u32
	uint8_t var3306;	// u8
	uint8_t var3307;	// u8
	uint8_t var3308;	// u8
	uint8_t var3309;	// u8
	uint8_t var3310;	// u8
	uint8_t var3311;	// u8
	uint8_t var3312;	// u8
	uint8_t var3313;	// u8
	uint8_t var3314;	// u8
	int8_t var3315;	// i8
	int8_t var3316;	// i8
	int8_t var3317;	// i8
	int8_t var3318;	// i8
	int8_t var3319;	// i8
	uint32_t var3320;	// u32
	uint32_t var3321;	// u32
	uintptr_t var3322;	// usize
	uint32_t var3323;	// u32
	uintptr_t var3324;	// usize
	uintptr_t var3325;	// usize
	uint32_t var3326;	// u32
	uint32_t var3327;	// u32
	uint32_t var3328;	// u32
	uintptr_t var3329;	// usize
	uintptr_t var3330;	// usize
	intptr_t var3331;	// isize
	intptr_t var3332;	// isize
	intptr_t var3333;	// isize
	int32_t var3334;	// i32
	int32_t var3335;	// i32
	uint32_t var3336;	// u32
	uint32_t var3337;	// u32
	uint32_t var3338;	// u32
	uint32_t var3339;	// u32
	uint32_t var3340;	// u32
	int16_t var3341;	// i16
	int16_t var3342;	// i16
	int16_t var3343;	// i16
	int16_t var3344;	// i16
	int16_t var3345;	// i16
	uint64_t var3346;	// u64
	uint64_t var3347;	// u64
	uint64_t var3348;	// u64
	uint16_t var3349;	// u16
	uint16_t var3350;	// u16
	uint16_t var3351;	// u16
	uintptr_t var3352;	// usize
	uintptr_t var3353;	// usize
	uintptr_t var3354;	// usize
	uintptr_t var3355;	// usize
	uintptr_t var3356;	// usize
	uintptr_t var3357;	// usize
	uint32_t var3358;	// u32
	uintptr_t var3359;	// usize
	uint8_t var3360;	// u8
	int8_t var3361;	// i8
	int32_t var3362;	// i32
	int32_t var3363;	// i32
	int32_t var3364;	// i32
	int32_t var3365;	// i32
	int32_t var3366;	// i32
	uint8_t var3367;	// u8
	uint8_t var3368;	// u8
	uint8_t var3369;	// u8
	uint8_t var3370;	// u8
	int128_t var3371;	// i128
	int128_t var3372;	// i128
	int128_t var3373;	// i128
	int128_t var3374;	// i128
	int128_t var3375;	// i128
	int32_t var3376;	// i32
	int32_t var3377;	// i32
	int32_t var3378;	// i32
	int32_t var3379;	// i32
	int32_t var3380;	// i32
	int32_t var3381;	// i32
	int32_t var3382;	// i32
	int16_t var3383;	// i16
	int32_t var3384;	// i32
	int32_t var3385;	// i32
	uint16_t var3386;	// u16
	uint16_t var3387;	// u16
	uint16_t var3388;	// u16
	uint16_t var3389;	// u16
	uint16_t var3390;	// u16
	uint16_t var3391;	// u16
	uint16_t var3392;	// u16
	uint128_t var3393;	// u128
	uint128_t var3394;	// u128
	uint128_t var3395;	// u128
	uint128_t var3396;	// u128
	uint128_t var3397;	// u128
	uint128_t var3398;	// u128
	uint128_t var3399;	// u128
	uint128_t var3400;	// u128
	uint128_t var3401;	// u128
	uint128_t var3402;	// u128
	uint128_t var3403;	// u128
	uint128_t var3404;	// u128
	uint128_t var3405;	// u128
	uint128_t var3406;	// u128
	uint128_t var3407;	// u128
	uint128_t var3408;	// u128
	uint128_t var3409;	// u128
	uint128_t var3410;	// u128
	uint128_t var3411;	// u128
	uint128_t var3412;	// u128
	uint128_t var3413;	// u128
	uint128_t var3414;	// u128
	uint128_t var3415;	// u128
	uint128_t var3416;	// u128
	uint128_t var3417;	// u128
	uint128_t var3418;	// u128
	uint128_t var3419;	// u128
	uint128_t var3420;	// u128
	uint128_t var3421;	// u128
	uint128_t var3422;	// u128
	uint128_t var3423;	// u128
	uint128_t var3424;	// u128
	uint128_t var3425;	// u128
	uint128_t var3426;	// u128
	uint128_t var3427;	// u128
	uint128_t var3428;	// u128
	uint128_t var3429;	// u128
	uint128_t var3430;	// u128
	uint128_t var3431;	// u128
	uint128_t var3432;	// u128
	uint128_t var3433;	// u128
	uint128_t var3434;	// u128
	uint128_t var3435;	// u128
	uint128_t var3436;	// u128
	uint128_t var3437;	// u128
	uint128_t var3438;	// u128
	uint128_t var3439;	// u128
	uint128_t var3440;	// u128
	uint128_t var3441;	// u128
	uint128_t var3442;	// u128
	uint128_t var3443;	// u128
	uint128_t var3444;	// u128
	uint128_t var3445;	// u128
	uint128_t var3446;	// u128
	uint128_t var3447;	// u128
	uint128_t var3448;	// u128
	uint128_t var3449;	// u128
	uint128_t var3450;	// u128
	uint128_t var3451;	// u128
	uint128_t var3452;	// u128
	uint128_t var3453;	// u128
	uint128_t var3454;	// u128
	uint128_t var3455;	// u128
	uint128_t var3456;	// u128
	uint128_t var3457;	// u128
	uint128_t var3458;	// u128
	uint128_t var3459;	// u128
	uint128_t var3460;	// u128
	uint128_t var3461;	// u128
	uint128_t var3462;	// u128
	uint128_t var3463;	// u128
	uint128_t var3464;	// u128
	uint128_t var3465;	// u128
	uint128_t var3466;	// u128
	uint128_t var3467;	// u128
	uint128_t var3468;	// u128
	uint128_t var3469;	// u128
	uint128_t var3470;	// u128
	uint128_t var3471;	// u128
	uint128_t var3472;	// u128
	uint128_t var3473;	// u128
	uint128_t var3474;	// u128
	uint128_t var3475;	// u128
	uint128_t var3476;	// u128
	uint128_t var3477;	// u128
	uint128_t var3478;	// u128
	uint128_t var3479;	// u128
	uint128_t var3480;	// u128
	uint128_t var3481;	// u128
	uint128_t var3482;	// u128
	uint128_t var3483;	// u128
	uint128_t var3484;	// u128
	uint128_t var3485;	// u128
	uint128_t var3486;	// u128
	uint128_t var3487;	// u128
	uint128_t var3488;	// u128
	uint128_t var3489;	// u128
	uint128_t var3490;	// u128
	uint128_t var3491;	// u128
	uint128_t var3492;	// u128
	uint128_t var3493;	// u128
	uint128_t var3494;	// u128
	uint128_t var3495;	// u128
	uint128_t var3496;	// u128
	uint128_t var3497;	// u128
	uint128_t var3498;	// u128
	uint128_t var3499;	// u128
	uint128_t var3500;	// u128
	uint128_t var3501;	// u128
	uint128_t var3502;	// u128
	uint128_t var3503;	// u128
	uint128_t var3504;	// u128
	uint128_t var3505;	// u128
	uint128_t var3506;	// u128
	uint128_t var3507;	// u128
	uint128_t var3508;	// u128
	uint128_t var3509;	// u128
	uint128_t var3510;	// u128
	uint128_t var3511;	// u128
	uint128_t var3512;	// u128
	uint128_t var3513;	// u128
	uint128_t var3514;	// u128
	uint128_t var3515;	// u128
	uint128_t var3516;	// u128
	uint128_t var3517;	// u128
	uint128_t var3518;	// u128
	uint128_t var3519;	// u128
	uint128_t var3520;	// u128
	uint128_t var3521;	// u128
	uint128_t var3522;	// u128
	uint128_t var3523;	// u128
	uint128_t var3524;	// u128
	uint128_t var3525;	// u128
	uint128_t var3526;	// u128
	uint128_t var3527;	// u128
	uint128_t var3528;	// u128
	uint128_t var3529;	// u128
	uint128_t var3530;	// u128
	uint128_t var3531;	// u128
	uint128_t var3532;	// u128
	uint128_t var3533;	// u128
	uint128_t var3534;	// u128
	uint128_t var3535;	// u128
	uint128_t var3536;	// u128
	uint128_t var3537;	// u128
	uint128_t var3538;	// u128
	uint128_t var3539;	// u128
	uint128_t var3540;	// u128
	uint128_t var3541;	// u128
	uint128_t var3542;	// u128
	uint128_t var3543;	// u128
	uint128_t var3544;	// u128
	uint128_t var3545;	// u128
	uint128_t var3546;	// u128
	uint128_t var3547;	// u128
	uint128_t var3548;	// u128
	uint128_t var3549;	// u128
	uint128_t var3550;	// u128
	uint128_t var3551;	// u128
	uint128_t var3552;	// u128
	uint128_t var3553;	// u128
	uint128_t var3554;	// u128
	uint128_t var3555;	// u128
	uint128_t var3556;	// u128
	uint128_t var3557;	// u128
	uint128_t var3558;	// u128
	uint128_t var3559;	// u128
	uint128_t var3560;	// u128
	uint128_t var3561;	// u128
	uint128_t var3562;	// u128
	uint128_t var3563;	// u128
	uint128_t var3564;	// u128
	uint128_t var3565;	// u128
	uint128_t var3566;	// u128
	uint128_t var3567;	// u128
	uint128_t var3568;	// u128
	uint128_t var3569;	// u128
	uint128_t var3570;	// u128
	uint128_t var3571;	// u128
	uint128_t var3572;	// u128
	uint128_t var3573;	// u128
	uint128_t var3574;	// u128
	uint128_t var3575;	// u128
	uint128_t var3576;	// u128
	uint128_t var3577;	// u128
	uint128_t var3578;	// u128
	uint128_t var3579;	// u128
	uint128_t var3580;	// u128
	uint128_t var3581;	// u128
	uint128_t var3582;	// u128
	uint128_t var3583;	// u128
	uint128_t var3584;	// u128
	uint128_t var3585;	// u128
	uint128_t var3586;	// u128
	uint128_t var3587;	// u128
	uint128_t var3588;	// u128
	uint128_t var3589;	// u128
	uint128_t var3590;	// u128
	uint128_t var3591;	// u128
	uint128_t var3592;	// u128
	uint128_t var3593;	// u128
	uint128_t var3594;	// u128
	uint128_t var3595;	// u128
	uint128_t var3596;	// u128
	uint128_t var3597;	// u128
	uint128_t var3598;	// u128
	uint128_t var3599;	// u128
	uint128_t var3600;	// u128
	uint128_t var3601;	// u128
	uint128_t var3602;	// u128
	uint128_t var3603;	// u128
	uint128_t var3604;	// u128
	uint128_t var3605;	// u128
	uint128_t var3606;	// u128
	uint128_t var3607;	// u128
	uint128_t var3608;	// u128
	uint128_t var3609;	// u128
	uint128_t var3610;	// u128
	uint128_t var3611;	// u128
	uint128_t var3612;	// u128
	uint128_t var3613;	// u128
	uint128_t var3614;	// u128
	uint128_t var3615;	// u128
	uint128_t var3616;	// u128
	uint128_t var3617;	// u128
	uint128_t var3618;	// u128
	uint128_t var3619;	// u128
	uint128_t var3620;	// u128
	uint128_t var3621;	// u128
	uint128_t var3622;	// u128
	uint128_t var3623;	// u128
	uint128_t var3624;	// u128
	uint128_t var3625;	// u128
	uint128_t var3626;	// u128
	uint128_t var3627;	// u128
	uint128_t var3628;	// u128
	uint128_t var3629;	// u128
	uint128_t var3630;	// u128
	uint128_t var3631;	// u128
	uint128_t var3632;	// u128
	uint128_t var3633;	// u128
	uint128_t var3634;	// u128
	uint128_t var3635;	// u128
	uint128_t var3636;	// u128
	uint128_t var3637;	// u128
	uint128_t var3638;	// u128
	uint128_t var3639;	// u128
	uint128_t var3640;	// u128
	uint128_t var3641;	// u128
	uint128_t var3642;	// u128
	uint128_t var3643;	// u128
	uint128_t var3644;	// u128
	uint128_t var3645;	// u128
	uint128_t var3646;	// u128
	uint128_t var3647;	// u128
	uint128_t var3648;	// u128
	uint128_t var3649;	// u128
	uint128_t var3650;	// u128
	uint128_t var3651;	// u128
	uint128_t var3652;	// u128
	uint128_t var3653;	// u128
	uint128_t var3654;	// u128
	uint128_t var3655;	// u128
	uint128_t var3656;	// u128
	uint128_t var3657;	// u128
	uint128_t var3658;	// u128
	uint128_t var3659;	// u128
	uint128_t var3660;	// u128
	uint128_t var3661;	// u128
	uint128_t var3662;	// u128
	uint128_t var3663;	// u128
	uint128_t var3664;	// u128
	uint128_t var3665;	// u128
	uint128_t var3666;	// u128
	uint128_t var3667;	// u128
	uint128_t var3668;	// u128
	uint128_t var3669;	// u128
	uint128_t var3670;	// u128
	uint128_t var3671;	// u128
	uint128_t var3672;	// u128
	uint128_t var3673;	// u128
	uint128_t var3674;	// u128
	uint128_t var3675;	// u128
	uint128_t var3676;	// u128
	uint128_t var3677;	// u128
	uint128_t var3678;	// u128
	uint128_t var3679;	// u128
	uint128_t var3680;	// u128
	uint128_t var3681;	// u128
	uint128_t var3682;	// u128
	uint128_t var3683;	// u128
	uint128_t var3684;	// u128
	uint128_t var3685;	// u128
	uint128_t var3686;	// u128
	uint128_t var3687;	// u128
	uint128_t var3688;	// u128
	uint128_t var3689;	// u128
	uint128_t var3690;	// u128
	uint128_t var3691;	// u128
	uint128_t var3692;	// u128
	uint128_t var3693;	// u128
	uint128_t var3694;	// u128
	uint128_t var3695;	// u128
	uint128_t var3696;	// u128
	uint128_t var3697;	// u128
	uint128_t var3698;	// u128
	uint128_t var3699;	// u128
	uint128_t var3700;	// u128
	uint128_t var3701;	// u128
	uint128_t var3702;	// u128
	uint128_t var3703;	// u128
	uint128_t var3704;	// u128
	uint128_t var3705;	// u128
	uint128_t var3706;	// u128
	uint128_t var3707;	// u128
	uint128_t var3708;	// u128
	uint128_t var3709;	// u128
	uint128_t var3710;	// u128
	uint128_t var3711;	// u128
	uint128_t var3712;	// u128
	uint128_t var3713;	// u128
	uint128_t var3714;	// u128
	uint128_t var3715;	// u128
	uint128_t var3716;	// u128
	uint128_t var3717;	// u128
	uint128_t var3718;	// u128
	uint128_t var3719;	// u128
	uint128_t var3720;	// u128
	uint128_t var3721;	// u128
	uint128_t var3722;	// u128
	uint128_t var3723;	// u128
	uint128_t var3724;	// u128
	uint128_t var3725;	// u128
	uint128_t var3726;	// u128
	uint128_t var3727;	// u128
	uint128_t var3728;	// u128
	uint128_t var3729;	// u128
	uint128_t var3730;	// u128
	uint128_t var3731;	// u128
	uint128_t var3732;	// u128
	uint128_t var3733;	// u128
	uint128_t var3734;	// u128
	uint128_t var3735;	// u128
	uint128_t var3736;	// u128
	uint128_t var3737;	// u128
	uint128_t var3738;	// u128
	uint128_t var3739;	// u128
	uint128_t var3740;	// u128
	uint128_t var3741;	// u128
	uint128_t var3742;	// u128
	uint128_t var3743;	// u128
	uint128_t var3744;	// u128
	uint128_t var3745;	// u128
	uint128_t var3746;	// u128
	uint128_t var3747;	// u128
	uint128_t var3748;	// u128
	uint128_t var3749;	// u128
	uint128_t var3750;	// u128
	uint128_t var3751;	// u128
	uint128_t var3752;	// u128
	uint128_t var3753;	// u128
	uint128_t var3754;	// u128
	uint128_t var3755;	// u128
	uint128_t var3756;	// u128
	uint128_t var3757;	// u128
	uint128_t var3758;	// u128
	uint128_t var3759;	// u128
	uint128_t var3760;	// u128
	uint128_t var3761;	// u128
	uint128_t var3762;	// u128
	uint128_t var3763;	// u128
	uint128_t var3764;	// u128
	uint128_t var3765;	// u128
	uint128_t var3766;	// u128
	uint128_t var3767;	// u128
	uint128_t var3768;	// u128
	uint128_t var3769;	// u128
	uint128_t var3770;	// u128
	uint128_t var3771;	// u128
	uint128_t var3772;	// u128
	uint128_t var3773;	// u128
	uint128_t var3774;	// u128
	uint128_t var3775;	// u128
	uint128_t var3776;	// u128
	uint128_t var3777;	// u128
	uint128_t var3778;	// u128
	uint128_t var3779;	// u128
	uint128_t var3780;	// u128
	uint128_t var3781;	// u128
	uint128_t var3782;	// u128
	uint128_t var3783;	// u128
	uint128_t var3784;	// u128
	uint128_t var3785;	// u128
	uint128_t var3786;	// u128
	uint128_t var3787;	// u128
	uint128_t var3788;	// u128
	uint128_t var3789;	// u128
	uint128_t var3790;	// u128
	uint128_t var3791;	// u128
	uint128_t var3792;	// u128
	uint128_t var3793;	// u128
	uint128_t var3794;	// u128
	uint128_t var3795;	// u128
	uint128_t var3796;	// u128
	uint128_t var3797;	// u128
	uint128_t var3798;	// u128
	uint128_t var3799;	// u128
	uint128_t var3800;	// u128
	uint128_t var3801;	// u128
	uint128_t var3802;	// u128
	uint128_t var3803;	// u128
	uint128_t var3804;	// u128
	uint128_t var3805;	// u128
	uint128_t var3806;	// u128
	uint128_t var3807;	// u128
	uint128_t var3808;	// u128
	uint128_t var3809;	// u128
	uint128_t var3810;	// u128
	uint128_t var3811;	// u128
	uint128_t var3812;	// u128
	uint128_t var3813;	// u128
	uint128_t var3814;	// u128
	uint128_t var3815;	// u128
	uint128_t var3816;	// u128
	uint128_t var3817;	// u128
	uint128_t var3818;	// u128
	uint128_t var3819;	// u128
	uint128_t var3820;	// u128
	uint128_t var3821;	// u128
	uint128_t var3822;	// u128
	uint128_t var3823;	// u128
	uint128_t var3824;	// u128
	uint128_t var3825;	// u128
	uint128_t var3826;	// u128
	uint128_t var3827;	// u128
	uint128_t var3828;	// u128
	uint128_t var3829;	// u128
	uint128_t *var3830;	// &u128
	struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g var3831;	// ::"core-0_0_0"::fmt::ArgumentV1/*S*/
	t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g var3832;	// [::"core-0_0_0"::fmt::ArgumentV1/*S*/; 1]
	t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g *var3833;	// &[::"core-0_0_0"::fmt::ArgumentV1/*S*/; 1]
	tUNIT var3834 = {0};	// ()
	int32_t var3835;	// i32
	int8_t var3836;	// i8
	uint16_t var3837;	// u16
	uint16_t var3838;	// u16
	TUP_2_ZRTCd_ZRTCw var3839;	// (i16, bool, )
	int16_t var3840;	// i16
	uint8_t var3841;	// u8
	uint8_t var3842;	// u8
	uint32_t var3843;	// u32
	uint32_t var3844;	// u32
	uint32_t var3845;	// u32
	int16_t var3846;	// i16
	uint32_t var3847;	// u32
	uint32_t var3848;	// u32
	uint32_t var3849;	// u32
	uint32_t var3850;	// u32
	uint32_t var3851;	// u32
	uint32_t var3852;	// u32
	uintptr_t var3853;	// usize
	uint16_t var3854;	// u16
	uint16_t var3855;	// u16
	uint32_t var3856;	// u32
	uint32_t var3857;	// u32
	uint32_t var3858;	// u32
	uint16_t var3859;	// u16
	uint32_t var3860;	// u32
	TUP_2_ZRTCh_ZRTCw var3861;	// (i64, bool, )
	TUP_2_ZRTCb_ZRTCw var3862;	// (i8, bool, )
	uint32_t var3863;	// u32
	uint16_t var3864;	// u16
	uint32_t var3865;	// u32
	int32_t var3866;	// i32
	TUP_2_ZRTCf_ZRTCw var3867;	// (i32, bool, )
	int32_t var3868;	// i32
	int32_t var3869;	// i32
	uint32_t var3870;	// u32
	uint32_t var3871;	// u32
	uint32_t var3872;	// u32
	uint32_t var3873;	// u32
	uint32_t var3874;	// u32
	uint32_t var3875;	// u32
	uint32_t var3876;	// u32
	TUP_2_ZRTCf_ZRTCw var3877;	// (i32, bool, )
	uint32_t var3878;	// u32
	uint32_t var3879;	// u32
	uint32_t var3880;	// u32
	uint32_t var3881;	// u32
	uint32_t var3882;	// u32
	uint8_t var3883;	// u8
	uint8_t var3884;	// u8
	uint32_t var3885;	// u32
	uint8_t var3886;	// u8
	uint32_t var3887;	// u32
	uint32_t var3888;	// u32
	uint16_t var3889;	// u16
	uint16_t var3890;	// u16
	uint32_t var3891;	// u32
	uint16_t var3892;	// u16
	uint16_t var3893;	// u16
	TUP_2_ZRTCd_ZRTCw var3894;	// (i16, bool, )
	int16_t var3895;	// i16
	int16_t var3896;	// i16
	uint32_t var3897;	// u32
	uint64_t var3898;	// u64
	uint64_t var3899;	// u64
	uint64_t var3900;	// u64
	uint64_t var3901;	// u64
	uint64_t var3902;	// u64
	uint32_t var3903;	// u32
	uint32_t var3904;	// u32
	uint32_t var3905;	// u32
	uint32_t var3906;	// u32
	uint32_t var3907;	// u32
	int16_t var3908;	// i16
	int16_t var3909;	// i16
	uint32_t var3910;	// u32
	uint32_t var3911;	// u32
	uint32_t var3912;	// u32
	uint32_t var3913;	// u32
	uint32_t var3914;	// u32
	uint8_t var3915;	// u8
	uint32_t var3916;	// u32
	TUP_2_ZRTCb_ZRTCw var3917;	// (i8, bool, )
	int8_t var3918;	// i8
	int8_t var3919;	// i8
	int8_t var3920;	// i8
	TUP_2_ZRTCb_ZRTCw var3921;	// (i8, bool, )
	int8_t var3922;	// i8
	uint32_t var3923;	// u32
	uint32_t var3924;	// u32
	uint32_t var3925;	// u32
	uint16_t var3926;	// u16
	uint16_t var3927;	// u16
	uint32_t var3928;	// u32
	uint16_t var3929;	// u16
	uint32_t var3930;	// u32
	uint16_t var3931;	// u16
	int32_t var3932;	// i32
	int32_t var3933;	// i32
	int32_t var3934;	// i32
	uint32_t var3935;	// u32
	int32_t var3936;	// i32
	int32_t var3937;	// i32
	uint32_t var3938;	// u32
	TUP_2_ZRTCf_ZRTCw var3939;	// (i32, bool, )
	int32_t var3940;	// i32
	int32_t var3941;	// i32
	TUP_2_ZRTCf_ZRTCw var3942;	// (i32, bool, )
	int32_t var3943;	// i32
	TUP_2_ZRTCd_ZRTCw var3944;	// (i16, bool, )
	int16_t var3945;	// i16
	int16_t var3946;	// i16
	int16_t var3947;	// i16
	uint32_t var3948;	// u32
	int16_t var3949;	// i16
	uint32_t var3950;	// u32
	uint32_t var3951;	// u32
	int16_t var3952;	// i16
	int16_t var3953;	// i16
	int16_t var3954;	// i16
	int16_t var3955;	// i16
	int16_t var3956;	// i16
	TUP_2_ZRTCd_ZRTCw var3957;	// (i16, bool, )
	int16_t var3958;	// i16
	int16_t var3959;	// i16
	uint32_t var3960;	// u32
	uint32_t var3961;	// u32
	uint32_t var3962;	// u32
	uint16_t var3963;	// u16
	uint16_t var3964;	// u16
	uint32_t var3965;	// u32
	TUP_2_ZRTCb_ZRTCw var3966;	// (i8, bool, )
	int8_t var3967;	// i8
	int8_t var3968;	// i8
	uint32_t var3969;	// u32
	uint32_t var3970;	// u32
	uint32_t var3971;	// u32
	int16_t var3972;	// i16
	int16_t var3973;	// i16
	int16_t var3974;	// i16
	TUP_2_ZRTCd_ZRTCw var3975;	// (i16, bool, )
	int16_t var3976;	// i16
	uint32_t var3977;	// u32
	uint32_t var3978;	// u32
	uint32_t var3979;	// u32
	uint32_t var3980;	// u32
	uint32_t var3981;	// u32
	TUP_2_ZRTCb_ZRTCw var3982;	// (i8, bool, )
	int8_t var3983;	// i8
	int8_t var3984;	// i8
	TUP_2_ZRTCb_ZRTCw var3985;	// (i8, bool, )
	int8_t var3986;	// i8
	int8_t var3987;	// i8
	uint32_t var3988;	// u32
	uint32_t var3989;	// u32
	int8_t var3990;	// i8
	int8_t var3991;	// i8
	uint32_t var3992;	// u32
	int8_t var3993;	// i8
	uint32_t var3994;	// u32
	int8_t var3995;	// i8
	int8_t var3996;	// i8
	uint32_t var3997;	// u32
	TUP_2_ZRTCj_ZRTCw var3998;	// (i128, bool, )
	int128_t var3999;	// i128
	int128_t var4000;	// i128
	uint32_t var4001;	// u32
	uint32_t var4002;	// u32
	uint32_t var4003;	// u32
	int128_t var4004;	// i128
	int128_t var4005;	// i128
	uint32_t var4006;	// u32
	uint32_t var4007;	// u32
	uint16_t var4008;	// u16
	uint16_t var4009;	// u16
	uint32_t var4010;	// u32
	uint16_t var4011;	// u16
	uint16_t var4012;	// u16
	uint32_t var4013;	// u32
	uint16_t var4014;	// u16
	uint16_t var4015;	// u16
	uint16_t var4016;	// u16
	uint16_t var4017;	// u16
	uint16_t var4018;	// u16
	uint16_t var4019;	// u16
	uint16_t var4020;	// u16
	uint32_t var4021;	// u32
	uint32_t var4022;	// u32
	uint32_t var4023;	// u32
	uint32_t var4024;	// u32
	uint32_t var4025;	// u32
	uint32_t var4026;	// u32
	uint32_t var4027;	// u32
	uintptr_t var4028;	// usize
	uintptr_t var4029;	// usize
	uint32_t var4030;	// u32
	uint8_t var4031;	// u8
	uint8_t var4032;	// u8
	uint8_t var4033;	// u8
	uint8_t var4034;	// u8
	uint32_t var4035;	// u32
	uint16_t var4036;	// u16
	uint16_t var4037;	// u16
	uint32_t var4038;	// u32
	uint16_t var4039;	// u16
	uintptr_t var4040;	// usize
	uintptr_t var4041;	// usize
	uintptr_t var4042;	// usize
	uintptr_t var4043;	// usize
	uint32_t var4044;	// u32
	int128_t var4045;	// i128
	int128_t var4046;	// i128
	uint32_t var4047;	// u32
	int128_t var4048;	// i128
	int128_t var4049;	// i128
	uint32_t var4050;	// u32
	uint32_t var4051;	// u32
	uint8_t var4052;	// u8
	uint32_t var4053;	// u32
	uint32_t var4054;	// u32
	uint32_t var4055;	// u32
	uint32_t var4056;	// u32
	int16_t var4057;	// i16
	int16_t var4058;	// i16
	uint32_t var4059;	// u32
	uint32_t var4060;	// u32
	intptr_t var4061;	// isize
	intptr_t var4062;	// isize
	uint32_t var4063;	// u32
	intptr_t var4064;	// isize
	int32_t var4065;	// i32
	TUP_2_ZRTCf_ZRTCw var4066;	// (i32, bool, )
	int32_t var4067;	// i32
	TUP_2_ZRTCf_ZRTCw var4068;	// (i32, bool, )
	int32_t var4069;	// i32
	uint32_t var4070;	// u32
	uint32_t var4071;	// u32
	uint32_t var4072;	// u32
	uint32_t var4073;	// u32
	uint32_t var4074;	// u32
	uint32_t var4075;	// u32
	uint32_t var4076;	// u32
	uint64_t var4077;	// u64
	uint64_t var4078;	// u64
	uint32_t var4079;	// u32
	uint64_t var4080;	// u64
	uint32_t var4081;	// u32
	uint64_t var4082;	// u64
	uint64_t var4083;	// u64
	uint32_t var4084;	// u32
	uint8_t var4085;	// u8
	uint8_t var4086;	// u8
	uint8_t var4087;	// u8
	uint8_t var4088;	// u8
	uint32_t var4089;	// u32
	uint8_t var4090;	// u8
	uint8_t var4091;	// u8
	uint32_t var4092;	// u32
	uint8_t var4093;	// u8
	uint8_t var4094;	// u8
	uint8_t var4095;	// u8
	uint8_t var4096;	// u8
	int8_t var4097;	// i8
	TUP_2_ZRTCd_ZRTCw var4098;	// (i16, bool, )
	TUP_2_ZRTCd_ZRTCw var4099;	// (i16, bool, )
	int16_t var4100;	// i16
	int16_t var4101;	// i16
	TUP_2_ZRTCd_ZRTCw var4102;	// (i16, bool, )
	int16_t var4103;	// i16
	int16_t var4104;	// i16
	uint32_t var4105;	// u32
	uint16_t var4106;	// u16
	uint16_t var4107;	// u16
	uint16_t var4108;	// u16
	uint16_t var4109;	// u16
	TUP_2_ZRTCf_ZRTCw var4110;	// (i32, bool, )
	uintptr_t var4111;	// usize
	uintptr_t var4112;	// usize
	uintptr_t var4113;	// usize
	uintptr_t var4114;	// usize
	uint32_t var4115;	// u32
	int32_t var4116;	// i32
	TUP_2_ZRTCb_ZRTCw var4117;	// (i8, bool, )
	int8_t var4118;	// i8
	uint16_t var4119;	// u16
	uint16_t var4120;	// u16
	uint16_t var4121;	// u16
	uint16_t var4122;	// u16
	int16_t var4123;	// i16
	int16_t var4124;	// i16
	TUP_2_ZRTCf_ZRTCw var4125;	// (i32, bool, )
	uint32_t var4126;	// u32
	int16_t var4127;	// i16
	int16_t var4128;	// i16
	TUP_2_ZRTCd_ZRTCw var4129;	// (i16, bool, )
	int16_t var4130;	// i16
	TUP_2_ZRTCd_ZRTCw var4131;	// (i16, bool, )
	int16_t var4132;	// i16
	int16_t var4133;	// i16
	uint16_t var4134;	// u16
	uint16_t var4135;	// u16
	uint32_t var4136;	// u32
	uint128_t var4137;	// u128
	uint128_t var4138;	// u128
	uint32_t var4139;	// u32
	uint32_t var4140;	// u32
	int128_t var4141;	// i128
	TUP_2_ZRTCj_ZRTCw var4142;	// (i128, bool, )
	int128_t var4143;	// i128
	int128_t var4144;	// i128
	int128_t var4145;	// i128
	int128_t var4146;	// i128
	int128_t var4147;	// i128
	uint32_t var4148;	// u32
	int8_t var4149;	// i8
	int8_t var4150;	// i8
	int8_t var4151;	// i8
	uint32_t var4152;	// u32
	int8_t var4153;	// i8
	int8_t var4154;	// i8
	int8_t var4155;	// i8
	uint32_t var4156;	// u32
	int8_t var4157;	// i8
	int8_t var4158;	// i8
	int8_t var4159;	// i8
	int8_t var4160;	// i8
	uint32_t var4161;	// u32
	uint32_t var4162;	// u32
	uint32_t var4163;	// u32
	uint16_t var4164;	// u16
	uint16_t var4165;	// u16
	uint32_t var4166;	// u32
	uint32_t var4167;	// u32
	uint16_t var4168;	// u16
	uint16_t var4169;	// u16
	uint32_t var4170;	// u32
	uint16_t var4171;	// u16
	uint16_t var4172;	// u16
	TUP_2_ZRTCd_ZRTCw var4173;	// (i16, bool, )
	uint32_t var4174;	// u32
	uint8_t var4175;	// u8
	uint8_t var4176;	// u8
	uint32_t var4177;	// u32
	TUP_2_ZRTCf_ZRTCw var4178;	// (i32, bool, )
	int32_t var4179;	// i32
	uint32_t var4180;	// u32
	uint64_t var4181;	// u64
	uint64_t var4182;	// u64
	uint128_t var4183;	// u128
	uint128_t var4184;	// u128
	uint128_t var4185;	// u128
	uint128_t var4186;	// u128
	uint128_t var4187;	// u128
	uint32_t var4188;	// u32
	uint128_t var4189;	// u128
	uint128_t var4190;	// u128
	uint32_t var4191;	// u32
	uint128_t var4192;	// u128
	uint128_t var4193;	// u128
	uint128_t var4194;	// u128
	intptr_t var4195;	// isize
	intptr_t var4196;	// isize
	uintptr_t var4197;	// usize
	uintptr_t var4198;	// usize
	uintptr_t var4199;	// usize
	uintptr_t var4200;	// usize
	uint32_t var4201;	// u32
	uint128_t var4202;	// u128
	uint128_t var4203;	// u128
	uint32_t var4204;	// u32
	uint32_t var4205;	// u32
	uint32_t var4206;	// u32
	uint8_t var4207;	// u8
	uint8_t var4208;	// u8
	uint32_t var4209;	// u32
	intptr_t var4210;	// isize
	intptr_t var4211;	// isize
	uint32_t var4212;	// u32
	uint32_t var4213;	// u32
	int8_t var4214;	// i8
	int8_t var4215;	// i8
	uint32_t var4216;	// u32
	uint32_t var4217;	// u32
	int8_t var4218;	// i8
	int8_t var4219;	// i8
	uint32_t var4220;	// u32
	TUP_2_ZRTCb_ZRTCw var4221;	// (i8, bool, )
	int8_t var4222;	// i8
	int8_t var4223;	// i8
	TUP_2_ZRTCb_ZRTCw var4224;	// (i8, bool, )
	uint32_t var4225;	// u32
	int8_t var4226;	// i8
	uint32_t var4227;	// u32
	int8_t var4228;	// i8
	int8_t var4229;	// i8
	TUP_2_ZRTCv_ZRTCw var4230;	// (isize, bool, )
	intptr_t var4231;	// isize
	intptr_t var4232;	// isize
	uint32_t var4233;	// u32
	intptr_t var4234;	// isize
	uint32_t var4235;	// u32
	int128_t var4236;	// i128
	uint32_t var4237;	// u32
	uint32_t var4238;	// u32
	uint16_t var4239;	// u16
	uint16_t var4240;	// u16
	uint32_t var4241;	// u32
	uint32_t var4242;	// u32
	uint32_t var4243;	// u32
	uint32_t var4244;	// u32
	uint32_t var4245;	// u32
	uint16_t var4246;	// u16
	uint16_t var4247;	// u16
	uint32_t var4248;	// u32
	uint32_t var4249;	// u32
	uint16_t var4250;	// u16
	uint16_t var4251;	// u16
	uint16_t var4252;	// u16
	uint16_t var4253;	// u16
	uint16_t var4254;	// u16
	uint16_t var4255;	// u16
	uint16_t var4256;	// u16
	int16_t var4257;	// i16
	TUP_2_ZRTCd_ZRTCw var4258;	// (i16, bool, )
	int16_t var4259;	// i16
	int16_t var4260;	// i16
	uintptr_t var4261;	// usize
	uintptr_t var4262;	// usize
	uint32_t var4263;	// u32
	uint32_t var4264;	// u32
	uint32_t var4265;	// u32
	uint32_t var4266;	// u32
	uint32_t var4267;	// u32
	uint32_t var4268;	// u32
	uint32_t var4269;	// u32
	uint32_t var4270;	// u32
	uint32_t var4271;	// u32
	uint32_t var4272;	// u32
	uint32_t var4273;	// u32
	uint32_t var4274;	// u32
	uint32_t var4275;	// u32
	int8_t var4276;	// i8
	uintptr_t var4277;	// usize
	uintptr_t var4278;	// usize
	uintptr_t var4279;	// usize
	uintptr_t var4280;	// usize
	uint32_t var4281;	// u32
	uint32_t var4282;	// u32
	TUP_2_ZRTCj_ZRTCw var4283;	// (i128, bool, )
	uint32_t var4284;	// u32
	uint32_t var4285;	// u32
	uint32_t var4286;	// u32
	uint32_t var4287;	// u32
	uint32_t var4288;	// u32
	int64_t var4289;	// i64
	uint32_t var4290;	// u32
	int64_t var4291;	// i64
	int64_t var4292;	// i64
	uint32_t var4293;	// u32
	uint32_t var4294;	// u32
	uint32_t var4295;	// u32
	int64_t var4296;	// i64
	int64_t var4297;	// i64
	uint32_t var4298;	// u32
	uint32_t var4299;	// u32
	uintptr_t var4300;	// usize
	uint32_t var4301;	// u32
	uintptr_t var4302;	// usize
	uint32_t var4303;	// u32
	uintptr_t var4304;	// usize
	uintptr_t var4305;	// usize
	uintptr_t var4306;	// usize
	uintptr_t var4307;	// usize
	uint16_t var4308;	// u16
	uint16_t var4309;	// u16
	uint16_t var4310;	// u16
	uint16_t var4311;	// u16
	uint16_t var4312;	// u16
	uint16_t var4313;	// u16
	uint16_t var4314;	// u16
	uint32_t var4315;	// u32
	uint16_t var4316;	// u16
	uint16_t var4317;	// u16
	uint16_t var4318;	// u16
	uint16_t var4319;	// u16
	TUP_2_ZRTCh_ZRTCw var4320;	// (i64, bool, )
	int64_t var4321;	// i64
	int64_t var4322;	// i64
	TUP_2_ZRTCh_ZRTCw var4323;	// (i64, bool, )
	int64_t var4324;	// i64
	int64_t var4325;	// i64
	int64_t var4326;	// i64
	uint32_t var4327;	// u32
	uint32_t var4328;	// u32
	uint32_t var4329;	// u32
	uint32_t var4330;	// u32
	uint32_t var4331;	// u32
	uint32_t var4332;	// u32
	uint32_t var4333;	// u32
	uint32_t var4334;	// u32
	int8_t var4335;	// i8
	int8_t var4336;	// i8
	uint32_t var4337;	// u32
	TUP_2_ZRTCb_ZRTCw var4338;	// (i8, bool, )
	TUP_2_ZRTCb_ZRTCw var4339;	// (i8, bool, )
	TUP_2_ZRTCb_ZRTCw var4340;	// (i8, bool, )
	uint32_t var4341;	// u32
	int8_t var4342;	// i8
	uint32_t var4343;	// u32
	int8_t var4344;	// i8
	int8_t var4345;	// i8
	uint32_t var4346;	// u32
	uint8_t var4347;	// u8
	uint32_t var4348;	// u32
	uint32_t var4349;	// u32
	uint32_t var4350;	// u32
	uint8_t var4351;	// u8
	uint8_t var4352;	// u8
	uint32_t var4353;	// u32
	int32_t var4354;	// i32
	int32_t var4355;	// i32
	int32_t var4356;	// i32
	uint32_t var4357;	// u32
	uint16_t var4358;	// u16
	uint32_t var4359;	// u32
	uint8_t var4360;	// u8
	uint8_t var4361;	// u8
	uint32_t var4362;	// u32
	uint128_t var4363;	// u128
	uint128_t var4364;	// u128
	uint128_t var4365;	// u128
	uint32_t var4366;	// u32
	uint128_t var4367;	// u128
	uint128_t var4368;	// u128
	uint128_t var4369;	// u128
	uint128_t var4370;	// u128
	uint128_t var4371;	// u128
	uint32_t var4372;	// u32
	uint32_t var4373;	// u32
	uint32_t var4374;	// u32
	uint32_t var4375;	// u32
	uint16_t var4376;	// u16
	uint16_t var4377;	// u16
	uint32_t var4378;	// u32
	uint8_t var4379;	// u8
	uint32_t var4380;	// u32
	uint8_t var4381;	// u8
	uint8_t var4382;	// u8
	uint32_t var4383;	// u32
	TUP_2_ZRTCj_ZRTCw var4384;	// (i128, bool, )
	int128_t var4385;	// i128
	uint32_t var4386;	// u32
	uint32_t var4387;	// u32
	uint32_t var4388;	// u32
	uint32_t var4389;	// u32
	uint128_t var4390;	// u128
	uint128_t var4391;	// u128
	uint32_t var4392;	// u32
	int16_t var4393;	// i16
	int16_t var4394;	// i16
	int16_t var4395;	// i16
	uint8_t var4396;	// u8
	uint8_t var4397;	// u8
	uint8_t var4398;	// u8
	uint32_t var4399;	// u32
	int32_t var4400;	// i32
	TUP_2_ZRTCf_ZRTCw var4401;	// (i32, bool, )
	TUP_2_ZRTCf_ZRTCw var4402;	// (i32, bool, )
	int32_t var4403;	// i32
	uint32_t var4404;	// u32
	int32_t var4405;	// i32
	int32_t var4406;	// i32
	TUP_2_ZRTCf_ZRTCw var4407;	// (i32, bool, )
	int32_t var4408;	// i32
	uint8_t var4409;	// u8
	uint64_t var4410;	// u64
	uint32_t var4411;	// u32
	uint32_t var4412;	// u32
	uint32_t var4413;	// u32
	uint32_t var4414;	// u32
	uint32_t var4415;	// u32
	uint32_t var4416;	// u32
	uint32_t var4417;	// u32
	uint32_t var4418;	// u32
	uint32_t var4419;	// u32
	uint32_t var4420;	// u32
	int8_t var4421;	// i8
	int8_t var4422;	// i8
	int8_t var4423;	// i8
	int8_t var4424;	// i8
	TUP_2_ZRTCb_ZRTCw var4425;	// (i8, bool, )
	int8_t var4426;	// i8
	int8_t var4427;	// i8
	TUP_2_ZRTCj_ZRTCw var4428;	// (i128, bool, )
	uint32_t var4429;	// u32
	int8_t var4430;	// i8
	int8_t var4431;	// i8
	int8_t var4432;	// i8
	uint8_t var4433;	// u8
	uint32_t var4434;	// u32
	uint32_t var4435;	// u32
	uint32_t var4436;	// u32
	uint32_t var4437;	// u32
	uint8_t var4438;	// u8
	uint8_t var4439;	// u8
	uint32_t var4440;	// u32
	uint32_t var4441;	// u32
	uint32_t var4442;	// u32
	uint8_t var4443;	// u8
	uint8_t var4444;	// u8
	uint32_t var4445;	// u32
	uint16_t var4446;	// u16
	uint16_t var4447;	// u16
	uint16_t var4448;	// u16
	uint16_t var4449;	// u16
	uint16_t var4450;	// u16
	int128_t var4451;	// i128
	int128_t var4452;	// i128
	int8_t var4453;	// i8
	int8_t var4454;	// i8
	int8_t var4455;	// i8
	TUP_2_ZRTCb_ZRTCw var4456;	// (i8, bool, )
	int8_t var4457;	// i8
	uint32_t var4458;	// u32
	int8_t var4459;	// i8
	uint32_t var4460;	// u32
	int8_t var4461;	// i8
	TUP_2_ZRTCb_ZRTCw var4462;	// (i8, bool, )
	int8_t var4463;	// i8
	int8_t var4464;	// i8
	uint16_t var4465;	// u16
	uint16_t var4466;	// u16
	uint32_t var4467;	// u32
	uint8_t var4468;	// u8
	uint16_t var4469;	// u16
	uint16_t var4470;	// u16
	uint32_t var4471;	// u32
	uint32_t var4472;	// u32
	uint32_t var4473;	// u32
	uint32_t var4474;	// u32
	uint16_t var4475;	// u16
	uint16_t var4476;	// u16
	uint32_t var4477;	// u32
	uint32_t var4478;	// u32
	uint32_t var4479;	// u32
	uint32_t var4480;	// u32
	uint32_t var4481;	// u32
	uint64_t var4482;	// u64
	uint32_t var4483;	// u32
	uint64_t var4484;	// u64
	uint64_t var4485;	// u64
	uint32_t var4486;	// u32
	uint32_t var4487;	// u32
	uint32_t var4488;	// u32
	uint32_t var4489;	// u32
	uint32_t var4490;	// u32
	uint32_t var4491;	// u32
	uint32_t var4492;	// u32
	uint32_t var4493;	// u32
	uint32_t var4494;	// u32
	uint64_t var4495;	// u64
	uint64_t var4496;	// u64
	uint32_t var4497;	// u32
	uint8_t var4498;	// u8
	uint32_t var4499;	// u32
	uint8_t var4500;	// u8
	uint32_t var4501;	// u32
	uint32_t var4502;	// u32
	uint32_t var4503;	// u32
	uint8_t var4504;	// u8
	uint32_t var4505;	// u32
	uint8_t var4506;	// u8
	uint8_t var4507;	// u8
	uint32_t var4508;	// u32
	int16_t var4509;	// i16
	int16_t var4510;	// i16
	uint32_t var4511;	// u32
	TUP_2_ZRTCd_ZRTCw var4512;	// (i16, bool, )
	int16_t var4513;	// i16
	uint32_t var4514;	// u32
	int8_t var4515;	// i8
	uint32_t var4516;	// u32
	TUP_2_ZRTCb_ZRTCw var4517;	// (i8, bool, )
	int8_t var4518;	// i8
	TUP_2_ZRTCv_ZRTCw var4519;	// (isize, bool, )
	uint32_t var4520;	// u32
	uint128_t var4521;	// u128
	uint32_t var4522;	// u32
	uint16_t var4523;	// u16
	uint16_t var4524;	// u16
	TUP_2_ZRTCd_ZRTCw var4525;	// (i16, bool, )
	int16_t var4526;	// i16
	int16_t var4527;	// i16
	TUP_2_ZRTCd_ZRTCw var4528;	// (i16, bool, )
	int32_t var4529;	// i32
	int32_t var4530;	// i32
	TUP_2_ZRTCv_ZRTCw var4531;	// (isize, bool, )
	intptr_t var4532;	// isize
	intptr_t var4533;	// isize
	int8_t var4534;	// i8
	uint32_t var4535;	// u32
	int8_t var4536;	// i8
	int8_t var4537;	// i8
	int8_t var4538;	// i8
	int8_t var4539;	// i8
	int8_t var4540;	// i8
	int8_t var4541;	// i8
	uint32_t var4542;	// u32
	uint32_t var4543;	// u32
	uint32_t var4544;	// u32
	int8_t var4545;	// i8
	int8_t var4546;	// i8
	uint32_t var4547;	// u32
	uint32_t var4548;	// u32
	int32_t var4549;	// i32
	uint32_t var4550;	// u32
	int32_t var4551;	// i32
	int32_t var4552;	// i32
	uint32_t var4553;	// u32
	uint32_t var4554;	// u32
	uint32_t var4555;	// u32
	uint32_t var4556;	// u32
	uint32_t var4557;	// u32
	uint32_t var4558;	// u32
	uint32_t var4559;	// u32
	uint32_t var4560;	// u32
	uint32_t var4561;	// u32
	uint32_t var4562;	// u32
	uint32_t var4563;	// u32
	uint32_t var4564;	// u32
	uint32_t var4565;	// u32
	uint32_t var4566;	// u32
	uint32_t var4567;	// u32
	uint32_t var4568;	// u32
	uintptr_t var4569;	// usize
	uint32_t var4570;	// u32
	uintptr_t var4571;	// usize
	uintptr_t var4572;	// usize
	uint32_t var4573;	// u32
	uintptr_t var4574;	// usize
	uintptr_t var4575;	// usize
	uintptr_t var4576;	// usize
	uintptr_t var4577;	// usize
	uint32_t var4578;	// u32
	uint32_t var4579;	// u32
	int16_t var4580;	// i16
	int16_t var4581;	// i16
	uint32_t var4582;	// u32
	TUP_2_ZRTCv_ZRTCw var4583;	// (isize, bool, )
	TUP_2_ZRTCj_ZRTCw var4584;	// (i128, bool, )
	uint32_t var4585;	// u32
	int128_t var4586;	// i128
	int128_t var4587;	// i128
	uint32_t var4588;	// u32
	uint32_t var4589;	// u32
	int128_t var4590;	// i128
	int8_t var4591;	// i8
	int8_t var4592;	// i8
	int8_t var4593;	// i8
	TUP_2_ZRTCj_ZRTCw var4594;	// (i128, bool, )
	uint16_t var4595;	// u16
	uint16_t var4596;	// u16
	uint16_t var4597;	// u16
	uint8_t var4598;	// u8
	uint8_t var4599;	// u8
	uint32_t var4600;	// u32
	uint32_t var4601;	// u32
	uint32_t var4602;	// u32
	uint32_t var4603;	// u32
	uint8_t var4604;	// u8
	uint8_t var4605;	// u8
	uint32_t var4606;	// u32
	uint8_t var4607;	// u8
	uint8_t var4608;	// u8
	uint8_t var4609;	// u8
	uint8_t var4610;	// u8
	uint8_t var4611;	// u8
	uint8_t var4612;	// u8
	uint8_t var4613;	// u8
	TUP_2_ZRTCh_ZRTCw var4614;	// (i64, bool, )
	int64_t var4615;	// i64
	uint16_t var4616;	// u16
	uint16_t var4617;	// u16
	uint8_t var4618;	// u8
	uint8_t var4619;	// u8
	uint8_t var4620;	// u8
	uint32_t var4621;	// u32
	uint8_t var4622;	// u8
	uint8_t var4623;	// u8
	uint8_t var4624;	// u8
	uint32_t var4625;	// u32
	uint32_t var4626;	// u32
	uint32_t var4627;	// u32
	uint8_t var4628;	// u8
	uint8_t var4629;	// u8
	uint32_t var4630;	// u32
	uint16_t var4631;	// u16
	uint32_t var4632;	// u32
	uint16_t var4633;	// u16
	uint16_t var4634;	// u16
	uint32_t var4635;	// u32
	uint16_t var4636;	// u16
	int8_t var4637;	// i8
	TUP_2_ZRTCb_ZRTCw var4638;	// (i8, bool, )
	int8_t var4639;	// i8
	int8_t var4640;	// i8
	uint64_t var4641;	// u64
	uint64_t var4642;	// u64
	uint64_t var4643;	// u64
	uint32_t var4644;	// u32
	uint64_t var4645;	// u64
	uint64_t var4646;	// u64
	uint32_t var4647;	// u32
	uint64_t var4648;	// u64
	uint64_t var4649;	// u64
	uint8_t var4650;	// u8
	uint32_t var4651;	// u32
	uint8_t var4652;	// u8
	uint8_t var4653;	// u8
	uint8_t var4654;	// u8
	uint8_t var4655;	// u8
	uint8_t var4656;	// u8
	TUP_2_ZRTCd_ZRTCw var4657;	// (i16, bool, )
	uint32_t var4658;	// u32
	uint32_t var4659;	// u32
	uint32_t var4660;	// u32
	uint32_t var4661;	// u32
	uint32_t var4662;	// u32
	uint32_t var4663;	// u32
	uint32_t var4664;	// u32
	uint8_t var4665;	// u8
	uint8_t var4666;	// u8
	uint32_t var4667;	// u32
	uint32_t var4668;	// u32
	uint32_t var4669;	// u32
	int8_t var4670;	// i8
	uint32_t var4671;	// u32
	int8_t var4672;	// i8
	int8_t var4673;	// i8
	uint32_t var4674;	// u32
	uint32_t var4675;	// u32
	int8_t var4676;	// i8
	TUP_2_ZRTCb_ZRTCw var4677;	// (i8, bool, )
	int8_t var4678;	// i8
	int8_t var4679;	// i8
	int8_t var4680;	// i8
	uint32_t var4681;	// u32
	uint8_t var4682;	// u8
	uint8_t var4683;	// u8
	uint32_t var4684;	// u32
	uint32_t var4685;	// u32
	uint32_t var4686;	// u32
	uint8_t var4687;	// u8
	uint32_t var4688;	// u32
	uint8_t var4689;	// u8
	uint8_t var4690;	// u8
	uint32_t var4691;	// u32
	uint32_t var4692;	// u32
	uint8_t var4693;	// u8
	uint8_t var4694;	// u8
	uint32_t var4695;	// u32
	uint8_t var4696;	// u8
	uint8_t var4697;	// u8
	uint8_t var4698;	// u8
	uint8_t var4699;	// u8
	uint8_t var4700;	// u8
	uint8_t var4701;	// u8
	uint128_t var4702;	// u128
	uint128_t var4703;	// u128
	uint128_t var4704;	// u128
	int128_t var4705;	// i128
	TUP_2_ZRTCb_ZRTCw var4706;	// (i8, bool, )
	TUP_2_ZRTCb_ZRTCw var4707;	// (i8, bool, )
	uint32_t var4708;	// u32
	uint32_t var4709;	// u32
	uint8_t var4710;	// u8
	uint32_t var4711;	// u32
	uint32_t var4712;	// u32
	uint8_t var4713;	// u8
	uint8_t var4714;	// u8
	uint32_t var4715;	// u32
	uint8_t var4716;	// u8
	uint16_t var4717;	// u16
	uint16_t var4718;	// u16
	uint16_t var4719;	// u16
	uint32_t var4720;	// u32
	uint32_t var4721;	// u32
	uint64_t var4722;	// u64
	uint64_t var4723;	// u64
	uint64_t var4724;	// u64
	uint16_t var4725;	// u16
	uint16_t var4726;	// u16
	uint16_t var4727;	// u16
	uint16_t var4728;	// u16
	uint64_t var4729;	// u64
	uint64_t var4730;	// u64
	uint64_t var4731;	// u64
	uint32_t var4732;	// u32
	int32_t var4733;	// i32
	int32_t var4734;	// i32
	TUP_2_ZRTCv_ZRTCw var4735;	// (isize, bool, )
	intptr_t var4736;	// isize
	uint32_t var4737;	// u32
	uint16_t var4738;	// u16
	uint16_t var4739;	// u16
	uint16_t var4740;	// u16
	uint16_t var4741;	// u16
	uint16_t var4742;	// u16
	uint32_t var4743;	// u32
	int16_t var4744;	// i16
	uint32_t var4745;	// u32
	int16_t var4746;	// i16
	int16_t var4747;	// i16
	uint32_t var4748;	// u32
	uint32_t var4749;	// u32
	uint32_t var4750;	// u32
	int16_t var4751;	// i16
	int16_t var4752;	// i16
	uint32_t var4753;	// u32
	int16_t var4754;	// i16
	int16_t var4755;	// i16
	int16_t var4756;	// i16
	int16_t var4757;	// i16
	uint32_t var4758;	// u32
	int64_t var4759;	// i64
	int64_t var4760;	// i64
	int64_t var4761;	// i64
	TUP_2_ZRTCh_ZRTCw var4762;	// (i64, bool, )
	int64_t var4763;	// i64
	int64_t var4764;	// i64
	int8_t var4765;	// i8
	TUP_2_ZRTCv_ZRTCw var4766;	// (isize, bool, )
	intptr_t var4767;	// isize
	intptr_t var4768;	// isize
	uint32_t var4769;	// u32
	uint32_t var4770;	// u32
	uint32_t var4771;	// u32
	uint32_t var4772;	// u32
	uint32_t var4773;	// u32
	int16_t var4774;	// i16
	int128_t var4775;	// i128
	int128_t var4776;	// i128
	int8_t var4777;	// i8
	int8_t var4778;	// i8
	int8_t var4779;	// i8
	int8_t var4780;	// i8
	int8_t var4781;	// i8
	uint32_t var4782;	// u32
	int8_t var4783;	// i8
	uint32_t var4784;	// u32
	uint32_t var4785;	// u32
	int8_t var4786;	// i8
	int8_t var4787;	// i8
	uint32_t var4788;	// u32
	int8_t var4789;	// i8
	int8_t var4790;	// i8
	uint32_t var4791;	// u32
	int8_t var4792;	// i8
	int8_t var4793;	// i8
	uint32_t var4794;	// u32
	TUP_2_ZRTCb_ZRTCw var4795;	// (i8, bool, )
	int8_t var4796;	// i8
	int8_t var4797;	// i8
	int8_t var4798;	// i8
	uint8_t var4799;	// u8
	uint8_t var4800;	// u8
	uint8_t var4801;	// u8
	TUP_2_ZRTCv_ZRTCw var4802;	// (isize, bool, )
	intptr_t var4803;	// isize
	uint16_t var4804;	// u16
	uint64_t var4805;	// u64
	uint64_t var4806;	// u64
	uint64_t var4807;	// u64
	uint64_t var4808;	// u64
	uint64_t var4809;	// u64
	uint64_t var4810;	// u64
	uint64_t var4811;	// u64
	uint32_t var4812;	// u32
	uint32_t var4813;	// u32
	uint32_t var4814;	// u32
	uint32_t var4815;	// u32
	uint64_t var4816;	// u64
	uint64_t var4817;	// u64
	uint32_t var4818;	// u32
	uint64_t var4819;	// u64
	uint64_t var4820;	// u64
	uint64_t var4821;	// u64
	uint64_t var4822;	// u64
	uint32_t var4823;	// u32
	int16_t var4824;	// i16
	int16_t var4825;	// i16
	uint32_t var4826;	// u32
	int16_t var4827;	// i16
	int16_t var4828;	// i16
	uint32_t var4829;	// u32
	uint32_t var4830;	// u32
	uint32_t var4831;	// u32
	uint32_t var4832;	// u32
	uint32_t var4833;	// u32
	uint32_t var4834;	// u32
	uint32_t var4835;	// u32
	int16_t var4836;	// i16
	int16_t var4837;	// i16
	uint32_t var4838;	// u32
	uint16_t var4839;	// u16
	uint16_t var4840;	// u16
	int8_t var4841;	// i8
	int8_t var4842;	// i8
	uint32_t var4843;	// u32
	uint32_t var4844;	// u32
	uint32_t var4845;	// u32
	uint32_t var4846;	// u32
	uint32_t var4847;	// u32
	uint32_t var4848;	// u32
	uint32_t var4849;	// u32
	uint32_t var4850;	// u32
	uint16_t var4851;	// u16
	uint32_t var4852;	// u32
	uint32_t var4853;	// u32
	uint32_t var4854;	// u32
	uint16_t var4855;	// u16
	uint16_t var4856;	// u16
	uint32_t var4857;	// u32
	uint16_t var4858;	// u16
	uint16_t var4859;	// u16
	uint32_t var4860;	// u32
	uint32_t var4861;	// u32
	uint32_t var4862;	// u32
	uint8_t var4863;	// u8
	uint8_t var4864;	// u8
	uint32_t var4865;	// u32
	uint8_t var4866;	// u8
	uint8_t var4867;	// u8
	uint32_t var4868;	// u32
	uint32_t var4869;	// u32
	uint32_t var4870;	// u32
	uint64_t var4871;	// u64
	uint64_t var4872;	// u64
	uint32_t var4873;	// u32
	uint64_t var4874;	// u64
	uint32_t var4875;	// u32
	int64_t var4876;	// i64
	uint64_t var4877;	// u64
	uint64_t var4878;	// u64
	uint64_t var4879;	// u64
	uint64_t var4880;	// u64
	uint64_t var4881;	// u64
	uint32_t var4882;	// u32
	uint32_t var4883;	// u32
	uint32_t var4884;	// u32
	uint32_t var4885;	// u32
	uint32_t var4886;	// u32
	uint32_t var4887;	// u32
	uint32_t var4888;	// u32
	uint32_t var4889;	// u32
	uint32_t var4890;	// u32
	uint32_t var4891;	// u32
	TUP_2_ZRTCv_ZRTCw var4892;	// (isize, bool, )
	intptr_t var4893;	// isize
	intptr_t var4894;	// isize
	TUP_2_ZRTCv_ZRTCw var4895;	// (isize, bool, )
	uint32_t var4896;	// u32
	uint16_t var4897;	// u16
	uint16_t var4898;	// u16
	uint32_t var4899;	// u32
	uint16_t var4900;	// u16
	uint32_t var4901;	// u32
	uint8_t var4902;	// u8
	uint8_t var4903;	// u8
	uint32_t var4904;	// u32
	uint8_t var4905;	// u8
	uint8_t var4906;	// u8
	uint8_t var4907;	// u8
	uint8_t var4908;	// u8
	uint8_t var4909;	// u8
	uint8_t var4910;	// u8
	uint32_t var4911;	// u32
	uint32_t var4912;	// u32
	uint8_t var4913;	// u8
	uint32_t var4914;	// u32
	TUP_2_ZRTCf_ZRTCw var4915;	// (i32, bool, )
	TUP_2_ZRTCf_ZRTCw var4916;	// (i32, bool, )
	int32_t var4917;	// i32
	uint32_t var4918;	// u32
	uint32_t var4919;	// u32
	uint32_t var4920;	// u32
	uint32_t var4921;	// u32
	uint8_t var4922;	// u8
	uint8_t var4923;	// u8
	uint32_t var4924;	// u32
	uint32_t var4925;	// u32
	int64_t var4926;	// i64
	uint32_t var4927;	// u32
	uint16_t var4928;	// u16
	uint16_t var4929;	// u16
	uint128_t var4930;	// u128
	uint128_t var4931;	// u128
	uint128_t var4932;	// u128
	uint128_t var4933;	// u128
	uint128_t var4934;	// u128
	uint128_t var4935;	// u128
	uint128_t var4936;	// u128
	uint32_t var4937;	// u32
	uint32_t var4938;	// u32
	uint32_t var4939;	// u32
	uint32_t var4940;	// u32
	uint32_t var4941;	// u32
	uint32_t var4942;	// u32
	TUP_2_ZRTCd_ZRTCw var4943;	// (i16, bool, )
	uint32_t var4944;	// u32
	uint16_t var4945;	// u16
	uint32_t var4946;	// u32
	int64_t var4947;	// i64
	int64_t var4948;	// i64
	uint32_t var4949;	// u32
	uint64_t var4950;	// u64
	uint64_t var4951;	// u64
	uint32_t var4952;	// u32
	int128_t var4953;	// i128
	int128_t var4954;	// i128
	int128_t var4955;	// i128
	int128_t var4956;	// i128
	uint32_t var4957;	// u32
	uint16_t var4958;	// u16
	uint16_t var4959;	// u16
	uint16_t var4960;	// u16
	uint16_t var4961;	// u16
	TUP_2_ZRTCd_ZRTCw var4962;	// (i16, bool, )
	uint32_t var4963;	// u32
	uint16_t var4964;	// u16
	uint16_t var4965;	// u16
	uint32_t var4966;	// u32
	uint32_t var4967;	// u32
	uint16_t var4968;	// u16
	uint32_t var4969;	// u32
	uint16_t var4970;	// u16
	uint16_t var4971;	// u16
	uint16_t var4972;	// u16
	uint16_t var4973;	// u16
	uint16_t var4974;	// u16
	uint32_t var4975;	// u32
	uint32_t var4976;	// u32
	uint16_t var4977;	// u16
	uint16_t var4978;	// u16
	uint32_t var4979;	// u32
	uint16_t var4980;	// u16
	uint16_t var4981;	// u16
	TUP_2_ZRTCb_ZRTCw var4982;	// (i8, bool, )
	int8_t var4983;	// i8
	int8_t var4984;	// i8
	uint32_t var4985;	// u32
	uint32_t var4986;	// u32
	uint32_t var4987;	// u32
	uintptr_t var4988;	// usize
	uint32_t var4989;	// u32
	int32_t var4990;	// i32
	int32_t var4991;	// i32
	uint32_t var4992;	// u32
	uint32_t var4993;	// u32
	uintptr_t var4994;	// usize
	uint32_t var4995;	// u32
	uint32_t var4996;	// u32
	int32_t var4997;	// i32
	uint32_t var4998;	// u32
	TUP_2_ZRTCf_ZRTCw var4999;	// (i32, bool, )
	int32_t var5000;	// i32
	int32_t var5001;	// i32
	TUP_2_ZRTCv_ZRTCw var5002;	// (isize, bool, )
	TUP_2_ZRTCf_ZRTCw var5003;	// (i32, bool, )
	uint32_t var5004;	// u32
	int32_t var5005;	// i32
	uint32_t var5006;	// u32
	int32_t var5007;	// i32
	int32_t var5008;	// i32
	int32_t var5009;	// i32
	uint8_t var5010;	// u8
	uint32_t var5011;	// u32
	uint8_t var5012;	// u8
	uint8_t var5013;	// u8
	uint32_t var5014;	// u32
	uint8_t var5015;	// u8
	uint8_t var5016;	// u8
	uint8_t var5017;	// u8
	uint8_t var5018;	// u8
	uint32_t var5019;	// u32
	uint32_t var5020;	// u32
	uintptr_t var5021;	// usize
	uintptr_t var5022;	// usize
	uintptr_t var5023;	// usize
	uintptr_t var5024;	// usize
	uint32_t var5025;	// u32
	uintptr_t var5026;	// usize
	uint32_t var5027;	// u32
	uintptr_t var5028;	// usize
	uintptr_t var5029;	// usize
	uint32_t var5030;	// u32
	uintptr_t var5031;	// usize
	uintptr_t var5032;	// usize
	uint32_t var5033;	// u32
	uint32_t var5034;	// u32
	int32_t var5035;	// i32
	TUP_2_ZRTCf_ZRTCw var5036;	// (i32, bool, )
	int32_t var5037;	// i32
	int32_t var5038;	// i32
	uint32_t var5039;	// u32
	uint32_t var5040;	// u32
	uint32_t var5041;	// u32
	uint32_t var5042;	// u32
	uint32_t var5043;	// u32
	uint32_t var5044;	// u32
	uint32_t var5045;	// u32
	uint32_t var5046;	// u32
	uint32_t var5047;	// u32
	uint32_t var5048;	// u32
	uint32_t var5049;	// u32
	uint32_t var5050;	// u32
	uint32_t var5051;	// u32
	uint32_t var5052;	// u32
	uint8_t var5053;	// u8
	TUP_2_ZRTCf_ZRTCw var5054;	// (i32, bool, )
	int32_t var5055;	// i32
	int32_t var5056;	// i32
	uint32_t var5057;	// u32
	int32_t var5058;	// i32
	int32_t var5059;	// i32
	int32_t var5060;	// i32
	uint32_t var5061;	// u32
	int32_t var5062;	// i32
	TUP_2_ZRTCf_ZRTCw var5063;	// (i32, bool, )
	int32_t var5064;	// i32
	int32_t var5065;	// i32
	int32_t var5066;	// i32
	int32_t var5067;	// i32
	TUP_2_ZRTCd_ZRTCw var5068;	// (i16, bool, )
	int16_t var5069;	// i16
	int16_t var5070;	// i16
	int16_t var5071;	// i16
	int16_t var5072;	// i16
	uint32_t var5073;	// u32
	uint32_t var5074;	// u32
	uint32_t var5075;	// u32
	uint32_t var5076;	// u32
	uint32_t var5077;	// u32
	uint32_t var5078;	// u32
	uint32_t var5079;	// u32
	uint32_t var5080;	// u32
	uint32_t var5081;	// u32
	uint16_t var5082;	// u16
	uint32_t var5083;	// u32
	uint16_t var5084;	// u16
	uint32_t var5085;	// u32
	uint32_t var5086;	// u32
	uint32_t var5087;	// u32
	uint32_t var5088;	// u32
	uint32_t var5089;	// u32
	uint32_t var5090;	// u32
	uint32_t var5091;	// u32
	uint32_t var5092;	// u32
	uint32_t var5093;	// u32
	uint32_t var5094;	// u32
	int16_t var5095;	// i16
	int16_t var5096;	// i16
	uint32_t var5097;	// u32
	uint32_t var5098;	// u32
	uint32_t var5099;	// u32
	uint32_t var5100;	// u32
	int8_t var5101;	// i8
	int8_t var5102;	// i8
	uint32_t var5103;	// u32
	int8_t var5104;	// i8
	int8_t var5105;	// i8
	int64_t var5106;	// i64
	int64_t var5107;	// i64
	int32_t var5108;	// i32
	uint8_t var5109;	// u8
	uint8_t var5110;	// u8
	uint32_t var5111;	// u32
	uint32_t var5112;	// u32
	uint32_t var5113;	// u32
	uint8_t var5114;	// u8
	uint8_t var5115;	// u8
	uint32_t var5116;	// u32
	uint8_t var5117;	// u8
	uint8_t var5118;	// u8
	TUP_2_ZRTCf_ZRTCw var5119;	// (i32, bool, )
	uint32_t var5120;	// u32
	int32_t var5121;	// i32
	uint32_t var5122;	// u32
	uint32_t var5123;	// u32
	uint32_t var5124;	// u32
	uint32_t var5125;	// u32
	TUP_2_ZRTCd_ZRTCw var5126;	// (i16, bool, )
	uint32_t var5127;	// u32
	int16_t var5128;	// i16
	int16_t var5129;	// i16
	uint32_t var5130;	// u32
	uint32_t var5131;	// u32
	int16_t var5132;	// i16
	uint16_t var5133;	// u16
	uint16_t var5134;	// u16
	uint16_t var5135;	// u16
	uint32_t var5136;	// u32
	uint16_t var5137;	// u16
	uint16_t var5138;	// u16
	uint32_t var5139;	// u32
	uint64_t var5140;	// u64
	uint16_t var5141;	// u16
	uint32_t var5142;	// u32
	uint16_t var5143;	// u16
	uint16_t var5144;	// u16
	uint32_t var5145;	// u32
	uint32_t var5146;	// u32
	uint32_t var5147;	// u32
	int128_t var5148;	// i128
	int128_t var5149;	// i128
	uint32_t var5150;	// u32
	uint32_t var5151;	// u32
	int16_t var5152;	// i16
	int16_t var5153;	// i16
	uint32_t var5154;	// u32
	uint32_t var5155;	// u32
	int16_t var5156;	// i16
	int16_t var5157;	// i16
	uint32_t var5158;	// u32
	uint32_t var5159;	// u32
	uint16_t var5160;	// u16
	uint16_t var5161;	// u16
	uint32_t var5162;	// u32
	uint16_t var5163;	// u16
	uint16_t var5164;	// u16
	uint16_t var5165;	// u16
	uint16_t var5166;	// u16
	uint8_t var5167;	// u8
	uint8_t var5168;	// u8
	uint8_t var5169;	// u8
	uint32_t var5170;	// u32
	uint64_t var5171;	// u64
	uint64_t var5172;	// u64
	uint64_t var5173;	// u64
	uintptr_t var5174;	// usize
	uint64_t var5175;	// u64
	uint8_t var5176;	// u8
	uint8_t var5177;	// u8
	uint32_t var5178;	// u32
	uint128_t var5179;	// u128
	uint32_t var5180;	// u32
	uint128_t var5181;	// u128
	uint128_t var5182;	// u128
	uint32_t var5183;	// u32
	uint32_t var5184;	// u32
	uint128_t var5185;	// u128
	uint128_t var5186;	// u128
	uint32_t var5187;	// u32
	uint128_t var5188;	// u128
	uint128_t var5189;	// u128
	TUP_2_ZRTCd_ZRTCw var5190;	// (i16, bool, )
	uintptr_t var5191;	// usize
	uintptr_t var5192;	// usize
	uintptr_t var5193;	// usize
	uint8_t var5194;	// u8
	uint8_t var5195;	// u8
	uint8_t var5196;	// u8
	uint32_t var5197;	// u32
	uint8_t var5198;	// u8
	uint32_t var5199;	// u32
	uint32_t var5200;	// u32
	uint8_t var5201;	// u8
	uint8_t var5202;	// u8
	uint32_t var5203;	// u32
	uint8_t var5204;	// u8
	uint8_t var5205;	// u8
	uint8_t var5206;	// u8
	uint32_t var5207;	// u32
	uint32_t var5208;	// u32
	uint32_t var5209;	// u32
	uint8_t var5210;	// u8
	uint8_t var5211;	// u8
	uint32_t var5212;	// u32
	TUP_2_ZRTCb_ZRTCw var5213;	// (i8, bool, )
	uint32_t var5214;	// u32
	int8_t var5215;	// i8
	uint32_t var5216;	// u32
	int8_t var5217;	// i8
	uint32_t var5218;	// u32
	uint32_t var5219;	// u32
	uint32_t var5220;	// u32
	uint32_t var5221;	// u32
	int128_t var5222;	// i128
	int128_t var5223;	// i128
	uint32_t var5224;	// u32
	int8_t var5225;	// i8
	int8_t var5226;	// i8
	uint32_t var5227;	// u32
	uintptr_t var5228;	// usize
	uintptr_t var5229;	// usize
	uintptr_t var5230;	// usize
	uint32_t var5231;	// u32
	uint32_t var5232;	// u32
	uint32_t var5233;	// u32
	int32_t var5234;	// i32
	int32_t var5235;	// i32
	uint32_t var5236;	// u32
	TUP_2_ZRTCb_ZRTCw var5237;	// (i8, bool, )
	TUP_2_ZRTCb_ZRTCw var5238;	// (i8, bool, )
	int8_t var5239;	// i8
	TUP_2_ZRTCj_ZRTCw var5240;	// (i128, bool, )
	int16_t var5241;	// i16
	TUP_2_ZRTCd_ZRTCw var5242;	// (i16, bool, )
	int16_t var5243;	// i16
	int16_t var5244;	// i16
	uint8_t var5245;	// u8
	uint32_t var5246;	// u32
	uint8_t var5247;	// u8
	uint8_t var5248;	// u8
	uint32_t var5249;	// u32
	uint32_t var5250;	// u32
	uint16_t var5251;	// u16
	uint32_t var5252;	// u32
	int16_t var5253;	// i16
	int16_t var5254;	// i16
	TUP_2_ZRTCd_ZRTCw var5255;	// (i16, bool, )
	int16_t var5256;	// i16
	uint32_t var5257;	// u32
	uint32_t var5258;	// u32
	uint32_t var5259;	// u32
	uint32_t var5260;	// u32
	uint8_t var5261;	// u8
	uint8_t var5262;	// u8
	uint32_t var5263;	// u32
	TUP_2_ZRTCd_ZRTCw var5264;	// (i16, bool, )
	TUP_2_ZRTCd_ZRTCw var5265;	// (i16, bool, )
	int16_t var5266;	// i16
	uint32_t var5267;	// u32
	uint32_t var5268;	// u32
	uint32_t var5269;	// u32
	uint32_t var5270;	// u32
	uint32_t var5271;	// u32
	uint32_t var5272;	// u32
	uint32_t var5273;	// u32
	uint32_t var5274;	// u32
	TUP_2_ZRTCh_ZRTCw var5275;	// (i64, bool, )
	int64_t var5276;	// i64
	int64_t var5277;	// i64
	uint32_t var5278;	// u32
	uint8_t var5279;	// u8
	uint8_t var5280;	// u8
	uint32_t var5281;	// u32
	uint8_t var5282;	// u8
	int8_t var5283;	// i8
	TUP_2_ZRTCb_ZRTCw var5284;	// (i8, bool, )
	int8_t var5285;	// i8
	int8_t var5286;	// i8
	uint32_t var5287;	// u32
	uint32_t var5288;	// u32
	int8_t var5289;	// i8
	int8_t var5290;	// i8
	uint32_t var5291;	// u32
	uint32_t var5292;	// u32
	uint32_t var5293;	// u32
	uint32_t var5294;	// u32
	uint32_t var5295;	// u32
	uint32_t var5296;	// u32
	uint32_t var5297;	// u32
	uint32_t var5298;	// u32
	uint32_t var5299;	// u32
	uint32_t var5300;	// u32
	uint32_t var5301;	// u32
	TUP_2_ZRTCh_ZRTCw var5302;	// (i64, bool, )
	int64_t var5303;	// i64
	int64_t var5304;	// i64
	uint32_t var5305;	// u32
	intptr_t var5306;	// isize
	TUP_2_ZRTCv_ZRTCw var5307;	// (isize, bool, )
	intptr_t var5308;	// isize
	intptr_t var5309;	// isize
	intptr_t var5310;	// isize
	uint32_t var5311;	// u32
	uint32_t var5312;	// u32
	uint32_t var5313;	// u32
	intptr_t var5314;	// isize
	intptr_t var5315;	// isize
	uint32_t var5316;	// u32
	TUP_2_ZRTCv_ZRTCw var5317;	// (isize, bool, )
	intptr_t var5318;	// isize
	intptr_t var5319;	// isize
	uint8_t var5320;	// u8
	uint8_t var5321;	// u8
	uint8_t var5322;	// u8
	uint8_t var5323;	// u8
	uint32_t var5324;	// u32
	uint32_t var5325;	// u32
	uint8_t var5326;	// u8
	uint8_t var5327;	// u8
	uint32_t var5328;	// u32
	uint8_t var5329;	// u8
	uint8_t var5330;	// u8
	uint8_t var5331;	// u8
	uint16_t var5332;	// u16
	uint32_t var5333;	// u32
	uint16_t var5334;	// u16
	uint16_t var5335;	// u16
	uint32_t var5336;	// u32
	uint32_t var5337;	// u32
	uint16_t var5338;	// u16
	uint32_t var5339;	// u32
	uint16_t var5340;	// u16
	uint16_t var5341;	// u16
	uint16_t var5342;	// u16
	TUP_2_ZRTCf_ZRTCw var5343;	// (i32, bool, )
	int32_t var5344;	// i32
	TUP_2_ZRTCf_ZRTCw var5345;	// (i32, bool, )
	int32_t var5346;	// i32
	TUP_2_ZRTCb_ZRTCw var5347;	// (i8, bool, )
	int8_t var5348;	// i8
	int8_t var5349;	// i8
	uint32_t var5350;	// u32
	int8_t var5351;	// i8
	int8_t var5352;	// i8
	uint32_t var5353;	// u32
	uint32_t var5354;	// u32
	uint16_t var5355;	// u16
	uint16_t var5356;	// u16
	uint16_t var5357;	// u16
	uint16_t var5358;	// u16
	uint16_t var5359;	// u16
	uint32_t var5360;	// u32
	uint128_t var5361;	// u128
	uint128_t var5362;	// u128
	uint32_t var5363;	// u32
	uint32_t var5364;	// u32
	uint16_t var5365;	// u16
	uint16_t var5366;	// u16
	uint16_t var5367;	// u16
	uint32_t var5368;	// u32
	uint32_t var5369;	// u32
	uint32_t var5370;	// u32
	uint32_t var5371;	// u32
	uint32_t var5372;	// u32
	uint32_t var5373;	// u32
	uint32_t var5374;	// u32
	TUP_2_ZRTCb_ZRTCw var5375;	// (i8, bool, )
	uint32_t var5376;	// u32
	int8_t var5377;	// i8
	uint32_t var5378;	// u32
	uint32_t var5379;	// u32
	uint32_t var5380;	// u32
	TUP_2_ZRTCb_ZRTCw var5381;	// (i8, bool, )
	int8_t var5382;	// i8
	TUP_2_ZRTCb_ZRTCw var5383;	// (i8, bool, )
	int8_t var5384;	// i8
	uint16_t var5385;	// u16
	int32_t var5386;	// i32
	uint32_t var5387;	// u32
	uint32_t var5388;	// u32
	uint32_t var5389;	// u32
	uint32_t var5390;	// u32
	uint32_t var5391;	// u32
	uint32_t var5392;	// u32
	uint16_t var5393;	// u16
	uint32_t var5394;	// u32
	uint8_t var5395;	// u8
	uint8_t var5396;	// u8
	int16_t var5397;	// i16
	int16_t var5398;	// i16
	TUP_2_ZRTCv_ZRTCw var5399;	// (isize, bool, )
	uint32_t var5400;	// u32
	uint32_t var5401;	// u32
	uint32_t var5402;	// u32
	uint32_t var5403;	// u32
	intptr_t var5404;	// isize
	intptr_t var5405;	// isize
	uint32_t var5406;	// u32
	int64_t var5407;	// i64
	TUP_2_ZRTCv_ZRTCw var5408;	// (isize, bool, )
	TUP_2_ZRTCd_ZRTCw var5409;	// (i16, bool, )
	int16_t var5410;	// i16
	int32_t var5411;	// i32
	uintptr_t var5412;	// usize
	uintptr_t var5413;	// usize
	TUP_2_ZRTCb_ZRTCw var5414;	// (i8, bool, )
	int8_t var5415;	// i8
	TUP_2_ZRTCb_ZRTCw var5416;	// (i8, bool, )
	int8_t var5417;	// i8
	int8_t var5418;	// i8
	uint32_t var5419;	// u32
	uint32_t var5420;	// u32
	int8_t var5421;	// i8
	uint32_t var5422;	// u32
	int128_t var5423;	// i128
	uint32_t var5424;	// u32
	int128_t var5425;	// i128
	int128_t var5426;	// i128
	uint32_t var5427;	// u32
	int128_t var5428;	// i128
	int128_t var5429;	// i128
	uint32_t var5430;	// u32
	uint32_t var5431;	// u32
	uint32_t var5432;	// u32
	uint32_t var5433;	// u32
	uint32_t var5434;	// u32
	uint16_t var5435;	// u16
	uint32_t var5436;	// u32
	TUP_2_ZRTCf_ZRTCw var5437;	// (i32, bool, )
	int32_t var5438;	// i32
	TUP_2_ZRTCf_ZRTCw var5439;	// (i32, bool, )
	int32_t var5440;	// i32
	uint32_t var5441;	// u32
	intptr_t var5442;	// isize
	TUP_2_ZRTCv_ZRTCw var5443;	// (isize, bool, )
	TUP_2_ZRTCv_ZRTCw var5444;	// (isize, bool, )
	uint32_t var5445;	// u32
	uint32_t var5446;	// u32
	uint32_t var5447;	// u32
	uint32_t var5448;	// u32
	uint32_t var5449;	// u32
	uint32_t var5450;	// u32
	uint32_t var5451;	// u32
	uint32_t var5452;	// u32
	uint32_t var5453;	// u32
	TUP_2_ZRTCv_ZRTCw var5454;	// (isize, bool, )
	intptr_t var5455;	// isize
	intptr_t var5456;	// isize
	TUP_2_ZRTCv_ZRTCw var5457;	// (isize, bool, )
	intptr_t var5458;	// isize
	intptr_t var5459;	// isize
	uint32_t var5460;	// u32
	uint32_t var5461;	// u32
	uint32_t var5462;	// u32
	uint32_t var5463;	// u32
	intptr_t var5464;	// isize
	uint32_t var5465;	// u32
	TUP_2_ZRTCj_ZRTCw var5466;	// (i128, bool, )
	int128_t var5467;	// i128
	int128_t var5468;	// i128
	int128_t var5469;	// i128
	TUP_2_ZRTCj_ZRTCw var5470;	// (i128, bool, )
	int128_t var5471;	// i128
	uint32_t var5472;	// u32
	uint32_t var5473;	// u32
	int128_t var5474;	// i128
	int128_t var5475;	// i128
	uint32_t var5476;	// u32
	uint32_t var5477;	// u32
	uint32_t var5478;	// u32
	uint32_t var5479;	// u32
	uint32_t var5480;	// u32
	uint32_t var5481;	// u32
	uint32_t var5482;	// u32
	intptr_t var5483;	// isize
	intptr_t var5484;	// isize
	uint32_t var5485;	// u32
	uint32_t var5486;	// u32
	uint32_t var5487;	// u32
	uint32_t var5488;	// u32
	int32_t var5489;	// i32
	int32_t var5490;	// i32
	uint32_t var5491;	// u32
	uint32_t var5492;	// u32
	uint32_t var5493;	// u32
	TUP_2_ZRTCb_ZRTCw var5494;	// (i8, bool, )
	uint32_t var5495;	// u32
	uint8_t var5496;	// u8
	uint32_t var5497;	// u32
	uint32_t var5498;	// u32
	int8_t var5499;	// i8
	TUP_2_ZRTCf_ZRTCw var5500;	// (i32, bool, )
	uint32_t var5501;	// u32
	uint32_t var5502;	// u32
	int32_t var5503;	// i32
	uint32_t var5504;	// u32
	TUP_2_ZRTCf_ZRTCw var5505;	// (i32, bool, )
	TUP_2_ZRTCf_ZRTCw var5506;	// (i32, bool, )
	int32_t var5507;	// i32
	int32_t var5508;	// i32
	TUP_2_ZRTCf_ZRTCw var5509;	// (i32, bool, )
	TUP_2_ZRTCf_ZRTCw var5510;	// (i32, bool, )
	int32_t var5511;	// i32
	TUP_2_ZRTCd_ZRTCw var5512;	// (i16, bool, )
	uint32_t var5513;	// u32
	uint32_t var5514;	// u32
	uint32_t var5515;	// u32
	int16_t var5516;	// i16
	uint32_t var5517;	// u32
	TUP_2_ZRTCd_ZRTCw var5518;	// (i16, bool, )
	int16_t var5519;	// i16
	int16_t var5520;	// i16
	intptr_t var5521;	// isize
	intptr_t var5522;	// isize
	TUP_2_ZRTCb_ZRTCw var5523;	// (i8, bool, )
	int8_t var5524;	// i8
	int8_t var5525;	// i8
	int8_t var5526;	// i8
	TUP_2_ZRTCf_ZRTCw var5527;	// (i32, bool, )
	int32_t var5528;	// i32
	uint32_t var5529;	// u32
	int32_t var5530;	// i32
	int32_t var5531;	// i32
	uint32_t var5532;	// u32
	TUP_2_ZRTCf_ZRTCw var5533;	// (i32, bool, )
	uint32_t var5534;	// u32
	int32_t var5535;	// i32
	uint16_t var5536;	// u16
	uint32_t var5537;	// u32
	uint16_t var5538;	// u16
	uint16_t var5539;	// u16
	uint32_t var5540;	// u32
	uint32_t var5541;	// u32
	uint32_t var5542;	// u32
	uint32_t var5543;	// u32
	uint16_t var5544;	// u16
	uint16_t var5545;	// u16
	uint32_t var5546;	// u32
	uint16_t var5547;	// u16
	uint16_t var5548;	// u16
	uint16_t var5549;	// u16
	uint16_t var5550;	// u16
	uint32_t var5551;	// u32
	uint16_t var5552;	// u16
	uint32_t var5553;	// u32
	uint32_t var5554;	// u32
	uint16_t var5555;	// u16
	uint32_t var5556;	// u32
	uint32_t var5557;	// u32
	uint8_t var5558;	// u8
	uint8_t var5559;	// u8
	uint32_t var5560;	// u32
	uint32_t var5561;	// u32
	uint8_t var5562;	// u8
	uint8_t var5563;	// u8
	TUP_2_ZRTCv_ZRTCw var5564;	// (isize, bool, )
	intptr_t var5565;	// isize
	uint8_t var5566;	// u8
	uint8_t var5567;	// u8
	uint8_t var5568;	// u8
	uint8_t var5569;	// u8
	uint32_t var5570;	// u32
	uint8_t var5571;	// u8
	uint8_t var5572;	// u8
	uint32_t var5573;	// u32
	uint8_t var5574;	// u8
	uint8_t var5575;	// u8
	uint8_t var5576;	// u8
	uint8_t var5577;	// u8
	uint32_t var5578;	// u32
	uint32_t var5579;	// u32
	uint32_t var5580;	// u32
	uint32_t var5581;	// u32
	uint32_t var5582;	// u32
	uint32_t var5583;	// u32
	uint32_t var5584;	// u32
	uint32_t var5585;	// u32
	uint32_t var5586;	// u32
	int16_t var5587;	// i16
	uint32_t var5588;	// u32
	int16_t var5589;	// i16
	uint32_t var5590;	// u32
	uint8_t var5591;	// u8
	uint32_t var5592;	// u32
	int32_t var5593;	// i32
	int32_t var5594;	// i32
	int32_t var5595;	// i32
	uint16_t var5596;	// u16
	uint32_t var5597;	// u32
	uint16_t var5598;	// u16
	uint16_t var5599;	// u16
	uint32_t var5600;	// u32
	uint32_t var5601;	// u32
	uint32_t var5602;	// u32
	uint32_t var5603;	// u32
	uint32_t var5604;	// u32
	uint32_t var5605;	// u32
	uint32_t var5606;	// u32
	TUP_2_ZRTCd_ZRTCw var5607;	// (i16, bool, )
	int16_t var5608;	// i16
	int16_t var5609;	// i16
	uint32_t var5610;	// u32
	int16_t var5611;	// i16
	int16_t var5612;	// i16
	uint32_t var5613;	// u32
	int16_t var5614;	// i16
	TUP_2_ZRTCd_ZRTCw var5615;	// (i16, bool, )
	int16_t var5616;	// i16
	int16_t var5617;	// i16
	int16_t var5618;	// i16
	int16_t var5619;	// i16
	int64_t var5620;	// i64
	int64_t var5621;	// i64
	int64_t var5622;	// i64
	uint32_t var5623;	// u32
	int64_t var5624;	// i64
	int64_t var5625;	// i64
	intptr_t var5626;	// isize
	intptr_t var5627;	// isize
	uint32_t var5628;	// u32
	uint32_t var5629;	// u32
	uint32_t var5630;	// u32
	intptr_t var5631;	// isize
	intptr_t var5632;	// isize
	uint32_t var5633;	// u32
	uint32_t var5634;	// u32
	intptr_t var5635;	// isize
	uint32_t var5636;	// u32
	uint128_t var5637;	// u128
	uint32_t var5638;	// u32
	uint32_t var5639;	// u32
	uint32_t var5640;	// u32
	uint32_t var5641;	// u32
	uint32_t var5642;	// u32
	uint32_t var5643;	// u32
	uint32_t var5644;	// u32
	uint64_t var5645;	// u64
	uint64_t var5646;	// u64
	uint64_t var5647;	// u64
	uint64_t var5648;	// u64
	uint32_t var5649;	// u32
	uint32_t var5650;	// u32
	uint16_t var5651;	// u16
	uint16_t var5652;	// u16
	int128_t var5653;	// i128
	uint32_t var5654;	// u32
	int128_t var5655;	// i128
	int128_t var5656;	// i128
	int128_t var5657;	// i128
	uint32_t var5658;	// u32
	uint32_t var5659;	// u32
	int8_t var5660;	// i8
	int8_t var5661;	// i8
	uint32_t var5662;	// u32
	uint32_t var5663;	// u32
	uint8_t var5664;	// u8
	uint8_t var5665;	// u8
	uint32_t var5666;	// u32
	uint8_t var5667;	// u8
	uint8_t var5668;	// u8
	uint8_t var5669;	// u8
	uint8_t var5670;	// u8
	uint8_t var5671;	// u8
	uint8_t var5672;	// u8
	uint32_t var5673;	// u32
	uint32_t var5674;	// u32
	uint32_t var5675;	// u32
	uint32_t var5676;	// u32
	uint32_t var5677;	// u32
	uint32_t var5678;	// u32
	uint32_t var5679;	// u32
	uint32_t var5680;	// u32
	TUP_2_ZRTCj_ZRTCw var5681;	// (i128, bool, )
	int128_t var5682;	// i128
	int128_t var5683;	// i128
	uint32_t var5684;	// u32
	intptr_t var5685;	// isize
	uint32_t var5686;	// u32
	intptr_t var5687;	// isize
	intptr_t var5688;	// isize
	TUP_2_ZRTCv_ZRTCw var5689;	// (isize, bool, )
	intptr_t var5690;	// isize
	intptr_t var5691;	// isize
	TUP_2_ZRTCv_ZRTCw var5692;	// (isize, bool, )
	intptr_t var5693;	// isize
	intptr_t var5694;	// isize
	uintptr_t var5695;	// usize
	uint32_t var5696;	// u32
	uint8_t var5697;	// u8
	uint32_t var5698;	// u32
	uint8_t var5699;	// u8
	uint8_t var5700;	// u8
	uint32_t var5701;	// u32
	uint8_t var5702;	// u8
	TUP_2_ZRTCf_ZRTCw var5703;	// (i32, bool, )
	int32_t var5704;	// i32
	int32_t var5705;	// i32
	uint32_t var5706;	// u32
	int32_t var5707;	// i32
	int32_t var5708;	// i32
	uint32_t var5709;	// u32
	uint32_t var5710;	// u32
	int32_t var5711;	// i32
	int32_t var5712;	// i32
	int32_t var5713;	// i32
	int32_t var5714;	// i32
	int32_t var5715;	// i32
	uint32_t var5716;	// u32
	int32_t var5717;	// i32
	int32_t var5718;	// i32
	TUP_2_ZRTCf_ZRTCw var5719;	// (i32, bool, )
	int32_t var5720;	// i32
	int32_t var5721;	// i32
	uint32_t var5722;	// u32
	uint32_t var5723;	// u32
	uint8_t var5724;	// u8
	uint8_t var5725;	// u8
	uint32_t var5726;	// u32
	uint8_t var5727;	// u8
	uint8_t var5728;	// u8
	uint32_t var5729;	// u32
	uint32_t var5730;	// u32
	int16_t var5731;	// i16
	int16_t var5732;	// i16
	uint32_t var5733;	// u32
	uint16_t var5734;	// u16
	uint32_t var5735;	// u32
	uint16_t var5736;	// u16
	uint16_t var5737;	// u16
	uint16_t var5738;	// u16
	uint16_t var5739;	// u16
	uint16_t var5740;	// u16
	uint16_t var5741;	// u16
	uint32_t var5742;	// u32
	uint32_t var5743;	// u32
	uint32_t var5744;	// u32
	uint32_t var5745;	// u32
	uint32_t var5746;	// u32
	uint32_t var5747;	// u32
	uint64_t var5748;	// u64
	uint32_t var5749;	// u32
	uint32_t var5750;	// u32
	uint128_t var5751;	// u128
	uint128_t var5752;	// u128
	uint128_t var5753;	// u128
	uint128_t var5754;	// u128
	uint128_t var5755;	// u128
	uint128_t var5756;	// u128
	uint128_t var5757;	// u128
	uint32_t var5758;	// u32
	uint32_t var5759;	// u32
	uint32_t var5760;	// u32
	uint32_t var5761;	// u32
	uintptr_t var5762;	// usize
	uint32_t var5763;	// u32
	uint64_t var5764;	// u64
	uint32_t var5765;	// u32
	uint32_t var5766;	// u32
	uint32_t var5767;	// u32
	uint32_t var5768;	// u32
	uint32_t var5769;	// u32
	uint16_t var5770;	// u16
	uint16_t var5771;	// u16
	uint32_t var5772;	// u32
	int32_t var5773;	// i32
	int32_t var5774;	// i32
	uint32_t var5775;	// u32
	TUP_2_ZRTCf_ZRTCw var5776;	// (i32, bool, )
	int32_t var5777;	// i32
	int32_t var5778;	// i32
	int8_t var5779;	// i8
	int8_t var5780;	// i8
	uint8_t var5781;	// u8
	uint32_t var5782;	// u32
	uint8_t var5783;	// u8
	uint32_t var5784;	// u32
	uint8_t var5785;	// u8
	uint8_t var5786;	// u8
	uint32_t var5787;	// u32
	uint32_t var5788;	// u32
	uint32_t var5789;	// u32
	uint32_t var5790;	// u32
	uintptr_t var5791;	// usize
	uintptr_t var5792;	// usize
	uint32_t var5793;	// u32
	uint32_t var5794;	// u32
	uint32_t var5795;	// u32
	uint32_t var5796;	// u32
	uint32_t var5797;	// u32
	intptr_t var5798;	// isize
	uint32_t var5799;	// u32
	int16_t var5800;	// i16
	int16_t var5801;	// i16
	int16_t var5802;	// i16
	uint32_t var5803;	// u32
	uint32_t var5804;	// u32
	uint32_t var5805;	// u32
	uint32_t var5806;	// u32
	uint32_t var5807;	// u32
	int8_t var5808;	// i8
	int8_t var5809;	// i8
	uint32_t var5810;	// u32
	int32_t var5811;	// i32
	uint32_t var5812;	// u32
	int32_t var5813;	// i32
	uint32_t var5814;	// u32
	uint32_t var5815;	// u32
	uint16_t var5816;	// u16
	uint32_t var5817;	// u32
	uint16_t var5818;	// u16
	uint32_t var5819;	// u32
	uint16_t var5820;	// u16
	uint16_t var5821;	// u16
	uint16_t var5822;	// u16
	uint32_t var5823;	// u32
	uint32_t var5824;	// u32
	uint32_t var5825;	// u32
	uint16_t var5826;	// u16
	uint16_t var5827;	// u16
	uint32_t var5828;	// u32
	uint16_t var5829;	// u16
	uint16_t var5830;	// u16
	uint32_t var5831;	// u32
	uint16_t var5832;	// u16
	uint16_t var5833;	// u16
	uint32_t var5834;	// u32
	uint32_t var5835;	// u32
	uint32_t var5836;	// u32
	uint16_t var5837;	// u16
	uint16_t var5838;	// u16
	uint32_t var5839;	// u32
	uint16_t var5840;	// u16
	uint16_t var5841;	// u16
	int64_t var5842;	// i64
	int64_t var5843;	// i64
	uint32_t var5844;	// u32
	uint32_t var5845;	// u32
	uint32_t var5846;	// u32
	uint32_t var5847;	// u32
	uint32_t var5848;	// u32
	uint32_t var5849;	// u32
	uint16_t var5850;	// u16
	uint16_t var5851;	// u16
	uint32_t var5852;	// u32
	uint16_t var5853;	// u16
	uint16_t var5854;	// u16
	int16_t var5855;	// i16
	int16_t var5856;	// i16
	uint32_t var5857;	// u32
	uint8_t var5858;	// u8
	uint32_t var5859;	// u32
	uint8_t var5860;	// u8
	uint8_t var5861;	// u8
	TUP_2_ZRTCb_ZRTCw var5862;	// (i8, bool, )
	int8_t var5863;	// i8
	int8_t var5864;	// i8
	int64_t var5865;	// i64
	TUP_2_ZRTCh_ZRTCw var5866;	// (i64, bool, )
	uint32_t var5867;	// u32
	TUP_2_ZRTCd_ZRTCw var5868;	// (i16, bool, )
	uint32_t var5869;	// u32
	uint32_t var5870;	// u32
	int16_t var5871;	// i16
	int16_t var5872;	// i16
	uint32_t var5873;	// u32
	uint32_t var5874;	// u32
	uint8_t var5875;	// u8
	uint8_t var5876;	// u8
	uint32_t var5877;	// u32
	uint32_t var5878;	// u32
	uint32_t var5879;	// u32
	uint8_t var5880;	// u8
	uint32_t var5881;	// u32
	uint8_t var5882;	// u8
	uint8_t var5883;	// u8
	uint8_t var5884;	// u8
	uint8_t var5885;	// u8
	intptr_t var5886;	// isize
	TUP_2_ZRTCd_ZRTCw var5887;	// (i16, bool, )
	TUP_2_ZRTCd_ZRTCw var5888;	// (i16, bool, )
	uint16_t var5889;	// u16
	uint16_t var5890;	// u16
	uint16_t var5891;	// u16
	uint128_t var5892;	// u128
	uint128_t var5893;	// u128
	uint8_t var5894;	// u8
	uint32_t var5895;	// u32
	uint32_t var5896;	// u32
	uint32_t var5897;	// u32
	uint16_t var5898;	// u16
	uint16_t var5899;	// u16
	uint32_t var5900;	// u32
	uint32_t var5901;	// u32
	uint16_t var5902;	// u16
	uint32_t var5903;	// u32
	uint32_t var5904;	// u32
	int32_t var5905;	// i32
	int32_t var5906;	// i32
	uint32_t var5907;	// u32
	uint32_t var5908;	// u32
	uint16_t var5909;	// u16
	uint16_t var5910;	// u16
	uint32_t var5911;	// u32
	TUP_2_ZRTCb_ZRTCw var5912;	// (i8, bool, )
	int8_t var5913;	// i8
	uint8_t var5914;	// u8
	uint8_t var5915;	// u8
	uint8_t var5916;	// u8
	uint32_t var5917;	// u32
	uint32_t var5918;	// u32
	uint32_t var5919;	// u32
	uint32_t var5920;	// u32
	uint8_t var5921;	// u8
	uint8_t var5922;	// u8
	uint32_t var5923;	// u32
	TUP_2_ZRTCd_ZRTCw var5924;	// (i16, bool, )
	int16_t var5925;	// i16
	int16_t var5926;	// i16
	TUP_2_ZRTCb_ZRTCw var5927;	// (i8, bool, )
	uint32_t var5928;	// u32
	int8_t var5929;	// i8
	int8_t var5930;	// i8
	uint32_t var5931;	// u32
	int8_t var5932;	// i8
	int8_t var5933;	// i8
	TUP_2_ZRTCb_ZRTCw var5934;	// (i8, bool, )
	int8_t var5935;	// i8
	uint16_t var5936;	// u16
	uint16_t var5937;	// u16
	uint32_t var5938;	// u32
	uint32_t var5939;	// u32
	uint32_t var5940;	// u32
	uint32_t var5941;	// u32
	uint32_t var5942;	// u32
	uint32_t var5943;	// u32
	uint128_t var5944;	// u128
	uint128_t var5945;	// u128
	uint128_t var5946;	// u128
	uint128_t var5947;	// u128
	uint32_t var5948;	// u32
	int8_t var5949;	// i8
	int8_t var5950;	// i8
	uint32_t var5951;	// u32
	TUP_2_ZRTCd_ZRTCw var5952;	// (i16, bool, )
	TUP_2_ZRTCd_ZRTCw var5953;	// (i16, bool, )
	int16_t var5954;	// i16
	TUP_2_ZRTCj_ZRTCw var5955;	// (i128, bool, )
	int128_t var5956;	// i128
	uint32_t var5957;	// u32
	int16_t var5958;	// i16
	uint32_t var5959;	// u32
	TUP_2_ZRTCd_ZRTCw var5960;	// (i16, bool, )
	int16_t var5961;	// i16
	uint32_t var5962;	// u32
	uint32_t var5963;	// u32
	uint32_t var5964;	// u32
	uint32_t var5965;	// u32
	int16_t var5966;	// i16
	uint32_t var5967;	// u32
	int16_t var5968;	// i16
	uint32_t var5969;	// u32
	uint16_t var5970;	// u16
	uint16_t var5971;	// u16
	uint64_t var5972;	// u64
	uint32_t var5973;	// u32
	uint32_t var5974;	// u32
	uint32_t var5975;	// u32
	uint32_t var5976;	// u32
	uint64_t var5977;	// u64
	uint64_t var5978;	// u64
	uint32_t var5979;	// u32
	uint32_t var5980;	// u32
	uint64_t var5981;	// u64
	uint64_t var5982;	// u64
	uint32_t var5983;	// u32
	uint32_t var5984;	// u32
	uint64_t var5985;	// u64
	uint64_t var5986;	// u64
	uint64_t var5987;	// u64
	uint64_t var5988;	// u64
	uint32_t var5989;	// u32
	uint64_t var5990;	// u64
	uint64_t var5991;	// u64
	uint32_t var5992;	// u32
	TUP_2_ZRTCf_ZRTCw var5993;	// (i32, bool, )
	TUP_2_ZRTCf_ZRTCw var5994;	// (i32, bool, )
	int32_t var5995;	// i32
	int32_t var5996;	// i32
	int64_t var5997;	// i64
	int64_t var5998;	// i64
	uint32_t var5999;	// u32
	uint32_t var6000;	// u32
	uint8_t var6001;	// u8
	uint32_t var6002;	// u32
	int64_t var6003;	// i64
	int64_t var6004;	// i64
	uint32_t var6005;	// u32
	int32_t var6006;	// i32
	int32_t var6007;	// i32
	uint32_t var6008;	// u32
	int128_t var6009;	// i128
	int128_t var6010;	// i128
	uint32_t var6011;	// u32
	TUP_2_ZRTCf_ZRTCw var6012;	// (i32, bool, )
	int32_t var6013;	// i32
	int32_t var6014;	// i32
	TUP_2_ZRTCd_ZRTCw var6015;	// (i16, bool, )
	int16_t var6016;	// i16
	int16_t var6017;	// i16
	int16_t var6018;	// i16
	uint32_t var6019;	// u32
	int32_t var6020;	// i32
	int32_t var6021;	// i32
	uint32_t var6022;	// u32
	uint16_t var6023;	// u16
	uint16_t var6024;	// u16
	uint16_t var6025;	// u16
	int32_t var6026;	// i32
	uint16_t var6027;	// u16
	uint16_t var6028;	// u16
	int16_t var6029;	// i16
	int16_t var6030;	// i16
	uint32_t var6031;	// u32
	uint32_t var6032;	// u32
	uint32_t var6033;	// u32
	uint32_t var6034;	// u32
	int16_t var6035;	// i16
	int16_t var6036;	// i16
	uint32_t var6037;	// u32
	uint32_t var6038;	// u32
	uint32_t var6039;	// u32
	uint32_t var6040;	// u32
	int128_t var6041;	// i128
	int128_t var6042;	// i128
	uint32_t var6043;	// u32
	uint32_t var6044;	// u32
	uint32_t var6045;	// u32
	uint16_t var6046;	// u16
	uint16_t var6047;	// u16
	uint32_t var6048;	// u32
	uint128_t var6049;	// u128
	uint16_t var6050;	// u16
	uint128_t var6051;	// u128
	uint128_t var6052;	// u128
	int8_t var6053;	// i8
	uint32_t var6054;	// u32
	uint32_t var6055;	// u32
	uint8_t var6056;	// u8
	uint8_t var6057;	// u8
	uint32_t var6058;	// u32
	uint32_t var6059;	// u32
	uint32_t var6060;	// u32
	uint32_t var6061;	// u32
	uint32_t var6062;	// u32
	uint32_t var6063;	// u32
	int8_t var6064;	// i8
	int8_t var6065;	// i8
	uint32_t var6066;	// u32
	TUP_2_ZRTCb_ZRTCw var6067;	// (i8, bool, )
	int8_t var6068;	// i8
	TUP_2_ZRTCd_ZRTCw var6069;	// (i16, bool, )
	uint32_t var6070;	// u32
	uint32_t var6071;	// u32
	uint32_t var6072;	// u32
	uint32_t var6073;	// u32
	uint32_t var6074;	// u32
	uint32_t var6075;	// u32
	int16_t var6076;	// i16
	uint8_t var6077;	// u8
	uint32_t var6078;	// u32
	uint8_t var6079;	// u8
	uint8_t var6080;	// u8
	uint8_t var6081;	// u8
	uint8_t var6082;	// u8
	uint8_t var6083;	// u8
	uint8_t var6084;	// u8
	uint8_t var6085;	// u8
	uint128_t var6086;	// u128
	int128_t var6087;	// i128
	int128_t var6088;	// i128
	uint32_t var6089;	// u32
	uint32_t var6090;	// u32
	uint32_t var6091;	// u32
	uint32_t var6092;	// u32
	uint128_t var6093;	// u128
	uint128_t var6094;	// u128
	uint32_t var6095;	// u32
	uint8_t var6096;	// u8
	uint8_t var6097;	// u8
	uint8_t var6098;	// u8
	uint8_t var6099;	// u8
	uint8_t var6100;	// u8
	uint32_t var6101;	// u32
	uint8_t var6102;	// u8
	uint32_t var6103;	// u32
	uint8_t var6104;	// u8
	uint8_t var6105;	// u8
	uint32_t var6106;	// u32
	uint32_t var6107;	// u32
	uint32_t var6108;	// u32
	uint32_t var6109;	// u32
	uint32_t var6110;	// u32
	uint8_t var6111;	// u8
	uint8_t var6112;	// u8
	uint32_t var6113;	// u32
	uint32_t var6114;	// u32
	uint32_t var6115;	// u32
	uint32_t var6116;	// u32
	uint32_t var6117;	// u32
	uint32_t var6118;	// u32
	uint32_t var6119;	// u32
	uint32_t var6120;	// u32
	uint32_t var6121;	// u32
	uint32_t var6122;	// u32
	uint32_t var6123;	// u32
	TUP_2_ZRTCj_ZRTCw var6124;	// (i128, bool, )
	int128_t var6125;	// i128
	int128_t var6126;	// i128
	uint32_t var6127;	// u32
	uint32_t var6128;	// u32
	uintptr_t var6129;	// usize
	uintptr_t var6130;	// usize
	uint32_t var6131;	// u32
	uint16_t var6132;	// u16
	uint16_t var6133;	// u16
	uint16_t var6134;	// u16
	uint32_t var6135;	// u32
	uint16_t var6136;	// u16
	uint32_t var6137;	// u32
	uint16_t var6138;	// u16
	uint16_t var6139;	// u16
	uintptr_t var6140;	// usize
	uintptr_t var6141;	// usize
	TUP_2_ZRTCh_ZRTCw var6142;	// (i64, bool, )
	int64_t var6143;	// i64
	int64_t var6144;	// i64
	int64_t var6145;	// i64
	uint8_t var6146;	// u8
	uint32_t var6147;	// u32
	uintptr_t var6148;	// usize
	uint32_t var6149;	// u32
	uint32_t var6150;	// u32
	uintptr_t var6151;	// usize
	uint32_t var6152;	// u32
	uintptr_t var6153;	// usize
	uintptr_t var6154;	// usize
	uintptr_t var6155;	// usize
	uintptr_t var6156;	// usize
	uintptr_t var6157;	// usize
	uint32_t var6158;	// u32
	uint32_t var6159;	// u32
	uint32_t var6160;	// u32
	uint32_t var6161;	// u32
	int8_t var6162;	// i8
	int8_t var6163;	// i8
	uint32_t var6164;	// u32
	uint32_t var6165;	// u32
	uint32_t var6166;	// u32
	uint32_t var6167;	// u32
	uint32_t var6168;	// u32
	uint32_t var6169;	// u32
	uint32_t var6170;	// u32
	uint16_t var6171;	// u16
	uint16_t var6172;	// u16
	uint16_t var6173;	// u16
	uint32_t var6174;	// u32
	uint16_t var6175;	// u16
	uint16_t var6176;	// u16
	uint32_t var6177;	// u32
	uint16_t var6178;	// u16
	TUP_2_ZRTCb_ZRTCw var6179;	// (i8, bool, )
	int8_t var6180;	// i8
	int8_t var6181;	// i8
	uint16_t var6182;	// u16
	uint32_t var6183;	// u32
	uint16_t var6184;	// u16
	uint16_t var6185;	// u16
	uint32_t var6186;	// u32
	uint16_t var6187;	// u16
	uint16_t var6188;	// u16
	uint32_t var6189;	// u32
	uint32_t var6190;	// u32
	uint32_t var6191;	// u32
	uint32_t var6192;	// u32
	uintptr_t var6193;	// usize
	uintptr_t var6194;	// usize
	uint16_t var6195;	// u16
	uint16_t var6196;	// u16
	uint16_t var6197;	// u16
	uint16_t var6198;	// u16
	uint16_t var6199;	// u16
	uint32_t var6200;	// u32
	uint16_t var6201;	// u16
	uint32_t var6202;	// u32
	uint32_t var6203;	// u32
	uint32_t var6204;	// u32
	uint32_t var6205;	// u32
	uint32_t var6206;	// u32
	uint32_t var6207;	// u32
	uint32_t var6208;	// u32
	uint32_t var6209;	// u32
	uint16_t var6210;	// u16
	uint16_t var6211;	// u16
	uint32_t var6212;	// u32
	uint16_t var6213;	// u16
	uint32_t var6214;	// u32
	uint32_t var6215;	// u32
	uint32_t var6216;	// u32
	uint16_t var6217;	// u16
	uint16_t var6218;	// u16
	uint32_t var6219;	// u32
	uint16_t var6220;	// u16
	uint16_t var6221;	// u16
	uint16_t var6222;	// u16
	uint16_t var6223;	// u16
	uint32_t var6224;	// u32
	uint32_t var6225;	// u32
	int8_t var6226;	// i8
	int8_t var6227;	// i8
	uint32_t var6228;	// u32
	uint32_t var6229;	// u32
	uint16_t var6230;	// u16
	TUP_2_ZRTCb_ZRTCw var6231;	// (i8, bool, )
	int8_t var6232;	// i8
	int8_t var6233;	// i8
	uint32_t var6234;	// u32
	uint16_t var6235;	// u16
	uint16_t var6236;	// u16
	uint16_t var6237;	// u16
	uint16_t var6238;	// u16
	uint32_t var6239;	// u32
	int16_t var6240;	// i16
	int16_t var6241;	// i16
	uint32_t var6242;	// u32
	int16_t var6243;	// i16
	int16_t var6244;	// i16
	int16_t var6245;	// i16
	uint32_t var6246;	// u32
	int16_t var6247;	// i16
	int16_t var6248;	// i16
	int16_t var6249;	// i16
	uint32_t var6250;	// u32
	uint128_t var6251;	// u128
	uint128_t var6252;	// u128
	uint128_t var6253;	// u128
	TUP_2_ZRTCd_ZRTCw var6254;	// (i16, bool, )
	int16_t var6255;	// i16
	TUP_2_ZRTCd_ZRTCw var6256;	// (i16, bool, )
	int16_t var6257;	// i16
	int16_t var6258;	// i16
	uint8_t var6259;	// u8
	uint32_t var6260;	// u32
	uint16_t var6261;	// u16
	uint32_t var6262;	// u32
	uint128_t var6263;	// u128
	uint128_t var6264;	// u128
	uint128_t var6265;	// u128
	uint32_t var6266;	// u32
	uint128_t var6267;	// u128
	uint128_t var6268;	// u128
	uint32_t var6269;	// u32
	uint32_t var6270;	// u32
	uint32_t var6271;	// u32
	uint32_t var6272;	// u32
	intptr_t var6273;	// isize
	uint32_t var6274;	// u32
	intptr_t var6275;	// isize
	intptr_t var6276;	// isize
	uint32_t var6277;	// u32
	uint32_t var6278;	// u32
	uint32_t var6279;	// u32
	uint32_t var6280;	// u32
	int128_t var6281;	// i128
	uint32_t var6282;	// u32
	int128_t var6283;	// i128
	uint64_t var6284;	// u64
	uint64_t var6285;	// u64
	int32_t var6286;	// i32
	TUP_2_ZRTCf_ZRTCw var6287;	// (i32, bool, )
	int32_t var6288;	// i32
	int32_t var6289;	// i32
	uint8_t var6290;	// u8
	uint8_t var6291;	// u8
	uint8_t var6292;	// u8
	uint8_t var6293;	// u8
	uint8_t var6294;	// u8
	uint8_t var6295;	// u8
	TUP_2_ZRTCf_ZRTCw var6296;	// (i32, bool, )
	uint8_t var6297;	// u8
	uint8_t var6298;	// u8
	uint16_t var6299;	// u16
	uint16_t var6300;	// u16
	uint16_t var6301;	// u16
	uint16_t var6302;	// u16
	uint32_t var6303;	// u32
	uint128_t var6304;	// u128
	uint128_t var6305;	// u128
	uint32_t var6306;	// u32
	uint32_t var6307;	// u32
	uint8_t var6308;	// u8
	uint8_t var6309;	// u8
	uint8_t var6310;	// u8
	uint8_t var6311;	// u8
	uint8_t var6312;	// u8
	uint8_t var6313;	// u8
	uint32_t var6314;	// u32
	uint8_t var6315;	// u8
	uint8_t var6316;	// u8
	uint32_t var6317;	// u32
	uint8_t var6318;	// u8
	uint8_t var6319;	// u8
	uint8_t var6320;	// u8
	uint32_t var6321;	// u32
	uint32_t var6322;	// u32
	uint32_t var6323;	// u32
	uint8_t var6324;	// u8
	uint8_t var6325;	// u8
	uint32_t var6326;	// u32
	uint16_t var6327;	// u16
	uint16_t var6328;	// u16
	uint16_t var6329;	// u16
	uint16_t var6330;	// u16
	uint16_t var6331;	// u16
	uint16_t var6332;	// u16
	uint32_t var6333;	// u32
	uint32_t var6334;	// u32
	uint32_t var6335;	// u32
	uint32_t var6336;	// u32
	uintptr_t var6337;	// usize
	uintptr_t var6338;	// usize
	uintptr_t var6339;	// usize
	uint32_t var6340;	// u32
	uint32_t var6341;	// u32
	uint32_t var6342;	// u32
	uintptr_t var6343;	// usize
	uintptr_t var6344;	// usize
	uint32_t var6345;	// u32
	uint32_t var6346;	// u32
	uint32_t var6347;	// u32
	uint32_t var6348;	// u32
	uint32_t var6349;	// u32
	uint8_t var6350;	// u8
	uint8_t var6351;	// u8
	uint32_t var6352;	// u32
	uint16_t var6353;	// u16
	uint16_t var6354;	// u16
	TUP_2_ZRTCf_ZRTCw var6355;	// (i32, bool, )
	int32_t var6356;	// i32
	int32_t var6357;	// i32
	uint32_t var6358;	// u32
	uint32_t var6359;	// u32
	uint32_t var6360;	// u32
	uint32_t var6361;	// u32
	uint32_t var6362;	// u32
	uint32_t var6363;	// u32
	uint32_t var6364;	// u32
	uint32_t var6365;	// u32
	uint32_t var6366;	// u32
	uint32_t var6367;	// u32
	uint32_t var6368;	// u32
	uint32_t var6369;	// u32
	uint32_t var6370;	// u32
	uint16_t var6371;	// u16
	uint16_t var6372;	// u16
	uint32_t var6373;	// u32
	uint32_t var6374;	// u32
	uint16_t var6375;	// u16
	uint16_t var6376;	// u16
	uint32_t var6377;	// u32
	uint16_t var6378;	// u16
	uint16_t var6379;	// u16
	uint32_t var6380;	// u32
	uint128_t var6381;	// u128
	TUP_2_ZRTCb_ZRTCw var6382;	// (i8, bool, )
	int8_t var6383;	// i8
	int8_t var6384;	// i8
	int8_t var6385;	// i8
	int16_t var6386;	// i16
	TUP_2_ZRTCd_ZRTCw var6387;	// (i16, bool, )
	TUP_2_ZRTCd_ZRTCw var6388;	// (i16, bool, )
	TUP_2_ZRTCd_ZRTCw var6389;	// (i16, bool, )
	int16_t var6390;	// i16
	int16_t var6391;	// i16
	int16_t var6392;	// i16
	int16_t var6393;	// i16
	int16_t var6394;	// i16
	uint32_t var6395;	// u32
	int16_t var6396;	// i16
	uint32_t var6397;	// u32
	int16_t var6398;	// i16
	int16_t var6399;	// i16
	uint32_t var6400;	// u32
	uint128_t var6401;	// u128
	uint32_t var6402;	// u32
	uint128_t var6403;	// u128
	uint32_t var6404;	// u32
	int32_t var6405;	// i32
	int16_t var6406;	// i16
	int16_t var6407;	// i16
	uint32_t var6408;	// u32
	uint16_t var6409;	// u16
	uint32_t var6410;	// u32
	uint16_t var6411;	// u16
	uint16_t var6412;	// u16
	uint16_t var6413;	// u16
	uint16_t var6414;	// u16
	uint32_t var6415;	// u32
	uint8_t var6416;	// u8
	uint8_t var6417;	// u8
	uint8_t var6418;	// u8
	uint8_t var6419;	// u8
	uint8_t var6420;	// u8
	uint8_t var6421;	// u8
	int16_t var6422;	// i16
	int16_t var6423;	// i16
	int16_t var6424;	// i16
	TUP_2_ZRTCd_ZRTCw var6425;	// (i16, bool, )
	int16_t var6426;	// i16
	int16_t var6427;	// i16
	TUP_2_ZRTCf_ZRTCw var6428;	// (i32, bool, )
	int32_t var6429;	// i32
	int32_t var6430;	// i32
	TUP_2_ZRTCf_ZRTCw var6431;	// (i32, bool, )
	int32_t var6432;	// i32
	int32_t var6433;	// i32
	int32_t var6434;	// i32
	int32_t var6435;	// i32
	int32_t var6436;	// i32
	int32_t var6437;	// i32
	int32_t var6438;	// i32
	uint16_t var6439;	// u16
	uint16_t var6440;	// u16
	uint32_t var6441;	// u32
	uint32_t var6442;	// u32
	int32_t var6443;	// i32
	int32_t var6444;	// i32
	uint32_t var6445;	// u32
	TUP_2_ZRTCf_ZRTCw var6446;	// (i32, bool, )
	int32_t var6447;	// i32
	int32_t var6448;	// i32
	uint32_t var6449;	// u32
	intptr_t var6450;	// isize
	uint32_t var6451;	// u32
	uint32_t var6452;	// u32
	intptr_t var6453;	// isize
	uint32_t var6454;	// u32
	uint32_t var6455;	// u32
	int16_t var6456;	// i16
	uint32_t var6457;	// u32
	int16_t var6458;	// i16
	int16_t var6459;	// i16
	uint32_t var6460;	// u32
	int32_t var6461;	// i32
	int32_t var6462;	// i32
	int8_t var6463;	// i8
	uint32_t var6464;	// u32
	uint32_t var6465;	// u32
	uint32_t var6466;	// u32
	int8_t var6467;	// i8
	int8_t var6468;	// i8
	uint32_t var6469;	// u32
	TUP_2_ZRTCb_ZRTCw var6470;	// (i8, bool, )
	uint8_t var6471;	// u8
	uint8_t var6472;	// u8
	uint8_t var6473;	// u8
	uint32_t var6474;	// u32
	uint8_t var6475;	// u8
	uint32_t var6476;	// u32
	uint8_t var6477;	// u8
	uint8_t var6478;	// u8
	uint16_t var6479;	// u16
	uint32_t var6480;	// u32
	uint128_t var6481;	// u128
	uint32_t var6482;	// u32
	uint32_t var6483;	// u32
	uint128_t var6484;	// u128
	uint32_t var6485;	// u32
	TUP_2_ZRTCd_ZRTCw var6486;	// (i16, bool, )
	int16_t var6487;	// i16
	int16_t var6488;	// i16
	TUP_2_ZRTCd_ZRTCw var6489;	// (i16, bool, )
	int16_t var6490;	// i16
	int16_t var6491;	// i16
	int16_t var6492;	// i16
	TUP_2_ZRTCd_ZRTCw var6493;	// (i16, bool, )
	int16_t var6494;	// i16
	uint32_t var6495;	// u32
	int64_t var6496;	// i64
	uint8_t var6497;	// u8
	uint8_t var6498;	// u8
	uint8_t var6499;	// u8
	uint8_t var6500;	// u8
	uint8_t var6501;	// u8
	uint8_t var6502;	// u8
	uint32_t var6503;	// u32
	uintptr_t var6504;	// usize
	uintptr_t var6505;	// usize
	uint32_t var6506;	// u32
	uint32_t var6507;	// u32
	uint32_t var6508;	// u32
	uint32_t var6509;	// u32
	uint32_t var6510;	// u32
	uint32_t var6511;	// u32
	uint32_t var6512;	// u32
	uint32_t var6513;	// u32
	uint32_t var6514;	// u32
	uint32_t var6515;	// u32
	uintptr_t var6516;	// usize
	uintptr_t var6517;	// usize
	uint32_t var6518;	// u32
	int32_t var6519;	// i32
	uint32_t var6520;	// u32
	uint32_t var6521;	// u32
	uint32_t var6522;	// u32
	uint32_t var6523;	// u32
	uint32_t var6524;	// u32
	uint32_t var6525;	// u32
	int16_t var6526;	// i16
	int16_t var6527;	// i16
	uint32_t var6528;	// u32
	int16_t var6529;	// i16
	int16_t var6530;	// i16
	int16_t var6531;	// i16
	int16_t var6532;	// i16
	uint128_t var6533;	// u128
	uint8_t var6534;	// u8
	uint32_t var6535;	// u32
	uint32_t var6536;	// u32
	uint32_t var6537;	// u32
	uint32_t var6538;	// u32
	uint8_t var6539;	// u8
	uint8_t var6540;	// u8
	uint32_t var6541;	// u32
	TUP_2_ZRTCf_ZRTCw var6542;	// (i32, bool, )
	int32_t var6543;	// i32
	int32_t var6544;	// i32
	int8_t var6545;	// i8
	int8_t var6546;	// i8
	uint32_t var6547;	// u32
	uint128_t var6548;	// u128
	uint32_t var6549;	// u32
	uint128_t var6550;	// u128
	uint128_t var6551;	// u128
	uint128_t var6552;	// u128
	uint128_t var6553;	// u128
	uint16_t var6554;	// u16
	uint16_t var6555;	// u16
	uint16_t var6556;	// u16
	uint32_t var6557;	// u32
	uint32_t var6558;	// u32
	uint32_t var6559;	// u32
	uint32_t var6560;	// u32
	uint32_t var6561;	// u32
	uint32_t var6562;	// u32
	uint16_t var6563;	// u16
	uint16_t var6564;	// u16
	uint32_t var6565;	// u32
	uint16_t var6566;	// u16
	uint16_t var6567;	// u16
	uint16_t var6568;	// u16
	uint16_t var6569;	// u16
	uint32_t var6570;	// u32
	int16_t var6571;	// i16
	uint64_t var6572;	// u64
	uint64_t var6573;	// u64
	uint32_t var6574;	// u32
	int64_t var6575;	// i64
	int64_t var6576;	// i64
	uint32_t var6577;	// u32
	uint32_t var6578;	// u32
	uint64_t var6579;	// u64
	uint128_t var6580;	// u128
	uint128_t var6581;	// u128
	uint128_t var6582;	// u128
	uint128_t var6583;	// u128
	uint128_t var6584;	// u128
	uint32_t var6585;	// u32
	uint32_t var6586;	// u32
	uint32_t var6587;	// u32
	uint32_t var6588;	// u32
	uint32_t var6589;	// u32
	uint32_t var6590;	// u32
	uint32_t var6591;	// u32
	int8_t var6592;	// i8
	uint32_t var6593;	// u32
	uint32_t var6594;	// u32
	int16_t var6595;	// i16
	uint128_t var6596;	// u128
	uint128_t var6597;	// u128
	uint128_t var6598;	// u128
	uint128_t var6599;	// u128
	int16_t var6600;	// i16
	uint16_t var6601;	// u16
	uint32_t var6602;	// u32
	uint16_t var6603;	// u16
	uint32_t var6604;	// u32
	uint16_t var6605;	// u16
	uint16_t var6606;	// u16
	uint32_t var6607;	// u32
	int64_t var6608;	// i64
	uint32_t var6609;	// u32
	uint32_t var6610;	// u32
	uint8_t var6611;	// u8
	uint8_t var6612;	// u8
	uint8_t var6613;	// u8
	uint128_t var6614;	// u128
	uint128_t var6615;	// u128
	uint128_t var6616;	// u128
	uint16_t var6617;	// u16
	uint16_t var6618;	// u16
	uint16_t var6619;	// u16
	uint16_t var6620;	// u16
	uint16_t var6621;	// u16
	uint32_t var6622;	// u32
	uint8_t var6623;	// u8
	uint32_t var6624;	// u32
	uint8_t var6625;	// u8
	uint8_t var6626;	// u8
	uint8_t var6627;	// u8
	uint8_t var6628;	// u8
	uint8_t var6629;	// u8
	uint8_t var6630;	// u8
	uint8_t var6631;	// u8
	uint8_t var6632;	// u8
	int16_t var6633;	// i16
	TUP_2_ZRTCb_ZRTCw var6634;	// (i8, bool, )
	int8_t var6635;	// i8
	int8_t var6636;	// i8
	TUP_2_ZRTCb_ZRTCw var6637;	// (i8, bool, )
	int8_t var6638;	// i8
	int8_t var6639;	// i8
	int8_t var6640;	// i8
	int8_t var6641;	// i8
	TUP_2_ZRTCb_ZRTCw var6642;	// (i8, bool, )
	int8_t var6643;	// i8
	int8_t var6644;	// i8
	uint16_t var6645;	// u16
	uint16_t var6646;	// u16
	TUP_2_ZRTCb_ZRTCw var6647;	// (i8, bool, )
	uint128_t var6648;	// u128
	uint128_t var6649;	// u128
	uint32_t var6650;	// u32
	uint32_t var6651;	// u32
	uint32_t var6652;	// u32
	TUP_2_ZRTCh_ZRTCw var6653;	// (i64, bool, )
	int64_t var6654;	// i64
	uint32_t var6655;	// u32
	int64_t var6656;	// i64
	uint32_t var6657;	// u32
	int32_t var6658;	// i32
	int32_t var6659;	// i32
	int32_t var6660;	// i32
	int32_t var6661;	// i32
	int32_t var6662;	// i32
	TUP_2_ZRTCd_ZRTCw var6663;	// (i16, bool, )
	uint16_t var6664;	// u16
	uint16_t var6665;	// u16
	uint32_t var6666;	// u32
	uint64_t var6667;	// u64
	uint64_t var6668;	// u64
	uint64_t var6669;	// u64
	uint64_t var6670;	// u64
	uint64_t var6671;	// u64
	uint64_t var6672;	// u64
	uint32_t var6673;	// u32
	uintptr_t var6674;	// usize
	uint32_t var6675;	// u32
	uint32_t var6676;	// u32
	uint32_t var6677;	// u32
	uint32_t var6678;	// u32
	TUP_2_ZRTCv_ZRTCw var6679;	// (isize, bool, )
	intptr_t var6680;	// isize
	uint32_t var6681;	// u32
	uint32_t var6682;	// u32
	int8_t var6683;	// i8
	uint32_t var6684;	// u32
	TUP_2_ZRTCb_ZRTCw var6685;	// (i8, bool, )
	int8_t var6686;	// i8
	int8_t var6687;	// i8
	TUP_2_ZRTCb_ZRTCw var6688;	// (i8, bool, )
	int8_t var6689;	// i8
	TUP_2_ZRTCb_ZRTCw var6690;	// (i8, bool, )
	TUP_2_ZRTCb_ZRTCw var6691;	// (i8, bool, )
	int8_t var6692;	// i8
	uint32_t var6693;	// u32
	int8_t var6694;	// i8
	uint32_t var6695;	// u32
	uint8_t var6696;	// u8
	uint8_t var6697;	// u8
	uint8_t var6698;	// u8
	uint8_t var6699;	// u8
	uint8_t var6700;	// u8
	uint8_t var6701;	// u8
	uint8_t var6702;	// u8
	uint8_t var6703;	// u8
	uint32_t var6704;	// u32
	uint32_t var6705;	// u32
	uint32_t var6706;	// u32
	uint32_t var6707;	// u32
	uint32_t var6708;	// u32
	int64_t var6709;	// i64
	int64_t var6710;	// i64
	uint32_t var6711;	// u32
	TUP_2_ZRTCv_ZRTCw var6712;	// (isize, bool, )
	uintptr_t var6713;	// usize
	uintptr_t var6714;	// usize
	TUP_2_ZRTCj_ZRTCw var6715;	// (i128, bool, )
	TUP_2_ZRTCj_ZRTCw var6716;	// (i128, bool, )
	uint32_t var6717;	// u32
	int32_t var6718;	// i32
	TUP_2_ZRTCj_ZRTCw var6719;	// (i128, bool, )
	uint32_t var6720;	// u32
	uint128_t var6721;	// u128
	uint128_t var6722;	// u128
	uint16_t var6723;	// u16
	uint16_t var6724;	// u16
	uint16_t var6725;	// u16
	uint16_t var6726;	// u16
	int8_t var6727;	// i8
	int8_t var6728;	// i8
	TUP_2_ZRTCb_ZRTCw var6729;	// (i8, bool, )
	int8_t var6730;	// i8
	uint64_t var6731;	// u64
	uint64_t var6732;	// u64
	uint32_t var6733;	// u32
	uint64_t var6734;	// u64
	uint64_t var6735;	// u64
	uint128_t var6736;	// u128
	uint128_t var6737;	// u128
	uint16_t var6738;	// u16
	uint16_t var6739;	// u16
	uint16_t var6740;	// u16
	uint16_t var6741;	// u16
	uint16_t var6742;	// u16
	uint32_t var6743;	// u32
	uint32_t var6744;	// u32
	uint32_t var6745;	// u32
	uint32_t var6746;	// u32
	uint16_t var6747;	// u16
	uint32_t var6748;	// u32
	uint16_t var6749;	// u16
	uint16_t var6750;	// u16
	TUP_2_ZRTCh_ZRTCw var6751;	// (i64, bool, )
	TUP_2_ZRTCh_ZRTCw var6752;	// (i64, bool, )
	int64_t var6753;	// i64
	int64_t var6754;	// i64
	int16_t var6755;	// i16
	int16_t var6756;	// i16
	int16_t var6757;	// i16
	int16_t var6758;	// i16
	TUP_2_ZRTCd_ZRTCw var6759;	// (i16, bool, )
	int16_t var6760;	// i16
	int16_t var6761;	// i16
	int16_t var6762;	// i16
	int16_t var6763;	// i16
	intptr_t var6764;	// isize
	intptr_t var6765;	// isize
	uint32_t var6766;	// u32
	int16_t var6767;	// i16
	int16_t var6768;	// i16
	TUP_2_ZRTCf_ZRTCw var6769;	// (i32, bool, )
	int32_t var6770;	// i32
	uint32_t var6771;	// u32
	uint32_t var6772;	// u32
	uint32_t var6773;	// u32
	int64_t var6774;	// i64
	int64_t var6775;	// i64
	uint32_t var6776;	// u32
	int16_t var6777;	// i16
	TUP_2_ZRTCd_ZRTCw var6778;	// (i16, bool, )
	int16_t var6779;	// i16
	uint32_t var6780;	// u32
	int16_t var6781;	// i16
	uint32_t var6782;	// u32
	uint32_t var6783;	// u32
	intptr_t var6784;	// isize
	intptr_t var6785;	// isize
	intptr_t var6786;	// isize
	int64_t var6787;	// i64
	TUP_2_ZRTCd_ZRTCw var6788;	// (i16, bool, )
	int16_t var6789;	// i16
	int16_t var6790;	// i16
	uint8_t var6791;	// u8
	uint32_t var6792;	// u32
	int64_t var6793;	// i64
	int64_t var6794;	// i64
	uint32_t var6795;	// u32
	int8_t var6796;	// i8
	int8_t var6797;	// i8
	uint32_t var6798;	// u32
	int8_t var6799;	// i8
	int8_t var6800;	// i8
	int8_t var6801;	// i8
	int8_t var6802;	// i8
	uint32_t var6803;	// u32
	uintptr_t var6804;	// usize
	uintptr_t var6805;	// usize
	uintptr_t var6806;	// usize
	TUP_2_ZRTCj_ZRTCw var6807;	// (i128, bool, )
	TUP_2_ZRTCj_ZRTCw var6808;	// (i128, bool, )
	uint32_t var6809;	// u32
	int128_t var6810;	// i128
	TUP_2_ZRTCj_ZRTCw var6811;	// (i128, bool, )
	int128_t var6812;	// i128
	int128_t var6813;	// i128
	TUP_2_ZRTCj_ZRTCw var6814;	// (i128, bool, )
	int128_t var6815;	// i128
	int128_t var6816;	// i128
	uint32_t var6817;	// u32
	uint32_t var6818;	// u32
	uint32_t var6819;	// u32
	uint32_t var6820;	// u32
	uint32_t var6821;	// u32
	uint32_t var6822;	// u32
	uint32_t var6823;	// u32
	uint32_t var6824;	// u32
	uint32_t var6825;	// u32
	uint32_t var6826;	// u32
	int32_t var6827;	// i32
	int32_t var6828;	// i32
	uint32_t var6829;	// u32
	uint32_t var6830;	// u32
	uint16_t var6831;	// u16
	uint32_t var6832;	// u32
	TUP_2_ZRTCd_ZRTCw var6833;	// (i16, bool, )
	int16_t var6834;	// i16
	int16_t var6835;	// i16
	intptr_t var6836;	// isize
	uint16_t var6837;	// u16
	uint16_t var6838;	// u16
	uint16_t var6839;	// u16
	uint32_t var6840;	// u32
	uint16_t var6841;	// u16
	uint16_t var6842;	// u16
	uint32_t var6843;	// u32
	uint16_t var6844;	// u16
	TUP_2_ZRTCb_ZRTCw var6845;	// (i8, bool, )
	uint16_t var6846;	// u16
	uint16_t var6847;	// u16
	uint16_t var6848;	// u16
	uint16_t var6849;	// u16
	uint32_t var6850;	// u32
	TUP_2_ZRTCd_ZRTCw var6851;	// (i16, bool, )
	int16_t var6852;	// i16
	uint32_t var6853;	// u32
	int16_t var6854;	// i16
	int16_t var6855;	// i16
	uint32_t var6856;	// u32
	int16_t var6857;	// i16
	int16_t var6858;	// i16
	TUP_2_ZRTCd_ZRTCw var6859;	// (i16, bool, )
	int16_t var6860;	// i16
	int16_t var6861;	// i16
	uint32_t var6862;	// u32
	int16_t var6863;	// i16
	int16_t var6864;	// i16
	int16_t var6865;	// i16
	TUP_2_ZRTCb_ZRTCw var6866;	// (i8, bool, )
	uint16_t var6867;	// u16
	uint32_t var6868;	// u32
	uint32_t var6869;	// u32
	uint32_t var6870;	// u32
	uint32_t var6871;	// u32
	uint32_t var6872;	// u32
	uint32_t var6873;	// u32
	uint32_t var6874;	// u32
	uint32_t var6875;	// u32
	uint32_t var6876;	// u32
	uint32_t var6877;	// u32
	uint32_t var6878;	// u32
	uint32_t var6879;	// u32
	int16_t var6880;	// i16
	int16_t var6881;	// i16
	uint32_t var6882;	// u32
	uint16_t var6883;	// u16
	uint16_t var6884;	// u16
	uint32_t var6885;	// u32
	intptr_t var6886;	// isize
	intptr_t var6887;	// isize
	uint32_t var6888;	// u32
	uint32_t var6889;	// u32
	uint8_t var6890;	// u8
	uint8_t var6891;	// u8
	uint8_t var6892;	// u8
	uint8_t var6893;	// u8
	uint32_t var6894;	// u32
	uint8_t var6895;	// u8
	uint8_t var6896;	// u8
	uint32_t var6897;	// u32
	uint8_t var6898;	// u8
	TUP_2_ZRTCb_ZRTCw var6899;	// (i8, bool, )
	uint32_t var6900;	// u32
	uint8_t var6901;	// u8
	uint8_t var6902;	// u8
	uint8_t var6903;	// u8
	uint8_t var6904;	// u8
	uint8_t var6905;	// u8
	uint8_t var6906;	// u8
	uint32_t var6907;	// u32
	uint8_t var6908;	// u8
	uint32_t var6909;	// u32
	uint8_t var6910;	// u8
	uint8_t var6911;	// u8
	uint8_t var6912;	// u8
	uint8_t var6913;	// u8
	uint32_t var6914;	// u32
	int128_t var6915;	// i128
	uint16_t var6916;	// u16
	uint16_t var6917;	// u16
	uint16_t var6918;	// u16
	uint16_t var6919;	// u16
	TUP_2_ZRTCf_ZRTCw var6920;	// (i32, bool, )
	int32_t var6921;	// i32
	TUP_2_ZRTCf_ZRTCw var6922;	// (i32, bool, )
	int128_t var6923;	// i128
	uint32_t var6924;	// u32
	uint32_t var6925;	// u32
	int128_t var6926;	// i128
	int128_t var6927;	// i128
	uint32_t var6928;	// u32
	int16_t var6929;	// i16
	TUP_2_ZRTCd_ZRTCw var6930;	// (i16, bool, )
	int16_t var6931;	// i16
	int16_t var6932;	// i16
	int128_t var6933;	// i128
	intptr_t var6934;	// isize
	uint32_t var6935;	// u32
	uint128_t var6936;	// u128
	uint128_t var6937;	// u128
	uint128_t var6938;	// u128
	uint128_t var6939;	// u128
	uint128_t var6940;	// u128
	uint128_t var6941;	// u128
	TUP_2_ZRTCd_ZRTCw var6942;	// (i16, bool, )
	TUP_2_ZRTCd_ZRTCw var6943;	// (i16, bool, )
	uint32_t var6944;	// u32
	uint16_t var6945;	// u16
	uint16_t var6946;	// u16
	uint16_t var6947;	// u16
	uint16_t var6948;	// u16
	uint16_t var6949;	// u16
	uint16_t var6950;	// u16
	uint16_t var6951;	// u16
	uint32_t var6952;	// u32
	uint32_t var6953;	// u32
	uint32_t var6954;	// u32
	uint32_t var6955;	// u32
	uint32_t var6956;	// u32
	uint32_t var6957;	// u32
	int8_t var6958;	// i8
	uint32_t var6959;	// u32
	int8_t var6960;	// i8
	int8_t var6961;	// i8
	TUP_2_ZRTCb_ZRTCw var6962;	// (i8, bool, )
	TUP_2_ZRTCb_ZRTCw var6963;	// (i8, bool, )
	TUP_2_ZRTCb_ZRTCw var6964;	// (i8, bool, )
	int8_t var6965;	// i8
	int8_t var6966;	// i8
	int8_t var6967;	// i8
	int8_t var6968;	// i8
	uint32_t var6969;	// u32
	uint8_t var6970;	// u8
	uint8_t var6971;	// u8
	int8_t var6972;	// i8
	int8_t var6973;	// i8
	uint32_t var6974;	// u32
	int8_t var6975;	// i8
	uint32_t var6976;	// u32
	uint32_t var6977;	// u32
	int8_t var6978;	// i8
	int8_t var6979;	// i8
	uint32_t var6980;	// u32
	TUP_2_ZRTCv_ZRTCw var6981;	// (isize, bool, )
	TUP_2_ZRTCv_ZRTCw var6982;	// (isize, bool, )
	uint32_t var6983;	// u32
	uint32_t var6984;	// u32
	intptr_t var6985;	// isize
	uint32_t var6986;	// u32
	uint16_t var6987;	// u16
	uint16_t var6988;	// u16
	uint16_t var6989;	// u16
	int32_t var6990;	// i32
	int128_t var6991;	// i128
	uint32_t var6992;	// u32
	uint32_t var6993;	// u32
	uint32_t var6994;	// u32
	uint32_t var6995;	// u32
	uint32_t var6996;	// u32
	uint8_t var6997;	// u8
	uint8_t var6998;	// u8
	uint32_t var6999;	// u32
	intptr_t var7000;	// isize
	TUP_2_ZRTCf_ZRTCw var7001;	// (i32, bool, )
	TUP_2_ZRTCv_ZRTCw var7002;	// (isize, bool, )
	intptr_t var7003;	// isize
	intptr_t var7004;	// isize
	intptr_t var7005;	// isize
	intptr_t var7006;	// isize
	uint32_t var7007;	// u32
	int8_t var7008;	// i8
	uint32_t var7009;	// u32
	TUP_2_ZRTCb_ZRTCw var7010;	// (i8, bool, )
	int8_t var7011;	// i8
	int8_t var7012;	// i8
	int8_t var7013;	// i8
	int8_t var7014;	// i8
	TUP_2_ZRTCb_ZRTCw var7015;	// (i8, bool, )
	int8_t var7016;	// i8
	int8_t var7017;	// i8
	uint64_t var7018;	// u64
	uint64_t var7019;	// u64
	uint64_t var7020;	// u64
	uint64_t var7021;	// u64
	uint64_t var7022;	// u64
	uintptr_t var7023;	// usize
	uintptr_t var7024;	// usize
	uint16_t var7025;	// u16
	uint32_t var7026;	// u32
	uint32_t var7027;	// u32
	uint32_t var7028;	// u32
	int32_t var7029;	// i32
	int32_t var7030;	// i32
	uint32_t var7031;	// u32
	int8_t var7032;	// i8
	int8_t var7033;	// i8
	int8_t var7034;	// i8
	int8_t var7035;	// i8
	int8_t var7036;	// i8
	int8_t var7037;	// i8
	int8_t var7038;	// i8
	int16_t var7039;	// i16
	int16_t var7040;	// i16
	uint16_t var7041;	// u16
	TUP_2_ZRTCh_ZRTCw var7042;	// (i64, bool, )
	int64_t var7043;	// i64
	uint32_t var7044;	// u32
	uint32_t var7045;	// u32
	uint32_t var7046;	// u32
	int16_t var7047;	// i16
	int16_t var7048;	// i16
	int16_t var7049;	// i16
	TUP_2_ZRTCb_ZRTCw var7050;	// (i8, bool, )
	int8_t var7051;	// i8
	TUP_2_ZRTCb_ZRTCw var7052;	// (i8, bool, )
	int8_t var7053;	// i8
	uint32_t var7054;	// u32
	int8_t var7055;	// i8
	TUP_2_ZRTCf_ZRTCw var7056;	// (i32, bool, )
	uint32_t var7057;	// u32
	uint32_t var7058;	// u32
	int128_t var7059;	// i128
	uint32_t var7060;	// u32
	uint32_t var7061;	// u32
	uint8_t var7062;	// u8
	uint8_t var7063;	// u8
	uint32_t var7064;	// u32
	uint8_t var7065;	// u8
	uint8_t var7066;	// u8
	uintptr_t var7067;	// usize
	uintptr_t var7068;	// usize
	TUP_2_ZRTCj_ZRTCw var7069;	// (i128, bool, )
	uint16_t var7070;	// u16
	uint32_t var7071;	// u32
	uint16_t var7072;	// u16
	uint16_t var7073;	// u16
	uint16_t var7074;	// u16
	uint16_t var7075;	// u16
	uint16_t var7076;	// u16
	uint16_t var7077;	// u16
	uint16_t var7078;	// u16
	uint32_t var7079;	// u32
	uint16_t var7080;	// u16
	uint32_t var7081;	// u32
	uint16_t var7082;	// u16
	uint16_t var7083;	// u16
	uint16_t var7084;	// u16
	uint16_t var7085;	// u16
	uint32_t var7086;	// u32
	uint8_t var7087;	// u8
	intptr_t var7088;	// isize
	intptr_t var7089;	// isize
	intptr_t var7090;	// isize
	uint8_t var7091;	// u8
	uint32_t var7092;	// u32
	uint32_t var7093;	// u32
	uint32_t var7094;	// u32
	uint32_t var7095;	// u32
	uint32_t var7096;	// u32
	uint32_t var7097;	// u32
	uint8_t var7098;	// u8
	uint32_t var7099;	// u32
	uint16_t var7100;	// u16
	uint16_t var7101;	// u16
	uint32_t var7102;	// u32
	int64_t var7103;	// i64
	TUP_2_ZRTCh_ZRTCw var7104;	// (i64, bool, )
	int64_t var7105;	// i64
	int64_t var7106;	// i64
	TUP_2_ZRTCh_ZRTCw var7107;	// (i64, bool, )
	int64_t var7108;	// i64
	int64_t var7109;	// i64
	TUP_2_ZRTCh_ZRTCw var7110;	// (i64, bool, )
	int64_t var7111;	// i64
	int64_t var7112;	// i64
	uint32_t var7113;	// u32
	uint32_t var7114;	// u32
	uint32_t var7115;	// u32
	uint32_t var7116;	// u32
	uint32_t var7117;	// u32
	uint32_t var7118;	// u32
	uint32_t var7119;	// u32
	int32_t var7120;	// i32
	int128_t var7121;	// i128
	uint32_t var7122;	// u32
	int128_t var7123;	// i128
	uint32_t var7124;	// u32
	TUP_2_ZRTCj_ZRTCw var7125;	// (i128, bool, )
	int128_t var7126;	// i128
	int128_t var7127;	// i128
	uint16_t var7128;	// u16
	uint16_t var7129;	// u16
	int8_t var7130;	// i8
	int8_t var7131;	// i8
	TUP_2_ZRTCb_ZRTCw var7132;	// (i8, bool, )
	int8_t var7133;	// i8
	uint32_t var7134;	// u32
	uint32_t var7135;	// u32
	uint32_t var7136;	// u32
	uint32_t var7137;	// u32
	uint32_t var7138;	// u32
	uint32_t var7139;	// u32
	uint32_t var7140;	// u32
	uint8_t var7141;	// u8
	uint8_t var7142;	// u8
	uint8_t var7143;	// u8
	uint32_t var7144;	// u32
	int16_t var7145;	// i16
	int16_t var7146;	// i16
	uint32_t var7147;	// u32
	int16_t var7148;	// i16
	int16_t var7149;	// i16
	uint32_t var7150;	// u32
	uint16_t var7151;	// u16
	uint32_t var7152;	// u32
	uint32_t var7153;	// u32
	uint32_t var7154;	// u32
	uint128_t var7155;	// u128
	uint128_t var7156;	// u128
	uint32_t var7157;	// u32
	uint128_t var7158;	// u128
	uint32_t var7159;	// u32
	uint128_t var7160;	// u128
	uint32_t var7161;	// u32
	uint128_t var7162;	// u128
	uint128_t var7163;	// u128
	uint32_t var7164;	// u32
	uint32_t var7165;	// u32
	int32_t var7166;	// i32
	int32_t var7167;	// i32
	uint32_t var7168;	// u32
	uint32_t var7169;	// u32
	uint32_t var7170;	// u32
	uint32_t var7171;	// u32
	uint32_t var7172;	// u32
	uint32_t var7173;	// u32
	uintptr_t var7174;	// usize
	uint32_t var7175;	// u32
	uint32_t var7176;	// u32
	uint32_t var7177;	// u32
	uint32_t var7178;	// u32
	uint32_t var7179;	// u32
	uint32_t var7180;	// u32
	uint32_t var7181;	// u32
	uint32_t var7182;	// u32
	uint32_t var7183;	// u32
	uint32_t var7184;	// u32
	uint32_t var7185;	// u32
	uint128_t var7186;	// u128
	uint32_t var7187;	// u32
	uint32_t var7188;	// u32
	uint32_t var7189;	// u32
	uint32_t var7190;	// u32
	uint32_t var7191;	// u32
	uint32_t var7192;	// u32
	uint128_t var7193;	// u128
	uint128_t var7194;	// u128
	uint32_t var7195;	// u32
	uint32_t var7196;	// u32
	uint128_t var7197;	// u128
	uint32_t var7198;	// u32
	uint128_t var7199;	// u128
	uint128_t var7200;	// u128
	uint32_t var7201;	// u32
	uint32_t var7202;	// u32
	uint32_t var7203;	// u32
	int32_t var7204;	// i32
	int32_t var7205;	// i32
	uint32_t var7206;	// u32
	uint32_t var7207;	// u32
	uint8_t var7208;	// u8
	uint8_t var7209;	// u8
	uint8_t var7210;	// u8
	uint8_t var7211;	// u8
	uint8_t var7212;	// u8
	uint8_t var7213;	// u8
	uint8_t var7214;	// u8
	uint32_t var7215;	// u32
	int8_t var7216;	// i8
	int8_t var7217;	// i8
	uint32_t var7218;	// u32
	uintptr_t var7219;	// usize
	uintptr_t var7220;	// usize
	uint32_t var7221;	// u32
	uint32_t var7222;	// u32
	uintptr_t var7223;	// usize
	uintptr_t var7224;	// usize
	uint32_t var7225;	// u32
	uint32_t var7226;	// u32
	uintptr_t var7227;	// usize
	uintptr_t var7228;	// usize
	uintptr_t var7229;	// usize
	uintptr_t var7230;	// usize
	TUP_2_ZRTCv_ZRTCw var7231;	// (isize, bool, )
	intptr_t var7232;	// isize
	intptr_t var7233;	// isize
	intptr_t var7234;	// isize
	uint32_t var7235;	// u32
	intptr_t var7236;	// isize
	intptr_t var7237;	// isize
	uint32_t var7238;	// u32
	TUP_2_ZRTCd_ZRTCw var7239;	// (i16, bool, )
	int16_t var7240;	// i16
	int16_t var7241;	// i16
	TUP_2_ZRTCd_ZRTCw var7242;	// (i16, bool, )
	int16_t var7243;	// i16
	int16_t var7244;	// i16
	uint64_t var7245;	// u64
	uint64_t var7246;	// u64
	uint64_t var7247;	// u64
	uint64_t var7248;	// u64
	uint64_t var7249;	// u64
	uint32_t var7250;	// u32
	uint16_t var7251;	// u16
	uintptr_t var7252;	// usize
	uintptr_t var7253;	// usize
	uintptr_t var7254;	// usize
	uintptr_t var7255;	// usize
	uint32_t var7256;	// u32
	uintptr_t var7257;	// usize
	uintptr_t var7258;	// usize
	uint32_t var7259;	// u32
	uint32_t var7260;	// u32
	uint8_t var7261;	// u8
	uint8_t var7262;	// u8
	uint32_t var7263;	// u32
	uint32_t var7264;	// u32
	uint8_t var7265;	// u8
	uint8_t var7266;	// u8
	uint32_t var7267;	// u32
	uint8_t var7268;	// u8
	uint8_t var7269;	// u8
	uint8_t var7270;	// u8
	uint32_t var7271;	// u32
	uint32_t var7272;	// u32
	uint32_t var7273;	// u32
	int8_t var7274;	// i8
	uint32_t var7275;	// u32
	int32_t var7276;	// i32
	uint8_t var7277;	// u8
	uint8_t var7278;	// u8
	TUP_2_ZRTCf_ZRTCw var7279;	// (i32, bool, )
	int32_t var7280;	// i32
	TUP_2_ZRTCf_ZRTCw var7281;	// (i32, bool, )
	int32_t var7282;	// i32
	uint32_t var7283;	// u32
	int32_t var7284;	// i32
	uint32_t var7285;	// u32
	int32_t var7286;	// i32
	int32_t var7287;	// i32
	TUP_2_ZRTCf_ZRTCw var7288;	// (i32, bool, )
	int32_t var7289;	// i32
	uint32_t var7290;	// u32
	int32_t var7291;	// i32
	int32_t var7292;	// i32
	uint32_t var7293;	// u32
	int32_t var7294;	// i32
	int32_t var7295;	// i32
	uint32_t var7296;	// u32
	TUP_2_ZRTCf_ZRTCw var7297;	// (i32, bool, )
	int32_t var7298;	// i32
	TUP_2_ZRTCf_ZRTCw var7299;	// (i32, bool, )
	int32_t var7300;	// i32
	int32_t var7301;	// i32
	uint32_t var7302;	// u32
	int16_t var7303;	// i16
	uint32_t var7304;	// u32
	int32_t var7305;	// i32
	uint32_t var7306;	// u32
	int32_t var7307;	// i32
	uint16_t var7308;	// u16
	uint128_t var7309;	// u128
	uint128_t var7310;	// u128
	uint128_t var7311;	// u128
	uint128_t var7312;	// u128
	uint128_t var7313;	// u128
	uint128_t var7314;	// u128
	uint128_t var7315;	// u128
	uint128_t var7316;	// u128
	uint128_t var7317;	// u128
	uint128_t var7318;	// u128
	uint128_t var7319;	// u128
	uint128_t var7320;	// u128
	uint128_t var7321;	// u128
	uint128_t var7322;	// u128
	uint128_t var7323;	// u128
	uint128_t var7324;	// u128
	uint128_t var7325;	// u128
	uint128_t var7326;	// u128
	uint128_t var7327;	// u128
	uint128_t var7328;	// u128
	uint128_t var7329;	// u128
	uint128_t var7330;	// u128
	uint128_t var7331;	// u128
	uint128_t var7332;	// u128
	uint128_t var7333;	// u128
	uint128_t var7334;	// u128
	uint128_t var7335;	// u128
	uint128_t var7336;	// u128
	uint128_t var7337;	// u128
	uint128_t var7338;	// u128
	uint128_t var7339;	// u128
	uint128_t var7340;	// u128
	uint128_t var7341;	// u128
	uint128_t var7342;	// u128
	uint128_t var7343;	// u128
	uint128_t var7344;	// u128
	uint128_t var7345;	// u128
	uint128_t var7346;	// u128
	uint128_t var7347;	// u128
	uint128_t var7348;	// u128
	uint128_t var7349;	// u128
	uint128_t var7350;	// u128
	uint128_t var7351;	// u128
	uint128_t var7352;	// u128
	uint128_t var7353;	// u128
	uint128_t var7354;	// u128
	uint128_t var7355;	// u128
	uint128_t var7356;	// u128
	uint128_t var7357;	// u128
	uint128_t var7358;	// u128
	uint128_t var7359;	// u128
	uint128_t var7360;	// u128
	uint128_t var7361;	// u128
	uint128_t var7362;	// u128
	uint128_t var7363;	// u128
	uint128_t var7364;	// u128
	uint128_t var7365;	// u128
	uint128_t var7366;	// u128
	uint128_t var7367;	// u128
	uint128_t var7368;	// u128
	uint128_t var7369;	// u128
	uint128_t var7370;	// u128
	uint128_t var7371;	// u128
	uint128_t var7372;	// u128
	uint128_t var7373;	// u128
	uint128_t var7374;	// u128
	uint128_t var7375;	// u128
	uint128_t var7376;	// u128
	uint128_t var7377;	// u128
	uint128_t var7378;	// u128
	uint128_t var7379;	// u128
	uint128_t var7380;	// u128
	uint128_t var7381;	// u128
	uint128_t var7382;	// u128
	uint128_t var7383;	// u128
	uint128_t var7384;	// u128
	struct s_ZRG2cE9core0_0_03fmt9Arguments0g var7385;	// ::"core-0_0_0"::fmt::Arguments/*S*/
	struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g var7386;	// ::"core-0_0_0"::option::Option<&[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>/*E*/
	SLICE_PTR var7387;	// &[&str]
	SLICE_PTR var7388;	// &[::"core-0_0_0"::fmt::ArgumentV1/*S*/]
	var0 = make128_raw(0ull, 0ull);	// _0 = Constant(0x0 u128)
	var547 = 545201568421088164ll >> 0ll;
	// ^ Call( _547 = "unchecked_shr"::<isize,>( +545201568421088164 isize, +0 isize, ), bb1, bb399)
	var3835 = (int32_t )var547;	// _3835 = Cast(_547 as i32)
	__builtin_sub_overflow(var3835, 1238774079, &var548);
	// ^ Call( _548 = "overflowing_sub"::<i32,>( _3835, -3056193217 i32, ), bb2, bb399)
	var550 = 1456770368;	// _550 = Constant(+1456770368 i32)
	__builtin_mul_overflow(0x7669, 0xa04e, &var551);
	// ^ Call( _551 = "overflowing_mul"::<u16,>( 0x7669 u16, 0xa04e u16, ), bb3, bb399)
	var552 = (int32_t )var551;	// _552 = Cast(_551 as i32)
	var549 = var550 / var552;	// _549 = BinOp(_550 DIV _552)
	var553 = -var549;	// _553 = UniOp(_549 NEG)
	var1 = var548 / var553;	// _1 = BinOp(_548 DIV _553)
	__builtin_mul_overflow(-114, -38, &var554);
	// ^ Call( _554 = "overflowing_mul"::<i8,>( -114 i8, -38 i8, ), bb4, bb399)
	var3836 = var554 & 48;	// _3836 = BinOp(_554 BIT_AND +48 i8)
	var555 = var3836 >> 2;
	// ^ Call( _555 = "unchecked_shr"::<i8,>( _3836, +2 i8, ), bb5, bb399)
	var3837 = 0x745f;	// _3837 = Constant(0x745f u16)
	__builtin_add_overflow(0xe19c, 0xceff, &var556);
	// ^ Call( _556 = "overflowing_add"::<u16,>( 0xe19c u16, 0xceff u16, ), bb6, bb399)
	var557 = 0xa486 << 0x1;
	// ^ Call( _557 = "unchecked_shl"::<u16,>( 0xa486 u16, 0x1 u16, ), bb7, bb399)
	var3838 = var556 | var557;	// _3838 = BinOp(_556 BIT_OR _557)
	__builtin_mul_overflow(var3837, var3838, &var558);
	// ^ Call( _558 = "overflowing_mul"::<u16,>( _3837, _3838, ), bb8, bb399)
	__builtin_mul_overflow(var1, var1, &var559);
	// ^ Call( _559 = "overflowing_mul"::<i32,>( _1, _1, ), bb9, bb399)
	var560 = -97 << 4;
	// ^ Call( _560 = "unchecked_shl"::<i8,>( -97 i8, +4 i8, ), bb10, bb399)
	var3840 = (int16_t )var560;	// _3840 = Cast(_560 as i16)
	var3839 = ZRICd15overflowing_div0g( var3840, -1 );
	// ^ Call( _3839 = <i16 /*- */>::overflowing_div( _3840, -1 i16, ), bb11, bb399)
	var3843 = 0xd868e434;	// _3843 = Constant(0xd868e434 u32)
	var3841 = 0x50;	// _3841 = Constant(0x50 u8)
	var3842 = 0xe2 << 0x3;
	// ^ Call( _3842 = "unchecked_shl"::<u8,>( 0xe2 u8, 0x3 u8, ), bb12, bb399)
	__builtin_sub_overflow(var3841, var3842, &var561);
	// ^ Call( _561 = "overflowing_sub"::<u8,>( _3841, _3842, ), bb13, bb399)
	var3844 = (uint32_t )var561;	// _3844 = Cast(_561 as u32)
	__builtin_mul_overflow(var3843, var3844, &var3847);
	// ^ Call( _3847 = "overflowing_mul"::<u32,>( _3843, _3844, ), bb14, bb399)
	var3845 = var3847 & 0xf;	// _3845 = BinOp(_3847 BIT_AND 0xf u32)
	var3846 = (int16_t )var3845;	// _3846 = Cast(_3845 as i16)
	var562 = var3839._0 << var3846;
	// ^ Call( _562 = "unchecked_shl"::<i16,>( _3839.0, _3846, ), bb15, bb399)
	var564 = 0x8a016f4b;	// _564 = Constant(0x8a016f4b u32)
	var565 = 0xe47c1a40 >> 0x2;
	// ^ Call( _565 = "unchecked_shr"::<u32,>( 0xe47c1a40 u32, 0x2 u32, ), bb16, bb399)
	var3848 = var564 + var565;	// _3848 = BinOp(_564 ADD _565)
	var566 = 0x55e37905 / var3848;	// _566 = BinOp(0x55e37905 u32 DIV _3848)
	var563 = var566 / 0xc810c510;	// _563 = BinOp(_566 DIV 0xc810c510 u32)
	var568 = (int16_t )var1;	// _568 = Cast(_1 as i16)
	var3849 = (uint32_t )var568;	// _3849 = Cast(_568 as u32)
	var569 = var3849 % 0x91c7;	// _569 = BinOp(_3849 MOD 0x91c7 u32)
	var3850 = (uint32_t )var1;	// _3850 = Cast(_1 as u32)
	__builtin_sub_overflow(0x474fb536, var3850, &var3851);
	// ^ Call( _3851 = "overflowing_sub"::<u32,>( 0x474fb536 u32, _3850, ), bb17, bb399)
	__builtin_sub_overflow(0xc, 0xa0, &var570);
	// ^ Call( _570 = "overflowing_sub"::<u8,>( 0xc u8, 0xa0 u8, ), bb18, bb399)
	var3852 = (uint32_t )var570;	// _3852 = Cast(_570 as u32)
	var571 = var3851 % var3852;	// _571 = BinOp(_3851 MOD _3852)
	var567 = var569 + var571;	// _567 = BinOp(_569 ADD _571)
	var2 = var563 & var567;	// _2 = BinOp(_563 BIT_AND _567)
	__builtin_sub_overflow(0x205d3bcfb9400900ull, 0xb6e86ccfe199e231ull, &var3853);
	// ^ Call( _3853 = "overflowing_sub"::<usize,>( 0x205d3bcfb9400900 usize, 0xb6e86ccfe199e231 usize, ), bb19, bb399)
	__builtin_add_overflow(0x6687, 0x5055, &var572);
	// ^ Call( _572 = "overflowing_add"::<u16,>( 0x6687 u16, 0x5055 u16, ), bb20, bb399)
	var3854 = 0x9c5e ^ var572;	// _3854 = BinOp(0x9c5e u16 BIT_XOR _572)
	__builtin_mul_overflow(0x3166, var3854, &var3855);
	// ^ Call( _3855 = "overflowing_mul"::<u16,>( 0x3166 u16, _3854, ), bb21, bb399)
	__builtin_add_overflow(var3855, 0xfe80, &var573);
	// ^ Call( _573 = "overflowing_add"::<u16,>( _3855, 0xfe80 u16, ), bb22, bb399)
	var3 = make128_raw(8314132606424571477ull, 2491874136609498654ull);	// _3 = Constant(0x7361bb8e2d6dde552294ea532197a61e u128)
	__builtin_add_overflow(0x80b4, 0x9b20, &var574);
	// ^ Call( _574 = "overflowing_add"::<u16,>( 0x80b4 u16, 0x9b20 u16, ), bb23, bb399)
	var575 = var2 * 0x5da27a70;	// _575 = BinOp(_2 MUL 0x5da27a70 u32)
	var3856 = var2 - var575;	// _3856 = BinOp(_2 SUB _575)
	var3857 = 0x1880a5df << 0x7;
	// ^ Call( _3857 = "unchecked_shl"::<u32,>( 0x1880a5df u32, 0x7 u32, ), bb24, bb399)
	var3860 = var3856 / var3857;	// _3860 = BinOp(_3856 DIV _3857)
	var3858 = var3860 & 0xf;	// _3858 = BinOp(_3860 BIT_AND 0xf u32)
	var3859 = (uint16_t )var3858;	// _3859 = Cast(_3858 as u16)
	var576 = 0x592a >> var3859;
	// ^ Call( _576 = "unchecked_shr"::<u16,>( 0x592a u16, _3859, ), bb25, bb399)
	var3861 = ZRICh15overflowing_rem0g( -5714630613921411952ll, 1694219704167259091ll );
	// ^ Call( _3861 = <i64 /*- */>::overflowing_rem( -5714630613921411952 i64, +1694219704167259091 i64, ), bb26, bb399)
	var578 = -10;	// _578 = Constant(-10 i8)
	var3862 = ZRICb15overflowing_rem0g( -76, -30 );
	// ^ Call( _3862 = <i8 /*- */>::overflowing_rem( -76 i8, -30 i8, ), bb27, bb399)
	var577 = var578 | var3862._0;	// _577 = BinOp(_578 BIT_OR _3862.0)
	var579 = -var577;	// _579 = UniOp(_577 NEG)
	var580 = -var579;	// _580 = UniOp(_579 NEG)
	var4 = -var580;	// _4 = UniOp(_580 NEG)
	__builtin_add_overflow(0xb24b1495, var2, &var3865);
	// ^ Call( _3865 = "overflowing_add"::<u32,>( 0xb24b1495 u32, _2, ), bb28, bb399)
	var3863 = var3865 & 0xf;	// _3863 = BinOp(_3865 BIT_AND 0xf u32)
	var3864 = (uint16_t )var3863;	// _3864 = Cast(_3863 as u16)
	var581 = 0x1653 >> var3864;
	// ^ Call( _581 = "unchecked_shr"::<u16,>( 0x1653 u16, _3864, ), bb29, bb399)
	var582 = -1495423857 << 29;
	// ^ Call( _582 = "unchecked_shl"::<i32,>( -1495423857 i32, +29 i32, ), bb30, bb399)
	var3868 = var582 + -613145279;	// _3868 = BinOp(_582 ADD -613145279 i32)
	var3866 = var1 | 1128487120;	// _3866 = BinOp(_1 BIT_OR +1128487120 i32)
	__builtin_sub_overflow(var3866, -703998120, &var3869);
	// ^ Call( _3869 = "overflowing_sub"::<i32,>( _3866, -703998120 i32, ), bb31, bb399)
	var3867 = ZRICf15overflowing_div0g( var3868, var3869 );
	// ^ Call( _3867 = <i32 /*- */>::overflowing_div( _3868, _3869, ), bb32, bb399)
	var583 = -var3867._0;	// _583 = UniOp(_3867.0 NEG)
	var5 = -var583;	// _5 = UniOp(_583 NEG)
	var6 = 0xf0462126;	// _6 = Constant(0xf0462126 u32)
	var584 = 0x81 << 0x0;
	// ^ Call( _584 = "unchecked_shl"::<u8,>( 0x81 u8, 0x0 u8, ), bb33, bb399)
	var3870 = (uint32_t )var584;	// _3870 = Cast(_584 as u32)
	var585 = var3870 << 0x0;
	// ^ Call( _585 = "unchecked_shl"::<u32,>( _3870, 0x0 u32, ), bb34, bb399)
	__builtin_sub_overflow(var2, 0xfb12ab0b, &var3871);
	// ^ Call( _3871 = "overflowing_sub"::<u32,>( _2, 0xfb12ab0b u32, ), bb35, bb399)
	var586 = var2 >> 0x0;
	// ^ Call( _586 = "unchecked_shr"::<u32,>( _2, 0x0 u32, ), bb36, bb399)
	var3874 = var586 & 0x4d1fd938;	// _3874 = BinOp(_586 BIT_AND 0x4d1fd938 u32)
	var3872 = var6 / 0x2da8aaa8;	// _3872 = BinOp(_6 DIV 0x2da8aaa8 u32)
	var3873 = var2 / var6;	// _3873 = BinOp(_2 DIV _6)
	__builtin_sub_overflow(var3872, var3873, &var3875);
	// ^ Call( _3875 = "overflowing_sub"::<u32,>( _3872, _3873, ), bb37, bb399)
	__builtin_sub_overflow(var3874, var3875, &var3876);
	// ^ Call( _3876 = "overflowing_sub"::<u32,>( _3874, _3875, ), bb38, bb399)
	__builtin_add_overflow(var6, 0x1, &var587);
	// ^ Call( _587 = "overflowing_add"::<u32,>( _6, 0x1 u32, ), bb39, bb399)
	var3877 = ZRICf15overflowing_div0g( 1716294149, -578083850 );
	// ^ Call( _3877 = <i32 /*- */>::overflowing_div( +1716294149 i32, -578083850 i32, ), bb40, bb399)
	__builtin_add_overflow(var5, 1718994833, &var588);
	// ^ Call( _588 = "overflowing_add"::<i32,>( _5, +1718994833 i32, ), bb41, bb399)
	var589 = 0xd5;	// _589 = Constant(0xd5 u8)
	var590 = 0xab >> 0x6;
	// ^ Call( _590 = "unchecked_shr"::<u8,>( 0xab u8, 0x6 u8, ), bb42, bb399)
	var3884 = var589 | var590;	// _3884 = BinOp(_589 BIT_OR _590)
	var3878 = var6 & 0x1f;	// _3878 = BinOp(_6 BIT_AND 0x1f u32)
	var3880 = 0xaa019a47 << var3878;
	// ^ Call( _3880 = "unchecked_shl"::<u32,>( 0xaa019a47 u32, _3878, ), bb43, bb399)
	var3879 = var2 & 0x1f;	// _3879 = BinOp(_2 BIT_AND 0x1f u32)
	var3881 = 0x7a821cd1 >> var3879;
	// ^ Call( _3881 = "unchecked_shr"::<u32,>( 0x7a821cd1 u32, _3879, ), bb44, bb399)
	var3885 = var3880 % var3881;	// _3885 = BinOp(_3880 MOD _3881)
	var3882 = var3885 & 0x7;	// _3882 = BinOp(_3885 BIT_AND 0x7 u32)
	var3883 = (uint8_t )var3882;	// _3883 = Cast(_3882 as u8)
	var591 = var3884 << var3883;
	// ^ Call( _591 = "unchecked_shl"::<u8,>( _3884, _3883, ), bb45, bb399)
	var3886 = var591 / 0xf3;	// _3886 = BinOp(_591 DIV 0xf3 u8)
	__builtin_sub_overflow(var3886, 0xf8, &var592);
	// ^ Call( _592 = "overflowing_sub"::<u8,>( _3886, 0xf8 u8, ), bb46, bb399)
	var3892 = 0x6e5b;	// _3892 = Constant(0x6e5b u16)
	var3890 = 0xb32f;	// _3890 = Constant(0xb32f u16)
	var3887 = 0xe5d17ddf << 0xb;
	// ^ Call( _3887 = "unchecked_shl"::<u32,>( 0xe5d17ddf u32, 0xb u32, ), bb47, bb399)
	var3891 = var3887 / var6;	// _3891 = BinOp(_3887 DIV _6)
	var3888 = var3891 & 0xf;	// _3888 = BinOp(_3891 BIT_AND 0xf u32)
	var3889 = (uint16_t )var3888;	// _3889 = Cast(_3888 as u16)
	var3893 = var3890 << var3889;
	// ^ Call( _3893 = "unchecked_shl"::<u16,>( _3890, _3889, ), bb48, bb399)
	__builtin_add_overflow(var3892, var3893, &var593);
	// ^ Call( _593 = "overflowing_add"::<u16,>( _3892, _3893, ), bb49, bb399)
	var3895 = 0;	// _3895 = Constant(+0 i16)
	__builtin_mul_overflow(var4, 24, &var594);
	// ^ Call( _594 = "overflowing_mul"::<i8,>( _4, +24 i8, ), bb50, bb399)
	var3896 = (int16_t )var594;	// _3896 = Cast(_594 as i16)
	var3894 = ZRICd15overflowing_div0g( var3895, var3896 );
	// ^ Call( _3894 = <i16 /*- */>::overflowing_div( _3895, _3896, ), bb51, bb399)
	__builtin_sub_overflow(0x18b22cc8883d518cull, 0xe9ad006c17ede3adull, &var3900);
	// ^ Call( _3900 = "overflowing_sub"::<u64,>( 0x18b22cc8883d518c u64, 0xe9ad006c17ede3ad u64, ), bb52, bb399)
	var3897 = var2 & 0x3f;	// _3897 = BinOp(_2 BIT_AND 0x3f u32)
	var3898 = (uint64_t )var3897;	// _3898 = Cast(_3897 as u64)
	var3899 = 0xac310b4d115b1413ull >> var3898;
	// ^ Call( _3899 = "unchecked_shr"::<u64,>( 0xac310b4d115b1413 u64, _3898, ), bb53, bb399)
	var3901 = var3899 % 0x7b63bd2434bf6bc2ull;	// _3901 = BinOp(_3899 MOD 0x7b63bd2434bf6bc2 u64)
	__builtin_mul_overflow(var3900, var3901, &var3902);
	// ^ Call( _3902 = "overflowing_mul"::<u64,>( _3900, _3901, ), bb54, bb399)
	__builtin_mul_overflow(var3902, 0xd683490067898726ull, &var595);
	// ^ Call( _595 = "overflowing_mul"::<u64,>( _3902, 0xd683490067898726 u64, ), bb55, bb399)
	var3909 = 11110;	// _3909 = Constant(+11110 i16)
	var3903 = (uint32_t )var4;	// _3903 = Cast(_4 as u32)
	__builtin_mul_overflow(0xdd735e4a, var3903, &var3904);
	// ^ Call( _3904 = "overflowing_mul"::<u32,>( 0xdd735e4a u32, _3903, ), bb56, bb399)
	__builtin_sub_overflow(var2, 0x3d1f2581, &var596);
	// ^ Call( _596 = "overflowing_sub"::<u32,>( _2, 0x3d1f2581 u32, ), bb57, bb399)
	var3905 = var596 - 0x415;	// _3905 = BinOp(_596 SUB 0x415 u32)
	__builtin_sub_overflow(var3904, var3905, &var597);
	// ^ Call( _597 = "overflowing_sub"::<u32,>( _3904, _3905, ), bb58, bb399)
	__builtin_sub_overflow(0xc9e1df40, 0xa2d16faa, &var598);
	// ^ Call( _598 = "overflowing_sub"::<u32,>( 0xc9e1df40 u32, 0xa2d16faa u32, ), bb59, bb399)
	var3906 = var598 * var2;	// _3906 = BinOp(_598 MUL _2)
	var599 = var3906 % var6;	// _599 = BinOp(_3906 MOD _6)
	var3910 = var597 & var599;	// _3910 = BinOp(_597 BIT_AND _599)
	var3907 = var3910 & 0xf;	// _3907 = BinOp(_3910 BIT_AND 0xf u32)
	var3908 = (int16_t )var3907;	// _3908 = Cast(_3907 as i16)
	var600 = var3909 >> var3908;
	// ^ Call( _600 = "unchecked_shr"::<i16,>( _3909, _3908, ), bb60, bb399)
	__builtin_mul_overflow(0xfab0f6c2, 0x3029941a, &var3911);
	// ^ Call( _3911 = "overflowing_mul"::<u32,>( 0xfab0f6c2 u32, 0x3029941a u32, ), bb61, bb399)
	var3912 = var3911 >> 0x1c;
	// ^ Call( _3912 = "unchecked_shr"::<u32,>( _3911, 0x1c u32, ), bb62, bb399)
	var602 = 0xf2ff7699 ^ var2;	// _602 = BinOp(0xf2ff7699 u32 BIT_XOR _2)
	var601 = var602 - 0x0;	// _601 = BinOp(_602 SUB 0x0 u32)
	var3913 = var601 - var6;	// _3913 = BinOp(_601 SUB _6)
	__builtin_sub_overflow(var3913, 0xc84676ce, &var3916);
	// ^ Call( _3916 = "overflowing_sub"::<u32,>( _3913, 0xc84676ce u32, ), bb63, bb399)
	var3914 = var3916 & 0x7;	// _3914 = BinOp(_3916 BIT_AND 0x7 u32)
	var3915 = (uint8_t )var3914;	// _3915 = Cast(_3914 as u8)
	var7 = 0x54 >> var3915;
	// ^ Call( _7 = "unchecked_shr"::<u8,>( 0x54 u8, _3915, ), bb64, bb399)
	var604 = var4 - var4;	// _604 = BinOp(_4 SUB _4)
	var603 = -117 * var604;	// _603 = BinOp(-117 i8 MUL _604)
	var3919 = -1 * var603;	// _3919 = BinOp(-1 i8 MUL _603)
	var3918 = -var4;	// _3918 = UniOp(_4 NEG)
	var3917 = ZRICb15overflowing_rem0g( var4, var3918 );
	// ^ Call( _3917 = <i8 /*- */>::overflowing_rem( _4, _3918, ), bb65, bb399)
	var3920 = -var3917._0;	// _3920 = UniOp(_3917.0 NEG)
	__builtin_mul_overflow(var3919, var3920, &var605);
	// ^ Call( _605 = "overflowing_mul"::<i8,>( _3919, _3920, ), bb66, bb399)
	var3922 = -var4;	// _3922 = UniOp(_4 NEG)
	var3921 = ZRICb15overflowing_div0g( var3922, 45 );
	// ^ Call( _3921 = <i8 /*- */>::overflowing_div( _3922, +63021 i8, ), bb67, bb399)
	var8 = var605 * var3921._0;	// _8 = BinOp(_605 MUL _3921.0)
	var9 = var3;	// _9 = Use(_3)
	var606 = (uint16_t )var6;	// _606 = Cast(_6 as u16)
	var3927 = var606 & 0x5c2b;	// _3927 = BinOp(_606 BIT_AND 0x5c2b u16)
	var3923 = 0xf02fb62d % var6;	// _3923 = BinOp(0xf02fb62d u32 MOD _6)
	var3924 = var2 ^ var2;	// _3924 = BinOp(_2 BIT_XOR _2)
	__builtin_add_overflow(var3923, var3924, &var3928);
	// ^ Call( _3928 = "overflowing_add"::<u32,>( _3923, _3924, ), bb68, bb399)
	var3925 = var3928 & 0xf;	// _3925 = BinOp(_3928 BIT_AND 0xf u32)
	var3926 = (uint16_t )var3925;	// _3926 = Cast(_3925 as u16)
	var3929 = var3927 << var3926;
	// ^ Call( _3929 = "unchecked_shl"::<u16,>( _3927, _3926, ), bb69, bb399)
	__builtin_sub_overflow(var3929, 0xe33d, &var607);
	// ^ Call( _607 = "overflowing_sub"::<u16,>( _3929, 0xe33d u16, ), bb70, bb399)
	var3930 = var6 & 0xf;	// _3930 = BinOp(_6 BIT_AND 0xf u32)
	var3931 = (uint16_t )var3930;	// _3931 = Cast(_3930 as u16)
	var608 = 0x1 << var3931;
	// ^ Call( _608 = "unchecked_shl"::<u16,>( 0x1 u16, _3931, ), bb71, bb399)
	__builtin_sub_overflow(0x2b35, 0x45c3, &var609);
	// ^ Call( _609 = "overflowing_sub"::<u16,>( 0x2b35 u16, 0x45c3 u16, ), bb72, bb399)
	var610 = -var5;	// _610 = UniOp(_5 NEG)
	var611 = -19324651 << 15;
	// ^ Call( _611 = "unchecked_shl"::<i32,>( -19324651 i32, +15 i32, ), bb73, bb399)
	var612 = -var611;	// _612 = UniOp(_611 NEG)
	var3932 = var610 | var612;	// _3932 = BinOp(_610 BIT_OR _612)
	var614 = var5 << 3;
	// ^ Call( _614 = "unchecked_shl"::<i32,>( _5, +3 i32, ), bb74, bb399)
	var615 = 1002584493 / var1;	// _615 = BinOp(+1002584493 i32 DIV _1)
	var613 = var614 - var615;	// _613 = BinOp(_614 SUB _615)
	var616 = var1 / var1;	// _616 = BinOp(_1 DIV _1)
	var617 = -var616;	// _617 = UniOp(_616 NEG)
	var3933 = var613 / var617;	// _3933 = BinOp(_613 DIV _617)
	__builtin_mul_overflow(var3932, var3933, &var618);
	// ^ Call( _618 = "overflowing_mul"::<i32,>( _3932, _3933, ), bb75, bb399)
	var619 = (uint64_t )var2;	// _619 = Cast(_2 as u64)
	var620 = (int32_t )var619;	// _620 = Cast(_619 as i32)
	var3934 = var5 ^ var620;	// _3934 = BinOp(_5 BIT_XOR _620)
	var621 = var3934 >> 21;
	// ^ Call( _621 = "unchecked_shr"::<i32,>( _3934, +21 i32, ), bb76, bb399)
	var622 = (uint16_t )var8;	// _622 = Cast(_8 as u16)
	var3937 = (int32_t )var622;	// _3937 = Cast(_622 as i32)
	var623 = 0x8aca955a;	// _623 = Constant(0x8aca955a u32)
	__builtin_mul_overflow(var2, var6, &var624);
	// ^ Call( _624 = "overflowing_mul"::<u32,>( _2, _6, ), bb77, bb399)
	var3938 = var623 * var624;	// _3938 = BinOp(_623 MUL _624)
	var3935 = var3938 & 0x1f;	// _3935 = BinOp(_3938 BIT_AND 0x1f u32)
	var3936 = (int32_t )var3935;	// _3936 = Cast(_3935 as i32)
	var3940 = var3937 << var3936;
	// ^ Call( _3940 = "unchecked_shl"::<i32,>( _3937, _3936, ), bb78, bb399)
	var3941 = -404629412 >> 22;
	// ^ Call( _3941 = "unchecked_shr"::<i32,>( -404629412 i32, +22 i32, ), bb79, bb399)
	var3939 = ZRICf15overflowing_rem0g( var3940, var3941 );
	// ^ Call( _3939 = <i32 /*- */>::overflowing_rem( _3940, _3941, ), bb80, bb399)
	var625 = 91748126 ^ var5;	// _625 = BinOp(+91748126 i32 BIT_XOR _5)
	var3943 = -var625;	// _3943 = UniOp(_625 NEG)
	var3942 = ZRICf15overflowing_rem0g( var3939._0, var3943 );
	// ^ Call( _3942 = <i32 /*- */>::overflowing_rem( _3939.0, _3943, ), bb81, bb399)
	var626 = 4;	// _626 = Constant(+4 i16)
	var3945 = 29871;	// _3945 = Constant(-7489382672454749009 i16)
	var627 = -1100 << 2;
	// ^ Call( _627 = "unchecked_shl"::<i16,>( -1100 i16, +2 i16, ), bb82, bb399)
	var3946 = var627 / -3017;	// _3946 = BinOp(_627 DIV -3017 i16)
	var3944 = ZRICd15overflowing_div0g( var3945, var3946 );
	// ^ Call( _3944 = <i16 /*- */>::overflowing_div( _3945, _3946, ), bb83, bb399)
	var3947 = var626 ^ var3944._0;	// _3947 = BinOp(_626 BIT_XOR _3944.0)
	__builtin_add_overflow(var3947, -25373, &var10);
	// ^ Call( _10 = "overflowing_add"::<i16,>( _3947, -25373 i16, ), bb84, bb399)
	var628 = var6 ^ 0xfb20b692;	// _628 = BinOp(_6 BIT_XOR 0xfb20b692 u32)
	var3950 = var628 + var2;	// _3950 = BinOp(_628 ADD _2)
	var3948 = var3950 & 0xf;	// _3948 = BinOp(_3950 BIT_AND 0xf u32)
	var3949 = (int16_t )var3948;	// _3949 = Cast(_3948 as i16)
	var629 = -24059 >> var3949;
	// ^ Call( _629 = "unchecked_shr"::<i16,>( -24059 i16, _3949, ), bb85, bb399)
	var3958 = -var629;	// _3958 = UniOp(_629 NEG)
	var3951 = var6 & 0xf;	// _3951 = BinOp(_6 BIT_AND 0xf u32)
	var3952 = (int16_t )var3951;	// _3952 = Cast(_3951 as i16)
	var3953 = -26877 >> var3952;
	// ^ Call( _3953 = "unchecked_shr"::<i16,>( -26877 i16, _3952, ), bb86, bb399)
	__builtin_mul_overflow(var10, -3778, &var3954);
	// ^ Call( _3954 = "overflowing_mul"::<i16,>( _10, -3778 i16, ), bb87, bb399)
	__builtin_add_overflow(var3953, var3954, &var3955);
	// ^ Call( _3955 = "overflowing_add"::<i16,>( _3953, _3954, ), bb88, bb399)
	__builtin_mul_overflow(var10, var10, &var630);
	// ^ Call( _630 = "overflowing_mul"::<i16,>( _10, _10, ), bb89, bb399)
	var3956 = var10 | var630;	// _3956 = BinOp(_10 BIT_OR _630)
	__builtin_sub_overflow(var3955, var3956, &var631);
	// ^ Call( _631 = "overflowing_sub"::<i16,>( _3955, _3956, ), bb90, bb399)
	var3959 = -var631;	// _3959 = UniOp(_631 NEG)
	var3957 = ZRICd15overflowing_div0g( var3958, var3959 );
	// ^ Call( _3957 = <i16 /*- */>::overflowing_div( _3958, _3959, ), bb91, bb399)
	var634 = var2 * var2;	// _634 = BinOp(_2 MUL _2)
	var633 = var634 & 0xc2df409f;	// _633 = BinOp(_634 BIT_AND 0xc2df409f u32)
	__builtin_add_overflow(0xfc87ee6f, 0x399e10d5, &var3960);
	// ^ Call( _3960 = "overflowing_add"::<u32,>( 0xfc87ee6f u32, 0x399e10d5 u32, ), bb92, bb399)
	var3961 = var2 << 0x10;
	// ^ Call( _3961 = "unchecked_shl"::<u32,>( _2, 0x10 u32, ), bb93, bb399)
	__builtin_add_overflow(var3960, var3961, &var635);
	// ^ Call( _635 = "overflowing_add"::<u32,>( _3960, _3961, ), bb94, bb399)
	var632 = var633 & var635;	// _632 = BinOp(_633 BIT_AND _635)
	var636 = (uint16_t )var632;	// _636 = Cast(_632 as u16)
	__builtin_sub_overflow(0xe5e, 0x3ff5, &var637);
	// ^ Call( _637 = "overflowing_sub"::<u16,>( 0xe5e u16, 0x3ff5 u16, ), bb95, bb399)
	__builtin_mul_overflow(0x15ee, 0xc40c, &var639);
	// ^ Call( _639 = "overflowing_mul"::<u16,>( 0x15ee u16, 0xc40c u16, ), bb96, bb399)
	__builtin_add_overflow(0xd1b0, 0x879, &var640);
	// ^ Call( _640 = "overflowing_add"::<u16,>( 0xd1b0 u16, 0x879 u16, ), bb97, bb399)
	var638 = var639 / var640;	// _638 = BinOp(_639 DIV _640)
	var3964 = var637 * var638;	// _3964 = BinOp(_637 MUL _638)
	var3965 = 0x95c600d2 >> 0xf;
	// ^ Call( _3965 = "unchecked_shr"::<u32,>( 0x95c600d2 u32, 0xf u32, ), bb98, bb399)
	var3962 = var3965 & 0xf;	// _3962 = BinOp(_3965 BIT_AND 0xf u32)
	var3963 = (uint16_t )var3962;	// _3963 = Cast(_3962 as u16)
	var641 = var3964 << var3963;
	// ^ Call( _641 = "unchecked_shl"::<u16,>( _3964, _3963, ), bb99, bb399)
	var11 = var636 ^ var641;	// _11 = BinOp(_636 BIT_XOR _641)
	var644 = -var4;	// _644 = UniOp(_4 NEG)
	var643 = -109 / var644;	// _643 = BinOp(-109 i8 DIV _644)
	var645 = -var643;	// _645 = UniOp(_643 NEG)
	var3967 = 62 / var4;	// _3967 = BinOp(+62 i8 DIV _4)
	__builtin_sub_overflow(-35, var8, &var3968);
	// ^ Call( _3968 = "overflowing_sub"::<i8,>( -35 i8, _8, ), bb100, bb399)
	var3966 = ZRICb15overflowing_div0g( var3967, var3968 );
	// ^ Call( _3966 = <i8 /*- */>::overflowing_div( _3967, _3968, ), bb101, bb399)
	var646 = -var3966._0;	// _646 = UniOp(_3966.0 NEG)
	var642 = var645 & var646;	// _642 = BinOp(_645 BIT_AND _646)
	var12 = -var642;	// _12 = UniOp(_642 NEG)
	var3970 = 0xf04a55c7;	// _3970 = Constant(0xf04a55c7 u32)
	var3969 = var2 & 0x1f;	// _3969 = BinOp(_2 BIT_AND 0x1f u32)
	var3971 = 0x3f6b3da >> var3969;
	// ^ Call( _3971 = "unchecked_shr"::<u32,>( 0x3f6b3da u32, _3969, ), bb102, bb399)
	var647 = var3970 / var3971;	// _647 = BinOp(_3970 DIV _3971)
	var3972 = (int16_t )var647;	// _3972 = Cast(_647 as i16)
	__builtin_add_overflow(13144, var3972, &var3973);
	// ^ Call( _3973 = "overflowing_add"::<i16,>( +13144 i16, _3972, ), bb103, bb399)
	var648 = -var10;	// _648 = UniOp(_10 NEG)
	var3974 = var10 ^ var648;	// _3974 = BinOp(_10 BIT_XOR _648)
	__builtin_sub_overflow(var3973, var3974, &var13);
	// ^ Call( _13 = "overflowing_sub"::<i16,>( _3973, _3974, ), bb104, bb399)
	var14 = sub128(make128_raw(11570608741256602693ull, 17596028907631201923ull), var3);	// _14 = BinOp(0xa0930f58b1a12445f431a71050dcce83 u128 SUB _3)
	var15 = var5;	// _15 = Use(_5)
	var3976 = var9.lo;	// _3976 = Cast(_9 as i16)
	var3975 = ZRICd15overflowing_div0g( var10, var3976 );
	// ^ Call( _3975 = <i16 /*- */>::overflowing_div( _10, _3976, ), bb105, bb399)
	var16 = var3975._0 * -196;	// _16 = BinOp(_3975.0 MUL -196 i16)
	var17 = 0xa4e1;	// _17 = Constant(0xa4e1 u16)
	var649 = var6 / 0xd9e8a836;	// _649 = BinOp(_6 DIV 0xd9e8a836 u32)
	var651 = var6 << 0x4;
	// ^ Call( _651 = "unchecked_shl"::<u32,>( _6, 0x4 u32, ), bb106, bb399)
	var652 = var2 / 0x23ee865d;	// _652 = BinOp(_2 DIV 0x23ee865d u32)
	var650 = var651 * var652;	// _650 = BinOp(_651 MUL _652)
	var3980 = var649 & var650;	// _3980 = BinOp(_649 BIT_AND _650)
	var653 = var14.lo;	// _653 = Cast(_14 as u32)
	var3978 = var6 * var2;	// _3978 = BinOp(_6 MUL _2)
	var3979 = var2 * var2;	// _3979 = BinOp(_2 MUL _2)
	var3977 = var3979 & 0x1f;	// _3977 = BinOp(_3979 BIT_AND 0x1f u32)
	var654 = var3978 << var3977;
	// ^ Call( _654 = "unchecked_shl"::<u32,>( _3978, _3977, ), bb107, bb399)
	var3981 = var653 * var654;	// _3981 = BinOp(_653 MUL _654)
	__builtin_add_overflow(var3980, var3981, &var655);
	// ^ Call( _655 = "overflowing_add"::<u32,>( _3980, _3981, ), bb108, bb399)
	var18 = var11;	// _18 = Use(_11)
	var3986 = var12;	// _3986 = Use(_12)
	var3983 = -55;	// _3983 = Constant(-55 i8)
	__builtin_add_overflow(var12, -35, &var656);
	// ^ Call( _656 = "overflowing_add"::<i8,>( _12, -35 i8, ), bb109, bb399)
	var3984 = -var656;	// _3984 = UniOp(_656 NEG)
	var3982 = ZRICb15overflowing_div0g( var3983, var3984 );
	// ^ Call( _3982 = <i8 /*- */>::overflowing_div( _3983, _3984, ), bb110, bb399)
	__builtin_mul_overflow(var4, var3982._0, &var3987);
	// ^ Call( _3987 = "overflowing_mul"::<i8,>( _4, _3982.0, ), bb111, bb399)
	var3985 = ZRICb15overflowing_rem0g( var3986, var3987 );
	// ^ Call( _3985 = <i8 /*- */>::overflowing_rem( _3986, _3987, ), bb112, bb399)
	var19 = var3985._0;	// _19 = Use(_3985.0)
	__builtin_add_overflow(var4, -61, &var657);
	// ^ Call( _657 = "overflowing_add"::<i8,>( _4, -61 i8, ), bb113, bb399)
	var3991 = -var657;	// _3991 = UniOp(_657 NEG)
	var3988 = var6 & 0x1f;	// _3988 = BinOp(_6 BIT_AND 0x1f u32)
	var658 = var6 << var3988;
	// ^ Call( _658 = "unchecked_shl"::<u32,>( _6, _3988, ), bb114, bb399)
	var659 = 0xda395a50 >> 0x1b;
	// ^ Call( _659 = "unchecked_shr"::<u32,>( 0xda395a50 u32, 0x1b u32, ), bb115, bb399)
	var3992 = var658 ^ var659;	// _3992 = BinOp(_658 BIT_XOR _659)
	var3989 = var3992 & 0x7;	// _3989 = BinOp(_3992 BIT_AND 0x7 u32)
	var3990 = (int8_t )var3989;	// _3990 = Cast(_3989 as i8)
	var3993 = var3991 >> var3990;
	// ^ Call( _3993 = "unchecked_shr"::<i8,>( _3991, _3990, ), bb116, bb399)
	__builtin_mul_overflow(var3993, -30, &var3996);
	// ^ Call( _3996 = "overflowing_mul"::<i8,>( _3993, -30 i8, ), bb117, bb399)
	__builtin_mul_overflow(0x6df34fb0, var6, &var3997);
	// ^ Call( _3997 = "overflowing_mul"::<u32,>( 0x6df34fb0 u32, _6, ), bb118, bb399)
	var3994 = var3997 & 0x7;	// _3994 = BinOp(_3997 BIT_AND 0x7 u32)
	var3995 = (int8_t )var3994;	// _3995 = Cast(_3994 as i8)
	var660 = var3996 >> var3995;
	// ^ Call( _660 = "unchecked_shr"::<i8,>( _3996, _3995, ), bb119, bb399)
	mul128s_o(make128s_raw(3203378611207683796ull, 3353449630294610677ull), make128s_raw(1119349507040309461ull, 695119132100302380ull), &var662);
	// ^ Call( _662 = "overflowing_mul"::<i128,>( +59091905412143274909516838487363425013 i128, +20648353885405536574071948740292941356 i128, ), bb120, bb399)
	var663 = shl128s(make128s_raw(8492029031805181519ull, 3555327495896948176ull), make128s_raw(0ull, 76ull).lo);
	// ^ Call( _663 = "unchecked_shl"::<i128,>( +156650286216221693602493996326876732880 i128, +76 i128, ), bb121, bb399)
	var661 = xor128s(var662, var663);	// _661 = BinOp(_662 BIT_XOR _663)
	var3999 = neg128s(var661);	// _3999 = UniOp(_661 NEG)
	var664 = var15 & 1131908170;	// _664 = BinOp(_15 BIT_AND +1131908170 i32)
	var665.lo = var664; var665.hi = var664 < 0 ? -1 : 0;	// _665 = Cast(_664 as i128)
	var4000 = add128s(var665, make128s_raw(8879224695760671431ull, 2902568334560529721ull));	// _4000 = BinOp(_665 ADD +163792785535658662180906339560671612217 i128)
	var3998 = ZRICj15overflowing_rem0g( var3999, var4000 );
	// ^ Call( _3998 = <i128 /*- */>::overflowing_rem( _3999, _4000, ), bb122, bb399)
	var666 = var3998._0;	// _666 = Use(_3998.0)
	var668 = make128s_raw(11115367327960530905ull, 529800544046592002ull);	// _668 = Constant(-135240030536777765963114734134860926974 i128)
	var669.lo = var16; var669.hi = var16 < 0 ? -1 : 0;	// _669 = Cast(_16 as i128)
	var4005 = mul128s(make128s_raw(10487573685336692574ull, 18433782163623374397ull), var669);	// _4005 = BinOp(-146820779193361587839733485646167937475 i128 MUL _669)
	__builtin_sub_overflow(0xa5c19718, var6, &var4001);
	// ^ Call( _4001 = "overflowing_sub"::<u32,>( 0xa5c19718 u32, _6, ), bb123, bb399)
	var4002 = var2 * 0xf3971cc2;	// _4002 = BinOp(_2 MUL 0xf3971cc2 u32)
	__builtin_sub_overflow(var4001, var4002, &var4006);
	// ^ Call( _4006 = "overflowing_sub"::<u32,>( _4001, _4002, ), bb124, bb399)
	var4003 = var4006 & 0x7f;	// _4003 = BinOp(_4006 BIT_AND 0x7f u32)
	var4004.lo = var4003; var4004.hi = var4003 < 0 ? -1 : 0;	// _4004 = Cast(_4003 as i128)
	var670 = shr128s(var4005, var4004.lo);
	// ^ Call( _670 = "unchecked_shr"::<i128,>( _4005, _4004, ), bb125, bb399)
	var667 = xor128s(var668, var670);	// _667 = BinOp(_668 BIT_XOR _670)
	var20 = div128s(var666, var667);	// _20 = BinOp(_666 DIV _667)
	var4011 = var17 ^ var11;	// _4011 = BinOp(_17 BIT_XOR _11)
	__builtin_add_overflow(0x3f, 0x0, &var4009);
	// ^ Call( _4009 = "overflowing_add"::<u16,>( 0x3f u16, 0x0 u16, ), bb126, bb399)
	var671 = var6 % var6;	// _671 = BinOp(_6 MOD _6)
	var4010 = var6 * var671;	// _4010 = BinOp(_6 MUL _671)
	var4007 = var4010 & 0xf;	// _4007 = BinOp(_4010 BIT_AND 0xf u32)
	var4008 = (uint16_t )var4007;	// _4008 = Cast(_4007 as u16)
	var4012 = var4009 >> var4008;
	// ^ Call( _4012 = "unchecked_shr"::<u16,>( _4009, _4008, ), bb127, bb399)
	__builtin_mul_overflow(var4011, var4012, &var672);
	// ^ Call( _672 = "overflowing_mul"::<u16,>( _4011, _4012, ), bb128, bb399)
	var4019 = var17;	// _4019 = Use(_17)
	var4015 = 0xe0;	// _4015 = Constant(0xe0 u16)
	var4013 = var6 & 0xf;	// _4013 = BinOp(_6 BIT_AND 0xf u32)
	var4014 = (uint16_t )var4013;	// _4014 = Cast(_4013 as u16)
	var4016 = var17 >> var4014;
	// ^ Call( _4016 = "unchecked_shr"::<u16,>( _17, _4014, ), bb129, bb399)
	var4017 = var4015 / var4016;	// _4017 = BinOp(_4015 DIV _4016)
	__builtin_add_overflow(0x655, 0x7fa2, &var673);
	// ^ Call( _673 = "overflowing_add"::<u16,>( 0x655 u16, 0x7fa2 u16, ), bb130, bb399)
	var674 = var17 ^ var18;	// _674 = BinOp(_17 BIT_XOR _18)
	var4018 = var673 | var674;	// _4018 = BinOp(_673 BIT_OR _674)
	var4020 = var4017 / var4018;	// _4020 = BinOp(_4017 DIV _4018)
	__builtin_add_overflow(var4019, var4020, &var675);
	// ^ Call( _675 = "overflowing_add"::<u16,>( _4019, _4020, ), bb131, bb399)
	__builtin_mul_overflow(var19, 67, &var677);
	// ^ Call( _677 = "overflowing_mul"::<i8,>( _19, +67 i8, ), bb132, bb399)
	var676 = var12 ^ var677;	// _676 = BinOp(_12 BIT_XOR _677)
	var678 = -var676;	// _678 = UniOp(_676 NEG)
	var679 = -var678;	// _679 = UniOp(_678 NEG)
	__builtin_sub_overflow(15, var12, &var681);
	// ^ Call( _681 = "overflowing_sub"::<i8,>( +15 i8, _12, ), bb133, bb399)
	var682 = -var681;	// _682 = UniOp(_681 NEG)
	var683 = -var682;	// _683 = UniOp(_682 NEG)
	var4021 = 0x9e8554e7 + var2;	// _4021 = BinOp(0x9e8554e7 u32 ADD _2)
	var684 = var4021 / 0xe73816b1;	// _684 = BinOp(_4021 DIV 0xe73816b1 u32)
	var685 = (int8_t )var684;	// _685 = Cast(_684 as i8)
	var680 = var683 * var685;	// _680 = BinOp(_683 MUL _685)
	var21 = var679 * var680;	// _21 = BinOp(_679 MUL _680)
	var686 = (uint32_t )var7;	// _686 = Cast(_7 as u32)
	var4022 = var6 / 0x50948d94;	// _4022 = BinOp(_6 DIV 0x50948d94 u32)
	var4024 = 0x60251893 % var4022;	// _4024 = BinOp(0x60251893 u32 MOD _4022)
	__builtin_add_overflow(var6, var6, &var4025);
	// ^ Call( _4025 = "overflowing_add"::<u32,>( _6, _6, ), bb134, bb399)
	var4023 = var4025 & 0x1f;	// _4023 = BinOp(_4025 BIT_AND 0x1f u32)
	var687 = var4024 >> var4023;
	// ^ Call( _687 = "unchecked_shr"::<u32,>( _4024, _4023, ), bb135, bb399)
	var4026 = var686 * var687;	// _4026 = BinOp(_686 MUL _687)
	__builtin_add_overflow(var4026, 0xedbbb8c4, &var22);
	// ^ Call( _22 = "overflowing_add"::<u32,>( _4026, 0xedbbb8c4 u32, ), bb136, bb399)
	var4027 = var2 & 0x3f;	// _4027 = BinOp(_2 BIT_AND 0x3f u32)
	var4028 = (uintptr_t )var4027;	// _4028 = Cast(_4027 as usize)
	var688 = 0x0ull >> var4028;
	// ^ Call( _688 = "unchecked_shr"::<usize,>( 0x0 usize, _4028, ), bb137, bb399)
	__builtin_add_overflow(0xe809fdf5ae6bfd5bull, 0xd71043571465f404ull, &var4029);
	// ^ Call( _4029 = "overflowing_add"::<usize,>( 0xe809fdf5ae6bfd5b usize, 0xd71043571465f404 usize, ), bb138, bb399)
	__builtin_mul_overflow(var4029, 0xffffffffffffb7aeull, &var689);
	// ^ Call( _689 = "overflowing_mul"::<usize,>( _4029, 0xffffffffffffffffffffffffffffb7ae usize, ), bb139, bb399)
	__builtin_mul_overflow(var16, 27629, &var690);
	// ^ Call( _690 = "overflowing_mul"::<i16,>( _16, +27629 i16, ), bb140, bb399)
	__builtin_sub_overflow(0x495f4358b158fe03ull, 0xa43854b633b77ec0ull, &var692);
	// ^ Call( _692 = "overflowing_sub"::<u64,>( 0x495f4358b158fe03 u64, 0xa43854b633b77ec0 u64, ), bb141, bb399)
	var691 = 0x242f38571eef29bull / var692;	// _691 = BinOp(0x242f38571eef29b u64 DIV _692)
	var23 = (uint16_t )var691;	// _23 = Cast(_691 as u16)
	__builtin_mul_overflow(0xfd1d, var17, &var24);
	// ^ Call( _24 = "overflowing_mul"::<u16,>( 0xfd1d u16, _17, ), bb142, bb399)
	var4030 = var6 & 0x1f;	// _4030 = BinOp(_6 BIT_AND 0x1f u32)
	var25 = 0x6dc6d935 << var4030;
	// ^ Call( _25 = "unchecked_shl"::<u32,>( 0x6dc6d935 u32, _4030, ), bb143, bb399)
	var4033 = var7 * var7;	// _4033 = BinOp(_7 MUL _7)
	__builtin_sub_overflow(var7, var7, &var4031);
	// ^ Call( _4031 = "overflowing_sub"::<u8,>( _7, _7, ), bb144, bb399)
	var4032 = var7 >> 0x0;
	// ^ Call( _4032 = "unchecked_shr"::<u8,>( _7, 0x0 u8, ), bb145, bb399)
	__builtin_sub_overflow(var4031, var4032, &var4034);
	// ^ Call( _4034 = "overflowing_sub"::<u8,>( _4031, _4032, ), bb146, bb399)
	__builtin_mul_overflow(var4033, var4034, &var694);
	// ^ Call( _694 = "overflowing_mul"::<u8,>( _4033, _4034, ), bb147, bb399)
	var697 = var7 % 0x77;	// _697 = BinOp(_7 MOD 0x77 u8)
	var696 = var697 & var7;	// _696 = BinOp(_697 BIT_AND _7)
	var695 = var696 | 0xd0;	// _695 = BinOp(_696 BIT_OR 0xd0 u8)
	var693 = var694 ^ var695;	// _693 = BinOp(_694 BIT_XOR _695)
	var26 = (int32_t )var693;	// _26 = Cast(_693 as i32)
	__builtin_add_overflow(0x45f, 0x5790, &var4037);
	// ^ Call( _4037 = "overflowing_add"::<u16,>( 0x45f u16, 0x5790 u16, ), bb148, bb399)
	__builtin_sub_overflow(0x19fb6331, 0xee380f06, &var4038);
	// ^ Call( _4038 = "overflowing_sub"::<u32,>( 0x19fb6331 u32, 0xee380f06 u32, ), bb149, bb399)
	var4035 = var4038 & 0xf;	// _4035 = BinOp(_4038 BIT_AND 0xf u32)
	var4036 = (uint16_t )var4035;	// _4036 = Cast(_4035 as u16)
	var4039 = var4037 << var4036;
	// ^ Call( _4039 = "unchecked_shl"::<u16,>( _4037, _4036, ), bb150, bb399)
	var698 = var4039 << 0xb;
	// ^ Call( _698 = "unchecked_shl"::<u16,>( _4039, 0xb u16, ), bb151, bb399)
	var4042 = (uintptr_t )var698;	// _4042 = Cast(_698 as usize)
	__builtin_mul_overflow(0x5c311773b1c89b4cull, 0x20e93952d9b54cbeull, &var4040);
	// ^ Call( _4040 = "overflowing_mul"::<usize,>( 0x5c311773b1c89b4c usize, 0x20e93952d9b54cbe usize, ), bb152, bb399)
	var4041 = var4040 % 0xf8d60fd6d7f8edd2ull;	// _4041 = BinOp(_4040 MOD 0xf8d60fd6d7f8edd2 usize)
	var4043 = 0xca7272c78e0ac6ecull % var4041;	// _4043 = BinOp(0xca7272c78e0ac6ec usize MOD _4041)
	var27 = var4042 / var4043;	// _27 = BinOp(_4042 DIV _4043)
	var4046 = neg128s(var20);	// _4046 = UniOp(_20 NEG)
	var4047 = var2 + var2;	// _4047 = BinOp(_2 ADD _2)
	var4044 = var4047 & 0x7f;	// _4044 = BinOp(_4047 BIT_AND 0x7f u32)
	var4045.lo = var4044; var4045.hi = var4044 < 0 ? -1 : 0;	// _4045 = Cast(_4044 as i128)
	var4048 = shr128s(var4046, var4045.lo);
	// ^ Call( _4048 = "unchecked_shr"::<i128,>( _4046, _4045, ), bb153, bb399)
	sub128s_o(var4048, make128s_raw(13938675025262256135ull, 9704790401036903997ull), &var4049);
	// ^ Call( _4049 = "overflowing_sub"::<i128,>( _4048, -83159196003318605435677004511336143299 i128, ), bb154, bb399)
	add128s_o(var20, var4049, &var699);
	// ^ Call( _699 = "overflowing_add"::<i128,>( _20, _4049, ), bb155, bb399)
	var28 = neg128s(var699);	// _28 = UniOp(_699 NEG)
	var700 = var2 >> 0x11;
	// ^ Call( _700 = "unchecked_shr"::<u32,>( _2, 0x11 u32, ), bb156, bb399)
	var701 = 0xd926df8c << 0x14;
	// ^ Call( _701 = "unchecked_shl"::<u32,>( 0xd926df8c u32, 0x14 u32, ), bb157, bb399)
	var4050 = var700 / var701;	// _4050 = BinOp(_700 DIV _701)
	var4053 = var4050 % 0x62abc042;	// _4053 = BinOp(_4050 MOD 0x62abc042 u32)
	var4051 = var4053 & 0x7;	// _4051 = BinOp(_4053 BIT_AND 0x7 u32)
	var4052 = (uint8_t )var4051;	// _4052 = Cast(_4051 as u8)
	var702 = var7 << var4052;
	// ^ Call( _702 = "unchecked_shl"::<u8,>( _7, _4052, ), bb158, bb399)
	var703 = div128s(var28, make128s_raw(8939332894006029465ull, 15381619564650143552ull));	// _703 = BinOp(_28 DIV +164901586085422579376037665430284508992 i128)
	var704 = and128s(var20, make128s_raw(11135223557644337588ull, 8789406885509373572ull));	// _704 = BinOp(_20 BIT_AND -134873747749531789341287275733443895676 i128)
	var29 = sub128s(var703, var704);	// _29 = BinOp(_703 SUB _704)
	__builtin_mul_overflow(0x9f99c2b70350329dull, 0x7d2b00d3fb0801f3ull, &var706);
	// ^ Call( _706 = "overflowing_mul"::<u64,>( 0x9f99c2b70350329d u64, 0x7d2b00d3fb0801f3 u64, ), bb159, bb399)
	__builtin_mul_overflow(0xf517b911e4afed40ull, 0x4603855136327193ull, &var707);
	// ^ Call( _707 = "overflowing_mul"::<u64,>( 0xf517b911e4afed40 u64, 0x4603855136327193 u64, ), bb160, bb399)
	var705 = var706 + var707;	// _705 = BinOp(_706 ADD _707)
	var708 = (int16_t )var705;	// _708 = Cast(_705 as i16)
	var4058 = -var708;	// _4058 = UniOp(_708 NEG)
	__builtin_sub_overflow(0x9a6df36b, 0x4c99d669, &var710);
	// ^ Call( _710 = "overflowing_sub"::<u32,>( 0x9a6df36b u32, 0x4c99d669 u32, ), bb161, bb399)
	var709 = var710 / 0xb05101a;	// _709 = BinOp(_710 DIV 0xb05101a u32)
	var4055 = 0xd750cfef | var709;	// _4055 = BinOp(0xd750cfef u32 BIT_OR _709)
	var4054 = var4055 & 0x1f;	// _4054 = BinOp(_4055 BIT_AND 0x1f u32)
	var4059 = var6 >> var4054;
	// ^ Call( _4059 = "unchecked_shr"::<u32,>( _6, _4054, ), bb162, bb399)
	var4056 = var4059 & 0xf;	// _4056 = BinOp(_4059 BIT_AND 0xf u32)
	var4057 = (int16_t )var4056;	// _4057 = Cast(_4056 as i16)
	var30 = var4058 << var4057;
	// ^ Call( _30 = "unchecked_shl"::<i16,>( _4058, _4057, ), bb163, bb399)
	var31 = 0x7de938bd3a150dc4ull;	// _31 = Constant(0x7de938bd3a150dc4 u64)
	var4062 = -6164336486566728954ll;	// _4062 = Constant(-6164336486566728954 isize)
	var4063 = 0x2 << 0x19;
	// ^ Call( _4063 = "unchecked_shl"::<u32,>( 0x2 u32, 0x19 u32, ), bb164, bb399)
	var4060 = var4063 & 0x3f;	// _4060 = BinOp(_4063 BIT_AND 0x3f u32)
	var4061 = (intptr_t )var4060;	// _4061 = Cast(_4060 as isize)
	var712 = var4062 >> var4061;
	// ^ Call( _712 = "unchecked_shr"::<isize,>( _4062, _4061, ), bb165, bb399)
	var713 = -9095749359833314619ll >> 51ll;
	// ^ Call( _713 = "unchecked_shr"::<isize,>( -9095749359833314619 isize, +51 isize, ), bb166, bb399)
	var4064 = var713 | 1ll;	// _4064 = BinOp(_713 BIT_OR +1 isize)
	__builtin_sub_overflow(var4064, -6ll, &var714);
	// ^ Call( _714 = "overflowing_sub"::<isize,>( _4064, -6 isize, ), bb167, bb399)
	var711 = var712 / var714;	// _711 = BinOp(_712 DIV _714)
	__builtin_sub_overflow(var22, var22, &var716);
	// ^ Call( _716 = "overflowing_sub"::<u32,>( _22, _22, ), bb168, bb399)
	var717 = 0x5a62086d | var6;	// _717 = BinOp(0x5a62086d u32 BIT_OR _6)
	var715 = var716 * var717;	// _715 = BinOp(_716 MUL _717)
	var718 = (intptr_t )var715;	// _718 = Cast(_715 as isize)
	var719 = -var718;	// _719 = UniOp(_718 NEG)
	var32 = var711 * var719;	// _32 = BinOp(_711 MUL _719)
	var720 = 768092710 / var26;	// _720 = BinOp(+768092710 i32 DIV _26)
	var4065 = -var720;	// _4065 = UniOp(_720 NEG)
	__builtin_sub_overflow(var4065, -1654680544, &var721);
	// ^ Call( _721 = "overflowing_sub"::<i32,>( _4065, -1654680544 i32, ), bb169, bb399)
	var722 = -var15;	// _722 = UniOp(_15 NEG)
	var723 = var9.lo;	// _723 = Cast(_9 as i32)
	var4067 = var722 - var723;	// _4067 = BinOp(_722 SUB _723)
	var4066 = ZRICf15overflowing_div0g( 372489316, var4067 );
	// ^ Call( _4066 = <i32 /*- */>::overflowing_div( +372489316 i32, _4067, ), bb170, bb399)
	var4069 = var721 + var4066._0;	// _4069 = BinOp(_721 ADD _4066.0)
	var4068 = ZRICf15overflowing_rem0g( var4069, var5 );
	// ^ Call( _4068 = <i32 /*- */>::overflowing_rem( _4069, _5, ), bb171, bb399)
	var33 = var4068._0;	// _33 = Use(_4068.0)
	var726 = 0x7d3d ^ var18;	// _726 = BinOp(0x7d3d u16 BIT_XOR _18)
	var725 = var726 / 0x53a5;	// _725 = BinOp(_726 DIV 0x53a5 u16)
	var724 = 0x6444 & var725;	// _724 = BinOp(0x6444 u16 BIT_AND _725)
	var727 = (uint32_t )var724;	// _727 = Cast(_724 as u32)
	var728 = (uint32_t )var4068._0;	// _728 = Cast(_4068.0 as u32)
	var4070 = 0xea952ca4 / var25;	// _4070 = BinOp(0xea952ca4 u32 DIV _25)
	var4071 = var22 / 0xc3f422eb;	// _4071 = BinOp(_22 DIV 0xc3f422eb u32)
	__builtin_add_overflow(var4070, var4071, &var729);
	// ^ Call( _729 = "overflowing_add"::<u32,>( _4070, _4071, ), bb172, bb399)
	var4075 = var728 | var729;	// _4075 = BinOp(_728 BIT_OR _729)
	__builtin_mul_overflow(var22, 0xa5c3652c, &var730);
	// ^ Call( _730 = "overflowing_mul"::<u32,>( _22, 0xa5c3652c u32, ), bb173, bb399)
	var4073 = var25 / 0x4d0ad49a;	// _4073 = BinOp(_25 DIV 0x4d0ad49a u32)
	var4074 = var6 | var2;	// _4074 = BinOp(_6 BIT_OR _2)
	var4072 = var4074 & 0x1f;	// _4072 = BinOp(_4074 BIT_AND 0x1f u32)
	var731 = var4073 >> var4072;
	// ^ Call( _731 = "unchecked_shr"::<u32,>( _4073, _4072, ), bb174, bb399)
	var4076 = var730 & var731;	// _4076 = BinOp(_730 BIT_AND _731)
	__builtin_mul_overflow(var4075, var4076, &var732);
	// ^ Call( _732 = "overflowing_mul"::<u32,>( _4075, _4076, ), bb175, bb399)
	var34 = var727 | var732;	// _34 = BinOp(_727 BIT_OR _732)
	var35 = make128s_raw(1369839603692377266ull, 16309916319736384059ull);	// _35 = Constant(+25269080591345001167636086593708345915 i128)
	var733 = var31 ^ var31;	// _733 = BinOp(_31 BIT_XOR _31)
	var4077 = var31 & var733;	// _4077 = BinOp(_31 BIT_AND _733)
	__builtin_add_overflow(0x1adbf38838dd253bull, 0x4ull, &var4078);
	// ^ Call( _4078 = "overflowing_add"::<u64,>( 0x1adbf38838dd253b u64, 0x4 u64, ), bb176, bb399)
	__builtin_mul_overflow(var4077, var4078, &var4082);
	// ^ Call( _4082 = "overflowing_mul"::<u64,>( _4077, _4078, ), bb177, bb399)
	var4081 = var6 / 0x90a6a344;	// _4081 = BinOp(_6 DIV 0x90a6a344 u32)
	var4079 = var4081 & 0x3f;	// _4079 = BinOp(_4081 BIT_AND 0x3f u32)
	var4080 = (uint64_t )var4079;	// _4080 = Cast(_4079 as u64)
	var734 = var31 >> var4080;
	// ^ Call( _734 = "unchecked_shr"::<u64,>( _31, _4080, ), bb178, bb399)
	var735 = -var26;	// _735 = UniOp(_26 NEG)
	var736 = (uint64_t )var735;	// _736 = Cast(_735 as u64)
	var4083 = var734 | var736;	// _4083 = BinOp(_734 BIT_OR _736)
	__builtin_add_overflow(var4082, var4083, &var737);
	// ^ Call( _737 = "overflowing_add"::<u64,>( _4082, _4083, ), bb179, bb399)
	var36 = var737 / var31;	// _36 = BinOp(_737 DIV _31)
	var4084 = var2 & 0x7;	// _4084 = BinOp(_2 BIT_AND 0x7 u32)
	var4085 = (uint8_t )var4084;	// _4085 = Cast(_4084 as u8)
	var738 = 0xdc << var4085;
	// ^ Call( _738 = "unchecked_shl"::<u8,>( 0xdc u8, _4085, ), bb180, bb399)
	var4087 = var7 ^ var738;	// _4087 = BinOp(_7 BIT_XOR _738)
	var4086 = var7 * 0x28;	// _4086 = BinOp(_7 MUL 0x28 u8)
	var4088 = var4086 << 0x0;
	// ^ Call( _4088 = "unchecked_shl"::<u8,>( _4086, 0x0 u8, ), bb181, bb399)
	var4091 = var4087 % var4088;	// _4091 = BinOp(_4087 MOD _4088)
	var4092 = (uint32_t )var7;	// _4092 = Cast(_7 as u32)
	var4089 = var4092 & 0x7;	// _4089 = BinOp(_4092 BIT_AND 0x7 u32)
	var4090 = (uint8_t )var4089;	// _4090 = Cast(_4089 as u8)
	var739 = var4091 << var4090;
	// ^ Call( _739 = "unchecked_shl"::<u8,>( _4091, _4090, ), bb182, bb399)
	var4093 = var7 - var7;	// _4093 = BinOp(_7 SUB _7)
	var4094 = var7 >> 0x1;
	// ^ Call( _4094 = "unchecked_shr"::<u8,>( _7, 0x1 u8, ), bb183, bb399)
	__builtin_sub_overflow(var4093, var4094, &var4095);
	// ^ Call( _4095 = "overflowing_sub"::<u8,>( _4093, _4094, ), bb184, bb399)
	__builtin_add_overflow(var7, 0x2c, &var740);
	// ^ Call( _740 = "overflowing_add"::<u8,>( _7, 0x2c u8, ), bb185, bb399)
	var4096 = var740 / var7;	// _4096 = BinOp(_740 DIV _7)
	__builtin_mul_overflow(var4095, var4096, &var741);
	// ^ Call( _741 = "overflowing_mul"::<u8,>( _4095, _4096, ), bb186, bb399)
	var743 = var19 * var8;	// _743 = BinOp(_19 MUL _8)
	var742 = var743 - -6;	// _742 = BinOp(_743 SUB -6 i8)
	var744 = -var742;	// _744 = UniOp(_742 NEG)
	var745 = -var744;	// _745 = UniOp(_744 NEG)
	var4097 = (int8_t )var11;	// _4097 = Cast(_11 as i8)
	__builtin_sub_overflow(var4097, var21, &var746);
	// ^ Call( _746 = "overflowing_sub"::<i8,>( _4097, _21, ), bb187, bb399)
	var747 = -var746;	// _747 = UniOp(_746 NEG)
	var37 = var745 * var747;	// _37 = BinOp(_745 MUL _747)
	var4104 = var13;	// _4104 = Use(_13)
	var4098 = ZRICd15overflowing_div0g( 18381, -13240 );
	// ^ Call( _4098 = <i16 /*- */>::overflowing_div( +18381 i16, -13240 i16, ), bb188, bb399)
	var4103 = -var4098._0;	// _4103 = UniOp(_4098.0 NEG)
	var4100 = -31171;	// _4100 = Constant(-31171 i16)
	__builtin_sub_overflow(var13, 3059, &var4101);
	// ^ Call( _4101 = "overflowing_sub"::<i16,>( _13, +3059 i16, ), bb189, bb399)
	var4099 = ZRICd15overflowing_rem0g( var4100, var4101 );
	// ^ Call( _4099 = <i16 /*- */>::overflowing_rem( _4100, _4101, ), bb190, bb399)
	var4102 = ZRICd15overflowing_div0g( var4103, var4099._0 );
	// ^ Call( _4102 = <i16 /*- */>::overflowing_div( _4103, _4099.0, ), bb191, bb399)
	__builtin_add_overflow(var4104, var4102._0, &var748);
	// ^ Call( _748 = "overflowing_add"::<i16,>( _4104, _4102.0, ), bb192, bb399)
	var38 = var748 / var13;	// _38 = BinOp(_748 DIV _13)
	var4105 = var25 & 0xf;	// _4105 = BinOp(_25 BIT_AND 0xf u32)
	var4106 = (uint16_t )var4105;	// _4106 = Cast(_4105 as u16)
	var4107 = var23 >> var4106;
	// ^ Call( _4107 = "unchecked_shr"::<u16,>( _23, _4106, ), bb193, bb399)
	var4108 = var11 | var24;	// _4108 = BinOp(_11 BIT_OR _24)
	var751 = var4107 % var4108;	// _751 = BinOp(_4107 MOD _4108)
	var752 = var11 * var23;	// _752 = BinOp(_11 MUL _23)
	var750 = var751 & var752;	// _750 = BinOp(_751 BIT_AND _752)
	var4109 = var23 + 0x87b3;	// _4109 = BinOp(_23 ADD 0x87b3 u16)
	__builtin_sub_overflow(var4109, 0x51fa, &var754);
	// ^ Call( _754 = "overflowing_sub"::<u16,>( _4109, 0x51fa u16, ), bb194, bb399)
	var753 = var24 / var754;	// _753 = BinOp(_24 DIV _754)
	var749 = var750 & var753;	// _749 = BinOp(_750 BIT_AND _753)
	var39 = var18 | var749;	// _39 = BinOp(_18 BIT_OR _749)
	__builtin_sub_overflow(-3462554333124362519ll, 8104199292132231236ll, &var756);
	// ^ Call( _756 = "overflowing_sub"::<isize,>( -3462554333124362519 isize, +8104199292132231236 isize, ), bb195, bb399)
	var757 = -var32;	// _757 = UniOp(_32 NEG)
	var755 = var756 - var757;	// _755 = BinOp(_756 SUB _757)
	var4112 = (uintptr_t )var755;	// _4112 = Cast(_755 as usize)
	var4110 = ZRICf15overflowing_div0g( var33, var1 );
	// ^ Call( _4110 = <i32 /*- */>::overflowing_div( _33, _1, ), bb196, bb399)
	var4111 = (uintptr_t )var4110._0;	// _4111 = Cast(_4110.0 as usize)
	__builtin_sub_overflow(var27, var4111, &var4113);
	// ^ Call( _4113 = "overflowing_sub"::<usize,>( _27, _4111, ), bb197, bb399)
	__builtin_mul_overflow(var4112, var4113, &var758);
	// ^ Call( _758 = "overflowing_mul"::<usize,>( _4112, _4113, ), bb198, bb399)
	__builtin_add_overflow(0x0ull, 0x46beull, &var4114);
	// ^ Call( _4114 = "overflowing_add"::<usize,>( 0x0 usize, 0x46be usize, ), bb199, bb399)
	var759 = var4114 >> 0x11ull;
	// ^ Call( _759 = "unchecked_shr"::<usize,>( _4114, 0x11 usize, ), bb200, bb399)
	var4115 = var25 & 0x1f;	// _4115 = BinOp(_25 BIT_AND 0x1f u32)
	var4116 = (int32_t )var4115;	// _4116 = Cast(_4115 as i32)
	var760 = -602861398 >> var4116;
	// ^ Call( _760 = "unchecked_shr"::<i32,>( +3692105898 i32, _4116, ), bb201, bb399)
	var761 = -var19;	// _761 = UniOp(_19 NEG)
	var762 = -var761;	// _762 = UniOp(_761 NEG)
	var4118 = 0 + var762;	// _4118 = BinOp(+0 i8 ADD _762)
	var4117 = ZRICb15overflowing_div0g( var4118, 47 );
	// ^ Call( _4117 = <i8 /*- */>::overflowing_div( _4118, +47 i8, ), bb202, bb399)
	var40 = -var4117._0;	// _40 = UniOp(_4117.0 NEG)
	var41 = var25;	// _41 = Use(_25)
	__builtin_mul_overflow(0xc3ec, var24, &var763);
	// ^ Call( _763 = "overflowing_mul"::<u16,>( 0xc3ec u16, _24, ), bb203, bb399)
	__builtin_add_overflow(0xc63e, 0xe4b0, &var764);
	// ^ Call( _764 = "overflowing_add"::<u16,>( 0xc63e u16, 0xe4b0 u16, ), bb204, bb399)
	var4119 = var23 / var17;	// _4119 = BinOp(_23 DIV _17)
	__builtin_sub_overflow(0x4981, var4119, &var4120);
	// ^ Call( _4120 = "overflowing_sub"::<u16,>( 0x4981 u16, _4119, ), bb205, bb399)
	var766 = 0xeeb6;	// _766 = Constant(0xeeb6 u16)
	__builtin_sub_overflow(var11, var23, &var767);
	// ^ Call( _767 = "overflowing_sub"::<u16,>( _11, _23, ), bb206, bb399)
	var765 = var766 | var767;	// _765 = BinOp(_766 BIT_OR _767)
	var4121 = var765 - 0x75ee;	// _4121 = BinOp(_765 SUB 0x75ee u16)
	var768 = (int8_t )var27;	// _768 = Cast(_27 as i8)
	var4122 = (uint16_t )var768;	// _4122 = Cast(_768 as u16)
	__builtin_sub_overflow(var4121, var4122, &var769);
	// ^ Call( _769 = "overflowing_sub"::<u16,>( _4121, _4122, ), bb207, bb399)
	var42 = var37 / 81;	// _42 = BinOp(_37 DIV +81 i8)
	var771 = var38 ^ -24097;	// _771 = BinOp(_38 BIT_XOR -24097 i16)
	var772 = -var38;	// _772 = UniOp(_38 NEG)
	var770 = var771 / var772;	// _770 = BinOp(_771 DIV _772)
	var773 = -var770;	// _773 = UniOp(_770 NEG)
	var4123 = -var30;	// _4123 = UniOp(_30 NEG)
	__builtin_add_overflow(6686, var4123, &var775);
	// ^ Call( _775 = "overflowing_add"::<i16,>( +6686 i16, _4123, ), bb208, bb399)
	var4124 = -var30;	// _4124 = UniOp(_30 NEG)
	var776 = var4124 << 7;
	// ^ Call( _776 = "unchecked_shl"::<i16,>( _4124, +7 i16, ), bb209, bb399)
	var774 = var775 * var776;	// _774 = BinOp(_775 MUL _776)
	var4132 = var773 - var774;	// _4132 = BinOp(_773 SUB _774)
	var4125 = ZRICf15overflowing_div0g( var26, var26 );
	// ^ Call( _4125 = <i32 /*- */>::overflowing_div( _26, _26, ), bb210, bb399)
	var777 = (int16_t )var4125._0;	// _777 = Cast(_4125.0 as i16)
	var4126 = var41 & 0xf;	// _4126 = BinOp(_41 BIT_AND 0xf u32)
	var4127 = (int16_t )var4126;	// _4127 = Cast(_4126 as i16)
	var4128 = var38 >> var4127;
	// ^ Call( _4128 = "unchecked_shr"::<i16,>( _38, _4127, ), bb211, bb399)
	__builtin_mul_overflow(var4128, 1, &var4130);
	// ^ Call( _4130 = "overflowing_mul"::<i16,>( _4128, +1 i16, ), bb212, bb399)
	var4129 = ZRICd15overflowing_rem0g( 18457, var4130 );
	// ^ Call( _4129 = <i16 /*- */>::overflowing_rem( +18457 i16, _4130, ), bb213, bb399)
	var4133 = var777 | var4129._0;	// _4133 = BinOp(_777 BIT_OR _4129.0)
	var4131 = ZRICd15overflowing_rem0g( var4132, var4133 );
	// ^ Call( _4131 = <i16 /*- */>::overflowing_rem( _4132, _4133, ), bb214, bb399)
	var43 = var4131._0;	// _43 = Use(_4131.0)
	var44 = 22555;	// _44 = Constant(-42981 i16)
	var45 = var39;	// _45 = Use(_39)
	var4134 = 0x564e;	// _4134 = Constant(0x564e u16)
	var4135 = 0x90b0 >> 0xd;
	// ^ Call( _4135 = "unchecked_shr"::<u16,>( 0x90b0 u16, 0xd u16, ), bb215, bb399)
	var779 = var4134 % var4135;	// _779 = BinOp(_4134 MOD _4135)
	var778 = var779 | var45;	// _778 = BinOp(_779 BIT_OR _45)
	var46 = var11 + var778;	// _46 = BinOp(_11 ADD _778)
	var4138 = add128(var9, var9);	// _4138 = BinOp(_9 ADD _9)
	var4139 = 0x6b75061b / var22;	// _4139 = BinOp(0x6b75061b u32 DIV _22)
	var4136 = var4139 & 0x7f;	// _4136 = BinOp(_4139 BIT_AND 0x7f u32)
	var4137.lo = var4136; var4137.hi = var4136 < 0 ? -1 : 0;	// _4137 = Cast(_4136 as u128)
	var780 = shr128(var4138, var4137.lo);
	// ^ Call( _780 = "unchecked_shr"::<u128,>( _4138, _4137, ), bb216, bb399)
	var781 = var780.lo;	// _781 = Cast(_780 as i8)
	var782 = -var781;	// _782 = UniOp(_781 NEG)
	var47 = (uint32_t )var782;	// _47 = Cast(_782 as u32)
	var784 = neg128s(var20);	// _784 = UniOp(_20 NEG)
	var783 = or128s(make128s_raw(253105665081205991ull, 13958647604138970639ull), var784);	// _783 = BinOp(+4668975427359051225807113429281902095 i128 BIT_OR _784)
	var785 = neg128s(var783);	// _785 = UniOp(_783 NEG)
	var4146 = neg128s(var785);	// _4146 = UniOp(_785 NEG)
	add128s_o(make128s_raw(2761997390108155222ull, 145383065167494413ull), var28, &var786);
	// ^ Call( _786 = "overflowing_add"::<i128,>( +50949858987578860882076906223716433165 i128, _28, ), bb217, bb399)
	var4143 = neg128s(var786);	// _4143 = UniOp(_786 NEG)
	var4140 = var47 & 0x7f;	// _4140 = BinOp(_47 BIT_AND 0x7f u32)
	var4141.lo = var4140; var4141.hi = var4140 < 0 ? -1 : 0;	// _4141 = Cast(_4140 as i128)
	var787 = shr128s(make128s_raw(5011652469553464409ull, 9532550258264920380ull), var4141.lo);
	// ^ Call( _787 = "unchecked_shr"::<i128,>( +92448670492227208661471799585069355324 i128, _4141, ), bb218, bb399)
	var4144 = xor128s(var787, var29);	// _4144 = BinOp(_787 BIT_XOR _29)
	var4142 = ZRICj15overflowing_div0g( var4143, var4144 );
	// ^ Call( _4142 = <i128 /*- */>::overflowing_div( _4143, _4144, ), bb219, bb399)
	var4145.lo = var32; var4145.hi = var32 < 0 ? -1 : 0;	// _4145 = Cast(_32 as i128)
	mul128s_o(var4142._0, var4145, &var4147);
	// ^ Call( _4147 = "overflowing_mul"::<i128,>( _4142.0, _4145, ), bb220, bb399)
	add128s_o(var4146, var4147, &var48);
	// ^ Call( _48 = "overflowing_add"::<i128,>( _4146, _4147, ), bb221, bb399)
	var4148 = var47 & 0x7;	// _4148 = BinOp(_47 BIT_AND 0x7 u32)
	var4149 = (int8_t )var4148;	// _4149 = Cast(_4148 as i8)
	var4150 = var12 << var4149;
	// ^ Call( _4150 = "unchecked_shl"::<i8,>( _12, _4149, ), bb222, bb399)
	var4151 = var19 << 0;
	// ^ Call( _4151 = "unchecked_shl"::<i8,>( _19, +0 i8, ), bb223, bb399)
	__builtin_sub_overflow(var4150, var4151, &var788);
	// ^ Call( _788 = "overflowing_sub"::<i8,>( _4150, _4151, ), bb224, bb399)
	var4154 = -115;	// _4154 = Constant(-115 i8)
	var4152 = var2 & 0x7;	// _4152 = BinOp(_2 BIT_AND 0x7 u32)
	var4153 = (int8_t )var4152;	// _4153 = Cast(_4152 as i8)
	var4155 = 48 << var4153;
	// ^ Call( _4155 = "unchecked_shl"::<i8,>( +48 i8, _4153, ), bb225, bb399)
	__builtin_sub_overflow(var4154, var4155, &var789);
	// ^ Call( _789 = "overflowing_sub"::<i8,>( _4154, _4155, ), bb226, bb399)
	__builtin_add_overflow(-77, -116, &var790);
	// ^ Call( _790 = "overflowing_add"::<i8,>( -77 i8, -116 i8, ), bb227, bb399)
	__builtin_mul_overflow(87, -119, &var791);
	// ^ Call( _791 = "overflowing_mul"::<i8,>( +87 i8, -119 i8, ), bb228, bb399)
	var4158 = var791 / -25;	// _4158 = BinOp(_791 DIV -25 i8)
	var4156 = var47 & 0x7;	// _4156 = BinOp(_47 BIT_AND 0x7 u32)
	var4157 = (int8_t )var4156;	// _4157 = Cast(_4156 as i8)
	var4159 = var4158 << var4157;
	// ^ Call( _4159 = "unchecked_shl"::<i8,>( _4158, _4157, ), bb229, bb399)
	__builtin_mul_overflow(-2, -71, &var792);
	// ^ Call( _792 = "overflowing_mul"::<i8,>( -2 i8, -3733355721159968583 i8, ), bb230, bb399)
	var4160 = 110 & var792;	// _4160 = BinOp(+110 i8 BIT_AND _792)
	__builtin_sub_overflow(var4159, var4160, &var793);
	// ^ Call( _793 = "overflowing_sub"::<i8,>( _4159, _4160, ), bb231, bb399)
	var796 = var13 - var38;	// _796 = BinOp(_13 SUB _38)
	__builtin_sub_overflow(var38, 6474, &var797);
	// ^ Call( _797 = "overflowing_sub"::<i16,>( _38, +6474 i16, ), bb232, bb399)
	var795 = var796 | var797;	// _795 = BinOp(_796 BIT_OR _797)
	var798 = (uint32_t )var795;	// _798 = Cast(_795 as u32)
	__builtin_mul_overflow(84, 44, &var799);
	// ^ Call( _799 = "overflowing_mul"::<i8,>( +84 i8, +44 i8, ), bb233, bb399)
	var800 = (uint32_t )var799;	// _800 = Cast(_799 as u32)
	var794 = var798 & var800;	// _794 = BinOp(_798 BIT_AND _800)
	var49 = var794 | var41;	// _49 = BinOp(_794 BIT_OR _41)
	var801 = var23 / 0xc1ec;	// _801 = BinOp(_23 DIV 0xc1ec u16)
	var4171 = 0x15fe ^ var801;	// _4171 = BinOp(0x15fe u16 BIT_XOR _801)
	var802 = var17 | 0x3ded;	// _802 = BinOp(_17 BIT_OR 0x3ded u16)
	var803 = 0x3770 | var18;	// _803 = BinOp(0x3770 u16 BIT_OR _18)
	var4165 = var802 / var803;	// _4165 = BinOp(_802 DIV _803)
	var4161 = 0x6d0da2ee;	// _4161 = Constant(0x6d0da2ee u32)
	__builtin_sub_overflow(0x128245ac, var2, &var4162);
	// ^ Call( _4162 = "overflowing_sub"::<u32,>( 0x128245ac u32, _2, ), bb234, bb399)
	var4166 = var4161 % var4162;	// _4166 = BinOp(_4161 MOD _4162)
	var4163 = var4166 & 0xf;	// _4163 = BinOp(_4166 BIT_AND 0xf u32)
	var4164 = (uint16_t )var4163;	// _4164 = Cast(_4163 as u16)
	var4169 = var4165 >> var4164;
	// ^ Call( _4169 = "unchecked_shr"::<u16,>( _4165, _4164, ), bb235, bb399)
	var805 = 0x1e9ab834 % var47;	// _805 = BinOp(0x1e9ab834 u32 MOD _47)
	var804 = var34 / var805;	// _804 = BinOp(_34 DIV _805)
	var807 = var25 | 0x1f1bb406;	// _807 = BinOp(_25 BIT_OR 0x1f1bb406 u32)
	var808 = var6 / 0x2b451dd5;	// _808 = BinOp(_6 DIV 0x2b451dd5 u32)
	var806 = var807 - var808;	// _806 = BinOp(_807 SUB _808)
	var4170 = var804 & var806;	// _4170 = BinOp(_804 BIT_AND _806)
	var4167 = var4170 & 0xf;	// _4167 = BinOp(_4170 BIT_AND 0xf u32)
	var4168 = (uint16_t )var4167;	// _4168 = Cast(_4167 as u16)
	var4172 = var4169 << var4168;
	// ^ Call( _4172 = "unchecked_shl"::<u16,>( _4169, _4168, ), bb236, bb399)
	__builtin_add_overflow(var4171, var4172, &var809);
	// ^ Call( _809 = "overflowing_add"::<u16,>( _4171, _4172, ), bb237, bb399)
	var50 = var10;	// _50 = Use(_10)
	var4173 = ZRICd15overflowing_div0g( 17454, -3034 );
	// ^ Call( _4173 = <i16 /*- */>::overflowing_div( +17454 i16, -3034 i16, ), bb238, bb399)
	var51 = 0x977addd9;	// _51 = Constant(0x977addd9 u32)
	var52 = var50;	// _52 = Use(_50)
	var53 = 0x2a7fa04abefc9063ull;	// _53 = Constant(0x2a7fa04abefc9063 usize)
	var812 = (uint8_t )var31;	// _812 = Cast(_31 as u8)
	var811 = var812 & 0xc7;	// _811 = BinOp(_812 BIT_AND 0xc7 u8)
	var4176 = var7 + var7;	// _4176 = BinOp(_7 ADD _7)
	var4177 = var25 << 0x7;
	// ^ Call( _4177 = "unchecked_shl"::<u32,>( _25, 0x7 u32, ), bb239, bb399)
	var4174 = var4177 & 0x7;	// _4174 = BinOp(_4177 BIT_AND 0x7 u32)
	var4175 = (uint8_t )var4174;	// _4175 = Cast(_4174 as u8)
	var814 = var4176 >> var4175;
	// ^ Call( _814 = "unchecked_shr"::<u8,>( _4176, _4175, ), bb240, bb399)
	var813 = var814 + 0x49;	// _813 = BinOp(_814 ADD 0x49 u8)
	var810 = var811 ^ var813;	// _810 = BinOp(_811 BIT_XOR _813)
	var54 = var810 & 0xb7;	// _54 = BinOp(_810 BIT_AND 0xb7 u8)
	var55 = -2741680884961781651ll;	// _55 = Constant(-2741680884961781651 isize)
	var56 = -166558696;	// _56 = Constant(+3371188408206656536 i32)
	var4178 = ZRICf15overflowing_div0g( 2060093167, 529254581 );
	// ^ Call( _4178 = <i32 /*- */>::overflowing_div( +2060093167 i32, +529254581 i32, ), bb241, bb399)
	var4179 = var1 / -699054442;	// _4179 = BinOp(_1 DIV -699054442 i32)
	__builtin_add_overflow(-1356141886, var4179, &var815);
	// ^ Call( _815 = "overflowing_add"::<i32,>( -1356141886 i32, _4179, ), bb242, bb399)
	var4182 = (uint64_t )var815;	// _4182 = Cast(_815 as u64)
	var4180 = var51 & 0x3f;	// _4180 = BinOp(_51 BIT_AND 0x3f u32)
	var4181 = (uint64_t )var4180;	// _4181 = Cast(_4180 as u64)
	var816 = var4182 << var4181;
	// ^ Call( _816 = "unchecked_shl"::<u64,>( _4182, _4181, ), bb243, bb399)
	sub128_o(make128_raw(15051799383552366670ull, 2256447892767224778ull), var3, &var818);
	// ^ Call( _818 = "overflowing_sub"::<u128,>( 0xd0e2bbca9f15184e1f5083673e91b3ca u128, _3, ), bb244, bb399)
	var4183 = div128(var818, make128_raw(1373758728805947567ull, 2318578689602738806ull));	// _4183 = BinOp(_818 DIV 0x131092490d9218af202d3f08a98fda76 u128)
	mul128_o(make128_raw(2603737322827077042ull, 4231212615559646361ull), make128_raw(3626403299743416678ull, 2972284334962270817ull), &var4184);
	// ^ Call( _4184 = "overflowing_mul"::<u128,>( 0x2422554cc788d5b23ab84974b7958c99 u128, 0x325392966d82c166293facdad4e26261 u128, ), bb245, bb399)
	sub128_o(var4183, var4184, &var819);
	// ^ Call( _819 = "overflowing_sub"::<u128,>( _4183, _4184, ), bb246, bb399)
	var817 = add128(var819, make128_raw(1787798023079138386ull, 13735197021902332512ull));	// _817 = BinOp(_819 ADD 0x18cf88d46fc71452be9d38eb527de260 u128)
	add128_o(var3, make128_raw(10297492591351466530ull, 13315938990363791625ull), &var4185);
	// ^ Call( _4185 = "overflowing_add"::<u128,>( _3, 0x8ee80af410b88a22b8cbb7f5fb685109 u128, ), bb247, bb399)
	var4186 = shr128(var9, make128_raw(0ull, 75ull).lo);
	// ^ Call( _4186 = "unchecked_shr"::<u128,>( _9, 0x4b u128, ), bb248, bb399)
	add128_o(var4185, var4186, &var4187);
	// ^ Call( _4187 = "overflowing_add"::<u128,>( _4185, _4186, ), bb249, bb399)
	mul128_o(var4187, make128_raw(13963171953791278946ull, 18195070981974767459ull), &var4193);
	// ^ Call( _4193 = "overflowing_mul"::<u128,>( _4187, 0xc1c726e9736d1f62fc81e0a80f9fb763 u128, ), bb250, bb399)
	var4190 = mod128(var9, var14);	// _4190 = BinOp(_9 MOD _14)
	var4191 = var34 * var6;	// _4191 = BinOp(_34 MUL _6)
	var4188 = var4191 & 0x7f;	// _4188 = BinOp(_4191 BIT_AND 0x7f u32)
	var4189.lo = var4188; var4189.hi = var4188 < 0 ? -1 : 0;	// _4189 = Cast(_4188 as u128)
	var4192 = shr128(var4190, var4189.lo);
	// ^ Call( _4192 = "unchecked_shr"::<u128,>( _4190, _4189, ), bb251, bb399)
	mul128_o(make128_raw(10903137768703443216ull, 10384230357203478359ull), var4192, &var4194);
	// ^ Call( _4194 = "overflowing_mul"::<u128,>( 0x974fba0888b6c110901c327deaf0e757 u128, _4192, ), bb252, bb399)
	var820 = mod128(var4193, var4194);	// _820 = BinOp(_4193 MOD _4194)
	var57 = or128(var817, var820);	// _57 = BinOp(_817 BIT_OR _820)
	__builtin_mul_overflow(-212960910699316903ll, var32, &var822);
	// ^ Call( _822 = "overflowing_mul"::<isize,>( -212960910699316903 isize, _32, ), bb253, bb399)
	var823 = var55 & 7095297920047343014ll;	// _823 = BinOp(_55 BIT_AND +7095297920047343014 isize)
	var821 = var822 ^ var823;	// _821 = BinOp(_822 BIT_XOR _823)
	var824 = var55 - var32;	// _824 = BinOp(_55 SUB _32)
	var825 = -var824;	// _825 = UniOp(_824 NEG)
	var4195 = var821 / var825;	// _4195 = BinOp(_821 DIV _825)
	var826 = 18128 ^ var52;	// _826 = BinOp(+18128 i16 BIT_XOR _52)
	var827 = (intptr_t )var826;	// _827 = Cast(_826 as isize)
	var4196 = -4559354874850638888ll + var827;	// _4196 = BinOp(-4559354874850638888 isize ADD _827)
	__builtin_mul_overflow(var4195, var4196, &var828);
	// ^ Call( _828 = "overflowing_mul"::<isize,>( _4195, _4196, ), bb254, bb399)
	var829 = var53 > var27;	// _829 = BinOp(_53 GT _27)
	var58 = !var829;	// _58 = UniOp(_829 INV)
	__builtin_mul_overflow(0x2ea6c6bce93ddfa1ull, 0x91581a316993def9ull, &var4197);
	// ^ Call( _4197 = "overflowing_mul"::<usize,>( 0x2ea6c6bce93ddfa1 usize, 0x91581a316993def9 usize, ), bb255, bb399)
	var4198 = var27 ^ 0xf85760423976b3bdull;	// _4198 = BinOp(_27 BIT_XOR 0xf85760423976b3bd usize)
	__builtin_sub_overflow(var4197, var4198, &var4199);
	// ^ Call( _4199 = "overflowing_sub"::<usize,>( _4197, _4198, ), bb256, bb399)
	var4200 = 0xd1caeaab791d9c9cull << 0x25ull;
	// ^ Call( _4200 = "unchecked_shl"::<usize,>( 0xd1caeaab791d9c9c usize, 0x25 usize, ), bb257, bb399)
	__builtin_sub_overflow(var4199, var4200, &var830);
	// ^ Call( _830 = "overflowing_sub"::<usize,>( _4199, _4200, ), bb258, bb399)
	var59 = -49;	// _59 = Constant(-49 i8)
	mul128_o(var14, make128_raw(12495966943414154570ull, 17263135506864480310ull), &var831);
	// ^ Call( _831 = "overflowing_mul"::<u128,>( _14, 0xad6a97ba8339754aef92fa478c172036 u128, ), bb259, bb399)
	var832 = div128(var9, make128_raw(5591331700668560290ull, 9932657202715252604ull));	// _832 = BinOp(_9 DIV 0x4d98668ebfbaf3a289d7e319b391577c u128)
	var4203 = xor128(var831, var832);	// _4203 = BinOp(_831 BIT_XOR _832)
	var4201 = var25 & 0x7f;	// _4201 = BinOp(_25 BIT_AND 0x7f u32)
	var4202.lo = var4201; var4202.hi = var4201 < 0 ? -1 : 0;	// _4202 = Cast(_4201 as u128)
	var833 = shr128(var4203, var4202.lo);
	// ^ Call( _833 = "unchecked_shr"::<u128,>( _4203, _4202, ), bb260, bb399)
	__builtin_add_overflow(var2, 0x6c52974a, &var4205);
	// ^ Call( _4205 = "overflowing_add"::<u32,>( _2, 0x6c52974a u32, ), bb261, bb399)
	var4206 = var47 << 0x11;
	// ^ Call( _4206 = "unchecked_shl"::<u32,>( _47, 0x11 u32, ), bb262, bb399)
	var4204 = var4206 & 0x1f;	// _4204 = BinOp(_4206 BIT_AND 0x1f u32)
	var834 = var4205 >> var4204;
	// ^ Call( _834 = "unchecked_shr"::<u32,>( _4205, _4204, ), bb263, bb399)
	var4207 = 0x27 | var54;	// _4207 = BinOp(0x27 u8 BIT_OR _54)
	var4208 = 0x0 * var7;	// _4208 = BinOp(0x0 u8 MUL _7)
	__builtin_add_overflow(var4207, var4208, &var835);
	// ^ Call( _835 = "overflowing_add"::<u8,>( _4207, _4208, ), bb264, bb399)
	var4209 = var49 & 0x3f;	// _4209 = BinOp(_49 BIT_AND 0x3f u32)
	var4210 = (intptr_t )var4209;	// _4210 = Cast(_4209 as isize)
	var836 = var55 << var4210;
	// ^ Call( _836 = "unchecked_shl"::<isize,>( _55, _4210, ), bb265, bb399)
	__builtin_sub_overflow(-2280188921596278315ll, var55, &var837);
	// ^ Call( _837 = "overflowing_sub"::<isize,>( -2280188921596278315 isize, _55, ), bb266, bb399)
	var4211 = var32 * 5362432580767606208ll;	// _4211 = BinOp(_32 MUL +5362432580767606208 isize)
	__builtin_sub_overflow(var4211, -6914327049137298907ll, &var838);
	// ^ Call( _838 = "overflowing_sub"::<isize,>( _4211, -6914327049137298907 isize, ), bb267, bb399)
	var60 = -var52;	// _60 = UniOp(_52 NEG)
	__builtin_sub_overflow(var6, 0xd652dd5c, &var839);
	// ^ Call( _839 = "overflowing_sub"::<u32,>( _6, 0xd652dd5c u32, ), bb268, bb399)
	var61 = var839 | var49;	// _61 = BinOp(_839 BIT_OR _49)
	var4215 = -25;	// _4215 = Constant(-25 i8)
	__builtin_sub_overflow(0xbe6c0e5b, var61, &var4212);
	// ^ Call( _4212 = "overflowing_sub"::<u32,>( 0xbe6c0e5b u32, _61, ), bb269, bb399)
	var4216 = var4212 / 0x7f;	// _4216 = BinOp(_4212 DIV 0x7f u32)
	var4213 = var4216 & 0x7;	// _4213 = BinOp(_4216 BIT_AND 0x7 u32)
	var4214 = (int8_t )var4213;	// _4214 = Cast(_4213 as i8)
	var840 = var4215 << var4214;
	// ^ Call( _840 = "unchecked_shl"::<i8,>( _4215, _4214, ), bb270, bb399)
	var842 = var19 & -68;	// _842 = BinOp(_19 BIT_AND -68 i8)
	var4222 = -var842;	// _4222 = UniOp(_842 NEG)
	var4219 = var59 + -34;	// _4219 = BinOp(_59 ADD -34 i8)
	var4220 = var22 % 0xb5a7bf86;	// _4220 = BinOp(_22 MOD 0xb5a7bf86 u32)
	var4217 = var4220 & 0x7;	// _4217 = BinOp(_4220 BIT_AND 0x7 u32)
	var4218 = (int8_t )var4217;	// _4218 = Cast(_4217 as i8)
	var4223 = var4219 << var4218;
	// ^ Call( _4223 = "unchecked_shl"::<i8,>( _4219, _4218, ), bb271, bb399)
	var4221 = ZRICb15overflowing_rem0g( var4222, var4223 );
	// ^ Call( _4221 = <i8 /*- */>::overflowing_rem( _4222, _4223, ), bb272, bb399)
	var843 = var4221._0;	// _843 = Use(_4221.0)
	var4228 = -27;	// _4228 = Constant(-27 i8)
	var4224 = ZRICb15overflowing_rem0g( 54, var59 );
	// ^ Call( _4224 = <i8 /*- */>::overflowing_rem( +54 i8, _59, ), bb273, bb399)
	__builtin_sub_overflow(0xd9a51de6, var25, &var4227);
	// ^ Call( _4227 = "overflowing_sub"::<u32,>( 0xd9a51de6 u32, _25, ), bb274, bb399)
	var4225 = var4227 & 0x7;	// _4225 = BinOp(_4227 BIT_AND 0x7 u32)
	var4226 = (int8_t )var4225;	// _4226 = Cast(_4225 as i8)
	var4229 = var4224._0 >> var4226;
	// ^ Call( _4229 = "unchecked_shr"::<i8,>( _4224.0, _4226, ), bb275, bb399)
	__builtin_add_overflow(var4228, var4229, &var844);
	// ^ Call( _844 = "overflowing_add"::<i8,>( _4228, _4229, ), bb276, bb399)
	var841 = var843 & var844;	// _841 = BinOp(_843 BIT_AND _844)
	var845 = -var19;	// _845 = UniOp(_19 NEG)
	var846 = -var845;	// _846 = UniOp(_845 NEG)
	var62 = var841 - var846;	// _62 = BinOp(_841 SUB _846)
	var63 = 0xe9;	// _63 = Constant(0xe9 u8)
	var847 = 539381523886160864ll;	// _847 = Constant(+539381523886160864 isize)
	var848 = var55 << 32ll;
	// ^ Call( _848 = "unchecked_shl"::<isize,>( _55, +32 isize, ), bb277, bb399)
	var4231 = var847 - var848;	// _4231 = BinOp(_847 SUB _848)
	var4232 = var55 ^ 9135738492385831775ll;	// _4232 = BinOp(_55 BIT_XOR +9135738492385831775 isize)
	var4230 = ZRICv15overflowing_rem0g( var4231, var4232 );
	// ^ Call( _4230 = <isize /*- */>::overflowing_rem( _4231, _4232, ), bb278, bb399)
	var850 = (uint32_t )var36;	// _850 = Cast(_36 as u32)
	var851 = 0xe5be7b52 << 0x19;
	// ^ Call( _851 = "unchecked_shl"::<u32,>( 0xe5be7b52 u32, 0x19 u32, ), bb279, bb399)
	var849 = var850 / var851;	// _849 = BinOp(_850 DIV _851)
	var4235 = var849 | var22;	// _4235 = BinOp(_849 BIT_OR _22)
	var4233 = var4235 & 0x3f;	// _4233 = BinOp(_4235 BIT_AND 0x3f u32)
	var4234 = (intptr_t )var4233;	// _4234 = Cast(_4233 as isize)
	var852 = var4230._0 >> var4234;
	// ^ Call( _852 = "unchecked_shr"::<isize,>( _4230.0, _4234, ), bb280, bb399)
	var64 = -var852;	// _64 = UniOp(_852 NEG)
	var4236.lo = var33; var4236.hi = var33 < 0 ? -1 : 0;	// _4236 = Cast(_33 as i128)
	add128s_o(var4236, var28, &var854);
	// ^ Call( _854 = "overflowing_add"::<i128,>( _4236, _28, ), bb281, bb399)
	var856 = make128s_raw(18064835514404941367ull, 1127827600262663731ull);	// _856 = Constant(-7044969453051271946606794615165448653 i128)
	mul128s_o(make128s_raw(16288445511910060219ull, 6644437347366079535ull), var48, &var857);
	// ^ Call( _857 = "overflowing_mul"::<i128,>( -39813581204170616367715107622353368017 i128, _48, ), bb282, bb399)
	var855 = xor128s(var856, var857);	// _855 = BinOp(_856 BIT_XOR _857)
	var853 = div128s(var854, var855);	// _853 = BinOp(_854 DIV _855)
	var858 = neg128s(var853);	// _858 = UniOp(_853 NEG)
	var65 = neg128s(var858);	// _65 = UniOp(_858 NEG)
	var66 = var45;	// _66 = Use(_45)
	var860 = shl128(make128_raw(0ull, 2613531666ull), make128_raw(0ull, 19ull).lo);
	// ^ Call( _860 = "unchecked_shl"::<u128,>( 0x9bc75412 u128, 0x13 u128, ), bb283, bb399)
	var861 = var860.lo;	// _861 = Cast(_860 as u32)
	var864 = var25 ^ var25;	// _864 = BinOp(_25 BIT_XOR _25)
	var863 = var864 ^ 0x646775e1;	// _863 = BinOp(_864 BIT_XOR 0x646775e1 u32)
	var866 = var49 >> 0x19;
	// ^ Call( _866 = "unchecked_shr"::<u32,>( _49, 0x19 u32, ), bb284, bb399)
	var865 = 0x5c74cf2c / var866;	// _865 = BinOp(0x5c74cf2c u32 DIV _866)
	var862 = var863 / var865;	// _862 = BinOp(_863 DIV _865)
	var859 = var861 | var862;	// _859 = BinOp(_861 BIT_OR _862)
	var67 = var859 / 0x6fd86c9a;	// _67 = BinOp(_859 DIV 0x6fd86c9a u32)
	__builtin_sub_overflow(0x1b8ef3ce, var47, &var4237);
	// ^ Call( _4237 = "overflowing_sub"::<u32,>( 0x1b8ef3ce u32, _47, ), bb285, bb399)
	__builtin_mul_overflow(0x3cbe3d15, var4237, &var868);
	// ^ Call( _868 = "overflowing_mul"::<u32,>( 0x3cbe3d15 u32, _4237, ), bb286, bb399)
	var869 = (uint8_t )var868;	// _869 = Cast(_868 as u8)
	var867 = var869 / 0x55;	// _867 = BinOp(_869 DIV 0x55 u8)
	var68 = (uint16_t )var867;	// _68 = Cast(_867 as u16)
	var871 = 0x9358 | var39;	// _871 = BinOp(0x9358 u16 BIT_OR _39)
	var872 = var39 / 0x657a;	// _872 = BinOp(_39 DIV 0x657a u16)
	var870 = var871 * var872;	// _870 = BinOp(_871 MUL _872)
	__builtin_add_overflow(0x6b99, var45, &var873);
	// ^ Call( _873 = "overflowing_add"::<u16,>( 0x6b99 u16, _45, ), bb287, bb399)
	var4240 = var870 + var873;	// _4240 = BinOp(_870 ADD _873)
	var4241 = (uint32_t )var11;	// _4241 = Cast(_11 as u32)
	var4238 = var4241 & 0xf;	// _4238 = BinOp(_4241 BIT_AND 0xf u32)
	var4239 = (uint16_t )var4238;	// _4239 = Cast(_4238 as u16)
	var4247 = var4240 >> var4239;
	// ^ Call( _4247 = "unchecked_shr"::<u16,>( _4240, _4239, ), bb288, bb399)
	var4242 = var22 % var22;	// _4242 = BinOp(_22 MOD _22)
	__builtin_add_overflow(var61, var4242, &var4243);
	// ^ Call( _4243 = "overflowing_add"::<u32,>( _61, _4242, ), bb289, bb399)
	var875 = 0xcf2d64ec << 0xe;
	// ^ Call( _875 = "unchecked_shl"::<u32,>( 0xcf2d64ec u32, 0xe u32, ), bb290, bb399)
	__builtin_sub_overflow(0xd9d4e00, 0x648cced, &var876);
	// ^ Call( _876 = "overflowing_sub"::<u32,>( 0xd9d4e00 u32, 0x648cced u32, ), bb291, bb399)
	var874 = var875 - var876;	// _874 = BinOp(_875 SUB _876)
	var4244 = var874 + 0x9f862b0;	// _4244 = BinOp(_874 ADD 0x9f862b0 u32)
	var4248 = var4243 % var4244;	// _4248 = BinOp(_4243 MOD _4244)
	var4245 = var4248 & 0xf;	// _4245 = BinOp(_4248 BIT_AND 0xf u32)
	var4246 = (uint16_t )var4245;	// _4246 = Cast(_4245 as u16)
	var877 = var4247 >> var4246;
	// ^ Call( _877 = "unchecked_shr"::<u16,>( _4247, _4246, ), bb292, bb399)
	__builtin_sub_overflow(var11, var18, &var878);
	// ^ Call( _878 = "overflowing_sub"::<u16,>( _11, _18, ), bb293, bb399)
	var4251 = var878 * var23;	// _4251 = BinOp(_878 MUL _23)
	var879 = var45 * 0x95c;	// _879 = BinOp(_45 MUL 0x95c u16)
	var4249 = var51 & 0xf;	// _4249 = BinOp(_51 BIT_AND 0xf u32)
	var4250 = (uint16_t )var4249;	// _4250 = Cast(_4249 as u16)
	var880 = 0x3dc8 << var4250;
	// ^ Call( _880 = "unchecked_shl"::<u16,>( 0x3dc8 u16, _4250, ), bb294, bb399)
	var4252 = var879 ^ var880;	// _4252 = BinOp(_879 BIT_XOR _880)
	var4255 = var4251 / var4252;	// _4255 = BinOp(_4251 DIV _4252)
	var881 = (uint32_t )var53;	// _881 = Cast(_53 as u32)
	var4253 = (uint16_t )var881;	// _4253 = Cast(_881 as u16)
	var882 = 0x2f02 ^ var39;	// _882 = BinOp(0x2f02 u16 BIT_XOR _39)
	var4254 = var882 ^ var24;	// _4254 = BinOp(_882 BIT_XOR _24)
	__builtin_mul_overflow(var4253, var4254, &var4256);
	// ^ Call( _4256 = "overflowing_mul"::<u16,>( _4253, _4254, ), bb295, bb399)
	__builtin_add_overflow(var4255, var4256, &var883);
	// ^ Call( _883 = "overflowing_add"::<u16,>( _4255, _4256, ), bb296, bb399)
	var69 = (uint8_t )var883;	// _69 = Cast(_883 as u8)
	var884 = var10 * var43;	// _884 = BinOp(_10 MUL _43)
	var885 = -var884;	// _885 = UniOp(_884 NEG)
	var886 = -var885;	// _886 = UniOp(_885 NEG)
	var4259 = var886 ^ -24577;	// _4259 = BinOp(_886 BIT_XOR -24577 i16)
	var888 = -var60;	// _888 = UniOp(_60 NEG)
	var4257 = var52 ^ var52;	// _4257 = BinOp(_52 BIT_XOR _52)
	__builtin_sub_overflow(var4257, -1229, &var889);
	// ^ Call( _889 = "overflowing_sub"::<i16,>( _4257, -1229 i16, ), bb297, bb399)
	var887 = var888 + var889;	// _887 = BinOp(_888 ADD _889)
	var4260 = -var887;	// _4260 = UniOp(_887 NEG)
	var4258 = ZRICd15overflowing_rem0g( var4259, var4260 );
	// ^ Call( _4258 = <i16 /*- */>::overflowing_rem( _4259, _4260, ), bb298, bb399)
	var70 = var4258._0;	// _70 = Use(_4258.0)
	var890 = var47 / 0x1b637e24;	// _890 = BinOp(_47 DIV 0x1b637e24 u32)
	var891 = (uintptr_t )var890;	// _891 = Cast(_890 as usize)
	var892 = -var56;	// _892 = UniOp(_56 NEG)
	var893 = (uintptr_t )var892;	// _893 = Cast(_892 as usize)
	var4261 = var891 & var893;	// _4261 = BinOp(_891 BIT_AND _893)
	var894 = 0x68a21369de043b49ull - var53;	// _894 = BinOp(0x68a21369de043b49 usize SUB _53)
	var4262 = var894 & var53;	// _4262 = BinOp(_894 BIT_AND _53)
	__builtin_sub_overflow(var4261, var4262, &var895);
	// ^ Call( _895 = "overflowing_sub"::<usize,>( _4261, _4262, ), bb299, bb399)
	var4264 = 0x3e68;	// _4264 = Constant(0x3e68 u32)
	var4263 = var47 & 0x1f;	// _4263 = BinOp(_47 BIT_AND 0x1f u32)
	var4265 = 0x95cd89f3 >> var4263;
	// ^ Call( _4265 = "unchecked_shr"::<u32,>( 0x95cd89f3 u32, _4263, ), bb300, bb399)
	__builtin_sub_overflow(var4264, var4265, &var4266);
	// ^ Call( _4266 = "overflowing_sub"::<u32,>( _4264, _4265, ), bb301, bb399)
	var896 = (uint32_t )var46;	// _896 = Cast(_46 as u32)
	var897 = 0x724183c6 / var22;	// _897 = BinOp(0x724183c6 u32 DIV _22)
	var4267 = var896 ^ var897;	// _4267 = BinOp(_896 BIT_XOR _897)
	var898 = var4266 % var4267;	// _898 = BinOp(_4266 MOD _4267)
	var4268 = var6 & 0x1f;	// _4268 = BinOp(_6 BIT_AND 0x1f u32)
	var4269 = 0x8ddc3d7c << var4268;
	// ^ Call( _4269 = "unchecked_shl"::<u32,>( 0x8ddc3d7c u32, _4268, ), bb302, bb399)
	__builtin_mul_overflow(var61, var4269, &var899);
	// ^ Call( _899 = "overflowing_mul"::<u32,>( _61, _4269, ), bb303, bb399)
	var4273 = var898 * var899;	// _4273 = BinOp(_898 MUL _899)
	var4270 = 0xcf80cb77 & var6;	// _4270 = BinOp(0xcf80cb77 u32 BIT_AND _6)
	var4271 = 0x0 % var4270;	// _4271 = BinOp(0x0 u32 MOD _4270)
	var900 = var4271 << 0x13;
	// ^ Call( _900 = "unchecked_shl"::<u32,>( _4271, 0x13 u32, ), bb304, bb399)
	var4274 = var900 / 0x77350f6;	// _4274 = BinOp(_900 DIV 0x77350f6 u32)
	var4272 = var4274 & 0x1f;	// _4272 = BinOp(_4274 BIT_AND 0x1f u32)
	var71 = var4273 << var4272;
	// ^ Call( _71 = "unchecked_shl"::<u32,>( _4273, _4272, ), bb305, bb399)
	var72 = 20175;	// _72 = Constant(+20175 i16)
	var901 = 1 / var4;	// _901 = BinOp(+1 i8 DIV _4)
	var902 = -var901;	// _902 = UniOp(_901 NEG)
	var903 = -var902;	// _903 = UniOp(_902 NEG)
	var4275 = var47 & 0x7;	// _4275 = BinOp(_47 BIT_AND 0x7 u32)
	var4276 = (int8_t )var4275;	// _4276 = Cast(_4275 as i8)
	var904 = 24 << var4276;
	// ^ Call( _904 = "unchecked_shl"::<i8,>( +24 i8, _4276, ), bb306, bb399)
	var73 = var903 * var904;	// _73 = BinOp(_903 MUL _904)
	var4277 = var53 + var53;	// _4277 = BinOp(_53 ADD _53)
	var4278 = 0x10a25db0c1f85b9cull % var4277;	// _4278 = BinOp(0x10a25db0c1f85b9c usize MOD _4277)
	__builtin_sub_overflow(0x2ddb8d4ull, var4278, &var4279);
	// ^ Call( _4279 = "overflowing_sub"::<usize,>( 0x2ddb8d4 usize, _4278, ), bb307, bb399)
	__builtin_sub_overflow(var4279, 0x6acf87692a1082eeull, &var4280);
	// ^ Call( _4280 = "overflowing_sub"::<usize,>( _4279, 0x6acf87692a1082ee usize, ), bb308, bb399)
	__builtin_add_overflow(var53, var4280, &var905);
	// ^ Call( _905 = "overflowing_add"::<usize,>( _53, _4280, ), bb309, bb399)
	var907 = var71 | var25;	// _907 = BinOp(_71 BIT_OR _25)
	var4281 = var6 & 0x1f;	// _4281 = BinOp(_6 BIT_AND 0x1f u32)
	var908 = 0x59b0daf5 >> var4281;
	// ^ Call( _908 = "unchecked_shr"::<u32,>( 0x59b0daf5 u32, _4281, ), bb310, bb399)
	var906 = var907 ^ var908;	// _906 = BinOp(_907 BIT_XOR _908)
	var4282 = var47 / var906;	// _4282 = BinOp(_47 DIV _906)
	__builtin_sub_overflow(var4282, 0xa337172b, &var909);
	// ^ Call( _909 = "overflowing_sub"::<u32,>( _4282, 0xa337172b u32, ), bb311, bb399)
	var4283 = ZRICj15overflowing_rem0g( var20, make128s_raw(13913373976203877778ull, 16197675453824638665ull) );
	// ^ Call( _4283 = <i128 /*- */>::overflowing_rem( _20, -83625917980094881017411215161097183543 i128, ), bb312, bb399)
	var4285 = var4283._0.lo;	// _4285 = Cast(_4283.0 as u32)
	var4284 = var25 & 0x1f;	// _4284 = BinOp(_25 BIT_AND 0x1f u32)
	var4286 = var4285 << var4284;
	// ^ Call( _4286 = "unchecked_shl"::<u32,>( _4285, _4284, ), bb313, bb399)
	var911 = -var52;	// _911 = UniOp(_52 NEG)
	var912 = var10 - -25712;	// _912 = BinOp(_10 SUB -25712 i16)
	var910 = var911 / var912;	// _910 = BinOp(_911 DIV _912)
	var4287 = (uint32_t )var910;	// _4287 = Cast(_910 as u32)
	__builtin_mul_overflow(var4286, var4287, &var913);
	// ^ Call( _913 = "overflowing_mul"::<u32,>( _4286, _4287, ), bb314, bb399)
	var74 = 0x0ull;	// _74 = Constant(0x0 u64)
	__builtin_sub_overflow(6260787920672676941ll, -7857903449776528431ll, &var914);
	// ^ Call( _914 = "overflowing_sub"::<i64,>( +6260787920672676941 i64, -7857903449776528431 i64, ), bb315, bb399)
	__builtin_add_overflow(-134979100843130902ll, 102ll, &var915);
	// ^ Call( _915 = "overflowing_add"::<i64,>( -134979100843130902 i64, +102 i64, ), bb316, bb399)
	var4288 = var47 & 0x3f;	// _4288 = BinOp(_47 BIT_AND 0x3f u32)
	var4289 = (int64_t )var4288;	// _4289 = Cast(_4288 as i64)
	var4292 = 5526550070728971831ll << var4289;
	// ^ Call( _4292 = "unchecked_shl"::<i64,>( +5526550070728971831 i64, _4289, ), bb317, bb399)
	var4293 = 0xb86311e0 / var61;	// _4293 = BinOp(0xb86311e0 u32 DIV _61)
	var4290 = var4293 & 0x3f;	// _4290 = BinOp(_4293 BIT_AND 0x3f u32)
	var4291 = (int64_t )var4290;	// _4291 = Cast(_4290 as i64)
	var4297 = var4292 >> var4291;
	// ^ Call( _4297 = "unchecked_shr"::<i64,>( _4292, _4291, ), bb318, bb399)
	var4294 = var41 & 0x1f;	// _4294 = BinOp(_41 BIT_AND 0x1f u32)
	var916 = 0x246b973c << var4294;
	// ^ Call( _916 = "unchecked_shl"::<u32,>( 0x246b973c u32, _4294, ), bb319, bb399)
	var4298 = var916 ^ var49;	// _4298 = BinOp(_916 BIT_XOR _49)
	var4295 = var4298 & 0x3f;	// _4295 = BinOp(_4298 BIT_AND 0x3f u32)
	var4296 = (int64_t )var4295;	// _4296 = Cast(_4295 as i64)
	var917 = var4297 >> var4296;
	// ^ Call( _917 = "unchecked_shr"::<i64,>( _4297, _4296, ), bb320, bb399)
	var75 = 30514;	// _75 = Constant(+30514 i16)
	var4301 = var41 & var6;	// _4301 = BinOp(_41 BIT_AND _6)
	var4299 = var4301 & 0x3f;	// _4299 = BinOp(_4301 BIT_AND 0x3f u32)
	var4300 = (uintptr_t )var4299;	// _4300 = Cast(_4299 as usize)
	var4302 = 0xff6116307dd0dc1full >> var4300;
	// ^ Call( _4302 = "unchecked_shr"::<usize,>( 0xff6116307dd0dc1f usize, _4300, ), bb321, bb399)
	__builtin_sub_overflow(var53, var4302, &var919);
	// ^ Call( _919 = "overflowing_sub"::<usize,>( _53, _4302, ), bb322, bb399)
	var4306 = 0x8f9577e619f0a218ull % var53;	// _4306 = BinOp(0x8f9577e619f0a218 usize MOD _53)
	var4305 = 0x240558b27d4e3c90ull & var53;	// _4305 = BinOp(0x240558b27d4e3c90 usize BIT_AND _53)
	var4303 = var49 & 0x3f;	// _4303 = BinOp(_49 BIT_AND 0x3f u32)
	var4304 = (uintptr_t )var4303;	// _4304 = Cast(_4303 as usize)
	var4307 = var4305 << var4304;
	// ^ Call( _4307 = "unchecked_shl"::<usize,>( _4305, _4304, ), bb323, bb399)
	var920 = var4306 / var4307;	// _920 = BinOp(_4306 DIV _4307)
	var918 = var919 * var920;	// _918 = BinOp(_919 MUL _920)
	var921 = var27 << 0x2cull;
	// ^ Call( _921 = "unchecked_shl"::<usize,>( _27, 0x2c usize, ), bb324, bb399)
	var76 = var918 + var921;	// _76 = BinOp(_918 ADD _921)
	var77 = var63;	// _77 = Use(_63)
	var922 = var39 & var66;	// _922 = BinOp(_39 BIT_AND _66)
	var4308 = var45 - var922;	// _4308 = BinOp(_45 SUB _922)
	var4311 = var4308 / 0xc2ab;	// _4311 = BinOp(_4308 DIV 0xc2ab u16)
	var923 = neg128s(var48);	// _923 = UniOp(_48 NEG)
	var4309 = var923.lo;	// _4309 = Cast(_923 as u16)
	__builtin_add_overflow(var46, 0x9cd4, &var924);
	// ^ Call( _924 = "overflowing_add"::<u16,>( _46, 0x9cd4 u16, ), bb325, bb399)
	__builtin_sub_overflow(0x2ab7, 0x8ec4, &var925);
	// ^ Call( _925 = "overflowing_sub"::<u16,>( 0x2ab7 u16, 0x8ec4 u16, ), bb326, bb399)
	var4310 = var924 - var925;	// _4310 = BinOp(_924 SUB _925)
	__builtin_add_overflow(var4309, var4310, &var4312);
	// ^ Call( _4312 = "overflowing_add"::<u16,>( _4309, _4310, ), bb327, bb399)
	__builtin_sub_overflow(var4311, var4312, &var926);
	// ^ Call( _926 = "overflowing_sub"::<u16,>( _4311, _4312, ), bb328, bb399)
	var927 = 0x270d >> 0xa;
	// ^ Call( _927 = "unchecked_shr"::<u16,>( 0x270d u16, 0xa u16, ), bb329, bb399)
	var4313 = var927 * var18;	// _4313 = BinOp(_927 MUL _18)
	var4314 = 0xc936 * var39;	// _4314 = BinOp(0xc936 u16 MUL _39)
	__builtin_mul_overflow(var4313, var4314, &var4318);
	// ^ Call( _4318 = "overflowing_mul"::<u16,>( _4313, _4314, ), bb330, bb399)
	var928 = (uint16_t )var7;	// _928 = Cast(_7 as u16)
	var4316 = var928 - var11;	// _4316 = BinOp(_928 SUB _11)
	var4315 = var41 & 0x1f;	// _4315 = BinOp(_41 BIT_AND 0x1f u32)
	var929 = 0xcbc9e5b4 << var4315;
	// ^ Call( _929 = "unchecked_shl"::<u32,>( 0xcbc9e5b4 u32, _4315, ), bb331, bb399)
	var4317 = (uint16_t )var929;	// _4317 = Cast(_929 as u16)
	__builtin_mul_overflow(var4316, var4317, &var4319);
	// ^ Call( _4319 = "overflowing_mul"::<u16,>( _4316, _4317, ), bb332, bb399)
	__builtin_sub_overflow(var4318, var4319, &var930);
	// ^ Call( _930 = "overflowing_sub"::<u16,>( _4318, _4319, ), bb333, bb399)
	var78 = var63;	// _78 = Use(_63)
	var4321 = 14773074325963907ll;	// _4321 = Constant(+14773074325963907 i64)
	__builtin_add_overflow(-3913323603561150878ll, 7030265488881652640ll, &var931);
	// ^ Call( _931 = "overflowing_add"::<i64,>( -3913323603561150878 i64, +7030265488881652640 i64, ), bb334, bb399)
	var4322 = -var931;	// _4322 = UniOp(_931 NEG)
	var4320 = ZRICh15overflowing_div0g( var4321, var4322 );
	// ^ Call( _4320 = <i64 /*- */>::overflowing_div( _4321, _4322, ), bb335, bb399)
	var4323 = ZRICh15overflowing_rem0g( var4320._0, 3459397868659966888ll );
	// ^ Call( _4323 = <i64 /*- */>::overflowing_rem( _4320.0, +3459397868659966888 i64, ), bb336, bb399)
	var4324 = 6969451812974465189ll << 4ll;
	// ^ Call( _4324 = "unchecked_shl"::<i64,>( +6969451812974465189 i64, +4 i64, ), bb337, bb399)
	__builtin_sub_overflow(var4324, 7739699868511589586ll, &var4325);
	// ^ Call( _4325 = "overflowing_sub"::<i64,>( _4324, +7739699868511589586 i64, ), bb338, bb399)
	__builtin_sub_overflow(var4325, 1ll, &var932);
	// ^ Call( _932 = "overflowing_sub"::<i64,>( _4325, +1 i64, ), bb339, bb399)
	var4326 = -var932;	// _4326 = UniOp(_932 NEG)
	__builtin_mul_overflow(var4323._0, var4326, &var933);
	// ^ Call( _933 = "overflowing_mul"::<i64,>( _4323.0, _4326, ), bb340, bb399)
	__builtin_sub_overflow(var34, var67, &var934);
	// ^ Call( _934 = "overflowing_sub"::<u32,>( _34, _67, ), bb341, bb399)
	var935 = 0x7ae43841 << 0x19;
	// ^ Call( _935 = "unchecked_shl"::<u32,>( 0x7ae43841 u32, 0x19 u32, ), bb342, bb399)
	var4327 = var934 - var935;	// _4327 = BinOp(_934 SUB _935)
	var4328 = var4327 << 0x1;
	// ^ Call( _4328 = "unchecked_shl"::<u32,>( _4327, 0x1 u32, ), bb343, bb399)
	var4330 = var4328 << 0x1b;
	// ^ Call( _4330 = "unchecked_shl"::<u32,>( _4328, 0x1b u32, ), bb344, bb399)
	var4329 = var4330 & 0x1f;	// _4329 = BinOp(_4330 BIT_AND 0x1f u32)
	var79 = var22 >> var4329;
	// ^ Call( _79 = "unchecked_shr"::<u32,>( _22, _4329, ), bb345, bb399)
	var4336 = -58;	// _4336 = Constant(-58 i8)
	var4331 = var49 & 0x1f;	// _4331 = BinOp(_49 BIT_AND 0x1f u32)
	var4333 = 0xdfbc5c8e >> var4331;
	// ^ Call( _4333 = "unchecked_shr"::<u32,>( 0xdfbc5c8e u32, _4331, ), bb346, bb399)
	var4332 = var71 & 0x1f;	// _4332 = BinOp(_71 BIT_AND 0x1f u32)
	var4337 = var4333 << var4332;
	// ^ Call( _4337 = "unchecked_shl"::<u32,>( _4333, _4332, ), bb347, bb399)
	var4334 = var4337 & 0x7;	// _4334 = BinOp(_4337 BIT_AND 0x7 u32)
	var4335 = (int8_t )var4334;	// _4335 = Cast(_4334 as i8)
	var4344 = var4336 >> var4335;
	// ^ Call( _4344 = "unchecked_shr"::<i8,>( _4336, _4335, ), bb348, bb399)
	var4338 = ZRICb15overflowing_rem0g( var62, 117 );
	// ^ Call( _4338 = <i8 /*- */>::overflowing_rem( _62, +117 i8, ), bb349, bb399)
	var4339 = ZRICb15overflowing_rem0g( 16, -19 );
	// ^ Call( _4339 = <i8 /*- */>::overflowing_rem( +16 i8, -19 i8, ), bb350, bb399)
	var4340 = ZRICb15overflowing_div0g( var4338._0, var4339._0 );
	// ^ Call( _4340 = <i8 /*- */>::overflowing_div( _4338.0, _4339.0, ), bb351, bb399)
	var936 = var4340._0;	// _936 = Use(_4340.0)
	var4343 = var34 / 0x279d3f83;	// _4343 = BinOp(_34 DIV 0x279d3f83 u32)
	var4341 = var4343 & 0x7;	// _4341 = BinOp(_4343 BIT_AND 0x7 u32)
	var4342 = (int8_t )var4341;	// _4342 = Cast(_4341 as i8)
	var937 = 54 >> var4342;
	// ^ Call( _937 = "unchecked_shr"::<i8,>( +54 i8, _4342, ), bb352, bb399)
	var4345 = var936 / var937;	// _4345 = BinOp(_936 DIV _937)
	__builtin_mul_overflow(var4344, var4345, &var938);
	// ^ Call( _938 = "overflowing_mul"::<i8,>( _4344, _4345, ), bb353, bb399)
	var80 = -var938;	// _80 = UniOp(_938 NEG)
	var4346 = var79 & 0x7;	// _4346 = BinOp(_79 BIT_AND 0x7 u32)
	var4347 = (uint8_t )var4346;	// _4347 = Cast(_4346 as u8)
	var4352 = 0x66 << var4347;
	// ^ Call( _4352 = "unchecked_shl"::<u8,>( 0x66 u8, _4347, ), bb354, bb399)
	__builtin_mul_overflow(0xac31ac70, var6, &var939);
	// ^ Call( _939 = "overflowing_mul"::<u32,>( 0xac31ac70 u32, _6, ), bb355, bb399)
	var940 = 0x6d93395 ^ var67;	// _940 = BinOp(0x6d93395 u32 BIT_XOR _67)
	var4349 = var939 - var940;	// _4349 = BinOp(_939 SUB _940)
	var4348 = var4349 & 0x1f;	// _4348 = BinOp(_4349 BIT_AND 0x1f u32)
	var4353 = 0x6fc9780b << var4348;
	// ^ Call( _4353 = "unchecked_shl"::<u32,>( 0x6fc9780b u32, _4348, ), bb356, bb399)
	var4350 = var4353 & 0x7;	// _4350 = BinOp(_4353 BIT_AND 0x7 u32)
	var4351 = (uint8_t )var4350;	// _4351 = Cast(_4350 as u8)
	var941 = var4352 >> var4351;
	// ^ Call( _941 = "unchecked_shr"::<u8,>( _4352, _4351, ), bb357, bb399)
	var942 = var20.lo;	// _942 = Cast(_20 as u64)
	var943 = (uint8_t )var942;	// _943 = Cast(_942 as u8)
	var81 = var941 * var943;	// _81 = BinOp(_941 MUL _943)
	var945 = -var15;	// _945 = UniOp(_15 NEG)
	var946 = -var945;	// _946 = UniOp(_945 NEG)
	var948 = var33 + -1840988430;	// _948 = BinOp(_33 ADD -1840988430 i32)
	__builtin_add_overflow(-416061910, var56, &var949);
	// ^ Call( _949 = "overflowing_add"::<i32,>( -416061910 i32, _56, ), bb358, bb399)
	var947 = var948 ^ var949;	// _947 = BinOp(_948 BIT_XOR _949)
	var944 = var946 | var947;	// _944 = BinOp(_946 BIT_OR _947)
	var950 = -var33;	// _950 = UniOp(_33 NEG)
	var951 = -var950;	// _951 = UniOp(_950 NEG)
	var4355 = var944 & var951;	// _4355 = BinOp(_944 BIT_AND _951)
	var952 = var33 + 277706258;	// _952 = BinOp(_33 ADD +277706258 i32)
	var953 = var56 | -1567457;	// _953 = BinOp(_56 BIT_OR -1567457 i32)
	var4354 = var952 ^ var953;	// _4354 = BinOp(_952 BIT_XOR _953)
	__builtin_mul_overflow(1533495437, var4354, &var954);
	// ^ Call( _954 = "overflowing_mul"::<i32,>( +1533495437 i32, _4354, ), bb359, bb399)
	var4356 = -var954;	// _4356 = UniOp(_954 NEG)
	__builtin_add_overflow(var4355, var4356, &var955);
	// ^ Call( _955 = "overflowing_add"::<i32,>( _4355, _4356, ), bb360, bb399)
	var956 = 0xb << 0x1;
	// ^ Call( _956 = "unchecked_shl"::<u8,>( 0xb u8, 0x1 u8, ), bb361, bb399)
	var4357 = var71 & 0xf;	// _4357 = BinOp(_71 BIT_AND 0xf u32)
	var4358 = (uint16_t )var4357;	// _4358 = Cast(_4357 as u16)
	var957 = 0xdadc >> var4358;
	// ^ Call( _957 = "unchecked_shr"::<u16,>( 0xdadc u16, _4358, ), bb362, bb399)
	var4361 = 0x3e ^ var78;	// _4361 = BinOp(0x3e u8 BIT_XOR _78)
	__builtin_sub_overflow(var71, var22, &var4362);
	// ^ Call( _4362 = "overflowing_sub"::<u32,>( _71, _22, ), bb363, bb399)
	var4359 = var4362 & 0x7;	// _4359 = BinOp(_4362 BIT_AND 0x7 u32)
	var4360 = (uint8_t )var4359;	// _4360 = Cast(_4359 as u8)
	var958 = var4361 << var4360;
	// ^ Call( _958 = "unchecked_shl"::<u8,>( _4361, _4360, ), bb364, bb399)
	var4364 = make128_raw(0ull, 0ull);	// _4364 = Constant(0x0 u128)
	add128_o(make128_raw(2932094668382937627ull, 3596769784855016629ull), var9, &var4363);
	// ^ Call( _4363 = "overflowing_add"::<u128,>( 0x28b0e490e4c8221b31ea4b10152434b5 u128, _9, ), bb365, bb399)
	var4365 = shr128(var4363, make128_raw(0ull, 111ull).lo);
	// ^ Call( _4365 = "unchecked_shr"::<u128,>( _4363, 0x6f u128, ), bb366, bb399)
	var4370 = mod128(var4364, var4365);	// _4370 = BinOp(_4364 MOD _4365)
	var4366 = var41 & 0x7f;	// _4366 = BinOp(_41 BIT_AND 0x7f u32)
	var4367.lo = var4366; var4367.hi = var4366 < 0 ? -1 : 0;	// _4367 = Cast(_4366 as u128)
	var959 = shr128(make128_raw(14950656025334065839ull, 14419117846552679625ull), var4367.lo);
	// ^ Call( _959 = "unchecked_shr"::<u128,>( 0xcf7b66716d172aafc81aff49224494c9 u128, _4367, ), bb367, bb399)
	add128_o(var3, var14, &var960);
	// ^ Call( _960 = "overflowing_add"::<u128,>( _3, _14, ), bb368, bb399)
	var4368 = div128(var959, var960);	// _4368 = BinOp(_959 DIV _960)
	var4369 = mod128(var57, make128_raw(2716451617176140087ull, 6232693340770558597ull));	// _4369 = BinOp(_57 MOD 0x25b2c65a7b51b937567ef9923a926285 u128)
	mul128_o(var4368, var4369, &var4371);
	// ^ Call( _4371 = "overflowing_mul"::<u128,>( _4368, _4369, ), bb369, bb399)
	add128_o(var4370, var4371, &var961);
	// ^ Call( _961 = "overflowing_add"::<u128,>( _4370, _4371, ), bb370, bb399)
	var82 = mul128(var3, var961);	// _82 = BinOp(_3 MUL _961)
	var963 = var17 >> 0xd;
	// ^ Call( _963 = "unchecked_shr"::<u16,>( _17, 0xd u16, ), bb371, bb399)
	var962 = var11 + var963;	// _962 = BinOp(_11 ADD _963)
	var965 = var24 / 0xa397;	// _965 = BinOp(_24 DIV 0xa397 u16)
	var964 = var965 & 0xe276;	// _964 = BinOp(_965 BIT_AND 0xe276 u16)
	var4377 = var962 * var964;	// _4377 = BinOp(_962 MUL _964)
	__builtin_sub_overflow(0xad2ddb4f, var79, &var4372);
	// ^ Call( _4372 = "overflowing_sub"::<u32,>( 0xad2ddb4f u32, _79, ), bb372, bb399)
	var4373 = 0xc8a45788 & var49;	// _4373 = BinOp(0xc8a45788 u32 BIT_AND _49)
	__builtin_add_overflow(var4372, var4373, &var4374);
	// ^ Call( _4374 = "overflowing_add"::<u32,>( _4372, _4373, ), bb373, bb399)
	var4378 = 0xa0910486 % var4374;	// _4378 = BinOp(0xa0910486 u32 MOD _4374)
	var4375 = var4378 & 0xf;	// _4375 = BinOp(_4378 BIT_AND 0xf u32)
	var4376 = (uint16_t )var4375;	// _4376 = Cast(_4375 as u16)
	var966 = var4377 >> var4376;
	// ^ Call( _966 = "unchecked_shr"::<u16,>( _4377, _4376, ), bb374, bb399)
	var83 = (int32_t )var966;	// _83 = Cast(_966 as i32)
	var84 = var33 * 77350355;	// _84 = BinOp(_33 MUL +77350355 i32)
	var85 = 56;	// _85 = Constant(+56 i8)
	var4379 = 0x3e & var78;	// _4379 = BinOp(0x3e u8 BIT_AND _78)
	__builtin_sub_overflow(var4379, var78, &var4382);
	// ^ Call( _4382 = "overflowing_sub"::<u8,>( _4379, _78, ), bb375, bb399)
	mul128_o(make128_raw(5504560246433219691ull, 1941234394241720850ull), make128_raw(3519621869422411669ull, 17615269756440394885ull), &var968);
	// ^ Call( _968 = "overflowing_mul"::<u128,>( 0x4c6420613563846b1af0a6657e8c6212 u128, 0x30d83571469e7f95f4760283874fbc85 u128, ), bb376, bb399)
	var4383 = var968.lo;	// _4383 = Cast(_968 as u32)
	var4380 = var4383 & 0x7;	// _4380 = BinOp(_4383 BIT_AND 0x7 u32)
	var4381 = (uint8_t )var4380;	// _4381 = Cast(_4380 as u8)
	var969 = var4382 >> var4381;
	// ^ Call( _969 = "unchecked_shr"::<u8,>( _4382, _4381, ), bb377, bb399)
	var967 = var969 + 0x69;	// _967 = BinOp(_969 ADD 0x69 u8)
	var86 = (int32_t )var967;	// _86 = Cast(_967 as i32)
	var87 = 0x7e;	// _87 = Constant(0x7e u8)
	var971 = 122 + var40;	// _971 = BinOp(+122 i8 ADD _40)
	var970 = var971 - var42;	// _970 = BinOp(_971 SUB _42)
	var972.lo = var970; var972.hi = var970 < 0 ? -1 : 0;	// _972 = Cast(_970 as u128)
	var4385 = add128s(var48, make128s_raw(10000532930133617073ull, 2980158882912982104ull));	// _4385 = BinOp(_48 ADD -155805095358058945319542567129782889384 i128)
	var4384 = ZRICj15overflowing_div0g( make128s_raw(5695054648929893020ull, 5482484734741669217ull), var4385 );
	// ^ Call( _4384 = <i128 /*- */>::overflowing_div( +105055215594599535094048073457789789537 i128, _4385, ), bb378, bb399)
	var973.lo = var4384._0.lo; var973.hi = var4384._0.hi;	// _973 = Cast(_4384.0 as u128)
	var4391 = sub128(var972, var973);	// _4391 = BinOp(_972 SUB _973)
	var4387 = (uint32_t )var83;	// _4387 = Cast(_83 as u32)
	__builtin_sub_overflow(0xaf13ca6b, var22, &var4388);
	// ^ Call( _4388 = "overflowing_sub"::<u32,>( 0xaf13ca6b u32, _22, ), bb379, bb399)
	var4386 = var4388 & 0x1f;	// _4386 = BinOp(_4388 BIT_AND 0x1f u32)
	var974 = var4387 >> var4386;
	// ^ Call( _974 = "unchecked_shr"::<u32,>( _4387, _4386, ), bb380, bb399)
	var975 = (int16_t )var974;	// _975 = Cast(_974 as i16)
	var4392 = (uint32_t )var975;	// _4392 = Cast(_975 as u32)
	var4389 = var4392 & 0x7f;	// _4389 = BinOp(_4392 BIT_AND 0x7f u32)
	var4390.lo = var4389; var4390.hi = var4389 < 0 ? -1 : 0;	// _4390 = Cast(_4389 as u128)
	var976 = shl128(var4391, var4390.lo);
	// ^ Call( _976 = "unchecked_shl"::<u128,>( _4391, _4390, ), bb381, bb399)
	var4393 = -5332 - var43;	// _4393 = BinOp(-5332 i16 SUB _43)
	__builtin_sub_overflow(-25133, var4393, &var4394);
	// ^ Call( _4394 = "overflowing_sub"::<i16,>( -25133 i16, _4393, ), bb382, bb399)
	var977 = -var52;	// _977 = UniOp(_52 NEG)
	var978 = var13 - var72;	// _978 = BinOp(_13 SUB _72)
	var4395 = var977 / var978;	// _4395 = BinOp(_977 DIV _978)
	__builtin_add_overflow(var4394, var4395, &var979);
	// ^ Call( _979 = "overflowing_add"::<i16,>( _4394, _4395, ), bb383, bb399)
	var4396 = 0x2b & var54;	// _4396 = BinOp(0x2b u8 BIT_AND _54)
	__builtin_mul_overflow(var4396, 0xc9, &var4397);
	// ^ Call( _4397 = "overflowing_mul"::<u8,>( _4396, 0xc9 u8, ), bb384, bb399)
	__builtin_add_overflow(0x5, var4397, &var4398);
	// ^ Call( _4398 = "overflowing_add"::<u8,>( 0x5 u8, _4397, ), bb385, bb399)
	__builtin_mul_overflow(0x46, var4398, &var980);
	// ^ Call( _980 = "overflowing_mul"::<u8,>( 0x46 u8, _4398, ), bb386, bb399)
	var4399 = var71 & 0x1f;	// _4399 = BinOp(_71 BIT_AND 0x1f u32)
	var4400 = (int32_t )var4399;	// _4400 = Cast(_4399 as i32)
	var981 = 735980859 >> var4400;
	// ^ Call( _981 = "unchecked_shr"::<i32,>( +735980859 i32, _4400, ), bb387, bb399)
	__builtin_add_overflow(-491544952, var5, &var982);
	// ^ Call( _982 = "overflowing_add"::<i32,>( -491544952 i32, _5, ), bb388, bb399)
	var4401 = ZRICf15overflowing_div0g( 1770975935, 430546787 );
	// ^ Call( _4401 = <i32 /*- */>::overflowing_div( +1770975935 i32, +430546787 i32, ), bb389, bb399)
	var984 = var4401._0;	// _984 = Use(_4401.0)
	var4402 = ZRICf15overflowing_div0g( var1, 467908161 );
	// ^ Call( _4402 = <i32 /*- */>::overflowing_div( _1, +467908161 i32, ), bb390, bb399)
	var983 = var984 - var4402._0;	// _983 = BinOp(_984 SUB _4402.0)
	var4403 = -var983;	// _4403 = UniOp(_983 NEG)
	var985 = var4403 << 10;
	// ^ Call( _985 = "unchecked_shl"::<i32,>( _4403, +10 i32, ), bb391, bb399)
	var4404 = var79 & 0x1f;	// _4404 = BinOp(_79 BIT_AND 0x1f u32)
	var986 = 0x2cb5e978 >> var4404;
	// ^ Call( _986 = "unchecked_shr"::<u32,>( 0x2cb5e978 u32, _4404, ), bb392, bb399)
	var988 = 684039129;	// _988 = Constant(+684039129 i32)
	__builtin_mul_overflow(972835335, var1, &var990);
	// ^ Call( _990 = "overflowing_mul"::<i32,>( +972835335 i32, _1, ), bb393, bb399)
	var989 = var990 + -1487893302;	// _989 = BinOp(_990 ADD -1487893302 i32)
	var987 = var988 | var989;	// _987 = BinOp(_988 BIT_OR _989)
	var991 = -var987;	// _991 = UniOp(_987 NEG)
	var88 = -var991;	// _88 = UniOp(_991 NEG)
	var993 = -237803977 * var33;	// _993 = BinOp(-237803977 i32 MUL _33)
	var992 = -1511585634 + var993;	// _992 = BinOp(-1511585634 i32 ADD _993)
	var4405 = -var992;	// _4405 = UniOp(_992 NEG)
	var994 = -var88;	// _994 = UniOp(_88 NEG)
	var995 = -var994;	// _995 = UniOp(_994 NEG)
	var4406 = var995 & 42730566;	// _4406 = BinOp(_995 BIT_AND +42730566 i32)
	__builtin_mul_overflow(var4405, var4406, &var4408);
	// ^ Call( _4408 = "overflowing_mul"::<i32,>( _4405, _4406, ), bb394, bb399)
	var4407 = ZRICf15overflowing_div0g( var56, var4408 );
	// ^ Call( _4407 = <i32 /*- */>::overflowing_div( _56, _4408, ), bb395, bb399)
	var89 = var4407._0;	// _89 = Use(_4407.0)
	var90 = 1726957751;	// _90 = Constant(+1726957751 i32)
	var996 = 67 / var4;	// _996 = BinOp(+67 i8 DIV _4)
	var91 = -var996;	// _91 = UniOp(_996 NEG)
	var998 = var69 | 0x96;	// _998 = BinOp(_69 BIT_OR 0x96 u8)
	var997 = var63 / var998;	// _997 = BinOp(_63 DIV _998)
	var999 = (uint8_t )var64;	// _999 = Cast(_64 as u8)
	var4409 = var997 ^ var999;	// _4409 = BinOp(_997 BIT_XOR _999)
	__builtin_sub_overflow(0x66, var4409, &var1000);
	// ^ Call( _1000 = "overflowing_sub"::<u8,>( 0x66 u8, _4409, ), bb396, bb399)
	__builtin_sub_overflow(0xd4dcd44288725f99ull, 0x2daa14430fabe5f3ull, &var4410);
	// ^ Call( _4410 = "overflowing_sub"::<u64,>( 0xd4dcd44288725f99 u64, 0x2daa14430fabe5f3 u64, ), bb397, bb399)
	__builtin_sub_overflow(var31, var4410, &var1002);
	// ^ Call( _1002 = "overflowing_sub"::<u64,>( _31, _4410, ), bb398, bb399)
	var1003 = var74 | var74;	// _1003 = BinOp(_74 BIT_OR _74)
	var1001 = var1002 > var1003;	// _1001 = BinOp(_1002 GT _1003)
	if(var1001) goto bb400; else goto bb400;
	// ^ If( _1001 : 400, 400)
bb399: _Unwind_Resume(); // Diverge
bb400:
	var4411 = var22 / 0x3b7ba795;	// _4411 = BinOp(_22 DIV 0x3b7ba795 u32)
	__builtin_add_overflow(var4411, var51, &var4413);
	// ^ Call( _4413 = "overflowing_add"::<u32,>( _4411, _51, ), bb401, bb399)
	var4412 = var49 & 0x1f;	// _4412 = BinOp(_49 BIT_AND 0x1f u32)
	var4416 = var4413 >> var4412;
	// ^ Call( _4416 = "unchecked_shr"::<u32,>( _4413, _4412, ), bb402, bb399)
	var4414 = 0x96c2b8e4 | var25;	// _4414 = BinOp(0x96c2b8e4 u32 BIT_OR _25)
	var4415 = 0x0 % var4414;	// _4415 = BinOp(0x0 u32 MOD _4414)
	__builtin_mul_overflow(0x36400890, var4415, &var4417);
	// ^ Call( _4417 = "overflowing_mul"::<u32,>( 0x36400890 u32, _4415, ), bb403, bb399)
	__builtin_add_overflow(var4416, var4417, &var4419);
	// ^ Call( _4419 = "overflowing_add"::<u32,>( _4416, _4417, ), bb404, bb399)
	var1005 = 0x77d445ab;	// _1005 = Constant(0x77d445ab u32)
	__builtin_mul_overflow(var25, var61, &var1007);
	// ^ Call( _1007 = "overflowing_mul"::<u32,>( _25, _61, ), bb405, bb399)
	var1008 = var47 % var22;	// _1008 = BinOp(_47 MOD _22)
	var1006 = var1007 / var1008;	// _1006 = BinOp(_1007 DIV _1008)
	var1004 = var1005 & var1006;	// _1004 = BinOp(_1005 BIT_AND _1006)
	var1010 = -var43;	// _1010 = UniOp(_43 NEG)
	var1011 = -var72;	// _1011 = UniOp(_72 NEG)
	var1009 = var1010 - var1011;	// _1009 = BinOp(_1010 SUB _1011)
	var1012 = (uint32_t )var1009;	// _1012 = Cast(_1009 as u32)
	var4420 = var1004 + var1012;	// _4420 = BinOp(_1004 ADD _1012)
	var4418 = var4420 & 0x1f;	// _4418 = BinOp(_4420 BIT_AND 0x1f u32)
	var92 = var4419 << var4418;
	// ^ Call( _92 = "unchecked_shl"::<u32,>( _4419, _4418, ), bb406, bb399)
	__builtin_sub_overflow(var73, 20, &var1013);
	// ^ Call( _1013 = "overflowing_sub"::<i8,>( _73, +20 i8, ), bb407, bb399)
	var1014 = -var21;	// _1014 = UniOp(_21 NEG)
	var4421 = var1013 * var1014;	// _4421 = BinOp(_1013 MUL _1014)
	var4422 = -var91;	// _4422 = UniOp(_91 NEG)
	__builtin_add_overflow(var4421, var4422, &var4423);
	// ^ Call( _4423 = "overflowing_add"::<i8,>( _4421, _4422, ), bb408, bb399)
	var4424 = var57.lo;	// _4424 = Cast(_57 as i8)
	__builtin_mul_overflow(var4423, var4424, &var4426);
	// ^ Call( _4426 = "overflowing_mul"::<i8,>( _4423, _4424, ), bb409, bb399)
	var4425 = ZRICb15overflowing_div0g( 14, -98 );
	// ^ Call( _4425 = <i8 /*- */>::overflowing_div( +14 i8, -98 i8, ), bb410, bb399)
	var1016 = var4425._0;	// _1016 = Use(_4425.0)
	__builtin_mul_overflow(var19, -53, &var1017);
	// ^ Call( _1017 = "overflowing_mul"::<i8,>( _19, -53 i8, ), bb411, bb399)
	var1015 = var1016 * var1017;	// _1015 = BinOp(_1016 MUL _1017)
	var1018 = -var1015;	// _1018 = UniOp(_1015 NEG)
	var1020 = -6;	// _1020 = Constant(-6 i8)
	__builtin_mul_overflow(var80, 114, &var1022);
	// ^ Call( _1022 = "overflowing_mul"::<i8,>( _80, +114 i8, ), bb412, bb399)
	__builtin_mul_overflow(63, var12, &var1023);
	// ^ Call( _1023 = "overflowing_mul"::<i8,>( +63 i8, _12, ), bb413, bb399)
	var1021 = var1022 & var1023;	// _1021 = BinOp(_1022 BIT_AND _1023)
	var1019 = var1020 & var1021;	// _1019 = BinOp(_1020 BIT_AND _1021)
	var4427 = var1018 * var1019;	// _4427 = BinOp(_1018 MUL _1019)
	__builtin_add_overflow(var4426, var4427, &var93);
	// ^ Call( _93 = "overflowing_add"::<i8,>( _4426, _4427, ), bb414, bb399)
	var94 = -var88;	// _94 = UniOp(_88 NEG)
	var95 = 0x50db32f8;	// _95 = Constant(0x50db32f8 u32)
	var96 = var7 | 0x6c;	// _96 = BinOp(_7 BIT_OR 0x6c u8)
	var4428 = ZRICj15overflowing_div0g( make128s_raw(7813292770140177805ull, 802066854795243071ull), make128s_raw(6709333717067843678ull, 11205725889367297093ull) );
	// ^ Call( _4428 = <i128 /*- */>::overflowing_div( +144129812103741010815686046327860325951 i128, +123765361983860922898471521646727580741 i128, ), bb415, bb399)
	mul128s_o(var29, make128s_raw(886771364493523648ull, 5320751114998240757ull), &var1024);
	// ^ Call( _1024 = "overflowing_mul"::<i128,>( _29, +16358044412706240060648994144970855925 i128, ), bb416, bb399)
	__builtin_mul_overflow(var19, var62, &var4431);
	// ^ Call( _4431 = "overflowing_mul"::<i8,>( _19, _62, ), bb417, bb399)
	var4429 = var92 & 0x7;	// _4429 = BinOp(_92 BIT_AND 0x7 u32)
	var4430 = (int8_t )var4429;	// _4430 = Cast(_4429 as i8)
	var4432 = var21 >> var4430;
	// ^ Call( _4432 = "unchecked_shr"::<i8,>( _21, _4430, ), bb418, bb399)
	__builtin_sub_overflow(var4431, var4432, &var1025);
	// ^ Call( _1025 = "overflowing_sub"::<i8,>( _4431, _4432, ), bb419, bb399)
	var4433 = (uint8_t )var1025;	// _4433 = Cast(_1025 as u8)
	__builtin_sub_overflow(var4433, var87, &var1026);
	// ^ Call( _1026 = "overflowing_sub"::<u8,>( _4433, _87, ), bb420, bb399)
	var1027 = (uint8_t )var31;	// _1027 = Cast(_31 as u8)
	var4439 = var1027 - var87;	// _4439 = BinOp(_1027 SUB _87)
	var4435 = 0x9a17eb22 / var25;	// _4435 = BinOp(0x9a17eb22 u32 DIV _25)
	var4434 = var6 & 0x1f;	// _4434 = BinOp(_6 BIT_AND 0x1f u32)
	var4436 = 0x3ab8f651 << var4434;
	// ^ Call( _4436 = "unchecked_shl"::<u32,>( 0x3ab8f651 u32, _4434, ), bb421, bb399)
	var4440 = var4435 / var4436;	// _4440 = BinOp(_4435 DIV _4436)
	var4437 = var4440 & 0x7;	// _4437 = BinOp(_4440 BIT_AND 0x7 u32)
	var4438 = (uint8_t )var4437;	// _4438 = Cast(_4437 as u8)
	var4444 = var4439 << var4438;
	// ^ Call( _4444 = "unchecked_shl"::<u8,>( _4439, _4438, ), bb422, bb399)
	var1028 = var25 / 0x3978957c;	// _1028 = BinOp(_25 DIV 0x3978957c u32)
	var1029 = var49 | var34;	// _1029 = BinOp(_49 BIT_OR _34)
	var4441 = var1028 ^ var1029;	// _4441 = BinOp(_1028 BIT_XOR _1029)
	__builtin_add_overflow(var4441, var61, &var4445);
	// ^ Call( _4445 = "overflowing_add"::<u32,>( _4441, _61, ), bb423, bb399)
	var4442 = var4445 & 0x7;	// _4442 = BinOp(_4445 BIT_AND 0x7 u32)
	var4443 = (uint8_t )var4442;	// _4443 = Cast(_4442 as u8)
	var1030 = var4444 << var4443;
	// ^ Call( _1030 = "unchecked_shl"::<u8,>( _4444, _4443, ), bb424, bb399)
	var97 = var1026 | var1030;	// _97 = BinOp(_1026 BIT_OR _1030)
	var4446 = var3.lo;	// _4446 = Cast(_3 as u16)
	__builtin_sub_overflow(var45, var4446, &var4447);
	// ^ Call( _4447 = "overflowing_sub"::<u16,>( _45, _4446, ), bb425, bb399)
	__builtin_sub_overflow(var4447, 0x587b, &var4448);
	// ^ Call( _4448 = "overflowing_sub"::<u16,>( _4447, 0x587b u16, ), bb426, bb399)
	__builtin_add_overflow(var24, var66, &var4449);
	// ^ Call( _4449 = "overflowing_add"::<u16,>( _24, _66, ), bb427, bb399)
	var4450 = var4448 % var4449;	// _4450 = BinOp(_4448 MOD _4449)
	__builtin_add_overflow(0xc922, var4450, &var98);
	// ^ Call( _98 = "overflowing_add"::<u16,>( 0xc922 u16, _4450, ), bb428, bb399)
	mul128s_o(var48, make128s_raw(11437757205349536133ull, 15329566144492436570ull), &var4451);
	// ^ Call( _4451 = "overflowing_mul"::<i128,>( _48, -129292986976628184784856544370255233958 i128, ), bb429, bb399)
	var4452.lo = var5; var4452.hi = var5 < 0 ? -1 : 0;	// _4452 = Cast(_5 as i128)
	mul128s_o(var4451, var4452, &var1031);
	// ^ Call( _1031 = "overflowing_mul"::<i128,>( _4451, _4452, ), bb430, bb399)
	var1032 = neg128s(var1031);	// _1032 = UniOp(_1031 NEG)
	var1033 = neg128s(var1032);	// _1033 = UniOp(_1032 NEG)
	var99 = var1033.lo;	// _99 = Cast(_1033 as u8)
	var4453 = -var80;	// _4453 = UniOp(_80 NEG)
	__builtin_mul_overflow(var4453, 70, &var1035);
	// ^ Call( _1035 = "overflowing_mul"::<i8,>( _4453, +70 i8, ), bb431, bb399)
	var1034 = var12 * var1035;	// _1034 = BinOp(_12 MUL _1035)
	var4454 = -var1034;	// _4454 = UniOp(_1034 NEG)
	var1036 = -29 << 1;
	// ^ Call( _1036 = "unchecked_shl"::<i8,>( -29 i8, +1 i8, ), bb432, bb399)
	var1037 = -var1036;	// _1037 = UniOp(_1036 NEG)
	var4455 = -var1037;	// _4455 = UniOp(_1037 NEG)
	__builtin_mul_overflow(var4454, var4455, &var1038);
	// ^ Call( _1038 = "overflowing_mul"::<i8,>( _4454, _4455, ), bb433, bb399)
	__builtin_add_overflow(var12, var19, &var1039);
	// ^ Call( _1039 = "overflowing_add"::<i8,>( _12, _19, ), bb434, bb399)
	var1040 = -118 ^ var42;	// _1040 = BinOp(-118 i8 BIT_XOR _42)
	var4457 = var1039 / var1040;	// _4457 = BinOp(_1039 DIV _1040)
	var4456 = ZRICb15overflowing_div0g( var4457, -51 );
	// ^ Call( _4456 = <i8 /*- */>::overflowing_div( _4457, -51 i8, ), bb435, bb399)
	var4458 = var49 & 0x7;	// _4458 = BinOp(_49 BIT_AND 0x7 u32)
	var4459 = (int8_t )var4458;	// _4459 = Cast(_4458 as i8)
	var4463 = -52 << var4459;
	// ^ Call( _4463 = "unchecked_shl"::<i8,>( -52 i8, _4459, ), bb436, bb399)
	var4460 = var67 & 0x7;	// _4460 = BinOp(_67 BIT_AND 0x7 u32)
	var4461 = (int8_t )var4460;	// _4461 = Cast(_4460 as i8)
	var1041 = -37 << var4461;
	// ^ Call( _1041 = "unchecked_shl"::<i8,>( -37 i8, _4461, ), bb437, bb399)
	var4464 = var1041 & 2;	// _4464 = BinOp(_1041 BIT_AND +2 i8)
	var4462 = ZRICb15overflowing_rem0g( var4463, var4464 );
	// ^ Call( _4462 = <i8 /*- */>::overflowing_rem( _4463, _4464, ), bb438, bb399)
	__builtin_add_overflow(var4456._0, var4462._0, &var1042);
	// ^ Call( _1042 = "overflowing_add"::<i8,>( _4456.0, _4462.0, ), bb439, bb399)
	var100 = -var1042;	// _100 = UniOp(_1042 NEG)
	var101 = 0xea0c774a30b4fabaull;	// _101 = Constant(0xea0c774a30b4faba u64)
	var4465 = (uint16_t )var64;	// _4465 = Cast(_64 as u16)
	__builtin_add_overflow(var66, 0x92fb, &var4466);
	// ^ Call( _4466 = "overflowing_add"::<u16,>( _66, 0x92fb u16, ), bb440, bb399)
	__builtin_sub_overflow(var4465, var4466, &var4469);
	// ^ Call( _4469 = "overflowing_sub"::<u16,>( _4465, _4466, ), bb441, bb399)
	var4467 = var51 & 0x7;	// _4467 = BinOp(_51 BIT_AND 0x7 u32)
	var4468 = (uint8_t )var4467;	// _4468 = Cast(_4467 as u8)
	var1043 = 0x7 >> var4468;
	// ^ Call( _1043 = "unchecked_shr"::<u8,>( 0x7 u8, _4468, ), bb442, bb399)
	var4470 = (uint16_t )var1043;	// _4470 = Cast(_1043 as u16)
	__builtin_mul_overflow(var4469, var4470, &var1044);
	// ^ Call( _1044 = "overflowing_mul"::<u16,>( _4469, _4470, ), bb443, bb399)
	var4476 = var24 + var1044;	// _4476 = BinOp(_24 ADD _1044)
	var1047 = var34 + var41;	// _1047 = BinOp(_34 ADD _41)
	var1046 = 0xb6c1b7f0 | var1047;	// _1046 = BinOp(0xb6c1b7f0 u32 BIT_OR _1047)
	var1045 = var61 | var1046;	// _1045 = BinOp(_61 BIT_OR _1046)
	var1048 = var79 << 0x0;
	// ^ Call( _1048 = "unchecked_shl"::<u32,>( _79, 0x0 u32, ), bb444, bb399)
	__builtin_mul_overflow(var92, 0xb82cb239, &var1049);
	// ^ Call( _1049 = "overflowing_mul"::<u32,>( _92, 0xb82cb239 u32, ), bb445, bb399)
	var4472 = var1048 | var1049;	// _4472 = BinOp(_1048 BIT_OR _1049)
	__builtin_add_overflow(var2, 0xbef022f7, &var4473);
	// ^ Call( _4473 = "overflowing_add"::<u32,>( _2, 0xbef022f7 u32, ), bb446, bb399)
	var4471 = var4473 & 0x1f;	// _4471 = BinOp(_4473 BIT_AND 0x1f u32)
	var1050 = var4472 >> var4471;
	// ^ Call( _1050 = "unchecked_shr"::<u32,>( _4472, _4471, ), bb447, bb399)
	var4477 = var1045 | var1050;	// _4477 = BinOp(_1045 BIT_OR _1050)
	var4474 = var4477 & 0xf;	// _4474 = BinOp(_4477 BIT_AND 0xf u32)
	var4475 = (uint16_t )var4474;	// _4475 = Cast(_4474 as u16)
	var1051 = var4476 >> var4475;
	// ^ Call( _1051 = "unchecked_shr"::<u16,>( _4476, _4475, ), bb448, bb399)
	var1053 = 0xf961206cd154f258ull / var101;	// _1053 = BinOp(0xf961206cd154f258 u64 DIV _101)
	var1052 = var1053 ^ var74;	// _1052 = BinOp(_1053 BIT_XOR _74)
	var1054 = -var60;	// _1054 = UniOp(_60 NEG)
	var1055 = (uint64_t )var1054;	// _1055 = Cast(_1054 as u64)
	var4484 = var1052 / var1055;	// _4484 = BinOp(_1052 DIV _1055)
	var4479 = (uint32_t )var11;	// _4479 = Cast(_11 as u32)
	var4480 = 0xf219663d / var6;	// _4480 = BinOp(0xf219663d u32 DIV _6)
	var4478 = var4480 & 0x1f;	// _4478 = BinOp(_4480 BIT_AND 0x1f u32)
	var4483 = var4479 << var4478;
	// ^ Call( _4483 = "unchecked_shl"::<u32,>( _4479, _4478, ), bb449, bb399)
	var4481 = var4483 & 0x3f;	// _4481 = BinOp(_4483 BIT_AND 0x3f u32)
	var4482 = (uint64_t )var4481;	// _4482 = Cast(_4481 as u64)
	var4485 = var36 >> var4482;
	// ^ Call( _4485 = "unchecked_shr"::<u64,>( _36, _4482, ), bb450, bb399)
	__builtin_sub_overflow(var4484, var4485, &var4496);
	// ^ Call( _4496 = "overflowing_sub"::<u64,>( _4484, _4485, ), bb451, bb399)
	var4487 = 0x42f828b0;	// _4487 = Constant(0x42f828b0 u32)
	__builtin_sub_overflow(0xabf017c8, 0xa8a9534e, &var4488);
	// ^ Call( _4488 = "overflowing_sub"::<u32,>( 0xabf017c8 u32, 0xa8a9534e u32, ), bb452, bb399)
	var4486 = var4488 & 0x1f;	// _4486 = BinOp(_4488 BIT_AND 0x1f u32)
	var1056 = var4487 >> var4486;
	// ^ Call( _1056 = "unchecked_shr"::<u32,>( _4487, _4486, ), bb453, bb399)
	__builtin_add_overflow(var95, 0xdd95295e, &var4489);
	// ^ Call( _4489 = "overflowing_add"::<u32,>( _95, 0xdd95295e u32, ), bb454, bb399)
	var4490 = var6 / var67;	// _4490 = BinOp(_6 DIV _67)
	var1057 = var4489 % var4490;	// _1057 = BinOp(_4489 MOD _4490)
	var4492 = var1056 + var1057;	// _4492 = BinOp(_1056 ADD _1057)
	var4493 = 0x3068fec5 | var79;	// _4493 = BinOp(0x3068fec5 u32 BIT_OR _79)
	var4491 = var4493 & 0x1f;	// _4491 = BinOp(_4493 BIT_AND 0x1f u32)
	var4497 = var4492 >> var4491;
	// ^ Call( _4497 = "unchecked_shr"::<u32,>( _4492, _4491, ), bb455, bb399)
	var4494 = var4497 & 0x3f;	// _4494 = BinOp(_4497 BIT_AND 0x3f u32)
	var4495 = (uint64_t )var4494;	// _4495 = Cast(_4494 as u64)
	var102 = var4496 << var4495;
	// ^ Call( _102 = "unchecked_shl"::<u64,>( _4496, _4495, ), bb456, bb399)
	var4498 = var97 - 0x62;	// _4498 = BinOp(_97 SUB 0x62 u8)
	__builtin_add_overflow(0xb2, var4498, &var1060);
	// ^ Call( _1060 = "overflowing_add"::<u8,>( 0xb2 u8, _4498, ), bb457, bb399)
	__builtin_sub_overflow(var96, var78, &var1062);
	// ^ Call( _1062 = "overflowing_sub"::<u8,>( _96, _78, ), bb458, bb399)
	var1061 = var1062 / 0xce;	// _1061 = BinOp(_1062 DIV 0xce u8)
	var1059 = var1060 - var1061;	// _1059 = BinOp(_1060 SUB _1061)
	var1065 = 0x92 << 0x6;
	// ^ Call( _1065 = "unchecked_shl"::<u8,>( 0x92 u8, 0x6 u8, ), bb459, bb399)
	var1066 = (uint8_t )var62;	// _1066 = Cast(_62 as u8)
	var1064 = var1065 * var1066;	// _1064 = BinOp(_1065 MUL _1066)
	var1067 = (uint8_t )var47;	// _1067 = Cast(_47 as u8)
	var1063 = var1064 * var1067;	// _1063 = BinOp(_1064 MUL _1067)
	var1058 = var1059 * var1063;	// _1058 = BinOp(_1059 MUL _1063)
	var4501 = var41 * var2;	// _4501 = BinOp(_41 MUL _2)
	var4499 = var4501 & 0x7;	// _4499 = BinOp(_4501 BIT_AND 0x7 u32)
	var4500 = (uint8_t )var4499;	// _4500 = Cast(_4499 as u8)
	var1068 = var63 >> var4500;
	// ^ Call( _1068 = "unchecked_shr"::<u8,>( _63, _4500, ), bb460, bb399)
	var4506 = var99 ^ var1068;	// _4506 = BinOp(_99 BIT_XOR _1068)
	var4502 = var79 % 0xfcf91224;	// _4502 = BinOp(_79 MOD 0xfcf91224 u32)
	__builtin_sub_overflow(var4502, var71, &var4505);
	// ^ Call( _4505 = "overflowing_sub"::<u32,>( _4502, _71, ), bb461, bb399)
	var4503 = var4505 & 0x7;	// _4503 = BinOp(_4505 BIT_AND 0x7 u32)
	var4504 = (uint8_t )var4503;	// _4504 = Cast(_4503 as u8)
	var4507 = 0x99 << var4504;
	// ^ Call( _4507 = "unchecked_shl"::<u8,>( 0x99 u8, _4504, ), bb462, bb399)
	__builtin_add_overflow(var4506, var4507, &var1069);
	// ^ Call( _1069 = "overflowing_add"::<u8,>( _4506, _4507, ), bb463, bb399)
	var103 = var1058 / var1069;	// _103 = BinOp(_1058 DIV _1069)
	var4510 = var72 | 22772;	// _4510 = BinOp(_72 BIT_OR +22772 i16)
	__builtin_sub_overflow(0x2704ab62, var61, &var4511);
	// ^ Call( _4511 = "overflowing_sub"::<u32,>( 0x2704ab62 u32, _61, ), bb464, bb399)
	var4508 = var4511 & 0xf;	// _4508 = BinOp(_4511 BIT_AND 0xf u32)
	var4509 = (int16_t )var4508;	// _4509 = Cast(_4508 as i16)
	var1070 = var4510 << var4509;
	// ^ Call( _1070 = "unchecked_shl"::<i16,>( _4510, _4509, ), bb465, bb399)
	var1071 = -var1070;	// _1071 = UniOp(_1070 NEG)
	var1072 = -var1071;	// _1072 = UniOp(_1071 NEG)
	var1073 = (int16_t )var32;	// _1073 = Cast(_32 as i16)
	var1074 = -var1073;	// _1074 = UniOp(_1073 NEG)
	var4513 = -var1074;	// _4513 = UniOp(_1074 NEG)
	var4512 = ZRICd15overflowing_div0g( var4513, var50 );
	// ^ Call( _4512 = <i16 /*- */>::overflowing_div( _4513, _50, ), bb466, bb399)
	var104 = var1072 * var4512._0;	// _104 = BinOp(_1072 MUL _4512.0)
	var4516 = 0xeb865b2 / var71;	// _4516 = BinOp(0xeb865b2 u32 DIV _71)
	var4514 = var4516 & 0x7;	// _4514 = BinOp(_4516 BIT_AND 0x7 u32)
	var4515 = (int8_t )var4514;	// _4515 = Cast(_4514 as i8)
	var1075 = var8 << var4515;
	// ^ Call( _1075 = "unchecked_shl"::<i8,>( _8, _4515, ), bb467, bb399)
	__builtin_mul_overflow(var21, 30, &var4518);
	// ^ Call( _4518 = "overflowing_mul"::<i8,>( _21, +30 i8, ), bb468, bb399)
	var4517 = ZRICb15overflowing_rem0g( var4518, -85 );
	// ^ Call( _4517 = <i8 /*- */>::overflowing_rem( _4518, -85 i8, ), bb469, bb399)
	__builtin_sub_overflow(var7, 0xb6, &var1076);
	// ^ Call( _1076 = "overflowing_sub"::<u8,>( _7, 0xb6 u8, ), bb470, bb399)
	var4519 = ZRICv15overflowing_rem0g( -7979579645768242230ll, var55 );
	// ^ Call( _4519 = <isize /*- */>::overflowing_rem( -7979579645768242230 isize, _55, ), bb471, bb399)
	var1078 = var55 * var32;	// _1078 = BinOp(_55 MUL _32)
	var1077 = var4519._0 * var1078;	// _1077 = BinOp(_4519.0 MUL _1078)
	var1079 = -var1077;	// _1079 = UniOp(_1077 NEG)
	var1080 = -var1079;	// _1080 = UniOp(_1079 NEG)
	var105 = (uint16_t )var1080;	// _105 = Cast(_1080 as u16)
	__builtin_add_overflow(var2, 0x98bd751b, &var4522);
	// ^ Call( _4522 = "overflowing_add"::<u32,>( _2, 0x98bd751b u32, ), bb472, bb399)
	var4520 = var4522 & 0x7f;	// _4520 = BinOp(_4522 BIT_AND 0x7f u32)
	var4521.lo = var4520; var4521.hi = var4520 < 0 ? -1 : 0;	// _4521 = Cast(_4520 as u128)
	var1081 = shl128(var14, var4521.lo);
	// ^ Call( _1081 = "unchecked_shl"::<u128,>( _14, _4521, ), bb473, bb399)
	var4523 = var66 * var66;	// _4523 = BinOp(_66 MUL _66)
	var4524 = 0xbf4e ^ var46;	// _4524 = BinOp(0xbf4e u16 BIT_XOR _46)
	__builtin_sub_overflow(var4523, var4524, &var1084);
	// ^ Call( _1084 = "overflowing_sub"::<u16,>( _4523, _4524, ), bb474, bb399)
	var1083 = var1084 + var66;	// _1083 = BinOp(_1084 ADD _66)
	var1082 = var1083 | 0xda1c;	// _1082 = BinOp(_1083 BIT_OR 0xda1c u16)
	__builtin_mul_overflow(var11, var23, &var1085);
	// ^ Call( _1085 = "overflowing_mul"::<u16,>( _11, _23, ), bb475, bb399)
	var106 = var1082 * var1085;	// _106 = BinOp(_1082 MUL _1085)
	var4526 = -7014 >> 10;
	// ^ Call( _4526 = "unchecked_shr"::<i16,>( -7014 i16, +10 i16, ), bb476, bb399)
	var4527 = 393 << 1;
	// ^ Call( _4527 = "unchecked_shl"::<i16,>( +393 i16, +1 i16, ), bb477, bb399)
	var4525 = ZRICd15overflowing_div0g( var4526, var4527 );
	// ^ Call( _4525 = <i16 /*- */>::overflowing_div( _4526, _4527, ), bb478, bb399)
	var4528 = ZRICd15overflowing_div0g( -28067, -22055 );
	// ^ Call( _4528 = <i16 /*- */>::overflowing_div( -28067 i16, -22055 i16, ), bb479, bb399)
	var1089 = neg128s(var28);	// _1089 = UniOp(_28 NEG)
	var1090 = neg128s(var20);	// _1090 = UniOp(_20 NEG)
	var1088 = mul128s(var1089, var1090);	// _1088 = BinOp(_1089 MUL _1090)
	var1087 = and128s(var28, var1088);	// _1087 = BinOp(_28 BIT_AND _1088)
	var1086 = div128s(var1087, make128s_raw(2862078177605617390ull, 13356596103539216820ull));	// _1086 = BinOp(_1087 DIV +52796023661239856129883226403291419060 i128)
	var107 = or128s(make128s_raw(5771036211544866186ull, 173467469627751469ull), var1086);	// _107 = BinOp(+106456828034478482560243260706407808045 i128 BIT_OR _1086)
	__builtin_sub_overflow(var79, 0x6b793930, &var1091);
	// ^ Call( _1091 = "overflowing_sub"::<u32,>( _79, 0x6b793930 u32, ), bb480, bb399)
	var108 = 0x20217f4c & var1091;	// _108 = BinOp(0x20217f4c u32 BIT_AND _1091)
	var1092 = var97 / 0x25;	// _1092 = BinOp(_97 DIV 0x25 u8)
	var1093 = (intptr_t )var1092;	// _1093 = Cast(_1092 as isize)
	var1094 = -var1093;	// _1094 = UniOp(_1093 NEG)
	var4532 = -var1094;	// _4532 = UniOp(_1094 NEG)
	var4529 = var56 / -1871309132;	// _4529 = BinOp(_56 DIV -1871309132 i32)
	var4530 = -var26;	// _4530 = UniOp(_26 NEG)
	__builtin_sub_overflow(var4529, var4530, &var1095);
	// ^ Call( _1095 = "overflowing_sub"::<i32,>( _4529, _4530, ), bb481, bb399)
	var1096 = -var1095;	// _1096 = UniOp(_1095 NEG)
	var4533 = (intptr_t )var1096;	// _4533 = Cast(_1096 as isize)
	var4531 = ZRICv15overflowing_div0g( var4532, var4533 );
	// ^ Call( _4531 = <isize /*- */>::overflowing_div( _4532, _4533, ), bb482, bb399)
	var109 = var4531._0;	// _109 = Use(_4531.0)
	__builtin_add_overflow(var11, var105, &var1097);
	// ^ Call( _1097 = "overflowing_add"::<u16,>( _11, _105, ), bb483, bb399)
	var1099 = -92 / var93;	// _1099 = BinOp(-92 i8 DIV _93)
	var1100 = -var100;	// _1100 = UniOp(_100 NEG)
	var4534 = var1099 * var1100;	// _4534 = BinOp(_1099 MUL _1100)
	__builtin_add_overflow(-53, var4534, &var1101);
	// ^ Call( _1101 = "overflowing_add"::<i8,>( -53 i8, _4534, ), bb484, bb399)
	var4535 = var79 & 0x7;	// _4535 = BinOp(_79 BIT_AND 0x7 u32)
	var4536 = (int8_t )var4535;	// _4536 = Cast(_4535 as i8)
	var1102 = var37 >> var4536;
	// ^ Call( _1102 = "unchecked_shr"::<i8,>( _37, _4536, ), bb485, bb399)
	var1098 = var1101 * var1102;	// _1098 = BinOp(_1101 MUL _1102)
	var110 = (uint8_t )var1098;	// _110 = Cast(_1098 as u8)
	var1103 = var64 & var55;	// _1103 = BinOp(_64 BIT_AND _55)
	var1104 = -var1103;	// _1104 = UniOp(_1103 NEG)
	var4540 = (int8_t )var1104;	// _4540 = Cast(_1104 as i8)
	var4538 = 0;	// _4538 = Constant(+0 i8)
	__builtin_sub_overflow(-35, var91, &var4537);
	// ^ Call( _4537 = "overflowing_sub"::<i8,>( -35 i8, _91, ), bb486, bb399)
	__builtin_mul_overflow(var4537, var21, &var4539);
	// ^ Call( _4539 = "overflowing_mul"::<i8,>( _4537, _21, ), bb487, bb399)
	__builtin_add_overflow(var4538, var4539, &var4541);
	// ^ Call( _4541 = "overflowing_add"::<i8,>( _4538, _4539, ), bb488, bb399)
	__builtin_mul_overflow(var4540, var4541, &var4546);
	// ^ Call( _4546 = "overflowing_mul"::<i8,>( _4540, _4541, ), bb489, bb399)
	var4542 = var49 << 0x1a;
	// ^ Call( _4542 = "unchecked_shl"::<u32,>( _49, 0x1a u32, ), bb490, bb399)
	__builtin_add_overflow(0x95c7ccb6, var4542, &var1105);
	// ^ Call( _1105 = "overflowing_add"::<u32,>( 0x95c7ccb6 u32, _4542, ), bb491, bb399)
	var4543 = var1105 - 0x0;	// _4543 = BinOp(_1105 SUB 0x0 u32)
	__builtin_mul_overflow(var4543, 0x7589427b, &var4547);
	// ^ Call( _4547 = "overflowing_mul"::<u32,>( _4543, 0x7589427b u32, ), bb492, bb399)
	var4544 = var4547 & 0x7;	// _4544 = BinOp(_4547 BIT_AND 0x7 u32)
	var4545 = (int8_t )var4544;	// _4545 = Cast(_4544 as i8)
	var111 = var4546 >> var4545;
	// ^ Call( _111 = "unchecked_shr"::<i8,>( _4546, _4545, ), bb493, bb399)
	__builtin_sub_overflow(1074838070, -1169184778, &var4551);
	// ^ Call( _4551 = "overflowing_sub"::<i32,>( +1074838070 i32, -1169184778 i32, ), bb494, bb399)
	var1106 = 0x2c;	// _1106 = Constant(0x2c u32)
	__builtin_add_overflow(0x87ef0e0b, 0xf039736a, &var1107);
	// ^ Call( _1107 = "overflowing_add"::<u32,>( 0x87ef0e0b u32, 0xf039736a u32, ), bb495, bb399)
	var4550 = var1106 & var1107;	// _4550 = BinOp(_1106 BIT_AND _1107)
	var4548 = var4550 & 0x1f;	// _4548 = BinOp(_4550 BIT_AND 0x1f u32)
	var4549 = (int32_t )var4548;	// _4549 = Cast(_4548 as i32)
	var1108 = var26 << var4549;
	// ^ Call( _1108 = "unchecked_shl"::<i32,>( _26, _4549, ), bb496, bb399)
	var4552 = -var1108;	// _4552 = UniOp(_1108 NEG)
	__builtin_add_overflow(var4551, var4552, &var1109);
	// ^ Call( _1109 = "overflowing_add"::<i32,>( _4551, _4552, ), bb497, bb399)
	var4553 = var95 & 0x1f;	// _4553 = BinOp(_95 BIT_AND 0x1f u32)
	var4554 = 0x8d7b96d4 >> var4553;
	// ^ Call( _4554 = "unchecked_shr"::<u32,>( 0x8d7b96d4 u32, _4553, ), bb498, bb399)
	__builtin_sub_overflow(var4554, var61, &var4557);
	// ^ Call( _4557 = "overflowing_sub"::<u32,>( _4554, _61, ), bb499, bb399)
	var4555 = 0x510704dd ^ var25;	// _4555 = BinOp(0x510704dd u32 BIT_XOR _25)
	var4558 = var71 / var4555;	// _4558 = BinOp(_71 DIV _4555)
	var4556 = var4558 & 0x1f;	// _4556 = BinOp(_4558 BIT_AND 0x1f u32)
	var4561 = var4557 >> var4556;
	// ^ Call( _4561 = "unchecked_shr"::<u32,>( _4557, _4556, ), bb500, bb399)
	var4559 = (uint32_t )var66;	// _4559 = Cast(_66 as u32)
	var4560 = var49 + 0x57c70d74;	// _4560 = BinOp(_49 ADD 0x57c70d74 u32)
	__builtin_sub_overflow(var4559, var4560, &var1110);
	// ^ Call( _1110 = "overflowing_sub"::<u32,>( _4559, _4560, ), bb501, bb399)
	var4562 = var1110 / var95;	// _4562 = BinOp(_1110 DIV _95)
	__builtin_mul_overflow(var4561, var4562, &var4567);
	// ^ Call( _4567 = "overflowing_mul"::<u32,>( _4561, _4562, ), bb502, bb399)
	var4563 = var95 + 0x41ebe4f7;	// _4563 = BinOp(_95 ADD 0x41ebe4f7 u32)
	var4564 = 0xbbe4b6b0 | var92;	// _4564 = BinOp(0xbbe4b6b0 u32 BIT_OR _92)
	__builtin_add_overflow(var4563, var4564, &var1111);
	// ^ Call( _1111 = "overflowing_add"::<u32,>( _4563, _4564, ), bb503, bb399)
	var4565 = var1111 ^ var47;	// _4565 = BinOp(_1111 BIT_XOR _47)
	var1112 = var89 / 1940916074;	// _1112 = BinOp(_89 DIV +1940916074 i32)
	var1113 = (uint32_t )var1112;	// _1113 = Cast(_1112 as u32)
	__builtin_sub_overflow(0x5b7088bc, var79, &var1115);
	// ^ Call( _1115 = "overflowing_sub"::<u32,>( 0x5b7088bc u32, _79, ), bb504, bb399)
	var1114 = var1115 & var2;	// _1114 = BinOp(_1115 BIT_AND _2)
	var4566 = var1113 + var1114;	// _4566 = BinOp(_1113 ADD _1114)
	__builtin_sub_overflow(var4565, var4566, &var4568);
	// ^ Call( _4568 = "overflowing_sub"::<u32,>( _4565, _4566, ), bb505, bb399)
	__builtin_add_overflow(var4567, var4568, &var1116);
	// ^ Call( _1116 = "overflowing_add"::<u32,>( _4567, _4568, ), bb506, bb399)
	var1118 = (uintptr_t )var102;	// _1118 = Cast(_102 as usize)
	var1117 = 0xe441b8eac8430457ull / var1118;	// _1117 = BinOp(0xe441b8eac8430457 usize DIV _1118)
	var4576 = var1117 ^ var27;	// _4576 = BinOp(_1117 BIT_XOR _27)
	__builtin_sub_overflow(0xd7cc7a53aab1dc64ull, 0x32ddd2b9351c8353ull, &var1119);
	// ^ Call( _1119 = "overflowing_sub"::<usize,>( 0xd7cc7a53aab1dc64 usize, 0x32ddd2b9351c8353 usize, ), bb507, bb399)
	var1120 = var76 - var76;	// _1120 = BinOp(_76 SUB _76)
	var4569 = var1119 & var1120;	// _4569 = BinOp(_1119 BIT_AND _1120)
	__builtin_sub_overflow(0x5bb222408345a62full, var4569, &var1121);
	// ^ Call( _1121 = "overflowing_sub"::<usize,>( 0x5bb222408345a62f usize, _4569, ), bb508, bb399)
	var1122 = 0x11202900f4347353ull * var27;	// _1122 = BinOp(0x11202900f4347353 usize MUL _27)
	var1123 = var53 * var27;	// _1123 = BinOp(_53 MUL _27)
	var4574 = var1122 - var1123;	// _4574 = BinOp(_1122 SUB _1123)
	var4572 = var53 + 0x78073b4bd6de6c23ull;	// _4572 = BinOp(_53 ADD 0x78073b4bd6de6c23 usize)
	var4573 = var61 / var92;	// _4573 = BinOp(_61 DIV _92)
	var4570 = var4573 & 0x3f;	// _4570 = BinOp(_4573 BIT_AND 0x3f u32)
	var4571 = (uintptr_t )var4570;	// _4571 = Cast(_4570 as usize)
	var4575 = var4572 << var4571;
	// ^ Call( _4575 = "unchecked_shl"::<usize,>( _4572, _4571, ), bb509, bb399)
	__builtin_mul_overflow(var4574, var4575, &var1124);
	// ^ Call( _1124 = "overflowing_mul"::<usize,>( _4574, _4575, ), bb510, bb399)
	var4577 = var1121 + var1124;	// _4577 = BinOp(_1121 ADD _1124)
	__builtin_sub_overflow(var4576, var4577, &var112);
	// ^ Call( _112 = "overflowing_sub"::<usize,>( _4576, _4577, ), bb511, bb399)
	var4581 = 29548;	// _4581 = Constant(+29548 i16)
	var1125 = var47 - var41;	// _1125 = BinOp(_47 SUB _41)
	var4578 = var79 & 0x1f;	// _4578 = BinOp(_79 BIT_AND 0x1f u32)
	var1126 = var2 << var4578;
	// ^ Call( _1126 = "unchecked_shl"::<u32,>( _2, _4578, ), bb512, bb399)
	var4582 = var1125 & var1126;	// _4582 = BinOp(_1125 BIT_AND _1126)
	var4579 = var4582 & 0xf;	// _4579 = BinOp(_4582 BIT_AND 0xf u32)
	var4580 = (int16_t )var4579;	// _4580 = Cast(_4579 as i16)
	var1127 = var4581 >> var4580;
	// ^ Call( _1127 = "unchecked_shr"::<i16,>( _4581, _4580, ), bb513, bb399)
	var4583 = ZRICv15overflowing_div0g( var32, -2731148924490065716ll );
	// ^ Call( _4583 = <isize /*- */>::overflowing_div( _32, -2731148924490065716 isize, ), bb514, bb399)
	var113 = var4583._0;	// _113 = Use(_4583.0)
	var114 = var112;	// _114 = Use(_112)
	var4584 = ZRICj15overflowing_rem0g( var28, var28 );
	// ^ Call( _4584 = <i128 /*- */>::overflowing_rem( _28, _28, ), bb515, bb399)
	var4587 = mul128s(make128s_raw(1065801412045776549ull, 4086865443592959975ull), var4584._0);	// _4587 = BinOp(+19660565881406700478287172136910813159 i128 MUL _4584.0)
	var1128 = var95 - 0x710c371;	// _1128 = BinOp(_95 SUB 0x710c371 u32)
	var1129 = (uint32_t )var4;	// _1129 = Cast(_4 as u32)
	var4588 = var1128 / var1129;	// _4588 = BinOp(_1128 DIV _1129)
	var4585 = var4588 & 0x7f;	// _4585 = BinOp(_4588 BIT_AND 0x7f u32)
	var4586.lo = var4585; var4586.hi = var4585 < 0 ? -1 : 0;	// _4586 = Cast(_4585 as i128)
	var1130 = shr128s(var4587, var4586.lo);
	// ^ Call( _1130 = "unchecked_shr"::<i128,>( _4587, _4586, ), bb516, bb399)
	var4589 = var67 & 0x7f;	// _4589 = BinOp(_67 BIT_AND 0x7f u32)
	var4590.lo = var4589; var4590.hi = var4589 < 0 ? -1 : 0;	// _4590 = Cast(_4589 as i128)
	var1131 = shl128s(var65, var4590.lo);
	// ^ Call( _1131 = "unchecked_shl"::<i128,>( _65, _4590, ), bb517, bb399)
	var4591 = var93 / -106;	// _4591 = BinOp(_93 DIV -106 i8)
	var4592 = var91 / var93;	// _4592 = BinOp(_91 DIV _93)
	__builtin_add_overflow(var4591, var4592, &var1132);
	// ^ Call( _1132 = "overflowing_add"::<i8,>( _4591, _4592, ), bb518, bb399)
	var1133 = -var1132;	// _1133 = UniOp(_1132 NEG)
	var4593 = -var1133;	// _4593 = UniOp(_1133 NEG)
	__builtin_sub_overflow(var4593, -66, &var1134);
	// ^ Call( _1134 = "overflowing_sub"::<i8,>( _4593, +2219207614 i8, ), bb519, bb399)
	var4594 = ZRICj15overflowing_div0g( make128s_raw(3265798029268991908ull, 2243056723204942337ull), var48 );
	// ^ Call( _4594 = <i128 /*- */>::overflowing_div( +60243340442350109273024446514217265665 i128, _48, ), bb520, bb399)
	var115 = var4594._0;	// _115 = Use(_4594.0)
	__builtin_sub_overflow(var45, 0x2d09, &var1136);
	// ^ Call( _1136 = "overflowing_sub"::<u16,>( _45, 0x2d09 u16, ), bb521, bb399)
	var1137 = var18 * var11;	// _1137 = BinOp(_18 MUL _11)
	var1135 = var1136 * var1137;	// _1135 = BinOp(_1136 MUL _1137)
	var1138 = 0x878d << 0x0;
	// ^ Call( _1138 = "unchecked_shl"::<u16,>( 0x878d u16, 0x0 u16, ), bb522, bb399)
	var4595 = var1135 + var1138;	// _4595 = BinOp(_1135 ADD _1138)
	var1139 = var68 % var4595;	// _1139 = BinOp(_68 MOD _4595)
	var1141 = var66 % 0x4daa;	// _1141 = BinOp(_66 MOD 0x4daa u16)
	var4596 = var1141 * var11;	// _4596 = BinOp(_1141 MUL _11)
	var1142 = var39 + var45;	// _1142 = BinOp(_39 ADD _45)
	var4597 = var23 | var1142;	// _4597 = BinOp(_23 BIT_OR _1142)
	__builtin_add_overflow(var4596, var4597, &var1143);
	// ^ Call( _1143 = "overflowing_add"::<u16,>( _4596, _4597, ), bb523, bb399)
	var1140 = var1143 ^ 0xf290;	// _1140 = BinOp(_1143 BIT_XOR 0xf290 u16)
	var116 = var1139 / var1140;	// _116 = BinOp(_1139 DIV _1140)
	__builtin_sub_overflow(0x71, var7, &var4598);
	// ^ Call( _4598 = "overflowing_sub"::<u8,>( 0x71 u8, _7, ), bb524, bb399)
	var4599 = var99 / 0x3e;	// _4599 = BinOp(_99 DIV 0x3e u8)
	var4605 = var4598 % var4599;	// _4605 = BinOp(_4598 MOD _4599)
	var4600 = var34 & 0x1f;	// _4600 = BinOp(_34 BIT_AND 0x1f u32)
	var4601 = var22 << var4600;
	// ^ Call( _4601 = "unchecked_shl"::<u32,>( _22, _4600, ), bb525, bb399)
	var4602 = var25 % 0x58cec6c8;	// _4602 = BinOp(_25 MOD 0x58cec6c8 u32)
	__builtin_mul_overflow(var4601, var4602, &var4606);
	// ^ Call( _4606 = "overflowing_mul"::<u32,>( _4601, _4602, ), bb526, bb399)
	var4603 = var4606 & 0x7;	// _4603 = BinOp(_4606 BIT_AND 0x7 u32)
	var4604 = (uint8_t )var4603;	// _4604 = Cast(_4603 as u8)
	var1144 = var4605 << var4604;
	// ^ Call( _1144 = "unchecked_shl"::<u8,>( _4605, _4604, ), bb527, bb399)
	var117 = 0x3 | var69;	// _117 = BinOp(0x3 u8 BIT_OR _69)
	var1145 = var103 - var81;	// _1145 = BinOp(_103 SUB _81)
	var4607 = var1145 | 0x7a;	// _4607 = BinOp(_1145 BIT_OR 0x7a u8)
	__builtin_add_overflow(0xfe, var4607, &var4611);
	// ^ Call( _4611 = "overflowing_add"::<u8,>( 0xfe u8, _4607, ), bb528, bb399)
	var4608 = (uint8_t )var37;	// _4608 = Cast(_37 as u8)
	var4609 = var78 & 0x9c;	// _4609 = BinOp(_78 BIT_AND 0x9c u8)
	__builtin_sub_overflow(var4608, var4609, &var1146);
	// ^ Call( _1146 = "overflowing_sub"::<u8,>( _4608, _4609, ), bb529, bb399)
	var4610 = var69 & var78;	// _4610 = BinOp(_69 BIT_AND _78)
	__builtin_sub_overflow(0x38, var4610, &var1147);
	// ^ Call( _1147 = "overflowing_sub"::<u8,>( 0x38 u8, _4610, ), bb530, bb399)
	var4612 = var1146 ^ var1147;	// _4612 = BinOp(_1146 BIT_XOR _1147)
	__builtin_add_overflow(var4611, var4612, &var4613);
	// ^ Call( _4613 = "overflowing_add"::<u8,>( _4611, _4612, ), bb531, bb399)
	var118 = 0x5 / var4613;	// _118 = BinOp(0x5 u8 DIV _4613)
	var1148 = 0x3a6178df / var108;	// _1148 = BinOp(0x3a6178df u32 DIV _108)
	var1149 = (int64_t )var1148;	// _1149 = Cast(_1148 as i64)
	var4615 = 3871209788637647143ll / var1149;	// _4615 = BinOp(+3871209788637647143 i64 DIV _1149)
	var4614 = ZRICh15overflowing_rem0g( var4615, -872970648272584645ll );
	// ^ Call( _4614 = <i64 /*- */>::overflowing_rem( _4615, +166130597313313948903556499829369520187 i64, ), bb532, bb399)
	var119 = (int8_t )var4614._0;	// _119 = Cast(_4614.0 as i8)
	__builtin_mul_overflow(var66, 0x4568, &var1150);
	// ^ Call( _1150 = "overflowing_mul"::<u16,>( _66, 0x4568 u16, ), bb533, bb399)
	var4616 = var1150 + var24;	// _4616 = BinOp(_1150 ADD _24)
	var4617 = (uint16_t )var94;	// _4617 = Cast(_94 as u16)
	__builtin_add_overflow(var4616, var4617, &var1151);
	// ^ Call( _1151 = "overflowing_add"::<u16,>( _4616, _4617, ), bb534, bb399)
	var1152 = (uint8_t )var1151;	// _1152 = Cast(_1151 as u8)
	__builtin_sub_overflow(var118, var69, &var4618);
	// ^ Call( _4618 = "overflowing_sub"::<u8,>( _118, _69, ), bb535, bb399)
	var4619 = 0x79 | var110;	// _4619 = BinOp(0x79 u8 BIT_OR _110)
	__builtin_add_overflow(var4618, var4619, &var4620);
	// ^ Call( _4620 = "overflowing_add"::<u8,>( _4618, _4619, ), bb536, bb399)
	__builtin_add_overflow(var110, var4620, &var1154);
	// ^ Call( _1154 = "overflowing_add"::<u8,>( _110, _4620, ), bb537, bb399)
	var4623 = var69 + 0x53;	// _4623 = BinOp(_69 ADD 0x53 u8)
	var4621 = var95 & 0x7;	// _4621 = BinOp(_95 BIT_AND 0x7 u32)
	var4622 = (uint8_t )var4621;	// _4622 = Cast(_4621 as u8)
	var4624 = var54 << var4622;
	// ^ Call( _4624 = "unchecked_shl"::<u8,>( _54, _4622, ), bb538, bb399)
	__builtin_sub_overflow(var4623, var4624, &var4629);
	// ^ Call( _4629 = "overflowing_sub"::<u8,>( _4623, _4624, ), bb539, bb399)
	var4625 = 0x38f771e4 / var25;	// _4625 = BinOp(0x38f771e4 u32 DIV _25)
	__builtin_sub_overflow(0x74872f89, var41, &var4626);
	// ^ Call( _4626 = "overflowing_sub"::<u32,>( 0x74872f89 u32, _41, ), bb540, bb399)
	__builtin_mul_overflow(var4625, var4626, &var4630);
	// ^ Call( _4630 = "overflowing_mul"::<u32,>( _4625, _4626, ), bb541, bb399)
	var4627 = var4630 & 0x7;	// _4627 = BinOp(_4630 BIT_AND 0x7 u32)
	var4628 = (uint8_t )var4627;	// _4628 = Cast(_4627 as u8)
	var1155 = var4629 << var4628;
	// ^ Call( _1155 = "unchecked_shl"::<u8,>( _4629, _4628, ), bb542, bb399)
	var1153 = var1154 | var1155;	// _1153 = BinOp(_1154 BIT_OR _1155)
	var120 = var1152 ^ var1153;	// _120 = BinOp(_1152 BIT_XOR _1153)
	var4631 = 0x714c << 0x4;
	// ^ Call( _4631 = "unchecked_shl"::<u16,>( 0x714c u16, 0x4 u16, ), bb543, bb399)
	__builtin_sub_overflow(var4631, var105, &var4634);
	// ^ Call( _4634 = "overflowing_sub"::<u16,>( _4631, _105, ), bb544, bb399)
	var4635 = 0x0 * var2;	// _4635 = BinOp(0x0 u32 MUL _2)
	var4632 = var4635 & 0xf;	// _4632 = BinOp(_4635 BIT_AND 0xf u32)
	var4633 = (uint16_t )var4632;	// _4633 = Cast(_4632 as u16)
	var4636 = var4634 >> var4633;
	// ^ Call( _4636 = "unchecked_shr"::<u16,>( _4634, _4633, ), bb545, bb399)
	var121 = var4636 << 0x1;
	// ^ Call( _121 = "unchecked_shl"::<u16,>( _4636, 0x1 u16, ), bb546, bb399)
	__builtin_mul_overflow(2078510232, var90, &var1156);
	// ^ Call( _1156 = "overflowing_mul"::<i32,>( +2078510232 i32, _90, ), bb547, bb399)
	var1157 = -var1156;	// _1157 = UniOp(_1156 NEG)
	var1158 = -var1157;	// _1158 = UniOp(_1157 NEG)
	var1159 = -var1158;	// _1159 = UniOp(_1158 NEG)
	var122 = -var1159;	// _122 = UniOp(_1159 NEG)
	var4639 = -31 / var85;	// _4639 = BinOp(-31 i8 DIV _85)
	var4637 = (int8_t )var101;	// _4637 = Cast(_101 as i8)
	__builtin_add_overflow(var4637, -5, &var1160);
	// ^ Call( _1160 = "overflowing_add"::<i8,>( _4637, -5 i8, ), bb548, bb399)
	var4640 = -var1160;	// _4640 = UniOp(_1160 NEG)
	var4638 = ZRICb15overflowing_rem0g( var4639, var4640 );
	// ^ Call( _4638 = <i8 /*- */>::overflowing_rem( _4639, _4640, ), bb549, bb399)
	var123 = -var4638._0;	// _123 = UniOp(_4638.0 NEG)
	var1162 = var17 & 0xe80c;	// _1162 = BinOp(_17 BIT_AND 0xe80c u16)
	var1164 = 0xb79c >> 0x6;
	// ^ Call( _1164 = "unchecked_shr"::<u16,>( 0xb79c u16, 0x6 u16, ), bb550, bb399)
	var1163 = 0x712d & var1164;	// _1163 = BinOp(0x712d u16 BIT_AND _1164)
	var1161 = var1162 - var1163;	// _1161 = BinOp(_1162 SUB _1163)
	var124 = 0xe565 - var1161;	// _124 = BinOp(0xe565 u16 SUB _1161)
	var4641 = var36 * var74;	// _4641 = BinOp(_36 MUL _74)
	__builtin_sub_overflow(var4641, var36, &var4642);
	// ^ Call( _4642 = "overflowing_sub"::<u64,>( _4641, _36, ), bb551, bb399)
	var1165 = var36 ^ 0x51e41eb1b8be2f0bull;	// _1165 = BinOp(_36 BIT_XOR 0x51e41eb1b8be2f0b u64)
	__builtin_sub_overflow(var36, var101, &var1166);
	// ^ Call( _1166 = "overflowing_sub"::<u64,>( _36, _101, ), bb552, bb399)
	var4643 = var1165 ^ var1166;	// _4643 = BinOp(_1165 BIT_XOR _1166)
	__builtin_sub_overflow(var4642, var4643, &var4646);
	// ^ Call( _4646 = "overflowing_sub"::<u64,>( _4642, _4643, ), bb553, bb399)
	__builtin_sub_overflow(0x30061dec, var6, &var1168);
	// ^ Call( _1168 = "overflowing_sub"::<u32,>( 0x30061dec u32, _6, ), bb554, bb399)
	var1167 = var1168 | 0x43aa74d6;	// _1167 = BinOp(_1168 BIT_OR 0x43aa74d6 u32)
	var1170 = var25 << 0x9;
	// ^ Call( _1170 = "unchecked_shl"::<u32,>( _25, 0x9 u32, ), bb555, bb399)
	var1171 = var82.lo;	// _1171 = Cast(_82 as u32)
	var1169 = var1170 | var1171;	// _1169 = BinOp(_1170 BIT_OR _1171)
	var4647 = var1167 - var1169;	// _4647 = BinOp(_1167 SUB _1169)
	var4644 = var4647 & 0x3f;	// _4644 = BinOp(_4647 BIT_AND 0x3f u32)
	var4645 = (uint64_t )var4644;	// _4645 = Cast(_4644 as u64)
	var1172 = var4646 >> var4645;
	// ^ Call( _1172 = "unchecked_shr"::<u64,>( _4646, _4645, ), bb556, bb399)
	var1173 = 0x89c70a500912e72aull | var102;	// _1173 = BinOp(0x89c70a500912e72a u64 BIT_OR _102)
	var4648 = var1173 ^ var102;	// _4648 = BinOp(_1173 BIT_XOR _102)
	var4649 = 0x63a0c094e98b8891ull / var101;	// _4649 = BinOp(0x63a0c094e98b8891 u64 DIV _101)
	__builtin_mul_overflow(var4648, var4649, &var1174);
	// ^ Call( _1174 = "overflowing_mul"::<u64,>( _4648, _4649, ), bb557, bb399)
	var125 = 104233385;	// _125 = Constant(+104233385 i32)
	var4650 = var120 / 0x43;	// _4650 = BinOp(_120 DIV 0x43 u8)
	__builtin_sub_overflow(var7, var4650, &var1175);
	// ^ Call( _1175 = "overflowing_sub"::<u8,>( _7, _4650, ), bb558, bb399)
	var4655 = var1175 | 0xf5;	// _4655 = BinOp(_1175 BIT_OR 0xf5 u8)
	__builtin_add_overflow(var78, 0x3b, &var1177);
	// ^ Call( _1177 = "overflowing_add"::<u8,>( _78, 0x3b u8, ), bb559, bb399)
	var1178 = var54 / 0xf7;	// _1178 = BinOp(_54 DIV 0xf7 u8)
	var1176 = var1177 * var1178;	// _1176 = BinOp(_1177 MUL _1178)
	var4653 = 0xa2;	// _4653 = Constant(0xa2 u8)
	var4651 = var47 & 0x7;	// _4651 = BinOp(_47 BIT_AND 0x7 u32)
	var4652 = (uint8_t )var4651;	// _4652 = Cast(_4651 as u8)
	var4654 = 0x51 << var4652;
	// ^ Call( _4654 = "unchecked_shl"::<u8,>( 0x51 u8, _4652, ), bb560, bb399)
	__builtin_mul_overflow(var4653, var4654, &var1179);
	// ^ Call( _1179 = "overflowing_mul"::<u8,>( _4653, _4654, ), bb561, bb399)
	var4656 = var1176 * var1179;	// _4656 = BinOp(_1176 MUL _1179)
	__builtin_mul_overflow(var4655, var4656, &var1180);
	// ^ Call( _1180 = "overflowing_mul"::<u8,>( _4655, _4656, ), bb562, bb399)
	var4657 = ZRICd15overflowing_div0g( 22455, 28795 );
	// ^ Call( _4657 = <i16 /*- */>::overflowing_div( +22455 i16, +28795 i16, ), bb563, bb399)
	var1181 = 604 * var4657._0;	// _1181 = BinOp(+604 i16 MUL _4657.0)
	var4666 = (uint8_t )var1181;	// _4666 = Cast(_1181 as u8)
	var4659 = (uint32_t )var33;	// _4659 = Cast(_33 as u32)
	var4660 = (uint32_t )var125;	// _4660 = Cast(_125 as u32)
	var4658 = var4660 & 0x1f;	// _4658 = BinOp(_4660 BIT_AND 0x1f u32)
	var4662 = var4659 >> var4658;
	// ^ Call( _4662 = "unchecked_shr"::<u32,>( _4659, _4658, ), bb564, bb399)
	var4661 = var22 % var92;	// _4661 = BinOp(_22 MOD _92)
	var4663 = var4661 >> 0x1a;
	// ^ Call( _4663 = "unchecked_shr"::<u32,>( _4661, 0x1a u32, ), bb565, bb399)
	__builtin_sub_overflow(var4662, var4663, &var4667);
	// ^ Call( _4667 = "overflowing_sub"::<u32,>( _4662, _4663, ), bb566, bb399)
	var4664 = var4667 & 0x7;	// _4664 = BinOp(_4667 BIT_AND 0x7 u32)
	var4665 = (uint8_t )var4664;	// _4665 = Cast(_4664 as u8)
	var1182 = var4666 >> var4665;
	// ^ Call( _1182 = "unchecked_shr"::<u8,>( _4666, _4665, ), bb567, bb399)
	var126 = var1180 - var1182;	// _126 = BinOp(_1180 SUB _1182)
	__builtin_mul_overflow(0x55aad954, var61, &var1183);
	// ^ Call( _1183 = "overflowing_mul"::<u32,>( 0x55aad954 u32, _61, ), bb568, bb399)
	var4668 = 0xfebff637 ^ var1183;	// _4668 = BinOp(0xfebff637 u32 BIT_XOR _1183)
	__builtin_add_overflow(var4668, 0xab0cc310, &var4669);
	// ^ Call( _4669 = "overflowing_add"::<u32,>( _4668, 0xab0cc310 u32, ), bb569, bb399)
	var1184 = var4669 % 0xb65cf5b1;	// _1184 = BinOp(_4669 MOD 0xb65cf5b1 u32)
	var127 = var6 ^ var1184;	// _127 = BinOp(_6 BIT_XOR _1184)
	var1186 = 69 >> 5;
	// ^ Call( _1186 = "unchecked_shr"::<i8,>( +69 i8, +5 i8, ), bb570, bb399)
	var1185 = var1186 & 88;	// _1185 = BinOp(_1186 BIT_AND +88 i8)
	var4670 = -var91;	// _4670 = UniOp(_91 NEG)
	__builtin_add_overflow(var4670, 29, &var1187);
	// ^ Call( _1187 = "overflowing_add"::<i8,>( _4670, +29 i8, ), bb571, bb399)
	var4673 = var1185 * var1187;	// _4673 = BinOp(_1185 MUL _1187)
	var1189 = 0x23132f0a & var127;	// _1189 = BinOp(0x23132f0a u32 BIT_AND _127)
	var1190 = (uint32_t )var113;	// _1190 = Cast(_113 as u32)
	var1188 = var1189 & var1190;	// _1188 = BinOp(_1189 BIT_AND _1190)
	var4674 = var1188 * 0x1e9cd26a;	// _4674 = BinOp(_1188 MUL 0x1e9cd26a u32)
	var4671 = var4674 & 0x7;	// _4671 = BinOp(_4674 BIT_AND 0x7 u32)
	var4672 = (int8_t )var4671;	// _4672 = Cast(_4671 as i8)
	var4679 = var4673 << var4672;
	// ^ Call( _4679 = "unchecked_shl"::<i8,>( _4673, _4672, ), bb572, bb399)
	var4675 = var61 & 0x7;	// _4675 = BinOp(_61 BIT_AND 0x7 u32)
	var4676 = (int8_t )var4675;	// _4676 = Cast(_4675 as i8)
	var4678 = -122 << var4676;
	// ^ Call( _4678 = "unchecked_shl"::<i8,>( -122 i8, _4676, ), bb573, bb399)
	var4677 = ZRICb15overflowing_rem0g( var4678, 45 );
	// ^ Call( _4677 = <i8 /*- */>::overflowing_rem( _4678, +15674331756159729197 i8, ), bb574, bb399)
	__builtin_sub_overflow(var4677._0, var21, &var1191);
	// ^ Call( _1191 = "overflowing_sub"::<i8,>( _4677.0, _21, ), bb575, bb399)
	var4680 = -var1191;	// _4680 = UniOp(_1191 NEG)
	__builtin_add_overflow(var4679, var4680, &var128);
	// ^ Call( _128 = "overflowing_add"::<i8,>( _4679, _4680, ), bb576, bb399)
	var1195 = var126 - var110;	// _1195 = BinOp(_126 SUB _110)
	var1194 = var1195 + 0xd1;	// _1194 = BinOp(_1195 ADD 0xd1 u8)
	var1193 = 0xdd & var1194;	// _1193 = BinOp(0xdd u8 BIT_AND _1194)
	var4683 = var115.lo;	// _4683 = Cast(_115 as u8)
	var4681 = var95 & 0x7;	// _4681 = BinOp(_95 BIT_AND 0x7 u32)
	var4682 = (uint8_t )var4681;	// _4682 = Cast(_4681 as u8)
	var1196 = var4683 >> var4682;
	// ^ Call( _1196 = "unchecked_shr"::<u8,>( _4683, _4682, ), bb577, bb399)
	var1192 = var1193 / var1196;	// _1192 = BinOp(_1193 DIV _1196)
	var4685 = 0x88aa203e / var49;	// _4685 = BinOp(0x88aa203e u32 DIV _49)
	var4684 = var41 & 0x1f;	// _4684 = BinOp(_41 BIT_AND 0x1f u32)
	var4688 = var4685 << var4684;
	// ^ Call( _4688 = "unchecked_shl"::<u32,>( _4685, _4684, ), bb578, bb399)
	var4686 = var4688 & 0x7;	// _4686 = BinOp(_4688 BIT_AND 0x7 u32)
	var4687 = (uint8_t )var4686;	// _4687 = Cast(_4686 as u8)
	var1198 = var103 >> var4687;
	// ^ Call( _1198 = "unchecked_shr"::<u8,>( _103, _4687, ), bb579, bb399)
	var4689 = 0xfb ^ var96;	// _4689 = BinOp(0xfb u8 BIT_XOR _96)
	var4690 = (uint8_t )var16;	// _4690 = Cast(_16 as u8)
	__builtin_sub_overflow(var4689, var4690, &var4694);
	// ^ Call( _4694 = "overflowing_sub"::<u8,>( _4689, _4690, ), bb580, bb399)
	var4691 = var61 % 0xdd00952;	// _4691 = BinOp(_61 MOD 0xdd00952 u32)
	var4695 = var4691 >> 0xe;
	// ^ Call( _4695 = "unchecked_shr"::<u32,>( _4691, 0xe u32, ), bb581, bb399)
	var4692 = var4695 & 0x7;	// _4692 = BinOp(_4695 BIT_AND 0x7 u32)
	var4693 = (uint8_t )var4692;	// _4693 = Cast(_4692 as u8)
	var1199 = var4694 << var4693;
	// ^ Call( _1199 = "unchecked_shl"::<u8,>( _4694, _4693, ), bb582, bb399)
	var1197 = var1198 | var1199;	// _1197 = BinOp(_1198 BIT_OR _1199)
	var129 = var1192 / var1197;	// _129 = BinOp(_1192 DIV _1197)
	__builtin_sub_overflow(var99, var118, &var4696);
	// ^ Call( _4696 = "overflowing_sub"::<u8,>( _99, _118, ), bb583, bb399)
	__builtin_mul_overflow(0x99, var129, &var4697);
	// ^ Call( _4697 = "overflowing_mul"::<u8,>( 0x99 u8, _129, ), bb584, bb399)
	__builtin_sub_overflow(var4696, var4697, &var1200);
	// ^ Call( _1200 = "overflowing_sub"::<u8,>( _4696, _4697, ), bb585, bb399)
	var4699 = 0xc3 / var1200;	// _4699 = BinOp(0xc3 u8 DIV _1200)
	var1201 = (uint8_t )var60;	// _1201 = Cast(_60 as u8)
	var4698 = var1201 / 0x10;	// _4698 = BinOp(_1201 DIV 0x10 u8)
	__builtin_sub_overflow(var4698, var87, &var4700);
	// ^ Call( _4700 = "overflowing_sub"::<u8,>( _4698, _87, ), bb586, bb399)
	__builtin_sub_overflow(var4699, var4700, &var4701);
	// ^ Call( _4701 = "overflowing_sub"::<u8,>( _4699, _4700, ), bb587, bb399)
	__builtin_sub_overflow(0x94, var4701, &var130);
	// ^ Call( _130 = "overflowing_sub"::<u8,>( 0x94 u8, _4701, ), bb588, bb399)
	var131 = 0x1932;	// _131 = Constant(0x1932 u16)
	var1202 = div128(var57, make128_raw(17924553264948191844ull, 18283073141412734806ull));	// _1202 = BinOp(_57 DIV 0xf8c0ce39e2ce2264fdba86277c642756 u128)
	var4702 = mul128(var1202, make128_raw(12177694202497387931ull, 13151982962611713570ull));	// _4702 = BinOp(_1202 MUL 0xa8ffdc5b6330cd9bb6853ad28275f622 u128)
	mul128_o(var4702, make128_raw(14829850777009124537ull, 8364664650345357714ull), &var1203);
	// ^ Call( _1203 = "overflowing_mul"::<u128,>( _4702, 0xcdce36b5b3adf4b97415422e7d1a2192 u128, ), bb589, bb399)
	var1205 = mul128(make128_raw(6701417727463745250ull, 11210151342419617547ull), var82);	// _1205 = BinOp(0x5d0037eae0fb66e29b927540834a270b u128 MUL _82)
	sub128_o(var9, make128_raw(11186520415525463933ull, 957763987980277509ull), &var1207);
	// ^ Call( _1207 = "overflowing_sub"::<u128,>( _9, 0x9b3e810c980ce77d0d4aa945ca39d705 u128, ), bb590, bb399)
	var1206 = sub128(var1207, var57);	// _1206 = BinOp(_1207 SUB _57)
	var1204 = div128(var1205, var1206);	// _1204 = BinOp(_1205 DIV _1206)
	var4703 = mul128(var1203, var1204);	// _4703 = BinOp(_1203 MUL _1204)
	__builtin_add_overflow(0xe8, var99, &var1210);
	// ^ Call( _1210 = "overflowing_add"::<u8,>( 0xe8 u8, _99, ), bb591, bb399)
	var1211 = var99 | 0xb;	// _1211 = BinOp(_99 BIT_OR 0xb u8)
	var1209 = var1210 & var1211;	// _1209 = BinOp(_1210 BIT_AND _1211)
	var1208 = 0xbe / var1209;	// _1208 = BinOp(0xbe u8 DIV _1209)
	var4704.lo = var1208; var4704.hi = var1208 < 0 ? -1 : 0;	// _4704 = Cast(_1208 as u128)
	add128_o(var4703, var4704, &var132);
	// ^ Call( _132 = "overflowing_add"::<u128,>( _4703, _4704, ), bb592, bb399)
	var1213 = (int16_t )var102;	// _1213 = Cast(_102 as i16)
	var1214 = -31065 | var72;	// _1214 = BinOp(-31065 i16 BIT_OR _72)
	var1212 = var1213 ^ var1214;	// _1212 = BinOp(_1213 BIT_XOR _1214)
	var1215 = -var1212;	// _1215 = UniOp(_1212 NEG)
	var133 = (uint64_t )var1215;	// _133 = Cast(_1215 as u64)
	var134 = var116;	// _134 = Use(_116)
	__builtin_mul_overflow(var106, 0x4deb, &var135);
	// ^ Call( _135 = "overflowing_mul"::<u16,>( _106, 0x4deb u16, ), bb593, bb399)
	var4705.lo = var43; var4705.hi = var43 < 0 ? -1 : 0;	// _4705 = Cast(_43 as i128)
	mul128s_o(var4705, make128s_raw(18216523937686748229ull, 15851846805693127020ull), &var1216);
	// ^ Call( _1216 = "overflowing_mul"::<i128,>( _4705, -4246811929827255225685448401402996372 i128, ), bb594, bb399)
	var1217 = neg128s(var1216);	// _1217 = UniOp(_1216 NEG)
	var136 = sub128s(var1217, make128s_raw(17017758989596139213ull, 15690406324693796387ull));	// _136 = BinOp(_1217 SUB -26360122131788435364827098792129296861 i128)
	var4706 = ZRICb15overflowing_rem0g( 8, 62 );
	// ^ Call( _4706 = <i8 /*- */>::overflowing_rem( +8 i8, +62 i8, ), bb595, bb399)
	var4707 = ZRICb15overflowing_rem0g( -40, 86 );
	// ^ Call( _4707 = <i8 /*- */>::overflowing_rem( -40 i8, +86 i8, ), bb596, bb399)
	var4708 = var49 & 0x1f;	// _4708 = BinOp(_49 BIT_AND 0x1f u32)
	var4711 = var61 << var4708;
	// ^ Call( _4711 = "unchecked_shl"::<u32,>( _61, _4708, ), bb597, bb399)
	var4709 = var4711 & 0x7;	// _4709 = BinOp(_4711 BIT_AND 0x7 u32)
	var4710 = (uint8_t )var4709;	// _4710 = Cast(_4709 as u8)
	var1219 = 0x83 << var4710;
	// ^ Call( _1219 = "unchecked_shl"::<u8,>( 0x83 u8, _4710, ), bb598, bb399)
	var4714 = 0x8b | var87;	// _4714 = BinOp(0x8b u8 BIT_OR _87)
	var4715 = var6 >> 0x18;
	// ^ Call( _4715 = "unchecked_shr"::<u32,>( _6, 0x18 u32, ), bb599, bb399)
	var4712 = var4715 & 0x7;	// _4712 = BinOp(_4715 BIT_AND 0x7 u32)
	var4713 = (uint8_t )var4712;	// _4713 = Cast(_4712 as u8)
	var1220 = var4714 << var4713;
	// ^ Call( _1220 = "unchecked_shl"::<u8,>( _4714, _4713, ), bb600, bb399)
	var1218 = var1219 & var1220;	// _1218 = BinOp(_1219 BIT_AND _1220)
	var1222 = var97 - 0x8f;	// _1222 = BinOp(_97 SUB 0x8f u8)
	__builtin_add_overflow(0x12, var69, &var1223);
	// ^ Call( _1223 = "overflowing_add"::<u8,>( 0x12 u8, _69, ), bb601, bb399)
	var1221 = var1222 / var1223;	// _1221 = BinOp(_1222 DIV _1223)
	var4716 = var1218 ^ var1221;	// _4716 = BinOp(_1218 BIT_XOR _1221)
	var1224 = var4716 >> 0x2;
	// ^ Call( _1224 = "unchecked_shr"::<u8,>( _4716, 0x2 u8, ), bb602, bb399)
	__builtin_mul_overflow(var46, 0x271d, &var1225);
	// ^ Call( _1225 = "overflowing_mul"::<u16,>( _46, 0x271d u16, ), bb603, bb399)
	var1226 = var105 & var39;	// _1226 = BinOp(_105 BIT_AND _39)
	var4717 = var1225 & var1226;	// _4717 = BinOp(_1225 BIT_AND _1226)
	var4718 = var116 ^ var98;	// _4718 = BinOp(_116 BIT_XOR _98)
	__builtin_mul_overflow(var4717, var4718, &var1227);
	// ^ Call( _1227 = "overflowing_mul"::<u16,>( _4717, _4718, ), bb604, bb399)
	var4720 = (uint32_t )var1227;	// _4720 = Cast(_1227 as u32)
	var4719 = 0x9e37 | var45;	// _4719 = BinOp(0x9e37 u16 BIT_OR _45)
	__builtin_add_overflow(var4719, 0x2a5b, &var1228);
	// ^ Call( _1228 = "overflowing_add"::<u16,>( _4719, 0x2a5b u16, ), bb605, bb399)
	var1229 = (uint32_t )var1228;	// _1229 = Cast(_1228 as u32)
	__builtin_sub_overflow(var108, var47, &var1230);
	// ^ Call( _1230 = "overflowing_sub"::<u32,>( _108, _47, ), bb606, bb399)
	var4721 = var1229 & var1230;	// _4721 = BinOp(_1229 BIT_AND _1230)
	__builtin_mul_overflow(var4720, var4721, &var1231);
	// ^ Call( _1231 = "overflowing_mul"::<u32,>( _4720, _4721, ), bb607, bb399)
	__builtin_sub_overflow(0xca26f8c1b3ba6b1cull, var101, &var4722);
	// ^ Call( _4722 = "overflowing_sub"::<u64,>( 0xca26f8c1b3ba6b1c u64, _101, ), bb608, bb399)
	__builtin_mul_overflow(var4722, var74, &var1232);
	// ^ Call( _1232 = "overflowing_mul"::<u64,>( _4722, _74, ), bb609, bb399)
	var4723 = var101 - var1232;	// _4723 = BinOp(_101 SUB _1232)
	var1234 = var89 & var125;	// _1234 = BinOp(_89 BIT_AND _125)
	var1233 = var1234 ^ 52161;	// _1233 = BinOp(_1234 BIT_XOR +52161 i32)
	var4724 = (uint64_t )var1233;	// _4724 = Cast(_1233 as u64)
	__builtin_sub_overflow(var4723, var4724, &var1235);
	// ^ Call( _1235 = "overflowing_sub"::<u64,>( _4723, _4724, ), bb610, bb399)
	var1236 = var27 ^ 0x48cde32c4673f04cull;	// _1236 = BinOp(_27 BIT_XOR 0x48cde32c4673f04c usize)
	var4727 = (uint16_t )var1236;	// _4727 = Cast(_1236 as u16)
	__builtin_sub_overflow(var46, var131, &var4725);
	// ^ Call( _4725 = "overflowing_sub"::<u16,>( _46, _131, ), bb611, bb399)
	__builtin_add_overflow(var66, 0x3d78, &var4726);
	// ^ Call( _4726 = "overflowing_add"::<u16,>( _66, 0x3d78 u16, ), bb612, bb399)
	__builtin_mul_overflow(var4725, var4726, &var4728);
	// ^ Call( _4728 = "overflowing_mul"::<u16,>( _4725, _4726, ), bb613, bb399)
	__builtin_mul_overflow(var4727, var4728, &var1237);
	// ^ Call( _1237 = "overflowing_mul"::<u16,>( _4727, _4728, ), bb614, bb399)
	var1238 = (uint64_t )var1237;	// _1238 = Cast(_1237 as u64)
	var137 = var1235 - var1238;	// _137 = BinOp(_1235 SUB _1238)
	var1240 = var137 << 0x1aull;
	// ^ Call( _1240 = "unchecked_shl"::<u64,>( _137, 0x1a u64, ), bb615, bb399)
	var4729 = var101 - var1240;	// _4729 = BinOp(_101 SUB _1240)
	var1241 = div128(var3, make128_raw(4687547033927232223ull, 2769066979651052453ull));	// _1241 = BinOp(_3 DIV 0x410d8331112b2adf266db3bf315d63a5 u128)
	var4730 = var1241.lo;	// _4730 = Cast(_1241 as u64)
	var1242 = var4729 % var4730;	// _1242 = BinOp(_4729 MOD _4730)
	var1243 = 0x65bd3236c6eb3f9eull << 0xcull;
	// ^ Call( _1243 = "unchecked_shl"::<u64,>( 0x65bd3236c6eb3f9e u64, 0xc u64, ), bb616, bb399)
	var4731 = var1243 / var137;	// _4731 = BinOp(_1243 DIV _137)
	__builtin_mul_overflow(var4731, 0x9d12541eeae94554ull, &var1244);
	// ^ Call( _1244 = "overflowing_mul"::<u64,>( _4731, 0x9d12541eeae94554 u64, ), bb617, bb399)
	var1239 = var1242 & var1244;	// _1239 = BinOp(_1242 BIT_AND _1244)
	var138 = var1239 * var133;	// _138 = BinOp(_1239 MUL _133)
	var1245 = (int32_t )var52;	// _1245 = Cast(_52 as i32)
	var1246 = -var1245;	// _1246 = UniOp(_1245 NEG)
	var4734 = -var1246;	// _4734 = UniOp(_1246 NEG)
	var4732 = var79 & 0x1f;	// _4732 = BinOp(_79 BIT_AND 0x1f u32)
	var4733 = (int32_t )var4732;	// _4733 = Cast(_4732 as i32)
	var1247 = var4734 << var4733;
	// ^ Call( _1247 = "unchecked_shl"::<i32,>( _4734, _4733, ), bb618, bb399)
	var4736 = -8914806751105730860ll * var113;	// _4736 = BinOp(-8914806751105730860 isize MUL _113)
	var4735 = ZRICv15overflowing_div0g( var4736, -3442577308307838340ll );
	// ^ Call( _4735 = <isize /*- */>::overflowing_div( _4736, -3442577308307838340 isize, ), bb619, bb399)
	var4737 = var22 & 0xf;	// _4737 = BinOp(_22 BIT_AND 0xf u32)
	var4738 = (uint16_t )var4737;	// _4738 = Cast(_4737 as u16)
	var1249 = var11 << var4738;
	// ^ Call( _1249 = "unchecked_shl"::<u16,>( _11, _4738, ), bb620, bb399)
	var1250 = 0x3c01 * var105;	// _1250 = BinOp(0x3c01 u16 MUL _105)
	var1248 = var1249 | var1250;	// _1248 = BinOp(_1249 BIT_OR _1250)
	var1252 = var11 * 0x13de;	// _1252 = BinOp(_11 MUL 0x13de u16)
	var1251 = var1252 & var131;	// _1251 = BinOp(_1252 BIT_AND _131)
	var4739 = var1248 ^ var1251;	// _4739 = BinOp(_1248 BIT_XOR _1251)
	__builtin_sub_overflow(var4739, 0x38e0, &var4741);
	// ^ Call( _4741 = "overflowing_sub"::<u16,>( _4739, 0x38e0 u16, ), bb621, bb399)
	var4740 = (uint16_t )var104;	// _4740 = Cast(_104 as u16)
	__builtin_add_overflow(var4740, 0x345f, &var4742);
	// ^ Call( _4742 = "overflowing_add"::<u16,>( _4740, 0x345f u16, ), bb622, bb399)
	var4743 = var79 & 0xf;	// _4743 = BinOp(_79 BIT_AND 0xf u32)
	var4744 = (int16_t )var4743;	// _4744 = Cast(_4743 as i16)
	var1255 = var30 >> var4744;
	// ^ Call( _1255 = "unchecked_shr"::<i16,>( _30, _4744, ), bb623, bb399)
	var1254 = var1255 / -27072;	// _1254 = BinOp(_1255 DIV -27072 i16)
	var1253 = 22103 - var1254;	// _1253 = BinOp(+22103 i16 SUB _1254)
	var4756 = -var1253;	// _4756 = UniOp(_1253 NEG)
	var1256 = var13 + -24316;	// _1256 = BinOp(_13 ADD -24316 i16)
	var4747 = -var1256;	// _4747 = UniOp(_1256 NEG)
	var1257 = -var89;	// _1257 = UniOp(_89 NEG)
	var4748 = (uint32_t )var1257;	// _4748 = Cast(_1257 as u32)
	var4745 = var4748 & 0xf;	// _4745 = BinOp(_4748 BIT_AND 0xf u32)
	var4746 = (int16_t )var4745;	// _4746 = Cast(_4745 as i16)
	var4754 = var4747 << var4746;
	// ^ Call( _4754 = "unchecked_shl"::<i16,>( _4747, _4746, ), bb624, bb399)
	var1258 = -var13;	// _1258 = UniOp(_13 NEG)
	var4752 = var1258 | var60;	// _4752 = BinOp(_1258 BIT_OR _60)
	var4749 = var41 << 0x8;
	// ^ Call( _4749 = "unchecked_shl"::<u32,>( _41, 0x8 u32, ), bb625, bb399)
	__builtin_add_overflow(var4749, 0x36, &var4753);
	// ^ Call( _4753 = "overflowing_add"::<u32,>( _4749, 0x36 u32, ), bb626, bb399)
	var4750 = var4753 & 0xf;	// _4750 = BinOp(_4753 BIT_AND 0xf u32)
	var4751 = (int16_t )var4750;	// _4751 = Cast(_4750 as i16)
	var4755 = var4752 << var4751;
	// ^ Call( _4755 = "unchecked_shl"::<i16,>( _4752, _4751, ), bb627, bb399)
	__builtin_sub_overflow(var4754, var4755, &var4757);
	// ^ Call( _4757 = "overflowing_sub"::<i16,>( _4754, _4755, ), bb628, bb399)
	__builtin_add_overflow(var4756, var4757, &var1259);
	// ^ Call( _1259 = "overflowing_add"::<i16,>( _4756, _4757, ), bb629, bb399)
	var1260 = var48.lo;	// _1260 = Cast(_48 as i64)
	var4760 = 72364593710ll;	// _4760 = Constant(+72364593710 i64)
	var4758 = var67 & 0x3f;	// _4758 = BinOp(_67 BIT_AND 0x3f u32)
	var4759 = (int64_t )var4758;	// _4759 = Cast(_4758 as i64)
	var4761 = -1127025126359928071ll << var4759;
	// ^ Call( _4761 = "unchecked_shl"::<i64,>( -1127025126359928071 i64, _4759, ), bb630, bb399)
	__builtin_mul_overflow(var4760, var4761, &var1261);
	// ^ Call( _1261 = "overflowing_mul"::<i64,>( _4760, _4761, ), bb631, bb399)
	__builtin_mul_overflow(-226782538736708266ll, -3305247577333341294ll, &var1262);
	// ^ Call( _1262 = "overflowing_mul"::<i64,>( -226782538736708266 i64, -3305247577333341294 i64, ), bb632, bb399)
	var4763 = var1261 / var1262;	// _4763 = BinOp(_1261 DIV _1262)
	__builtin_add_overflow(var96, 0x77, &var1264);
	// ^ Call( _1264 = "overflowing_add"::<u8,>( _96, 0x77 u8, ), bb633, bb399)
	var1265 = var129 + 0x7d;	// _1265 = BinOp(_129 ADD 0x7d u8)
	var1263 = var1264 - var1265;	// _1263 = BinOp(_1264 SUB _1265)
	var4764 = (int64_t )var1263;	// _4764 = Cast(_1263 as i64)
	var4762 = ZRICh15overflowing_div0g( var4763, var4764 );
	// ^ Call( _4762 = <i64 /*- */>::overflowing_div( _4763, _4764, ), bb634, bb399)
	var139 = var1260 * var4762._0;	// _139 = BinOp(_1260 MUL _4762.0)
	var1268 = 69 * var100;	// _1268 = BinOp(+69 i8 MUL _100)
	var1267 = var21 & var1268;	// _1267 = BinOp(_21 BIT_AND _1268)
	var1266 = -22 ^ var1267;	// _1266 = BinOp(-22 i8 BIT_XOR _1267)
	var4765 = var1266 * var42;	// _4765 = BinOp(_1266 MUL _42)
	__builtin_sub_overflow(var8, var4765, &var1269);
	// ^ Call( _1269 = "overflowing_sub"::<i8,>( _8, _4765, ), bb635, bb399)
	var140 = var62;	// _140 = Use(_62)
	__builtin_add_overflow(0x2f22fa18, 0x12628588, &var141);
	// ^ Call( _141 = "overflowing_add"::<u32,>( 0x2f22fa18 u32, 0x12628588 u32, ), bb636, bb399)
	var4767 = var32 << 35ll;
	// ^ Call( _4767 = "unchecked_shl"::<isize,>( _32, +35 isize, ), bb637, bb399)
	__builtin_add_overflow(var113, -7559064242022332769ll, &var4768);
	// ^ Call( _4768 = "overflowing_add"::<isize,>( _113, -7559064242022332769 isize, ), bb638, bb399)
	var4766 = ZRICv15overflowing_rem0g( var4767, var4768 );
	// ^ Call( _4766 = <isize /*- */>::overflowing_rem( _4767, _4768, ), bb639, bb399)
	__builtin_sub_overflow(0x10384d8c, 0x8589690d, &var4769);
	// ^ Call( _4769 = "overflowing_sub"::<u32,>( 0x10384d8c u32, 0x8589690d u32, ), bb640, bb399)
	__builtin_sub_overflow(0xeb6a899d, var2, &var4770);
	// ^ Call( _4770 = "overflowing_sub"::<u32,>( 0xeb6a899d u32, _2, ), bb641, bb399)
	__builtin_add_overflow(var4769, var4770, &var4772);
	// ^ Call( _4772 = "overflowing_add"::<u32,>( _4769, _4770, ), bb642, bb399)
	__builtin_sub_overflow(var51, var6, &var1270);
	// ^ Call( _1270 = "overflowing_sub"::<u32,>( _51, _6, ), bb643, bb399)
	var1271 = var25 ^ 0xd2dcf154;	// _1271 = BinOp(_25 BIT_XOR 0xd2dcf154 u32)
	var4773 = var1270 - var1271;	// _4773 = BinOp(_1270 SUB _1271)
	var4771 = var4773 & 0x1f;	// _4771 = BinOp(_4773 BIT_AND 0x1f u32)
	var1272 = var4772 >> var4771;
	// ^ Call( _1272 = "unchecked_shr"::<u32,>( _4772, _4771, ), bb644, bb399)
	var4774 = -24565 >> 13;
	// ^ Call( _4774 = "unchecked_shr"::<i16,>( -24565 i16, +13 i16, ), bb645, bb399)
	var1273 = var4774 >> 4;
	// ^ Call( _1273 = "unchecked_shr"::<i16,>( _4774, +4 i16, ), bb646, bb399)
	var142 = -var1273;	// _142 = UniOp(_1273 NEG)
	var1274 = neg128s(var48);	// _1274 = UniOp(_48 NEG)
	var1275 = neg128s(var35);	// _1275 = UniOp(_35 NEG)
	var1276 = neg128s(var1275);	// _1276 = UniOp(_1275 NEG)
	var4775 = xor128s(var1274, var1276);	// _4775 = BinOp(_1274 BIT_XOR _1276)
	var1278 = xor128s(var20, make128s_raw(12819055936030504307ull, 17207239765070886656ull));	// _1278 = BinOp(_20 BIT_XOR -103812522802416509118809308299370514688 i128)
	var1279 = div128s(var48, var48);	// _1279 = BinOp(_48 DIV _48)
	var1277 = div128s(var1278, var1279);	// _1277 = BinOp(_1278 DIV _1279)
	var4776 = neg128s(var1277);	// _4776 = UniOp(_1277 NEG)
	sub128s_o(var4775, var4776, &var1280);
	// ^ Call( _1280 = "overflowing_sub"::<i128,>( _4775, _4776, ), bb647, bb399)
	__builtin_mul_overflow(var128, var119, &var4777);
	// ^ Call( _4777 = "overflowing_mul"::<i8,>( _128, _119, ), bb648, bb399)
	__builtin_sub_overflow(var4777, -87, &var1281);
	// ^ Call( _1281 = "overflowing_sub"::<i8,>( _4777, -87 i8, ), bb649, bb399)
	var4780 = -var1281;	// _4780 = UniOp(_1281 NEG)
	var4778 = -3 | var140;	// _4778 = BinOp(-3 i8 BIT_OR _140)
	var4779 = -var19;	// _4779 = UniOp(_19 NEG)
	__builtin_mul_overflow(var4778, var4779, &var1282);
	// ^ Call( _1282 = "overflowing_mul"::<i8,>( _4778, _4779, ), bb650, bb399)
	var4781 = -var1282;	// _4781 = UniOp(_1282 NEG)
	__builtin_add_overflow(var4780, var4781, &var1283);
	// ^ Call( _1283 = "overflowing_add"::<i8,>( _4780, _4781, ), bb651, bb399)
	var4782 = var92 & 0x7;	// _4782 = BinOp(_92 BIT_AND 0x7 u32)
	var4783 = (int8_t )var4782;	// _4783 = Cast(_4782 as i8)
	var1284 = var111 >> var4783;
	// ^ Call( _1284 = "unchecked_shr"::<i8,>( _111, _4783, ), bb652, bb399)
	var4787 = 84 | var1284;	// _4787 = BinOp(+84 i8 BIT_OR _1284)
	var4784 = var61 % var47;	// _4784 = BinOp(_61 MOD _47)
	var4788 = var4784 % var22;	// _4788 = BinOp(_4784 MOD _22)
	var4785 = var4788 & 0x7;	// _4785 = BinOp(_4788 BIT_AND 0x7 u32)
	var4786 = (int8_t )var4785;	// _4786 = Cast(_4785 as i8)
	var1285 = var4787 << var4786;
	// ^ Call( _1285 = "unchecked_shl"::<i8,>( _4787, _4786, ), bb653, bb399)
	var1286 = -var1285;	// _1286 = UniOp(_1285 NEG)
	var143 = var1283 & var1286;	// _143 = BinOp(_1283 BIT_AND _1286)
	var144 = make128_raw(15435934938185354629ull, 1544093369616838968ull);	// _144 = Constant(0xd637750b0e944d85156db8bd1c0c3138 u128)
	__builtin_sub_overflow(var4, 87, &var1287);
	// ^ Call( _1287 = "overflowing_sub"::<i8,>( _4, +87 i8, ), bb654, bb399)
	var145 = -361605119;	// _145 = Constant(-361605119 i32)
	var4789 = var40 * var19;	// _4789 = BinOp(_40 MUL _19)
	__builtin_add_overflow(var4789, 37, &var4790);
	// ^ Call( _4790 = "overflowing_add"::<i8,>( _4789, +37 i8, ), bb655, bb399)
	__builtin_add_overflow(var4790, 66, &var4793);
	// ^ Call( _4793 = "overflowing_add"::<i8,>( _4790, +66 i8, ), bb656, bb399)
	var4794 = 0x16 / var95;	// _4794 = BinOp(0x16 u32 DIV _95)
	var4791 = var4794 & 0x7;	// _4791 = BinOp(_4794 BIT_AND 0x7 u32)
	var4792 = (int8_t )var4791;	// _4792 = Cast(_4791 as i8)
	var4797 = var4793 << var4792;
	// ^ Call( _4797 = "unchecked_shl"::<i8,>( _4793, _4792, ), bb657, bb399)
	var1288 = 50 >> 1;
	// ^ Call( _1288 = "unchecked_shr"::<i8,>( +50 i8, +1 i8, ), bb658, bb399)
	var1290 = 80;	// _1290 = Constant(+2589666640 i8)
	var4795 = ZRICb15overflowing_div0g( var62, 96 );
	// ^ Call( _4795 = <i8 /*- */>::overflowing_div( _62, +96 i8, ), bb659, bb399)
	var1289 = var1290 & var4795._0;	// _1289 = BinOp(_1290 BIT_AND _4795.0)
	var4796 = var1288 * var1289;	// _4796 = BinOp(_1288 MUL _1289)
	__builtin_mul_overflow(var4796, var4, &var4798);
	// ^ Call( _4798 = "overflowing_mul"::<i8,>( _4796, _4, ), bb660, bb399)
	__builtin_add_overflow(var4797, var4798, &var146);
	// ^ Call( _146 = "overflowing_add"::<i8,>( _4797, _4798, ), bb661, bb399)
	var147 = var129;	// _147 = Use(_129)
	__builtin_add_overflow(-3615562238654552992ll, 8409685512824568342ll, &var1291);
	// ^ Call( _1291 = "overflowing_add"::<i64,>( -3615562238654552992 i64, +8409685512824568342 i64, ), bb662, bb399)
	var1292 = 0x5f + var96;	// _1292 = BinOp(0x5f u8 ADD _96)
	var4799 = var1292 & 0x92;	// _4799 = BinOp(_1292 BIT_AND 0x92 u8)
	__builtin_mul_overflow(0x65, var4799, &var4800);
	// ^ Call( _4800 = "overflowing_mul"::<u8,>( 0x65 u8, _4799, ), bb663, bb399)
	var1293 = var120 / 0x72;	// _1293 = BinOp(_120 DIV 0x72 u8)
	var1295 = (uint8_t )var76;	// _1295 = Cast(_76 as u8)
	var1296 = var130 + var96;	// _1296 = BinOp(_130 ADD _96)
	var1294 = var1295 + var1296;	// _1294 = BinOp(_1295 ADD _1296)
	var4801 = var1293 / var1294;	// _4801 = BinOp(_1293 DIV _1294)
	__builtin_mul_overflow(var4800, var4801, &var1297);
	// ^ Call( _1297 = "overflowing_mul"::<u8,>( _4800, _4801, ), bb664, bb399)
	var148 = (int64_t )var1297;	// _148 = Cast(_1297 as i64)
	__builtin_add_overflow(-2311878532500512053ll, -6468631855391799197ll, &var4803);
	// ^ Call( _4803 = "overflowing_add"::<isize,>( -2311878532500512053 isize, -6468631855391799197 isize, ), bb665, bb399)
	var4802 = ZRICv15overflowing_rem0g( var4803, -2061772770089266352ll );
	// ^ Call( _4802 = <isize /*- */>::overflowing_rem( _4803, -2061772770089266352 isize, ), bb666, bb399)
	var4804 = (uint16_t )var4802._0;	// _4804 = Cast(_4802.0 as u16)
	__builtin_sub_overflow(var135, var4804, &var1298);
	// ^ Call( _1298 = "overflowing_sub"::<u16,>( _135, _4804, ), bb667, bb399)
	var149 = 0x29b1 - var1298;	// _149 = BinOp(0x29b1 u16 SUB _1298)
	var1300 = 0x121028044823104ull / var36;	// _1300 = BinOp(0x121028044823104 u64 DIV _36)
	var1299 = var102 / var1300;	// _1299 = BinOp(_102 DIV _1300)
	var1301 = var138 | var133;	// _1301 = BinOp(_138 BIT_OR _133)
	var4807 = var101 / var1301;	// _4807 = BinOp(_101 DIV _1301)
	var4805 = 0x72a9061ca71c379eull;	// _4805 = Constant(0x72a9061ca71c379e u64)
	__builtin_sub_overflow(var101, var102, &var4806);
	// ^ Call( _4806 = "overflowing_sub"::<u64,>( _101, _102, ), bb668, bb399)
	__builtin_mul_overflow(var4805, var4806, &var4808);
	// ^ Call( _4808 = "overflowing_mul"::<u64,>( _4805, _4806, ), bb669, bb399)
	__builtin_add_overflow(var4807, var4808, &var1302);
	// ^ Call( _1302 = "overflowing_add"::<u64,>( _4807, _4808, ), bb670, bb399)
	var4821 = var1299 & var1302;	// _4821 = BinOp(_1299 BIT_AND _1302)
	__builtin_mul_overflow(var74, var138, &var4809);
	// ^ Call( _4809 = "overflowing_mul"::<u64,>( _74, _138, ), bb671, bb399)
	var4810 = 0x5cd380231e6b5cfaull % var36;	// _4810 = BinOp(0x5cd380231e6b5cfa u64 MOD _36)
	__builtin_add_overflow(var4809, var4810, &var4811);
	// ^ Call( _4811 = "overflowing_add"::<u64,>( _4809, _4810, ), bb672, bb399)
	var4819 = var4811 << 0x31ull;
	// ^ Call( _4819 = "unchecked_shl"::<u64,>( _4811, 0x31 u64, ), bb673, bb399)
	__builtin_add_overflow(var102, 0x8dbdedf85350f068ull, &var1303);
	// ^ Call( _1303 = "overflowing_add"::<u64,>( _102, 0x8dbdedf85350f068 u64, ), bb674, bb399)
	__builtin_sub_overflow(var31, 0xca15e7b7a6276de3ull, &var1304);
	// ^ Call( _1304 = "overflowing_sub"::<u64,>( _31, 0xca15e7b7a6276de3 u64, ), bb675, bb399)
	var4817 = var1303 & var1304;	// _4817 = BinOp(_1303 BIT_AND _1304)
	var4813 = 0x0;	// _4813 = Constant(0x0 u32)
	__builtin_mul_overflow(0xb26c73db, 0xc277e6c8, &var4814);
	// ^ Call( _4814 = "overflowing_mul"::<u32,>( 0xb26c73db u32, 0xc277e6c8 u32, ), bb676, bb399)
	var4812 = var4814 & 0x1f;	// _4812 = BinOp(_4814 BIT_AND 0x1f u32)
	var4818 = var4813 >> var4812;
	// ^ Call( _4818 = "unchecked_shr"::<u32,>( _4813, _4812, ), bb677, bb399)
	var4815 = var4818 & 0x3f;	// _4815 = BinOp(_4818 BIT_AND 0x3f u32)
	var4816 = (uint64_t )var4815;	// _4816 = Cast(_4815 as u64)
	var4820 = var4817 >> var4816;
	// ^ Call( _4820 = "unchecked_shr"::<u64,>( _4817, _4816, ), bb678, bb399)
	var4822 = var4819 / var4820;	// _4822 = BinOp(_4819 DIV _4820)
	__builtin_add_overflow(var4821, var4822, &var150);
	// ^ Call( _150 = "overflowing_add"::<u64,>( _4821, _4822, ), bb679, bb399)
	var1305 = !var58;	// _1305 = UniOp(_58 INV)
	var1306 = !var1305;	// _1306 = UniOp(_1305 INV)
	var1307 = !var1306;	// _1307 = UniOp(_1306 INV)
	var1308 = !var1307;	// _1308 = UniOp(_1307 INV)
	if(var1308) goto bb680; else goto bb680;
	// ^ If( _1308 : 680, 680)
bb680:
	var1309 = -var70;	// _1309 = UniOp(_70 NEG)
	var4827 = -var1309;	// _4827 = UniOp(_1309 NEG)
	var4825 = var60 + var16;	// _4825 = BinOp(_60 ADD _16)
	var4826 = 0x6445683f + var141;	// _4826 = BinOp(0x6445683f u32 ADD _141)
	var4823 = var4826 & 0xf;	// _4823 = BinOp(_4826 BIT_AND 0xf u32)
	var4824 = (int16_t )var4823;	// _4824 = Cast(_4823 as i16)
	var4828 = var4825 >> var4824;
	// ^ Call( _4828 = "unchecked_shr"::<i16,>( _4825, _4824, ), bb681, bb399)
	__builtin_mul_overflow(var4827, var4828, &var1310);
	// ^ Call( _1310 = "overflowing_mul"::<i16,>( _4827, _4828, ), bb682, bb399)
	var1313 = -var44;	// _1313 = UniOp(_44 NEG)
	var1312 = var1313 | var30;	// _1312 = BinOp(_1313 BIT_OR _30)
	var1311 = var1312 | 8977;	// _1311 = BinOp(_1312 BIT_OR +8977 i16)
	var4837 = var1310 / var1311;	// _4837 = BinOp(_1310 DIV _1311)
	__builtin_add_overflow(0x1, var41, &var4833);
	// ^ Call( _4833 = "overflowing_add"::<u32,>( 0x1 u32, _41, ), bb683, bb399)
	var4831 = var61 % var108;	// _4831 = BinOp(_61 MOD _108)
	var4829 = var34 & 0x1f;	// _4829 = BinOp(_34 BIT_AND 0x1f u32)
	var4830 = var41 >> var4829;
	// ^ Call( _4830 = "unchecked_shr"::<u32,>( _41, _4829, ), bb684, bb399)
	__builtin_add_overflow(var108, var4830, &var4832);
	// ^ Call( _4832 = "overflowing_add"::<u32,>( _108, _4830, ), bb685, bb399)
	__builtin_sub_overflow(var4831, var4832, &var4834);
	// ^ Call( _4834 = "overflowing_sub"::<u32,>( _4831, _4832, ), bb686, bb399)
	__builtin_sub_overflow(var4833, var4834, &var4838);
	// ^ Call( _4838 = "overflowing_sub"::<u32,>( _4833, _4834, ), bb687, bb399)
	var4835 = var4838 & 0xf;	// _4835 = BinOp(_4838 BIT_AND 0xf u32)
	var4836 = (int16_t )var4835;	// _4836 = Cast(_4835 as i16)
	var1314 = var4837 << var4836;
	// ^ Call( _1314 = "unchecked_shl"::<i16,>( _4837, _4836, ), bb688, bb399)
	var4839 = (uint16_t )var74;	// _4839 = Cast(_74 as u16)
	var4840 = var98 | 0x332b;	// _4840 = BinOp(_98 BIT_OR 0x332b u16)
	var1316 = var4839 % var4840;	// _1316 = BinOp(_4839 MOD _4840)
	var1317 = (uint8_t )var1316;	// _1317 = Cast(_1316 as u8)
	var1315 = 0x0 * var1317;	// _1315 = BinOp(0x0 u8 MUL _1317)
	var151 = var1315 & var81;	// _151 = BinOp(_1315 BIT_AND _81)
	var4841 = var59 / -82;	// _4841 = BinOp(_59 DIV -82 i8)
	var4842 = var42 * var8;	// _4842 = BinOp(_42 MUL _8)
	__builtin_sub_overflow(var4841, var4842, &var1318);
	// ^ Call( _1318 = "overflowing_sub"::<i8,>( _4841, _4842, ), bb689, bb399)
	var1319 = (uint32_t )var1318;	// _1319 = Cast(_1318 as u32)
	__builtin_add_overflow(var109, 8959587227405949369ll, &var1320);
	// ^ Call( _1320 = "overflowing_add"::<isize,>( _109, +8959587227405949369 isize, ), bb690, bb399)
	var4844 = (uint32_t )var1320;	// _4844 = Cast(_1320 as u32)
	var4843 = var4844 & 0x1f;	// _4843 = BinOp(_4844 BIT_AND 0x1f u32)
	var1321 = 0xdf3f4b8c >> var4843;
	// ^ Call( _1321 = "unchecked_shr"::<u32,>( 0xdf3f4b8c u32, _4843, ), bb691, bb399)
	var4849 = var1319 & var1321;	// _4849 = BinOp(_1319 BIT_AND _1321)
	var1324 = (uint32_t )var75;	// _1324 = Cast(_75 as u32)
	var1323 = 0x97961b79 ^ var1324;	// _1323 = BinOp(0x97961b79 u32 BIT_XOR _1324)
	var4846 = var95 / 0xae9e61ea;	// _4846 = BinOp(_95 DIV 0xae9e61ea u32)
	var4845 = var4846 & 0x1f;	// _4845 = BinOp(_4846 BIT_AND 0x1f u32)
	var1325 = 0x5daa4dd7 << var4845;
	// ^ Call( _1325 = "unchecked_shl"::<u32,>( 0x5daa4dd7 u32, _4845, ), bb692, bb399)
	var1322 = var1323 + var1325;	// _1322 = BinOp(_1323 ADD _1325)
	var4847 = 0x70ad048c | var92;	// _4847 = BinOp(0x70ad048c u32 BIT_OR _92)
	__builtin_add_overflow(0xf5677a2a, var71, &var4848);
	// ^ Call( _4848 = "overflowing_add"::<u32,>( 0xf5677a2a u32, _71, ), bb693, bb399)
	__builtin_add_overflow(var4847, var4848, &var1326);
	// ^ Call( _1326 = "overflowing_add"::<u32,>( _4847, _4848, ), bb694, bb399)
	var4850 = var1322 - var1326;	// _4850 = BinOp(_1322 SUB _1326)
	__builtin_sub_overflow(var4849, var4850, &var152);
	// ^ Call( _152 = "overflowing_sub"::<u32,>( _4849, _4850, ), bb695, bb399)
	var153 = 0xac49;	// _153 = Constant(0xac49 u16)
	var4851 = 0xe287 / var24;	// _4851 = BinOp(0xe287 u16 DIV _24)
	var4856 = var4851 / 0x12fb;	// _4856 = BinOp(_4851 DIV 0x12fb u16)
	var4853 = var92 % var41;	// _4853 = BinOp(_92 MOD _41)
	var4852 = var4853 & 0x1f;	// _4852 = BinOp(_4853 BIT_AND 0x1f u32)
	var4857 = 0xd2074bfc >> var4852;
	// ^ Call( _4857 = "unchecked_shr"::<u32,>( 0xd2074bfc u32, _4852, ), bb696, bb399)
	var4854 = var4857 & 0xf;	// _4854 = BinOp(_4857 BIT_AND 0xf u32)
	var4855 = (uint16_t )var4854;	// _4855 = Cast(_4854 as u16)
	var1328 = var4856 >> var4855;
	// ^ Call( _1328 = "unchecked_shr"::<u16,>( _4856, _4855, ), bb697, bb399)
	__builtin_sub_overflow(var23, 0x6cd0, &var1331);
	// ^ Call( _1331 = "overflowing_sub"::<u16,>( _23, 0x6cd0 u16, ), bb698, bb399)
	var1330 = var1331 + 0x1ae1;	// _1330 = BinOp(_1331 ADD 0x1ae1 u16)
	var1329 = var1330 & var106;	// _1329 = BinOp(_1330 BIT_AND _106)
	var1327 = var1328 * var1329;	// _1327 = BinOp(_1328 MUL _1329)
	var4858 = var98 & 0x14f9;	// _4858 = BinOp(_98 BIT_AND 0x14f9 u16)
	var4859 = var24 | var131;	// _4859 = BinOp(_24 BIT_OR _131)
	__builtin_sub_overflow(var4858, var4859, &var1334);
	// ^ Call( _1334 = "overflowing_sub"::<u16,>( _4858, _4859, ), bb699, bb399)
	var1335 = var17 & var24;	// _1335 = BinOp(_17 BIT_AND _24)
	var1333 = var1334 | var1335;	// _1333 = BinOp(_1334 BIT_OR _1335)
	var1336 = var106 * var149;	// _1336 = BinOp(_106 MUL _149)
	var1332 = var1333 * var1336;	// _1332 = BinOp(_1333 MUL _1336)
	var154 = var1327 * var1332;	// _154 = BinOp(_1327 MUL _1332)
	__builtin_mul_overflow(0x6c, 0x9d, &var1337);
	// ^ Call( _1337 = "overflowing_mul"::<u8,>( 0x6c u8, 0x9d u8, ), bb700, bb399)
	var4864 = var151 / var1337;	// _4864 = BinOp(_151 DIV _1337)
	__builtin_sub_overflow(0x4f0b8bd, var61, &var4860);
	// ^ Call( _4860 = "overflowing_sub"::<u32,>( 0x4f0b8bd u32, _61, ), bb701, bb399)
	__builtin_sub_overflow(0x203edd88, 0xfefc2faf, &var4861);
	// ^ Call( _4861 = "overflowing_sub"::<u32,>( 0x203edd88 u32, 0xfefc2faf u32, ), bb702, bb399)
	var4865 = var4860 % var4861;	// _4865 = BinOp(_4860 MOD _4861)
	var4862 = var4865 & 0x7;	// _4862 = BinOp(_4865 BIT_AND 0x7 u32)
	var4863 = (uint8_t )var4862;	// _4863 = Cast(_4862 as u8)
	var1338 = var4864 >> var4863;
	// ^ Call( _1338 = "unchecked_shr"::<u8,>( _4864, _4863, ), bb703, bb399)
	var1339 = var9.lo;	// _1339 = Cast(_9 as u8)
	var1340 = var129 * var77;	// _1340 = BinOp(_129 MUL _77)
	var4866 = var1339 ^ var1340;	// _4866 = BinOp(_1339 BIT_XOR _1340)
	var4867 = 0xe << 0x3;
	// ^ Call( _4867 = "unchecked_shl"::<u8,>( 0xe u8, 0x3 u8, ), bb704, bb399)
	__builtin_sub_overflow(var4866, var4867, &var1341);
	// ^ Call( _1341 = "overflowing_sub"::<u8,>( _4866, _4867, ), bb705, bb399)
	var1342 = var101 / var137;	// _1342 = BinOp(_101 DIV _137)
	__builtin_sub_overflow(0xc205cf8e0e2aa56eull, var101, &var1343);
	// ^ Call( _1343 = "overflowing_sub"::<u64,>( 0xc205cf8e0e2aa56e u64, _101, ), bb706, bb399)
	var4872 = var1342 ^ var1343;	// _4872 = BinOp(_1342 BIT_XOR _1343)
	var4868 = var47 - var49;	// _4868 = BinOp(_47 SUB _49)
	__builtin_mul_overflow(0x87a40473, var25, &var4869);
	// ^ Call( _4869 = "overflowing_mul"::<u32,>( 0x87a40473 u32, _25, ), bb707, bb399)
	__builtin_sub_overflow(var4868, var4869, &var4873);
	// ^ Call( _4873 = "overflowing_sub"::<u32,>( _4868, _4869, ), bb708, bb399)
	var4870 = var4873 & 0x3f;	// _4870 = BinOp(_4873 BIT_AND 0x3f u32)
	var4871 = (uint64_t )var4870;	// _4871 = Cast(_4870 as u64)
	var4874 = var4872 >> var4871;
	// ^ Call( _4874 = "unchecked_shr"::<u64,>( _4872, _4871, ), bb709, bb399)
	__builtin_add_overflow(var4874, var150, &var4880);
	// ^ Call( _4880 = "overflowing_add"::<u64,>( _4874, _150, ), bb710, bb399)
	var4875 = var79 & 0x3f;	// _4875 = BinOp(_79 BIT_AND 0x3f u32)
	var4876 = (int64_t )var4875;	// _4876 = Cast(_4875 as i64)
	var1345 = var148 >> var4876;
	// ^ Call( _1345 = "unchecked_shr"::<i64,>( _148, _4876, ), bb711, bb399)
	var1346 = (uint64_t )var1345;	// _1346 = Cast(_1345 as u64)
	var1344 = var1346 | var150;	// _1344 = BinOp(_1346 BIT_OR _150)
	var4877 = 0x7f6fdf7ffdbffd6full;	// _4877 = Constant(0x7f6fdf7ffdbffd6f u64)
	__builtin_add_overflow(var31, var74, &var4878);
	// ^ Call( _4878 = "overflowing_add"::<u64,>( _31, _74, ), bb712, bb399)
	var4879 = var4877 % var4878;	// _4879 = BinOp(_4877 MOD _4878)
	var1347 = var4879 >> 0xdull;
	// ^ Call( _1347 = "unchecked_shr"::<u64,>( _4879, 0xd u64, ), bb713, bb399)
	var4881 = var1344 * var1347;	// _4881 = BinOp(_1344 MUL _1347)
	__builtin_add_overflow(var4880, var4881, &var155);
	// ^ Call( _155 = "overflowing_add"::<u64,>( _4880, _4881, ), bb714, bb399)
	var1348 = var152 / 0x37c768db;	// _1348 = BinOp(_152 DIV 0x37c768db u32)
	__builtin_sub_overflow(0x45739d73, 0xf5e2e971, &var1349);
	// ^ Call( _1349 = "overflowing_sub"::<u32,>( 0x45739d73 u32, 0xf5e2e971 u32, ), bb715, bb399)
	var4886 = var1348 & var1349;	// _4886 = BinOp(_1348 BIT_AND _1349)
	var4883 = var108 ^ 0x5bb1c03e;	// _4883 = BinOp(_108 BIT_XOR 0x5bb1c03e u32)
	var4884 = var41 & var61;	// _4884 = BinOp(_41 BIT_AND _61)
	var4882 = var4884 & 0x1f;	// _4882 = BinOp(_4884 BIT_AND 0x1f u32)
	var4887 = var4883 << var4882;
	// ^ Call( _4887 = "unchecked_shl"::<u32,>( _4883, _4882, ), bb716, bb399)
	var4885 = var4887 & 0x1f;	// _4885 = BinOp(_4887 BIT_AND 0x1f u32)
	var1350 = var4886 << var4885;
	// ^ Call( _1350 = "unchecked_shl"::<u32,>( _4886, _4885, ), bb717, bb399)
	var156 = (uint64_t )var1350;	// _156 = Cast(_1350 as u64)
	var4888 = 0x42351e89 >> 0x3;
	// ^ Call( _4888 = "unchecked_shr"::<u32,>( 0x42351e89 u32, 0x3 u32, ), bb718, bb399)
	__builtin_sub_overflow(var34, var4888, &var4890);
	// ^ Call( _4890 = "overflowing_sub"::<u32,>( _34, _4888, ), bb719, bb399)
	var4889 = var61 & 0x1f;	// _4889 = BinOp(_61 BIT_AND 0x1f u32)
	var1351 = var4890 >> var4889;
	// ^ Call( _1351 = "unchecked_shr"::<u32,>( _4890, _4889, ), bb720, bb399)
	var4891 = var1351 / var22;	// _4891 = BinOp(_1351 DIV _22)
	var157 = var4891 / 0x12cf289c;	// _157 = BinOp(_4891 DIV 0x12cf289c u32)
	var158 = var33;	// _158 = Use(_33)
	var4893 = var113 | 475046820694834435ll;	// _4893 = BinOp(_113 BIT_OR +475046820694834435 isize)
	var4894 = var55 | var32;	// _4894 = BinOp(_55 BIT_OR _32)
	var4892 = ZRICv15overflowing_div0g( var4893, var4894 );
	// ^ Call( _4892 = <isize /*- */>::overflowing_div( _4893, _4894, ), bb721, bb399)
	var4895 = ZRICv15overflowing_rem0g( -7323965563134275776ll, -3332606229494339299ll );
	// ^ Call( _4895 = <isize /*- */>::overflowing_rem( -7323965563134275776 isize, -3332606229494339299 isize, ), bb722, bb399)
	var4898 = (uint16_t )var158;	// _4898 = Cast(_158 as u16)
	var4896 = var61 & 0xf;	// _4896 = BinOp(_61 BIT_AND 0xf u32)
	var4897 = (uint16_t )var4896;	// _4897 = Cast(_4896 as u16)
	var1352 = var4898 >> var4897;
	// ^ Call( _1352 = "unchecked_shr"::<u16,>( _4898, _4897, ), bb723, bb399)
	var1353 = var5 * var84;	// _1353 = BinOp(_5 MUL _84)
	var1354 = -var1353;	// _1354 = UniOp(_1353 NEG)
	var4901 = (uint32_t )var1354;	// _4901 = Cast(_1354 as u32)
	var4899 = var4901 & 0xf;	// _4899 = BinOp(_4901 BIT_AND 0xf u32)
	var4900 = (uint16_t )var4899;	// _4900 = Cast(_4899 as u16)
	var1355 = var66 >> var4900;
	// ^ Call( _1355 = "unchecked_shr"::<u16,>( _66, _4900, ), bb724, bb399)
	__builtin_add_overflow(0x39, 0x45, &var4902);
	// ^ Call( _4902 = "overflowing_add"::<u8,>( 0x39 u8, 0x45 u8, ), bb725, bb399)
	var4903 = var118 + 0xcd;	// _4903 = BinOp(_118 ADD 0xcd u8)
	var4906 = var4902 / var4903;	// _4906 = BinOp(_4902 DIV _4903)
	var4904 = var22 & 0x7;	// _4904 = BinOp(_22 BIT_AND 0x7 u32)
	var4905 = (uint8_t )var4904;	// _4905 = Cast(_4904 as u8)
	var1357 = var54 >> var4905;
	// ^ Call( _1357 = "unchecked_shr"::<u8,>( _54, _4905, ), bb726, bb399)
	var4907 = 0xb4 ^ var1357;	// _4907 = BinOp(0xb4 u8 BIT_XOR _1357)
	__builtin_sub_overflow(var4906, var4907, &var1358);
	// ^ Call( _1358 = "overflowing_sub"::<u8,>( _4906, _4907, ), bb727, bb399)
	var1359 = 0x90 - var7;	// _1359 = BinOp(0x90 u8 SUB _7)
	var4908 = var1359 & 0xae;	// _4908 = BinOp(_1359 BIT_AND 0xae u8)
	__builtin_sub_overflow(var118, var4908, &var1360);
	// ^ Call( _1360 = "overflowing_sub"::<u8,>( _118, _4908, ), bb728, bb399)
	var1356 = var1358 / var1360;	// _1356 = BinOp(_1358 DIV _1360)
	var4909 = var126 * 0x1c;	// _4909 = BinOp(_126 MUL 0x1c u8)
	__builtin_add_overflow(var4909, var147, &var4910);
	// ^ Call( _4910 = "overflowing_add"::<u8,>( _4909, _147, ), bb729, bb399)
	var1362 = var4910 << 0x0;
	// ^ Call( _1362 = "unchecked_shl"::<u8,>( _4910, 0x0 u8, ), bb730, bb399)
	var4911 = var92 ^ var2;	// _4911 = BinOp(_92 BIT_XOR _2)
	__builtin_add_overflow(0xa587, var4911, &var4914);
	// ^ Call( _4914 = "overflowing_add"::<u32,>( 0xa587 u32, _4911, ), bb731, bb399)
	var4912 = var4914 & 0x7;	// _4912 = BinOp(_4914 BIT_AND 0x7 u32)
	var4913 = (uint8_t )var4912;	// _4913 = Cast(_4912 as u8)
	var1363 = var97 >> var4913;
	// ^ Call( _1363 = "unchecked_shr"::<u8,>( _97, _4913, ), bb732, bb399)
	var1361 = var1362 / var1363;	// _1361 = BinOp(_1362 DIV _1363)
	var159 = var1356 + var1361;	// _159 = BinOp(_1356 ADD _1361)
	var4915 = ZRICf15overflowing_rem0g( var86, 1368905094 );
	// ^ Call( _4915 = <i32 /*- */>::overflowing_rem( _86, +1368905094 i32, ), bb733, bb399)
	var1364 = -var4915._0;	// _1364 = UniOp(_4915.0 NEG)
	var4917 = -var1364;	// _4917 = UniOp(_1364 NEG)
	var4916 = ZRICf15overflowing_rem0g( 1450971579, var4917 );
	// ^ Call( _4916 = <i32 /*- */>::overflowing_rem( +1450971579 i32, _4917, ), bb734, bb399)
	var1365 = -var38;	// _1365 = UniOp(_38 NEG)
	var1366 = -var1365;	// _1366 = UniOp(_1365 NEG)
	var4923 = (uint8_t )var1366;	// _4923 = Cast(_1366 as u8)
	var4918 = 0x4afc7259 % var92;	// _4918 = BinOp(0x4afc7259 u32 MOD _92)
	var4919 = var141 / var25;	// _4919 = BinOp(_141 DIV _25)
	__builtin_mul_overflow(var4918, var4919, &var4920);
	// ^ Call( _4920 = "overflowing_mul"::<u32,>( _4918, _4919, ), bb735, bb399)
	var4924 = var4920 << 0xf;
	// ^ Call( _4924 = "unchecked_shl"::<u32,>( _4920, 0xf u32, ), bb736, bb399)
	var4921 = var4924 & 0x7;	// _4921 = BinOp(_4924 BIT_AND 0x7 u32)
	var4922 = (uint8_t )var4921;	// _4922 = Cast(_4921 as u8)
	var1367 = var4923 << var4922;
	// ^ Call( _1367 = "unchecked_shl"::<u8,>( _4923, _4922, ), bb737, bb399)
	__builtin_sub_overflow(0xdf, 0xcd, &var1368);
	// ^ Call( _1368 = "overflowing_sub"::<u8,>( 0xdf u8, 0xcd u8, ), bb738, bb399)
	var160 = var3;	// _160 = Use(_3)
	var1370 = 0x33c99f64 & var49;	// _1370 = BinOp(0x33c99f64 u32 BIT_AND _49)
	var1371 = 0x2371fda0 / var71;	// _1371 = BinOp(0x2371fda0 u32 DIV _71)
	var1369 = var1370 ^ var1371;	// _1369 = BinOp(_1370 BIT_XOR _1371)
	var4927 = var1369 / var152;	// _4927 = BinOp(_1369 DIV _152)
	var4925 = var4927 & 0x3f;	// _4925 = BinOp(_4927 BIT_AND 0x3f u32)
	var4926 = (int64_t )var4925;	// _4926 = Cast(_4925 as i64)
	var1372 = 1ll >> var4926;
	// ^ Call( _1372 = "unchecked_shr"::<i64,>( +1 i64, _4926, ), bb739, bb399)
	var4928 = 0x4d19 << 0xb;
	// ^ Call( _4928 = "unchecked_shl"::<u16,>( 0x4d19 u16, 0xb u16, ), bb740, bb399)
	var4929 = var45 - var106;	// _4929 = BinOp(_45 SUB _106)
	__builtin_sub_overflow(var4928, var4929, &var1373);
	// ^ Call( _1373 = "overflowing_sub"::<u16,>( _4928, _4929, ), bb741, bb399)
	var4930.lo = var1373; var4930.hi = var1373 < 0 ? -1 : 0;	// _4930 = Cast(_1373 as u128)
	mul128_o(var4930, var160, &var4935);
	// ^ Call( _4935 = "overflowing_mul"::<u128,>( _4930, _160, ), bb742, bb399)
	var1374 = var2 % var152;	// _1374 = BinOp(_2 MOD _152)
	var4932.lo = var1374; var4932.hi = var1374 < 0 ? -1 : 0;	// _4932 = Cast(_1374 as u128)
	sub128_o(var57, var144, &var4931);
	// ^ Call( _4931 = "overflowing_sub"::<u128,>( _57, _144, ), bb743, bb399)
	add128_o(make128_raw(978989964077967912ull, 4972261068655942735ull), var4931, &var4933);
	// ^ Call( _4933 = "overflowing_add"::<u128,>( 0xd96122f778a2a284501051907bddc4f u128, _4931, ), bb744, bb399)
	add128_o(var4932, var4933, &var4934);
	// ^ Call( _4934 = "overflowing_add"::<u128,>( _4932, _4933, ), bb745, bb399)
	sub128_o(make128_raw(9265985347879057468ull, 10116473799710835135ull), var4934, &var4936);
	// ^ Call( _4936 = "overflowing_sub"::<u128,>( 0x80976494a24e383c8c64ef524b4f81bf u128, _4934, ), bb746, bb399)
	add128_o(var4935, var4936, &var1375);
	// ^ Call( _1375 = "overflowing_add"::<u128,>( _4935, _4936, ), bb747, bb399)
	var4937 = 0x22db56c2;	// _4937 = Constant(0x22db56c2 u32)
	__builtin_mul_overflow(0xa1b85dfc, var2, &var4938);
	// ^ Call( _4938 = "overflowing_mul"::<u32,>( 0xa1b85dfc u32, _2, ), bb748, bb399)
	__builtin_add_overflow(var4937, var4938, &var1376);
	// ^ Call( _1376 = "overflowing_add"::<u32,>( _4937, _4938, ), bb749, bb399)
	var4939 = var152 & 0x1f;	// _4939 = BinOp(_152 BIT_AND 0x1f u32)
	var1378 = var108 >> var4939;
	// ^ Call( _1378 = "unchecked_shr"::<u32,>( _108, _4939, ), bb750, bb399)
	var1377 = var49 * var1378;	// _1377 = BinOp(_49 MUL _1378)
	var4941 = var1376 * var1377;	// _4941 = BinOp(_1376 MUL _1377)
	__builtin_mul_overflow(0xb0a1046, 0xf3eb4858, &var4940);
	// ^ Call( _4940 = "overflowing_mul"::<u32,>( 0xb0a1046 u32, 0xf3eb4858 u32, ), bb751, bb399)
	__builtin_sub_overflow(var4940, var41, &var1379);
	// ^ Call( _1379 = "overflowing_sub"::<u32,>( _4940, _41, ), bb752, bb399)
	var4942 = var1379 & var157;	// _4942 = BinOp(_1379 BIT_AND _157)
	__builtin_sub_overflow(var4941, var4942, &var1380);
	// ^ Call( _1380 = "overflowing_sub"::<u32,>( _4941, _4942, ), bb753, bb399)
	__builtin_mul_overflow(0x25ecc2e, 0x2060ecb3, &var1381);
	// ^ Call( _1381 = "overflowing_mul"::<u32,>( 0x25ecc2e u32, 0x2060ecb3 u32, ), bb754, bb399)
	var1384 = 20519;	// _1384 = Constant(+20519 i16)
	var4943 = ZRICd15overflowing_rem0g( 7548, var13 );
	// ^ Call( _4943 = <i16 /*- */>::overflowing_rem( +7548 i16, _13, ), bb755, bb399)
	var1385 = -var4943._0;	// _1385 = UniOp(_4943.0 NEG)
	var1383 = var1384 + var1385;	// _1383 = BinOp(_1384 ADD _1385)
	var1386 = var30 - 3678;	// _1386 = BinOp(_30 SUB +3678 i16)
	var1387 = -var1386;	// _1387 = UniOp(_1386 NEG)
	var1388 = -var1387;	// _1388 = UniOp(_1387 NEG)
	var1382 = var1383 & var1388;	// _1382 = BinOp(_1383 BIT_AND _1388)
	var161 = (uintptr_t )var1382;	// _161 = Cast(_1382 as usize)
	var4944 = var95 & 0xf;	// _4944 = BinOp(_95 BIT_AND 0xf u32)
	var4945 = (uint16_t )var4944;	// _4945 = Cast(_4944 as u16)
	var162 = 0xffef >> var4945;
	// ^ Call( _162 = "unchecked_shr"::<u16,>( 0xffef u16, _4945, ), bb756, bb399)
	var1389 = (intptr_t )var155;	// _1389 = Cast(_155 as isize)
	var1390 = (int8_t )var1389;	// _1390 = Cast(_1389 as i8)
	var1391 = -var1390;	// _1391 = UniOp(_1390 NEG)
	var1392 = (uint32_t )var1391;	// _1392 = Cast(_1391 as u32)
	var163 = var1392 / 0xbc00d2b6;	// _163 = BinOp(_1392 DIV 0xbc00d2b6 u32)
	var4948 = -var139;	// _4948 = UniOp(_139 NEG)
	var1394 = var127 / var141;	// _1394 = BinOp(_127 DIV _141)
	var1395 = var79 - var157;	// _1395 = BinOp(_79 SUB _157)
	var4949 = var1394 & var1395;	// _4949 = BinOp(_1394 BIT_AND _1395)
	var4946 = var4949 & 0x3f;	// _4946 = BinOp(_4949 BIT_AND 0x3f u32)
	var4947 = (int64_t )var4946;	// _4947 = Cast(_4946 as i64)
	var1396 = var4948 << var4947;
	// ^ Call( _1396 = "unchecked_shl"::<i64,>( _4948, _4947, ), bb757, bb399)
	var1397 = (int8_t )var27;	// _1397 = Cast(_27 as i8)
	var1398 = (int64_t )var1397;	// _1398 = Cast(_1397 as i64)
	var1393 = var1396 + var1398;	// _1393 = BinOp(_1396 ADD _1398)
	var164 = 2453017949391454059ll * var1393;	// _164 = BinOp(+2453017949391454059 i64 MUL _1393)
	var4950 = 0x9d27221ab1052121ull | var133;	// _4950 = BinOp(0x9d27221ab1052121 u64 BIT_OR _133)
	__builtin_sub_overflow(0xee9c547d3300bc29ull, var4950, &var4951);
	// ^ Call( _4951 = "overflowing_sub"::<u64,>( 0xee9c547d3300bc29 u64, _4950, ), bb758, bb399)
	__builtin_add_overflow(0x6c58fa95895aebf0ull, 0x2d4378c4d214196full, &var1399);
	// ^ Call( _1399 = "overflowing_add"::<u64,>( 0x6c58fa95895aebf0 u64, 0x2d4378c4d214196f u64, ), bb759, bb399)
	var1400 = 0x67360ed2f4633831ull << 0x30ull;
	// ^ Call( _1400 = "unchecked_shl"::<u64,>( 0x67360ed2f4633831 u64, 0x30 u64, ), bb760, bb399)
	__builtin_mul_overflow(-1897603362, -54427607, &var1401);
	// ^ Call( _1401 = "overflowing_mul"::<i32,>( -1897603362 i32, -54427607 i32, ), bb761, bb399)
	var1402 = make128s_raw(4212423744964271237ull, 6954066895807477606ull);	// _1402 = Constant(+77705502753373066120364365715283146598 i128)
	var1404 = var85 / 8;	// _1404 = BinOp(_85 DIV +8 i8)
	var4955.lo = var1404; var4955.hi = var1404 < 0 ? -1 : 0;	// _4955 = Cast(_1404 as i128)
	var4954 = shl128s(var115, make128s_raw(0ull, 47ull).lo);
	// ^ Call( _4954 = "unchecked_shl"::<i128,>( _115, +47 i128, ), bb762, bb399)
	var4952 = var157 & 0x7f;	// _4952 = BinOp(_157 BIT_AND 0x7f u32)
	var4953.lo = var4952; var4953.hi = var4952 < 0 ? -1 : 0;	// _4953 = Cast(_4952 as i128)
	var4956 = shl128s(var4954, var4953.lo);
	// ^ Call( _4956 = "unchecked_shl"::<i128,>( _4954, _4953, ), bb763, bb399)
	mul128s_o(var4955, var4956, &var1405);
	// ^ Call( _1405 = "overflowing_mul"::<i128,>( _4955, _4956, ), bb764, bb399)
	var1407 = neg128s(var28);	// _1407 = UniOp(_28 NEG)
	var1406 = or128s(var1407, make128s_raw(2210069055237391296ull, 8438236056851228766ull));	// _1406 = BinOp(_1407 BIT_OR +40768578247189215575523308922552363102 i128)
	var1408 = neg128s(var1406);	// _1408 = UniOp(_1406 NEG)
	var1403 = add128s(var1405, var1408);	// _1403 = BinOp(_1405 ADD _1408)
	var165 = xor128s(var1402, var1403);	// _165 = BinOp(_1402 BIT_XOR _1403)
	var4957 = var47 & 0xf;	// _4957 = BinOp(_47 BIT_AND 0xf u32)
	var4958 = (uint16_t )var4957;	// _4958 = Cast(_4957 as u16)
	var4959 = 0xbac9 >> var4958;
	// ^ Call( _4959 = "unchecked_shr"::<u16,>( 0xbac9 u16, _4958, ), bb765, bb399)
	__builtin_mul_overflow(var134, var149, &var4960);
	// ^ Call( _4960 = "overflowing_mul"::<u16,>( _134, _149, ), bb766, bb399)
	__builtin_mul_overflow(var4959, var4960, &var1411);
	// ^ Call( _1411 = "overflowing_mul"::<u16,>( _4959, _4960, ), bb767, bb399)
	var1410 = 0x527b * var1411;	// _1410 = BinOp(0x527b u16 MUL _1411)
	var1409 = var124 | var1410;	// _1409 = BinOp(_124 BIT_OR _1410)
	__builtin_sub_overflow(var39, var106, &var1415);
	// ^ Call( _1415 = "overflowing_sub"::<u16,>( _39, _106, ), bb768, bb399)
	var1414 = var1415 * var66;	// _1414 = BinOp(_1415 MUL _66)
	var1413 = var1414 & 0xa736;	// _1413 = BinOp(_1414 BIT_AND 0xa736 u16)
	var1418 = var131 >> 0x3;
	// ^ Call( _1418 = "unchecked_shr"::<u16,>( _131, 0x3 u16, ), bb769, bb399)
	var1417 = var1418 / 0x61b0;	// _1417 = BinOp(_1418 DIV 0x61b0 u16)
	var4961 = var153 / 0x2496;	// _4961 = BinOp(_153 DIV 0x2496 u16)
	__builtin_add_overflow(var4961, 0x80, &var1419);
	// ^ Call( _1419 = "overflowing_add"::<u16,>( _4961, 0x80 u16, ), bb770, bb399)
	var1416 = var1417 / var1419;	// _1416 = BinOp(_1417 DIV _1419)
	var1412 = var1413 - var1416;	// _1412 = BinOp(_1413 SUB _1416)
	var166 = var1409 ^ var1412;	// _166 = BinOp(_1409 BIT_XOR _1412)
	var4962 = ZRICd15overflowing_div0g( 466, 371 );
	// ^ Call( _4962 = <i16 /*- */>::overflowing_div( +466 i16, +371 i16, ), bb771, bb399)
	var1421 = var4962._0 / var52;	// _1421 = BinOp(_4962.0 DIV _52)
	var1420 = var1421 * -17412;	// _1420 = BinOp(_1421 MUL -17412 i16)
	var1422 = (uint16_t )var1420;	// _1422 = Cast(_1420 as u16)
	__builtin_mul_overflow(var98, 0xffa8, &var1425);
	// ^ Call( _1425 = "overflowing_mul"::<u16,>( _98, 0xffa8 u16, ), bb772, bb399)
	__builtin_add_overflow(0xacf0, 0xbaab, &var4965);
	// ^ Call( _4965 = "overflowing_add"::<u16,>( 0xacf0 u16, 0xbaab u16, ), bb773, bb399)
	__builtin_add_overflow(0xde70dc41, var95, &var4966);
	// ^ Call( _4966 = "overflowing_add"::<u32,>( 0xde70dc41 u32, _95, ), bb774, bb399)
	var4963 = var4966 & 0xf;	// _4963 = BinOp(_4966 BIT_AND 0xf u32)
	var4964 = (uint16_t )var4963;	// _4964 = Cast(_4963 as u16)
	var1426 = var4965 >> var4964;
	// ^ Call( _1426 = "unchecked_shr"::<u16,>( _4965, _4964, ), bb775, bb399)
	var1424 = var1425 / var1426;	// _1424 = BinOp(_1425 DIV _1426)
	var1423 = 0xa312 + var1424;	// _1423 = BinOp(0xa312 u16 ADD _1424)
	var167 = var1422 ^ var1423;	// _167 = BinOp(_1422 BIT_XOR _1423)
	var168 = 0x6af2596c;	// _168 = Constant(0x6af2596c u32)
	var1427 = 0x2;	// _1427 = Constant(0x2 u16)
	var4969 = (uint32_t )var13;	// _4969 = Cast(_13 as u32)
	var4967 = var4969 & 0xf;	// _4967 = BinOp(_4969 BIT_AND 0xf u32)
	var4968 = (uint16_t )var4967;	// _4968 = Cast(_4967 as u16)
	var1428 = 0xc435 >> var4968;
	// ^ Call( _1428 = "unchecked_shr"::<u16,>( 0xc435 u16, _4968, ), bb776, bb399)
	var4971 = var1427 * var1428;	// _4971 = BinOp(_1427 MUL _1428)
	__builtin_mul_overflow(var11, 0xf309, &var4970);
	// ^ Call( _4970 = "overflowing_mul"::<u16,>( _11, 0xf309 u16, ), bb777, bb399)
	__builtin_mul_overflow(0x6f11, var4970, &var1429);
	// ^ Call( _1429 = "overflowing_mul"::<u16,>( 0x6f11 u16, _4970, ), bb778, bb399)
	var4972 = var1429 + var68;	// _4972 = BinOp(_1429 ADD _68)
	__builtin_sub_overflow(var4971, var4972, &var4980);
	// ^ Call( _4980 = "overflowing_sub"::<u16,>( _4971, _4972, ), bb779, bb399)
	var4973 = 0xa8;	// _4973 = Constant(0xa8 u16)
	__builtin_sub_overflow(var134, 0x5a41, &var4974);
	// ^ Call( _4974 = "overflowing_sub"::<u16,>( _134, 0x5a41 u16, ), bb780, bb399)
	var1431 = var4973 / var4974;	// _1431 = BinOp(_4973 DIV _4974)
	var4978 = var39 % 0x138d;	// _4978 = BinOp(_39 MOD 0x138d u16)
	var4975 = var163 & 0x1f;	// _4975 = BinOp(_163 BIT_AND 0x1f u32)
	var4979 = 0x51600408 >> var4975;
	// ^ Call( _4979 = "unchecked_shr"::<u32,>( 0x51600408 u32, _4975, ), bb781, bb399)
	var4976 = var4979 & 0xf;	// _4976 = BinOp(_4979 BIT_AND 0xf u32)
	var4977 = (uint16_t )var4976;	// _4977 = Cast(_4976 as u16)
	var1432 = var4978 << var4977;
	// ^ Call( _1432 = "unchecked_shl"::<u16,>( _4978, _4977, ), bb782, bb399)
	var1430 = var1431 + var1432;	// _1430 = BinOp(_1431 ADD _1432)
	var1433 = 0xfca8 & var167;	// _1433 = BinOp(0xfca8 u16 BIT_AND _167)
	var4981 = var1430 | var1433;	// _4981 = BinOp(_1430 BIT_OR _1433)
	var169 = var4980 % var4981;	// _169 = BinOp(_4980 MOD _4981)
	var4982 = ZRICb15overflowing_div0g( -67, 56 );
	// ^ Call( _4982 = <i8 /*- */>::overflowing_div( -67 i8, +56 i8, ), bb783, bb399)
	var170 = var4982._0;	// _170 = Use(_4982.0)
	var171 = -36;	// _171 = Constant(+220 i8)
	var4983 = 94 * var40;	// _4983 = BinOp(+94 i8 MUL _40)
	var4984 = -103 ^ var12;	// _4984 = BinOp(-103 i8 BIT_XOR _12)
	__builtin_add_overflow(var4983, var4984, &var1436);
	// ^ Call( _1436 = "overflowing_add"::<i8,>( _4983, _4984, ), bb784, bb399)
	var1435 = var1436 * var8;	// _1435 = BinOp(_1436 MUL _8)
	var1437 = -var19;	// _1437 = UniOp(_19 NEG)
	var1434 = var1435 * var1437;	// _1434 = BinOp(_1435 MUL _1437)
	var172 = -var1434;	// _172 = UniOp(_1434 NEG)
	__builtin_add_overflow(var92, var163, &var4985);
	// ^ Call( _4985 = "overflowing_add"::<u32,>( _92, _163, ), bb785, bb399)
	__builtin_sub_overflow(var163, var61, &var4986);
	// ^ Call( _4986 = "overflowing_sub"::<u32,>( _163, _61, ), bb786, bb399)
	var4989 = var4985 / var4986;	// _4989 = BinOp(_4985 DIV _4986)
	var4987 = var4989 & 0x3f;	// _4987 = BinOp(_4989 BIT_AND 0x3f u32)
	var4988 = (uintptr_t )var4987;	// _4988 = Cast(_4987 as usize)
	var1439 = 0xb73e5e04f5487874ull << var4988;
	// ^ Call( _1439 = "unchecked_shl"::<usize,>( 0xb73e5e04f5487874 usize, _4988, ), bb787, bb399)
	var1438 = var1439 > 0x335ull;	// _1438 = BinOp(_1439 GT 0x335 usize)
	if(var1438) goto bb794; else goto bb788;
	// ^ If( _1438 : 794, 788)
bb788:
	var1442 = var116 << 0x7;
	// ^ Call( _1442 = "unchecked_shl"::<u16,>( _116, 0x7 u16, ), bb789, bb399)
	var1443 = var106 | var68;	// _1443 = BinOp(_106 BIT_OR _68)
	var1441 = var1442 > var1443;	// _1441 = BinOp(_1442 GT _1443)
	if(var1441) goto bb790; else goto bb791;
	// ^ If( _1441 : 790, 791)
bb790:
	var1440 = true;	// _1440 = Constant(true)
	goto bb793;
	// ^ Goto(793)
bb791:
	var1444 = var117 % var69;	// _1444 = BinOp(_117 MOD _69)
	__builtin_sub_overflow(0x10, 0xb6, &var1445);
	// ^ Call( _1445 = "overflowing_sub"::<u8,>( 0x10 u8, 0xb6 u8, ), bb792, bb399)
	var1440 = var1444 > var1445;	// _1440 = BinOp(_1444 GT _1445)
	// ^ Goto(793)
bb793:
	if(var1440) goto bb794; else goto bb794;
	// ^ If( _1440 : 794, 794)
bb794:
	var4990 = var90 / 1149587639;	// _4990 = BinOp(_90 DIV +1149587639 i32)
	__builtin_sub_overflow(var4990, 2044152166, &var1446);
	// ^ Call( _1446 = "overflowing_sub"::<i32,>( _4990, +2044152166 i32, ), bb795, bb399)
	var1447 = -var1446;	// _1447 = UniOp(_1446 NEG)
	var1448 = -var1447;	// _1448 = UniOp(_1447 NEG)
	var1450 = -var5;	// _1450 = UniOp(_5 NEG)
	var4991 = 1551808543 * var1450;	// _4991 = BinOp(+1551808543 i32 MUL _1450)
	__builtin_sub_overflow(var4991, -568858627, &var1451);
	// ^ Call( _1451 = "overflowing_sub"::<i32,>( _4991, -568858627 i32, ), bb796, bb399)
	var1454 = var33 + var1;	// _1454 = BinOp(_33 ADD _1)
	var1453 = var1454 ^ -1315518544;	// _1453 = BinOp(_1454 BIT_XOR +5202038394457606064 i32)
	__builtin_mul_overflow(955635773, 868783177, &var1455);
	// ^ Call( _1455 = "overflowing_mul"::<i32,>( +955635773 i32, +868783177 i32, ), bb797, bb399)
	var1456 = -var1455;	// _1456 = UniOp(_1455 NEG)
	var1452 = var1453 ^ var1456;	// _1452 = BinOp(_1453 BIT_XOR _1456)
	var1449 = var1451 + var1452;	// _1449 = BinOp(_1451 ADD _1452)
	var173 = var1448 & var1449;	// _173 = BinOp(_1448 BIT_AND _1449)
	var1458 = 0x41afbc39 * var157;	// _1458 = BinOp(0x41afbc39 u32 MUL _157)
	var1459 = var2 * var34;	// _1459 = BinOp(_2 MUL _34)
	var1457 = var1458 * var1459;	// _1457 = BinOp(_1458 MUL _1459)
	__builtin_add_overflow(var79, 0x56c5d14a, &var4992);
	// ^ Call( _4992 = "overflowing_add"::<u32,>( _79, 0x56c5d14a u32, ), bb798, bb399)
	__builtin_mul_overflow(var4992, 0x4eaeaba7, &var1460);
	// ^ Call( _1460 = "overflowing_mul"::<u32,>( _4992, 0x4eaeaba7 u32, ), bb799, bb399)
	var4995 = var1457 | var1460;	// _4995 = BinOp(_1457 BIT_OR _1460)
	var4993 = var4995 & 0x3f;	// _4993 = BinOp(_4995 BIT_AND 0x3f u32)
	var4994 = (uintptr_t )var4993;	// _4994 = Cast(_4993 as usize)
	var1461 = 0x43a8b2c2155c809eull << var4994;
	// ^ Call( _1461 = "unchecked_shl"::<usize,>( 0x43a8b2c2155c809e usize, _4994, ), bb800, bb399)
	var1462.lo = var60; var1462.hi = var60 < 0 ? -1 : 0;	// _1462 = Cast(_60 as i128)
	var4998 = var1462.lo;	// _4998 = Cast(_1462 as u32)
	var4996 = var4998 & 0x1f;	// _4996 = BinOp(_4998 BIT_AND 0x1f u32)
	var4997 = (int32_t )var4996;	// _4997 = Cast(_4996 as i32)
	var5000 = var145 << var4997;
	// ^ Call( _5000 = "unchecked_shl"::<i32,>( _145, _4997, ), bb801, bb399)
	var4999 = ZRICf15overflowing_div0g( var5000, 421426497 );
	// ^ Call( _4999 = <i32 /*- */>::overflowing_div( _5000, +421426497 i32, ), bb802, bb399)
	var1463 = var88 >> 0;
	// ^ Call( _1463 = "unchecked_shr"::<i32,>( _88, +0 i32, ), bb803, bb399)
	var1464 = -var1463;	// _1464 = UniOp(_1463 NEG)
	var5001 = var1464 - -50361197;	// _5001 = BinOp(_1464 SUB -50361197 i32)
	__builtin_sub_overflow(var4999._0, var5001, &var1465);
	// ^ Call( _1465 = "overflowing_sub"::<i32,>( _4999.0, _5001, ), bb804, bb399)
	var1468 = 7976886077762996105ll << 20ll;
	// ^ Call( _1468 = "unchecked_shl"::<isize,>( +7976886077762996105 isize, +20 isize, ), bb805, bb399)
	var1467 = var1468 ^ 484984003209053641ll;	// _1467 = BinOp(_1468 BIT_XOR +484984003209053641 isize)
	var1469 = -var1467;	// _1469 = UniOp(_1467 NEG)
	var5002 = ZRICv15overflowing_div0g( var32, -4217642346925688838ll );
	// ^ Call( _5002 = <isize /*- */>::overflowing_div( _32, -4217642346925688838 isize, ), bb806, bb399)
	var1472 = -var64;	// _1472 = UniOp(_64 NEG)
	var1471 = var5002._0 ^ var1472;	// _1471 = BinOp(_5002.0 BIT_XOR _1472)
	__builtin_add_overflow(var113, var109, &var1473);
	// ^ Call( _1473 = "overflowing_add"::<isize,>( _113, _109, ), bb807, bb399)
	var1474 = -var1473;	// _1474 = UniOp(_1473 NEG)
	var1470 = var1471 + var1474;	// _1470 = BinOp(_1471 ADD _1474)
	var1466 = var1469 / var1470;	// _1466 = BinOp(_1469 DIV _1470)
	var5003 = ZRICf15overflowing_div0g( var122, -1895841097 );
	// ^ Call( _5003 = <i32 /*- */>::overflowing_div( _122, -1895841097 i32, ), bb808, bb399)
	var5006 = (uint32_t )var121;	// _5006 = Cast(_121 as u32)
	var5004 = var5006 & 0x1f;	// _5004 = BinOp(_5006 BIT_AND 0x1f u32)
	var5005 = (int32_t )var5004;	// _5005 = Cast(_5004 as i32)
	var5008 = var5003._0 << var5005;
	// ^ Call( _5008 = "unchecked_shl"::<i32,>( _5003.0, _5005, ), bb809, bb399)
	__builtin_add_overflow(-1344567928, var15, &var5007);
	// ^ Call( _5007 = "overflowing_add"::<i32,>( -1344567928 i32, _15, ), bb810, bb399)
	__builtin_sub_overflow(496745131, var5007, &var5009);
	// ^ Call( _5009 = "overflowing_sub"::<i32,>( +496745131 i32, _5007, ), bb811, bb399)
	__builtin_sub_overflow(var5008, var5009, &var1475);
	// ^ Call( _1475 = "overflowing_sub"::<i32,>( _5008, _5009, ), bb812, bb399)
	var1476 = (intptr_t )var1475;	// _1476 = Cast(_1475 as isize)
	var174 = var1466 ^ var1476;	// _174 = BinOp(_1466 BIT_XOR _1476)
	__builtin_sub_overflow(var54, var63, &var5010);
	// ^ Call( _5010 = "overflowing_sub"::<u8,>( _54, _63, ), bb813, bb399)
	__builtin_sub_overflow(var7, var5010, &var5013);
	// ^ Call( _5013 = "overflowing_sub"::<u8,>( _7, _5010, ), bb814, bb399)
	var5014 = var108 % 0xa952e797;	// _5014 = BinOp(_108 MOD 0xa952e797 u32)
	var5011 = var5014 & 0x7;	// _5011 = BinOp(_5014 BIT_AND 0x7 u32)
	var5012 = (uint8_t )var5011;	// _5012 = Cast(_5011 as u8)
	var5015 = var5013 << var5012;
	// ^ Call( _5015 = "unchecked_shl"::<u8,>( _5013, _5012, ), bb815, bb399)
	__builtin_sub_overflow(var5015, var120, &var1477);
	// ^ Call( _1477 = "overflowing_sub"::<u8,>( _5015, _120, ), bb816, bb399)
	var5016 = var117 & 0xc9;	// _5016 = BinOp(_117 BIT_AND 0xc9 u8)
	__builtin_mul_overflow(var129, 0x4c, &var5017);
	// ^ Call( _5017 = "overflowing_mul"::<u8,>( _129, 0x4c u8, ), bb817, bb399)
	__builtin_sub_overflow(var5016, var5017, &var1478);
	// ^ Call( _1478 = "overflowing_sub"::<u8,>( _5016, _5017, ), bb818, bb399)
	var5018 = 0xef / var1478;	// _5018 = BinOp(0xef u8 DIV _1478)
	var1479 = var5018 / var130;	// _1479 = BinOp(_5018 DIV _130)
	var175 = var1477 & var1479;	// _175 = BinOp(_1477 BIT_AND _1479)
	var1481 = var6 / 0x74ed4555;	// _1481 = BinOp(_6 DIV 0x74ed4555 u32)
	var1482 = 0x9007ca45 ^ var25;	// _1482 = BinOp(0x9007ca45 u32 BIT_XOR _25)
	var1480 = var1481 | var1482;	// _1480 = BinOp(_1481 BIT_OR _1482)
	var1483 = 0xb3253e46 / var108;	// _1483 = BinOp(0xb3253e46 u32 DIV _108)
	var5019 = var1480 / var1483;	// _5019 = BinOp(_1480 DIV _1483)
	var5020 = var5019 % 0xfffffff9;	// _5020 = BinOp(_5019 MOD 0xfffffff9 u32)
	var176 = var71 / var5020;	// _176 = BinOp(_71 DIV _5020)
	var5021 = var53 * var27;	// _5021 = BinOp(_53 MUL _27)
	var5022 = var53 ^ 0x501e9811ca4d5a6eull;	// _5022 = BinOp(_53 BIT_XOR 0x501e9811ca4d5a6e usize)
	__builtin_sub_overflow(var5021, var5022, &var5023);
	// ^ Call( _5023 = "overflowing_sub"::<usize,>( _5021, _5022, ), bb819, bb399)
	__builtin_add_overflow(0xf30b, var18, &var1485);
	// ^ Call( _1485 = "overflowing_add"::<u16,>( 0xf30b u16, _18, ), bb820, bb399)
	var5024 = (uintptr_t )var1485;	// _5024 = Cast(_1485 as usize)
	var1486 = var5023 / var5024;	// _1486 = BinOp(_5023 DIV _5024)
	var5025 = var127 & 0x3f;	// _5025 = BinOp(_127 BIT_AND 0x3f u32)
	var5026 = (uintptr_t )var5025;	// _5026 = Cast(_5025 as usize)
	var5029 = var76 >> var5026;
	// ^ Call( _5029 = "unchecked_shr"::<usize,>( _76, _5026, ), bb821, bb399)
	__builtin_mul_overflow(var67, 0x94cc163e, &var5030);
	// ^ Call( _5030 = "overflowing_mul"::<u32,>( _67, 0x94cc163e u32, ), bb822, bb399)
	var5027 = var5030 & 0x3f;	// _5027 = BinOp(_5030 BIT_AND 0x3f u32)
	var5028 = (uintptr_t )var5027;	// _5028 = Cast(_5027 as usize)
	var1488 = var5029 >> var5028;
	// ^ Call( _1488 = "unchecked_shr"::<usize,>( _5029, _5028, ), bb823, bb399)
	var5031 = var114 << 0x2full;
	// ^ Call( _5031 = "unchecked_shl"::<usize,>( _114, 0x2f usize, ), bb824, bb399)
	__builtin_add_overflow(var161, var27, &var5032);
	// ^ Call( _5032 = "overflowing_add"::<usize,>( _161, _27, ), bb825, bb399)
	__builtin_add_overflow(var5031, var5032, &var1489);
	// ^ Call( _1489 = "overflowing_add"::<usize,>( _5031, _5032, ), bb826, bb399)
	var1487 = var1488 / var1489;	// _1487 = BinOp(_1488 DIV _1489)
	var1484 = var1486 >= var1487;	// _1484 = BinOp(_1486 GE _1487)
	if(var1484) goto bb827; else goto bb830;
	// ^ If( _1484 : 827, 830)
bb827:
	var5034 = var41 & 0x1f;	// _5034 = BinOp(_41 BIT_AND 0x1f u32)
	var5035 = (int32_t )var5034;	// _5035 = Cast(_5034 as i32)
	var5037 = 757726598 >> var5035;
	// ^ Call( _5037 = "unchecked_shr"::<i32,>( +757726598 i32, _5035, ), bb828, bb399)
	var5038 = var90 ^ -1639540432;	// _5038 = BinOp(_90 BIT_XOR -1639540432 i32)
	var5036 = ZRICf15overflowing_div0g( var5037, var5038 );
	// ^ Call( _5036 = <i32 /*- */>::overflowing_div( _5037, _5038, ), bb829, bb399)
	var1490 = var5036._0 < 2058132545;	// _1490 = BinOp(_5036.0 LT +2058132545 i32)
	if(var1490) goto bb830; else goto bb830;
	// ^ If( _1490 : 830, 830)
bb830:
	var1491 = var108 | 0x9e3fcf9e;	// _1491 = BinOp(_108 BIT_OR 0x9e3fcf9e u32)
	var5033 = var2 & 0x1f;	// _5033 = BinOp(_2 BIT_AND 0x1f u32)
	var1492 = var61 << var5033;
	// ^ Call( _1492 = "unchecked_shl"::<u32,>( _61, _5033, ), bb831, bb399)
	var5039 = var1491 - var1492;	// _5039 = BinOp(_1491 SUB _1492)
	var5042 = var5039 / 0x754f;	// _5042 = BinOp(_5039 DIV 0x754f u32)
	var5040 = 0x43b876e9 ^ var79;	// _5040 = BinOp(0x43b876e9 u32 BIT_XOR _79)
	var1493 = 0xeda59d92 % var5040;	// _1493 = BinOp(0xeda59d92 u32 MOD _5040)
	__builtin_mul_overflow(var92, 0x2d4cba36, &var1494);
	// ^ Call( _1494 = "overflowing_mul"::<u32,>( _92, 0x2d4cba36 u32, ), bb832, bb399)
	var5043 = var1493 & var1494;	// _5043 = BinOp(_1493 BIT_AND _1494)
	var5041 = var5043 & 0x1f;	// _5041 = BinOp(_5043 BIT_AND 0x1f u32)
	var5046 = var5042 << var5041;
	// ^ Call( _5046 = "unchecked_shl"::<u32,>( _5042, _5041, ), bb833, bb399)
	var1497 = var71 / 0x12cb21ef;	// _1497 = BinOp(_71 DIV 0x12cb21ef u32)
	var1496 = var95 | var1497;	// _1496 = BinOp(_95 BIT_OR _1497)
	var5044 = var71 ^ 0x98db3520;	// _5044 = BinOp(_71 BIT_XOR 0x98db3520 u32)
	__builtin_sub_overflow(0x5988, var5044, &var1498);
	// ^ Call( _1498 = "overflowing_sub"::<u32,>( 0x5988 u32, _5044, ), bb834, bb399)
	var1495 = var1496 / var1498;	// _1495 = BinOp(_1496 DIV _1498)
	var1499 = 3001983724647392369ll * var113;	// _1499 = BinOp(+3001983724647392369 isize MUL _113)
	var5045 = (uint32_t )var1499;	// _5045 = Cast(_1499 as u32)
	__builtin_sub_overflow(0x8ecb93f2, var5045, &var1500);
	// ^ Call( _1500 = "overflowing_sub"::<u32,>( 0x8ecb93f2 u32, _5045, ), bb835, bb399)
	var5047 = var1495 | var1500;	// _5047 = BinOp(_1495 BIT_OR _1500)
	__builtin_add_overflow(var5046, var5047, &var177);
	// ^ Call( _177 = "overflowing_add"::<u32,>( _5046, _5047, ), bb836, bb399)
	var5048 = 0xd9064edd / var108;	// _5048 = BinOp(0xd9064edd u32 DIV _108)
	__builtin_sub_overflow(0x5f, var5048, &var5049);
	// ^ Call( _5049 = "overflowing_sub"::<u32,>( 0x5f u32, _5048, ), bb837, bb399)
	var5050 = 0xba5ce90e / var25;	// _5050 = BinOp(0xba5ce90e u32 DIV _25)
	__builtin_sub_overflow(var5049, var5050, &var1501);
	// ^ Call( _1501 = "overflowing_sub"::<u32,>( _5049, _5050, ), bb838, bb399)
	__builtin_mul_overflow(0x0, var168, &var1502);
	// ^ Call( _1502 = "overflowing_mul"::<u32,>( 0x0 u32, _168, ), bb839, bb399)
	var1503 = var79 / 0x46fb0635;	// _1503 = BinOp(_79 DIV 0x46fb0635 u32)
	var5051 = 0xf0330db3 | var1503;	// _5051 = BinOp(0xf0330db3 u32 BIT_OR _1503)
	var1504 = (uint32_t )var88;	// _1504 = Cast(_88 as u32)
	var5052 = var1504 | 0xfff2f7df;	// _5052 = BinOp(_1504 BIT_OR 0xfff2f7df u32)
	__builtin_add_overflow(var5051, var5052, &var1505);
	// ^ Call( _1505 = "overflowing_add"::<u32,>( _5051, _5052, ), bb840, bb399)
	__builtin_sub_overflow(var110, var77, &var1509);
	// ^ Call( _1509 = "overflowing_sub"::<u8,>( _110, _77, ), bb841, bb399)
	var1508 = var1509 ^ 0xdd;	// _1508 = BinOp(_1509 BIT_XOR 0xdd u8)
	var1511 = var78 ^ 0xe4;	// _1511 = BinOp(_78 BIT_XOR 0xe4 u8)
	var1510 = 0xa3 / var1511;	// _1510 = BinOp(0xa3 u8 DIV _1511)
	var1507 = var1508 / var1510;	// _1507 = BinOp(_1508 DIV _1510)
	var1513 = var99 % 0x6d;	// _1513 = BinOp(_99 MOD 0x6d u8)
	var5053 = var117 % 0xe4;	// _5053 = BinOp(_117 MOD 0xe4 u8)
	var1514 = 0x39 / var5053;	// _1514 = BinOp(0x39 u8 DIV _5053)
	var1512 = var1513 - var1514;	// _1512 = BinOp(_1513 SUB _1514)
	var1506 = var1507 | var1512;	// _1506 = BinOp(_1507 BIT_OR _1512)
	var178 = 0x41 | var1506;	// _178 = BinOp(0x41 u8 BIT_OR _1506)
	__builtin_add_overflow(var145, var173, &var1515);
	// ^ Call( _1515 = "overflowing_add"::<i32,>( _145, _173, ), bb842, bb399)
	__builtin_add_overflow(var125, 445316403, &var1516);
	// ^ Call( _1516 = "overflowing_add"::<i32,>( _125, +445316403 i32, ), bb843, bb399)
	var5055 = var1515 + var1516;	// _5055 = BinOp(_1515 ADD _1516)
	var1517 = -810136401 | var94;	// _1517 = BinOp(-810136401 i32 BIT_OR _94)
	var1518 = (int32_t )var169;	// _1518 = Cast(_169 as i32)
	var5056 = var1517 | var1518;	// _5056 = BinOp(_1517 BIT_OR _1518)
	var5054 = ZRICf15overflowing_div0g( var5055, var5056 );
	// ^ Call( _5054 = <i32 /*- */>::overflowing_div( _5055, _5056, ), bb844, bb399)
	var5059 = -var5054._0;	// _5059 = UniOp(_5054.0 NEG)
	var5057 = var41 & 0x1f;	// _5057 = BinOp(_41 BIT_AND 0x1f u32)
	var5058 = (int32_t )var5057;	// _5058 = Cast(_5057 as i32)
	var5060 = 2130164821 << var5058;
	// ^ Call( _5060 = "unchecked_shl"::<i32,>( +2130164821 i32, _5058, ), bb845, bb399)
	__builtin_mul_overflow(var5059, var5060, &var1519);
	// ^ Call( _1519 = "overflowing_mul"::<i32,>( _5059, _5060, ), bb846, bb399)
	var5061 = var92 & 0x1f;	// _5061 = BinOp(_92 BIT_AND 0x1f u32)
	var5062 = (int32_t )var5061;	// _5062 = Cast(_5061 as i32)
	var5064 = var88 << var5062;
	// ^ Call( _5064 = "unchecked_shl"::<i32,>( _88, _5062, ), bb847, bb399)
	var5065 = 1443983216 ^ var158;	// _5065 = BinOp(+1443983216 i32 BIT_XOR _158)
	var5063 = ZRICf15overflowing_div0g( var5064, var5065 );
	// ^ Call( _5063 = <i32 /*- */>::overflowing_div( _5064, _5065, ), bb848, bb399)
	var1520 = -var5063._0;	// _1520 = UniOp(_5063.0 NEG)
	var5066 = -var1520;	// _5066 = UniOp(_1520 NEG)
	var1522 = (int32_t )var54;	// _1522 = Cast(_54 as i32)
	var1521 = var1522 & -1218792933;	// _1521 = BinOp(_1522 BIT_AND -1218792933 i32)
	var1523 = -var1521;	// _1523 = UniOp(_1521 NEG)
	var5067 = var1523 ^ 1118513883;	// _5067 = BinOp(_1523 BIT_XOR +1118513883 i32)
	__builtin_sub_overflow(var5066, var5067, &var179);
	// ^ Call( _179 = "overflowing_sub"::<i32,>( _5066, _5067, ), bb849, bb399)
	__builtin_add_overflow(-29730, 1919, &var1525);
	// ^ Call( _1525 = "overflowing_add"::<i16,>( -29730 i16, +1919 i16, ), bb850, bb399)
	var1526 = -var1525;	// _1526 = UniOp(_1525 NEG)
	var1524 = var1526 ^ 0;	// _1524 = BinOp(_1526 BIT_XOR +0 i16)
	var5071 = -var1524;	// _5071 = UniOp(_1524 NEG)
	var1527 = -var50;	// _1527 = UniOp(_50 NEG)
	var1528 = -var1527;	// _1528 = UniOp(_1527 NEG)
	var5069 = -var1528;	// _5069 = UniOp(_1528 NEG)
	var5068 = ZRICd15overflowing_div0g( var142, var60 );
	// ^ Call( _5068 = <i16 /*- */>::overflowing_div( _142, _60, ), bb851, bb399)
	var1530 = -var60;	// _1530 = UniOp(_60 NEG)
	var1529 = var5068._0 ^ var1530;	// _1529 = BinOp(_5068.0 BIT_XOR _1530)
	var5070 = var1529 / -1562;	// _5070 = BinOp(_1529 DIV -1562 i16)
	__builtin_sub_overflow(var5069, var5070, &var5072);
	// ^ Call( _5072 = "overflowing_sub"::<i16,>( _5069, _5070, ), bb852, bb399)
	__builtin_mul_overflow(var5071, var5072, &var1531);
	// ^ Call( _1531 = "overflowing_mul"::<i16,>( _5071, _5072, ), bb853, bb399)
	var1532 = 0x9b27080c / var168;	// _1532 = BinOp(0x9b27080c u32 DIV _168)
	var5074 = var1532 * 0xa4fe95d8;	// _5074 = BinOp(_1532 MUL 0xa4fe95d8 u32)
	var1533 = var152 | 0x5efc8099;	// _1533 = BinOp(_152 BIT_OR 0x5efc8099 u32)
	var5075 = var71 & var1533;	// _5075 = BinOp(_71 BIT_AND _1533)
	var5073 = var5075 & 0x1f;	// _5073 = BinOp(_5075 BIT_AND 0x1f u32)
	var5076 = var5074 >> var5073;
	// ^ Call( _5076 = "unchecked_shr"::<u32,>( _5074, _5073, ), bb854, bb399)
	__builtin_add_overflow(var163, var5076, &var5079);
	// ^ Call( _5079 = "overflowing_add"::<u32,>( _163, _5076, ), bb855, bb399)
	var5077 = var163 / var49;	// _5077 = BinOp(_163 DIV _49)
	__builtin_mul_overflow(var25, var25, &var5078);
	// ^ Call( _5078 = "overflowing_mul"::<u32,>( _25, _25, ), bb856, bb399)
	var1535 = var5077 / var5078;	// _1535 = BinOp(_5077 DIV _5078)
	var1534 = var177 | var1535;	// _1534 = BinOp(_177 BIT_OR _1535)
	__builtin_mul_overflow(var176, 0x92cfbb8e, &var1536);
	// ^ Call( _1536 = "overflowing_mul"::<u32,>( _176, 0x92cfbb8e u32, ), bb857, bb399)
	var5080 = var1534 ^ var1536;	// _5080 = BinOp(_1534 BIT_XOR _1536)
	__builtin_sub_overflow(var5079, var5080, &var1537);
	// ^ Call( _1537 = "overflowing_sub"::<u32,>( _5079, _5080, ), bb858, bb399)
	var180 = var175;	// _180 = Use(_175)
	var5083 = var132.lo;	// _5083 = Cast(_132 as u32)
	var5081 = var5083 & 0xf;	// _5081 = BinOp(_5083 BIT_AND 0xf u32)
	var5082 = (uint16_t )var5081;	// _5082 = Cast(_5081 as u16)
	var5084 = var45 >> var5082;
	// ^ Call( _5084 = "unchecked_shr"::<u16,>( _45, _5082, ), bb859, bb399)
	__builtin_add_overflow(0x33dd, var5084, &var1538);
	// ^ Call( _1538 = "overflowing_add"::<u16,>( 0x33dd u16, _5084, ), bb860, bb399)
	var5096 = (int16_t )var1538;	// _5096 = Cast(_1538 as i16)
	var5085 = var157 * var141;	// _5085 = BinOp(_157 MUL _141)
	var5086 = var51 | var176;	// _5086 = BinOp(_51 BIT_OR _176)
	var5088 = var5085 % var5086;	// _5088 = BinOp(_5085 MOD _5086)
	var5087 = var5088 & 0x1f;	// _5087 = BinOp(_5088 BIT_AND 0x1f u32)
	var1539 = 0xffffffec << var5087;
	// ^ Call( _1539 = "unchecked_shl"::<u32,>( 0xffffffec u32, _5087, ), bb861, bb399)
	var5089 = var6 % var61;	// _5089 = BinOp(_6 MOD _61)
	var5090 = var79 / var141;	// _5090 = BinOp(_79 DIV _141)
	var1541 = var5089 / var5090;	// _1541 = BinOp(_5089 DIV _5090)
	var5092 = var71 >> 0xe;
	// ^ Call( _5092 = "unchecked_shr"::<u32,>( _71, 0xe u32, ), bb862, bb399)
	var5093 = var34 / 0x11099c46;	// _5093 = BinOp(_34 DIV 0x11099c46 u32)
	var5091 = var5093 & 0x1f;	// _5091 = BinOp(_5093 BIT_AND 0x1f u32)
	var1542 = var5092 << var5091;
	// ^ Call( _1542 = "unchecked_shl"::<u32,>( _5092, _5091, ), bb863, bb399)
	var1540 = var1541 + var1542;	// _1540 = BinOp(_1541 ADD _1542)
	var5097 = var1539 | var1540;	// _5097 = BinOp(_1539 BIT_OR _1540)
	var5094 = var5097 & 0xf;	// _5094 = BinOp(_5097 BIT_AND 0xf u32)
	var5095 = (int16_t )var5094;	// _5095 = Cast(_5094 as i16)
	var181 = var5096 >> var5095;
	// ^ Call( _181 = "unchecked_shr"::<i16,>( _5096, _5095, ), bb864, bb399)
	var1544 = -var59;	// _1544 = UniOp(_59 NEG)
	var1543 = var1544 + 3;	// _1543 = BinOp(_1544 ADD +3 i8)
	var5102 = -var1543;	// _5102 = UniOp(_1543 NEG)
	var5098 = var22 << 0x1c;
	// ^ Call( _5098 = "unchecked_shl"::<u32,>( _22, 0x1c u32, ), bb865, bb399)
	var5099 = var107.lo;	// _5099 = Cast(_107 as u32)
	var1545 = var5098 % var5099;	// _1545 = BinOp(_5098 MOD _5099)
	var5103 = var1545 / 0x38c30c37;	// _5103 = BinOp(_1545 DIV 0x38c30c37 u32)
	var5100 = var5103 & 0x7;	// _5100 = BinOp(_5103 BIT_AND 0x7 u32)
	var5101 = (int8_t )var5100;	// _5101 = Cast(_5100 as i8)
	var5104 = var5102 << var5101;
	// ^ Call( _5104 = "unchecked_shl"::<i8,>( _5102, _5101, ), bb866, bb399)
	var5105 = var12 - 72;	// _5105 = BinOp(_12 SUB +72 i8)
	__builtin_add_overflow(var5104, var5105, &var182);
	// ^ Call( _182 = "overflowing_add"::<i8,>( _5104, _5105, ), bb867, bb399)
	__builtin_mul_overflow(var164, var164, &var5106);
	// ^ Call( _5106 = "overflowing_mul"::<i64,>( _164, _164, ), bb868, bb399)
	__builtin_sub_overflow(-8754458446545229731ll, var148, &var5107);
	// ^ Call( _5107 = "overflowing_sub"::<i64,>( -8754458446545229731 i64, _148, ), bb869, bb399)
	__builtin_sub_overflow(var5106, var5107, &var1547);
	// ^ Call( _1547 = "overflowing_sub"::<i64,>( _5106, _5107, ), bb870, bb399)
	var1546 = 6452425059092296854ll | var1547;	// _1546 = BinOp(+6452425059092296854 i64 BIT_OR _1547)
	var1548 = -var1546;	// _1548 = UniOp(_1546 NEG)
	var183 = -var1548;	// _183 = UniOp(_1548 NEG)
	var1549 = -41;	// _1549 = Constant(-41 i8)
	var1550 = 0x88 - var151;	// _1550 = BinOp(0x88 u8 SUB _151)
	var5108 = (int32_t )var1550;	// _5108 = Cast(_1550 as i32)
	__builtin_sub_overflow(var1, var5108, &var1551);
	// ^ Call( _1551 = "overflowing_sub"::<i32,>( _1, _5108, ), bb871, bb399)
	var1552 = (int8_t )var1551;	// _1552 = Cast(_1551 as i8)
	var184 = var1549 - var1552;	// _184 = BinOp(_1549 SUB _1552)
	var185 = -var16;	// _185 = UniOp(_16 NEG)
	var186 = 0x25acull;	// _186 = Constant(0x25ac u64)
	var5109 = var126 | 0x5;	// _5109 = BinOp(_126 BIT_OR 0x5 u8)
	__builtin_add_overflow(var130, var5109, &var1554);
	// ^ Call( _1554 = "overflowing_add"::<u8,>( _130, _5109, ), bb872, bb399)
	var1553 = var1554 ^ 0x65;	// _1553 = BinOp(_1554 BIT_XOR 0x65 u8)
	var5117 = var1553 * var151;	// _5117 = BinOp(_1553 MUL _151)
	var5110 = 0x56 ^ var96;	// _5110 = BinOp(0x56 u8 BIT_XOR _96)
	__builtin_add_overflow(var5110, 0x4e, &var5115);
	// ^ Call( _5115 = "overflowing_add"::<u8,>( _5110, 0x4e u8, ), bb873, bb399)
	var5111 = var22 & 0x1f;	// _5111 = BinOp(_22 BIT_AND 0x1f u32)
	var5112 = 0xda3d379b << var5111;
	// ^ Call( _5112 = "unchecked_shl"::<u32,>( 0xda3d379b u32, _5111, ), bb874, bb399)
	__builtin_mul_overflow(0x4648ed26, var5112, &var5116);
	// ^ Call( _5116 = "overflowing_mul"::<u32,>( 0x4648ed26 u32, _5112, ), bb875, bb399)
	var5113 = var5116 & 0x7;	// _5113 = BinOp(_5116 BIT_AND 0x7 u32)
	var5114 = (uint8_t )var5113;	// _5114 = Cast(_5113 as u8)
	var1555 = var5115 >> var5114;
	// ^ Call( _1555 = "unchecked_shr"::<u8,>( _5115, _5114, ), bb876, bb399)
	var5118 = 0x41 | var1555;	// _5118 = BinOp(0x41 u8 BIT_OR _1555)
	__builtin_mul_overflow(var5117, var5118, &var187);
	// ^ Call( _187 = "overflowing_mul"::<u8,>( _5117, _5118, ), bb877, bb399)
	var5119 = ZRICf15overflowing_rem0g( 471576639, -1955948521 );
	// ^ Call( _5119 = <i32 /*- */>::overflowing_rem( +471576639 i32, -1955948521 i32, ), bb878, bb399)
	__builtin_sub_overflow(0x8ae958df, var22, &var1556);
	// ^ Call( _1556 = "overflowing_sub"::<u32,>( 0x8ae958df u32, _22, ), bb879, bb399)
	var1558 = 0x5341ee42;	// _1558 = Constant(0x5341ee42 u32)
	var1559 = 0x8148ded << 0xd;
	// ^ Call( _1559 = "unchecked_shl"::<u32,>( 0x8148ded u32, 0xd u32, ), bb880, bb399)
	var1557 = var1558 / var1559;	// _1557 = BinOp(_1558 DIV _1559)
	var5122 = var1556 - var1557;	// _5122 = BinOp(_1556 SUB _1557)
	var5120 = var5122 & 0x1f;	// _5120 = BinOp(_5122 BIT_AND 0x1f u32)
	var5121 = (int32_t )var5120;	// _5121 = Cast(_5120 as i32)
	var1560 = var5119._0 << var5121;
	// ^ Call( _1560 = "unchecked_shl"::<i32,>( _5119.0, _5121, ), bb881, bb399)
	var188 = var1560 | var84;	// _188 = BinOp(_1560 BIT_OR _84)
	var1562 = shr128(make128_raw(2962461520197608901ull, 10322731824256819177ull), make128_raw(0ull, 30ull).lo);
	// ^ Call( _1562 = "unchecked_shr"::<u128,>( 0x291cc70e8c2465c58f41b5e6e8729fe9 u128, 0x1e u128, ), bb882, bb399)
	var1561 = or128(var1562, make128_raw(1189522048362094608ull, 9224959766008253684ull));	// _1561 = BinOp(_1562 BIT_OR 0x10820800291e20108005a40800314cf4 u128)
	var5124 = var1561.lo;	// _5124 = Cast(_1561 as u32)
	var5123 = var79 / 0xb4a0a10f;	// _5123 = BinOp(_79 DIV 0xb4a0a10f u32)
	__builtin_mul_overflow(0xe3fbb068, var5123, &var1563);
	// ^ Call( _1563 = "overflowing_mul"::<u32,>( 0xe3fbb068 u32, _5123, ), bb883, bb399)
	var5125 = var1563 & var127;	// _5125 = BinOp(_1563 BIT_AND _127)
	__builtin_sub_overflow(var5124, var5125, &var1564);
	// ^ Call( _1564 = "overflowing_sub"::<u32,>( _5124, _5125, ), bb884, bb399)
	var189 = 0x3e0d;	// _189 = Constant(0x3e0d u16)
	var5126 = ZRICd15overflowing_rem0g( var181, 8699 );
	// ^ Call( _5126 = <i16 /*- */>::overflowing_rem( _181, +8699 i16, ), bb885, bb399)
	var1565 = var5126._0 * -6675;	// _1565 = BinOp(_5126.0 MUL +1800791533 i16)
	var5129 = -var1565;	// _5129 = UniOp(_1565 NEG)
	add128_o(var144, var14, &var1567);
	// ^ Call( _1567 = "overflowing_add"::<u128,>( _144, _14, ), bb886, bb399)
	var1568 = mod128(make128_raw(7069428001114524551ull, 18097907212873752237ull), var57);	// _1568 = BinOp(0x621ba74fc3a18b87fb28aeb92951dead u128 MOD _57)
	var1566 = add128(var1567, var1568);	// _1566 = BinOp(_1567 ADD _1568)
	var5130 = var1566.lo;	// _5130 = Cast(_1566 as u32)
	var5127 = var5130 & 0xf;	// _5127 = BinOp(_5130 BIT_AND 0xf u32)
	var5128 = (int16_t )var5127;	// _5128 = Cast(_5127 as i16)
	var1569 = var5129 << var5128;
	// ^ Call( _1569 = "unchecked_shl"::<i16,>( _5129, _5128, ), bb887, bb399)
	var190 = -var1569;	// _190 = UniOp(_1569 NEG)
	var5131 = var25 & 0xf;	// _5131 = BinOp(_25 BIT_AND 0xf u32)
	var5132 = (int16_t )var5131;	// _5132 = Cast(_5131 as i16)
	var1570 = 19214 << var5132;
	// ^ Call( _1570 = "unchecked_shl"::<i16,>( +19214 i16, _5132, ), bb888, bb399)
	var5133 = (uint16_t )var1570;	// _5133 = Cast(_1570 as u16)
	__builtin_sub_overflow(var158, -322204432, &var1571);
	// ^ Call( _1571 = "overflowing_sub"::<i32,>( _158, -322204432 i32, ), bb889, bb399)
	var5134 = (uint16_t )var1571;	// _5134 = Cast(_1571 as u16)
	__builtin_add_overflow(var5133, var5134, &var5135);
	// ^ Call( _5135 = "overflowing_add"::<u16,>( _5133, _5134, ), bb890, bb399)
	__builtin_mul_overflow(var5135, var46, &var5138);
	// ^ Call( _5138 = "overflowing_mul"::<u16,>( _5135, _46, ), bb891, bb399)
	var1573 = -var128;	// _1573 = UniOp(_128 NEG)
	var1572 = var1573 / -70;	// _1572 = BinOp(_1573 DIV -70 i8)
	var1574 = (uint16_t )var1572;	// _1574 = Cast(_1572 as u16)
	var5139 = (uint32_t )var1574;	// _5139 = Cast(_1574 as u32)
	var5136 = var5139 & 0xf;	// _5136 = BinOp(_5139 BIT_AND 0xf u32)
	var5137 = (uint16_t )var5136;	// _5137 = Cast(_5136 as u16)
	var191 = var5138 << var5137;
	// ^ Call( _191 = "unchecked_shl"::<u16,>( _5138, _5137, ), bb892, bb399)
	var1575 = 0x4b0aa64aa70fd673ull + var150;	// _1575 = BinOp(0x4b0aa64aa70fd673 u64 ADD _150)
	__builtin_mul_overflow(0x1d5109f45850443eull, 0xe4e7794ef9a56d13ull, &var1576);
	// ^ Call( _1576 = "overflowing_mul"::<u64,>( 0x1d5109f45850443e u64, 0xe4e7794ef9a56d13 u64, ), bb893, bb399)
	var5140 = var1575 / var1576;	// _5140 = BinOp(_1575 DIV _1576)
	__builtin_add_overflow(0x9d2a72ccdd5ea86dull, var5140, &var1577);
	// ^ Call( _1577 = "overflowing_add"::<u64,>( 0x9d2a72ccdd5ea86d u64, _5140, ), bb894, bb399)
	__builtin_add_overflow(var134, var46, &var5141);
	// ^ Call( _5141 = "overflowing_add"::<u16,>( _134, _46, ), bb895, bb399)
	var1578 = var5141 >> 0x9;
	// ^ Call( _1578 = "unchecked_shr"::<u16,>( _5141, 0x9 u16, ), bb896, bb399)
	var5144 = var154 % 0x109d;	// _5144 = BinOp(_154 MOD 0x109d u16)
	__builtin_add_overflow(0xbfaf5f9b, 0x79141758, &var5145);
	// ^ Call( _5145 = "overflowing_add"::<u32,>( 0xbfaf5f9b u32, 0x79141758 u32, ), bb897, bb399)
	var5142 = var5145 & 0xf;	// _5142 = BinOp(_5145 BIT_AND 0xf u32)
	var5143 = (uint16_t )var5142;	// _5143 = Cast(_5142 as u16)
	var1579 = var5144 << var5143;
	// ^ Call( _1579 = "unchecked_shl"::<u16,>( _5144, _5143, ), bb898, bb399)
	var1580 = 0xfffffffffdfd4bf7ull;	// _1580 = Constant(0xfffffffffdfd4bf7 u64)
	__builtin_add_overflow(3860528465148617235ll, var32, &var1582);
	// ^ Call( _1582 = "overflowing_add"::<isize,>( +3860528465148617235 isize, _32, ), bb899, bb399)
	var1583 = (int16_t )var1582;	// _1583 = Cast(_1582 as i16)
	var1581 = var1583 - 0;	// _1581 = BinOp(_1583 SUB +0 i16)
	var1584 = (uint64_t )var1581;	// _1584 = Cast(_1581 as u64)
	var192 = var1580 ^ var1584;	// _192 = BinOp(_1580 BIT_XOR _1584)
	var193 = var168;	// _193 = Use(_168)
	var5149 = or128s(var35, make128s_raw(9469497485441717801ull, 8561679598011953074ull));	// _5149 = BinOp(_35 BIT_OR -165600970300358954578774477021240741966 i128)
	var5146 = var157 & 0x1f;	// _5146 = BinOp(_157 BIT_AND 0x1f u32)
	var5150 = var127 << var5146;
	// ^ Call( _5150 = "unchecked_shl"::<u32,>( _127, _5146, ), bb900, bb399)
	var5147 = var5150 & 0x7f;	// _5147 = BinOp(_5150 BIT_AND 0x7f u32)
	var5148.lo = var5147; var5148.hi = var5147 < 0 ? -1 : 0;	// _5148 = Cast(_5147 as i128)
	var1585 = shr128s(var5149, var5148.lo);
	// ^ Call( _1585 = "unchecked_shr"::<i128,>( _5149, _5148, ), bb901, bb399)
	var1586 = neg128s(var1585);	// _1586 = UniOp(_1585 NEG)
	var1587 = neg128s(var1586);	// _1587 = UniOp(_1586 NEG)
	var194 = neg128s(var1587);	// _194 = UniOp(_1587 NEG)
	var195 = var183;	// _195 = Use(_183)
	var5153 = var60 / var30;	// _5153 = BinOp(_60 DIV _30)
	__builtin_mul_overflow(0xa8e99bea, var141, &var5154);
	// ^ Call( _5154 = "overflowing_mul"::<u32,>( 0xa8e99bea u32, _141, ), bb902, bb399)
	var5151 = var5154 & 0xf;	// _5151 = BinOp(_5154 BIT_AND 0xf u32)
	var5152 = (int16_t )var5151;	// _5152 = Cast(_5151 as i16)
	var1588 = var5153 >> var5152;
	// ^ Call( _1588 = "unchecked_shr"::<i16,>( _5153, _5152, ), bb903, bb399)
	__builtin_sub_overflow(var104, -166, &var1589);
	// ^ Call( _1589 = "overflowing_sub"::<i16,>( _104, -166 i16, ), bb904, bb399)
	var1590 = -var1589;	// _1590 = UniOp(_1589 NEG)
	var5157 = var1588 * var1590;	// _5157 = BinOp(_1588 MUL _1590)
	__builtin_mul_overflow(0xdfcee7e9, var71, &var1592);
	// ^ Call( _1592 = "overflowing_mul"::<u32,>( 0xdfcee7e9 u32, _71, ), bb905, bb399)
	var1593 = var127 / 0x45e76787;	// _1593 = BinOp(_127 DIV 0x45e76787 u32)
	var1591 = var1592 | var1593;	// _1591 = BinOp(_1592 BIT_OR _1593)
	var5158 = var1591 / var127;	// _5158 = BinOp(_1591 DIV _127)
	var5155 = var5158 & 0xf;	// _5155 = BinOp(_5158 BIT_AND 0xf u32)
	var5156 = (int16_t )var5155;	// _5156 = Cast(_5155 as i16)
	var1594 = var5157 >> var5156;
	// ^ Call( _1594 = "unchecked_shr"::<i16,>( _5157, _5156, ), bb906, bb399)
	var196 = 0x2d31f30edbb7c9cull;	// _196 = Constant(0x2d31f30edbb7c9c u64)
	__builtin_sub_overflow(var106, var166, &var5161);
	// ^ Call( _5161 = "overflowing_sub"::<u16,>( _106, _166, ), bb907, bb399)
	var5162 = var47 - 0x5791ba6c;	// _5162 = BinOp(_47 SUB 0x5791ba6c u32)
	var5159 = var5162 & 0xf;	// _5159 = BinOp(_5162 BIT_AND 0xf u32)
	var5160 = (uint16_t )var5159;	// _5160 = Cast(_5159 as u16)
	var1596 = var5161 >> var5160;
	// ^ Call( _1596 = "unchecked_shr"::<u16,>( _5161, _5160, ), bb908, bb399)
	var5163 = var153 / var153;	// _5163 = BinOp(_153 DIV _153)
	var1597 = 0xa058 % var5163;	// _1597 = BinOp(0xa058 u16 MOD _5163)
	var1595 = var1596 * var1597;	// _1595 = BinOp(_1596 MUL _1597)
	var1598 = var116 << 0x0;
	// ^ Call( _1598 = "unchecked_shl"::<u16,>( _116, 0x0 u16, ), bb909, bb399)
	var1599 = var24 + var116;	// _1599 = BinOp(_24 ADD _116)
	var5164 = var1598 ^ var1599;	// _5164 = BinOp(_1598 BIT_XOR _1599)
	var1600 = var5164 / var189;	// _1600 = BinOp(_5164 DIV _189)
	var5165 = var1595 * var1600;	// _5165 = BinOp(_1595 MUL _1600)
	var1601 = (int32_t )var186;	// _1601 = Cast(_186 as i32)
	var1602 = (uint16_t )var1601;	// _1602 = Cast(_1601 as u16)
	var5166 = var1602 ^ var23;	// _5166 = BinOp(_1602 BIT_XOR _23)
	__builtin_sub_overflow(var5165, var5166, &var1603);
	// ^ Call( _1603 = "overflowing_sub"::<u16,>( _5165, _5166, ), bb910, bb399)
	var1605 = -var183;	// _1605 = UniOp(_183 NEG)
	var1606 = -var164;	// _1606 = UniOp(_164 NEG)
	var1604 = var1605 * var1606;	// _1604 = BinOp(_1605 MUL _1606)
	var1607 = -var1604;	// _1607 = UniOp(_1604 NEG)
	var1608 = (uint8_t )var1607;	// _1608 = Cast(_1607 as u8)
	var5167 = var77 | 0x75;	// _5167 = BinOp(_77 BIT_OR 0x75 u8)
	var5168 = var103 / var7;	// _5168 = BinOp(_103 DIV _7)
	__builtin_mul_overflow(var5167, var5168, &var5169);
	// ^ Call( _5169 = "overflowing_mul"::<u8,>( _5167, _5168, ), bb911, bb399)
	__builtin_sub_overflow(var5169, 0x81, &var1610);
	// ^ Call( _1610 = "overflowing_sub"::<u8,>( _5169, 0x81 u8, ), bb912, bb399)
	var1609 = var159 / var1610;	// _1609 = BinOp(_159 DIV _1610)
	var197 = var1608 & var1609;	// _197 = BinOp(_1608 BIT_AND _1609)
	var5170 = var6 & 0x3f;	// _5170 = BinOp(_6 BIT_AND 0x3f u32)
	var5171 = (uint64_t )var5170;	// _5171 = Cast(_5170 as u64)
	var5172 = var155 << var5171;
	// ^ Call( _5172 = "unchecked_shl"::<u64,>( _155, _5171, ), bb913, bb399)
	__builtin_sub_overflow(var186, var133, &var5173);
	// ^ Call( _5173 = "overflowing_sub"::<u64,>( _186, _133, ), bb914, bb399)
	__builtin_mul_overflow(var5172, var5173, &var1611);
	// ^ Call( _1611 = "overflowing_mul"::<u64,>( _5172, _5173, ), bb915, bb399)
	var5174 = var114 - var76;	// _5174 = BinOp(_114 SUB _76)
	__builtin_sub_overflow(var5174, 0x1ull, &var1612);
	// ^ Call( _1612 = "overflowing_sub"::<usize,>( _5174, 0x1 usize, ), bb916, bb399)
	var5175 = (uint64_t )var1612;	// _5175 = Cast(_1612 as u64)
	__builtin_add_overflow(0x1aed6bd2ebd48ecfull, var5175, &var1613);
	// ^ Call( _1613 = "overflowing_add"::<u64,>( 0x1aed6bd2ebd48ecf u64, _5175, ), bb917, bb399)
	var1615 = -var125;	// _1615 = UniOp(_125 NEG)
	var1614 = 169535557 - var1615;	// _1614 = BinOp(+169535557 i32 SUB _1615)
	var5176 = (uint8_t )var1614;	// _5176 = Cast(_1614 as u8)
	var1617 = var30 ^ 30748;	// _1617 = BinOp(_30 BIT_XOR +30748 i16)
	var1616 = 20750 / var1617;	// _1616 = BinOp(+20750 i16 DIV _1617)
	var1618 = -var1616;	// _1618 = UniOp(_1616 NEG)
	var5177 = (uint8_t )var1618;	// _5177 = Cast(_1618 as u8)
	__builtin_sub_overflow(var5176, var5177, &var198);
	// ^ Call( _198 = "overflowing_sub"::<u8,>( _5176, _5177, ), bb918, bb399)
	var5178 = var108 & 0x7f;	// _5178 = BinOp(_108 BIT_AND 0x7f u32)
	var5179.lo = var5178; var5179.hi = var5178 < 0 ? -1 : 0;	// _5179 = Cast(_5178 as u128)
	var5182 = shl128(make128_raw(8905756062414881772ull, 7299967013175656492ull), var5179.lo);
	// ^ Call( _5182 = "unchecked_shl"::<u128,>( 0x7b9799f43c8543ec654eb1525467802c u128, _5179, ), bb919, bb399)
	var5183 = var157 >> 0x1b;
	// ^ Call( _5183 = "unchecked_shr"::<u32,>( _157, 0x1b u32, ), bb920, bb399)
	var5180 = var5183 & 0x7f;	// _5180 = BinOp(_5183 BIT_AND 0x7f u32)
	var5181.lo = var5180; var5181.hi = var5180 < 0 ? -1 : 0;	// _5181 = Cast(_5180 as u128)
	var1621 = shl128(var5182, var5181.lo);
	// ^ Call( _1621 = "unchecked_shl"::<u128,>( _5182, _5181, ), bb921, bb399)
	var1620 = div128(make128_raw(12061945637473498266ull, 14885528355895675780ull), var1621);	// _1620 = BinOp(0xa764a3a67dae349ace94052c3b2a8b84 u128 DIV _1621)
	var5186 = mod128(make128_raw(13199581265571107008ull, 4535414394377736760ull), var14);	// _5186 = BinOp(0xb72e553a064450c03ef1075cae141238 u128 MOD _14)
	var5187 = var67 & var163;	// _5187 = BinOp(_67 BIT_AND _163)
	var5184 = var5187 & 0x7f;	// _5184 = BinOp(_5187 BIT_AND 0x7f u32)
	var5185.lo = var5184; var5185.hi = var5184 < 0 ? -1 : 0;	// _5185 = Cast(_5184 as u128)
	var5188 = shr128(var5186, var5185.lo);
	// ^ Call( _5188 = "unchecked_shr"::<u128,>( _5186, _5185, ), bb922, bb399)
	var1622 = and128(var9, var132);	// _1622 = BinOp(_9 BIT_AND _132)
	var5189 = add128(var1622, make128_raw(1646072496721706512ull, 14813159670590278125ull));	// _5189 = BinOp(_1622 ADD 0x16d80636e9a33e10cd92ea3ca6ad09ed u128)
	var1623 = mod128(var5188, var5189);	// _1623 = BinOp(_5188 MOD _5189)
	var1619 = div128(var1620, var1623);	// _1619 = BinOp(_1620 DIV _1623)
	var199 = div128(var1619, make128_raw(8317347817613200966ull, 10548613471388033600ull));	// _199 = BinOp(_1619 DIV 0x736d27c5de348e469264341032fbe240 u128)
	var5190 = ZRICd15overflowing_div0g( 15778, var52 );
	// ^ Call( _5190 = <i16 /*- */>::overflowing_div( +15778 i16, _52, ), bb923, bb399)
	var5191 = (uintptr_t )var5190._0;	// _5191 = Cast(_5190.0 as usize)
	__builtin_mul_overflow(0x6f4ce586caf89984ull, var5191, &var1624);
	// ^ Call( _1624 = "overflowing_mul"::<usize,>( 0x6f4ce586caf89984 usize, _5191, ), bb924, bb399)
	__builtin_mul_overflow(0xd69e66a6, 0xb7344d0c, &var1625);
	// ^ Call( _1625 = "overflowing_mul"::<u32,>( 0xd69e66a6 u32, 0xb7344d0c u32, ), bb925, bb399)
	var5192 = (uintptr_t )var127;	// _5192 = Cast(_127 as usize)
	__builtin_add_overflow(var114, 0xd8d588f50bdc581cull, &var5193);
	// ^ Call( _5193 = "overflowing_add"::<usize,>( _114, 0xd8d588f50bdc581c usize, ), bb926, bb399)
	__builtin_sub_overflow(var5192, var5193, &var1626);
	// ^ Call( _1626 = "overflowing_sub"::<usize,>( _5192, _5193, ), bb927, bb399)
	var5194 = 0xee >> 0x6;
	// ^ Call( _5194 = "unchecked_shr"::<u8,>( 0xee u8, 0x6 u8, ), bb928, bb399)
	var1628 = var5194 % var120;	// _1628 = BinOp(_5194 MOD _120)
	var1629 = (uint8_t )var195;	// _1629 = Cast(_195 as u8)
	var1630 = var77 % var120;	// _1630 = BinOp(_77 MOD _120)
	var5195 = var1629 ^ var1630;	// _5195 = BinOp(_1629 BIT_XOR _1630)
	var1631 = var69 ^ var78;	// _1631 = BinOp(_69 BIT_XOR _78)
	__builtin_add_overflow(0x2c, var99, &var1632);
	// ^ Call( _1632 = "overflowing_add"::<u8,>( 0x2c u8, _99, ), bb929, bb399)
	var5196 = var1631 - var1632;	// _5196 = BinOp(_1631 SUB _1632)
	__builtin_sub_overflow(var5195, var5196, &var1633);
	// ^ Call( _1633 = "overflowing_sub"::<u8,>( _5195, _5196, ), bb930, bb399)
	var1627 = var1628 + var1633;	// _1627 = BinOp(_1628 ADD _1633)
	__builtin_sub_overflow(0xfdd715ff, var127, &var1634);
	// ^ Call( _1634 = "overflowing_sub"::<u32,>( 0xfdd715ff u32, _127, ), bb931, bb399)
	__builtin_add_overflow(0xe8c0e242, var92, &var1635);
	// ^ Call( _1635 = "overflowing_add"::<u32,>( 0xe8c0e242 u32, _92, ), bb932, bb399)
	var5199 = var1634 | var1635;	// _5199 = BinOp(_1634 BIT_OR _1635)
	var5197 = var5199 & 0x7;	// _5197 = BinOp(_5199 BIT_AND 0x7 u32)
	var5198 = (uint8_t )var5197;	// _5198 = Cast(_5197 as u8)
	var5205 = 0xaa >> var5198;
	// ^ Call( _5205 = "unchecked_shr"::<u8,>( 0xaa u8, _5198, ), bb933, bb399)
	var5202 = 0xc1;	// _5202 = Constant(0xc1 u8)
	__builtin_sub_overflow(var51, var152, &var5203);
	// ^ Call( _5203 = "overflowing_sub"::<u32,>( _51, _152, ), bb934, bb399)
	var5200 = var5203 & 0x7;	// _5200 = BinOp(_5203 BIT_AND 0x7 u32)
	var5201 = (uint8_t )var5200;	// _5201 = Cast(_5200 as u8)
	var5204 = var5202 << var5201;
	// ^ Call( _5204 = "unchecked_shl"::<u8,>( _5202, _5201, ), bb935, bb399)
	__builtin_mul_overflow(var5204, var69, &var5206);
	// ^ Call( _5206 = "overflowing_mul"::<u8,>( _5204, _69, ), bb936, bb399)
	var1636 = var5205 % var5206;	// _1636 = BinOp(_5205 MOD _5206)
	var200 = var1627 * var1636;	// _200 = BinOp(_1627 MUL _1636)
	__builtin_add_overflow(0x49, 0x0, &var5211);
	// ^ Call( _5211 = "overflowing_add"::<u8,>( 0x49 u8, 0x0 u8, ), bb937, bb399)
	__builtin_mul_overflow(var71, 0x0, &var5208);
	// ^ Call( _5208 = "overflowing_mul"::<u32,>( _71, 0x0 u32, ), bb938, bb399)
	var5207 = var5208 & 0x1f;	// _5207 = BinOp(_5208 BIT_AND 0x1f u32)
	var5212 = var49 >> var5207;
	// ^ Call( _5212 = "unchecked_shr"::<u32,>( _49, _5207, ), bb939, bb399)
	var5209 = var5212 & 0x7;	// _5209 = BinOp(_5212 BIT_AND 0x7 u32)
	var5210 = (uint8_t )var5209;	// _5210 = Cast(_5209 as u8)
	var201 = var5211 >> var5210;
	// ^ Call( _201 = "unchecked_shr"::<u8,>( _5211, _5210, ), bb940, bb399)
	var5213 = ZRICb15overflowing_div0g( -103, var143 );
	// ^ Call( _5213 = <i8 /*- */>::overflowing_div( -103 i8, _143, ), bb941, bb399)
	var5214 = var92 & 0x7;	// _5214 = BinOp(_92 BIT_AND 0x7 u32)
	var5215 = (int8_t )var5214;	// _5215 = Cast(_5214 as i8)
	var1637 = var5213._0 << var5215;
	// ^ Call( _1637 = "unchecked_shl"::<i8,>( _5213.0, _5215, ), bb942, bb399)
	__builtin_sub_overflow(-110, var123, &var1638);
	// ^ Call( _1638 = "overflowing_sub"::<i8,>( -110 i8, _123, ), bb943, bb399)
	var5216 = var34 & 0x7;	// _5216 = BinOp(_34 BIT_AND 0x7 u32)
	var5217 = (int8_t )var5216;	// _5217 = Cast(_5216 as i8)
	var1639 = 22 >> var5217;
	// ^ Call( _1639 = "unchecked_shr"::<i8,>( +22 i8, _5217, ), bb944, bb399)
	var202 = var187;	// _202 = Use(_187)
	var5223 = make128s_raw(2295058879516687599ull, 4842566903572337945ull);	// _5223 = Constant(+42336363784538940813064632615409947929 i128)
	var1640 = 0x37bdee15;	// _1640 = Constant(0x37bdee15 u32)
	__builtin_sub_overflow(var41, var71, &var5218);
	// ^ Call( _5218 = "overflowing_sub"::<u32,>( _41, _71, ), bb945, bb399)
	__builtin_add_overflow(var5218, 0xb8cd6124, &var5219);
	// ^ Call( _5219 = "overflowing_add"::<u32,>( _5218, 0xb8cd6124 u32, ), bb946, bb399)
	var1641 = (uint32_t )var122;	// _1641 = Cast(_122 as u32)
	var5220 = 0xd86334de | var1641;	// _5220 = BinOp(0xd86334de u32 BIT_OR _1641)
	var1642 = var5219 / var5220;	// _1642 = BinOp(_5219 DIV _5220)
	var5224 = var1640 + var1642;	// _5224 = BinOp(_1640 ADD _1642)
	var5221 = var5224 & 0x7f;	// _5221 = BinOp(_5224 BIT_AND 0x7f u32)
	var5222.lo = var5221; var5222.hi = var5221 < 0 ? -1 : 0;	// _5222 = Cast(_5221 as i128)
	var203 = shl128s(var5223, var5222.lo);
	// ^ Call( _203 = "unchecked_shl"::<i128,>( _5223, _5222, ), bb947, bb399)
	var1643 = var140 << 7;
	// ^ Call( _1643 = "unchecked_shl"::<i8,>( _140, +7 i8, ), bb948, bb399)
	var5225 = -var1643;	// _5225 = UniOp(_1643 NEG)
	var5226 = -var140;	// _5226 = UniOp(_140 NEG)
	__builtin_sub_overflow(var5225, var5226, &var1644);
	// ^ Call( _1644 = "overflowing_sub"::<i8,>( _5225, _5226, ), bb949, bb399)
	__builtin_mul_overflow(var184, var128, &var1645);
	// ^ Call( _1645 = "overflowing_mul"::<i8,>( _184, _128, ), bb950, bb399)
	var1646 = 25 >> 0;
	// ^ Call( _1646 = "unchecked_shr"::<i8,>( +25 i8, +0 i8, ), bb951, bb399)
	var1647 = var93 >> 0;
	// ^ Call( _1647 = "unchecked_shr"::<i8,>( _93, +0 i8, ), bb952, bb399)
	var1649 = (uint32_t )var149;	// _1649 = Cast(_149 as u32)
	var1648 = var1649 < var22;	// _1648 = BinOp(_1649 LT _22)
	if(var1648) goto bb953; else goto bb954;
	// ^ If( _1648 : 953, 954)
bb953:
	var204 = true;	// _204 = Constant(true)
	goto bb955;
	// ^ Goto(955)
bb954:
	var204 = 83 != var171;	// _204 = BinOp(+83 i8 NE _171)
	// ^ Goto(955)
bb955:
	__builtin_mul_overflow(0x40ull, var27, &var1650);
	// ^ Call( _1650 = "overflowing_mul"::<usize,>( 0x40 usize, _27, ), bb956, bb399)
	var5227 = var177 & 0x3f;	// _5227 = BinOp(_177 BIT_AND 0x3f u32)
	var5228 = (uintptr_t )var5227;	// _5228 = Cast(_5227 as usize)
	var5229 = 0x83a97d2e3dea579cull >> var5228;
	// ^ Call( _5229 = "unchecked_shr"::<usize,>( 0x83a97d2e3dea579c usize, _5228, ), bb957, bb399)
	var5230 = var107.lo;	// _5230 = Cast(_107 as usize)
	__builtin_add_overflow(var5229, var5230, &var1651);
	// ^ Call( _1651 = "overflowing_add"::<usize,>( _5229, _5230, ), bb958, bb399)
	var1652 = var89 >> 5;
	// ^ Call( _1652 = "unchecked_shr"::<i32,>( _89, +5 i32, ), bb959, bb399)
	var5235 = -var1652;	// _5235 = UniOp(_1652 NEG)
	var5231 = var127 >> 0x19;
	// ^ Call( _5231 = "unchecked_shr"::<u32,>( _127, 0x19 u32, ), bb960, bb399)
	var5232 = 0x3fe8bcbf << 0x6;
	// ^ Call( _5232 = "unchecked_shl"::<u32,>( 0x3fe8bcbf u32, 0x6 u32, ), bb961, bb399)
	__builtin_add_overflow(var5231, var5232, &var5236);
	// ^ Call( _5236 = "overflowing_add"::<u32,>( _5231, _5232, ), bb962, bb399)
	var5233 = var5236 & 0x1f;	// _5233 = BinOp(_5236 BIT_AND 0x1f u32)
	var5234 = (int32_t )var5233;	// _5234 = Cast(_5233 as i32)
	var1653 = var5235 << var5234;
	// ^ Call( _1653 = "unchecked_shl"::<i32,>( _5235, _5234, ), bb963, bb399)
	var205 = var27;	// _205 = Use(_27)
	var5239 = -22 + var128;	// _5239 = BinOp(-22 i8 ADD _128)
	var5237 = ZRICb15overflowing_rem0g( -126, 26 );
	// ^ Call( _5237 = <i8 /*- */>::overflowing_rem( -126 i8, +26 i8, ), bb964, bb399)
	var5238 = ZRICb15overflowing_rem0g( var5239, var5237._0 );
	// ^ Call( _5238 = <i8 /*- */>::overflowing_rem( _5239, _5237.0, ), bb965, bb399)
	var1655 = var5238._0;	// _1655 = Use(_5238.0)
	var5240 = ZRICj15overflowing_rem0g( var35, make128s_raw(7157090215740419846ull, 16634030521872778857ull) );
	// ^ Call( _5240 = <i128 /*- */>::overflowing_rem( _35, +132025011522214206045802506818120549993 i128, ), bb966, bb399)
	var1656 = var5240._0.lo;	// _1656 = Cast(_5240.0 as i8)
	var1654 = var1655 * var1656;	// _1654 = BinOp(_1655 MUL _1656)
	var1657 = -var1654;	// _1657 = UniOp(_1654 NEG)
	var206 = -var1657;	// _206 = UniOp(_1657 NEG)
	var5243 = 6397;	// _5243 = Constant(+6397 i16)
	__builtin_sub_overflow(var142, var10, &var1658);
	// ^ Call( _1658 = "overflowing_sub"::<i16,>( _142, _10, ), bb967, bb399)
	var5241 = -var1658;	// _5241 = UniOp(_1658 NEG)
	__builtin_sub_overflow(23176, var5241, &var1659);
	// ^ Call( _1659 = "overflowing_sub"::<i16,>( +23176 i16, _5241, ), bb968, bb399)
	var5244 = var1659 + var38;	// _5244 = BinOp(_1659 ADD _38)
	var5242 = ZRICd15overflowing_rem0g( var5243, var5244 );
	// ^ Call( _5242 = <i16 /*- */>::overflowing_rem( _5243, _5244, ), bb969, bb399)
	var207 = var5242._0;	// _207 = Use(_5242.0)
	var1662 = var105 + 0x31f2;	// _1662 = BinOp(_105 ADD 0x31f2 u16)
	var1663 = var39 << 0x8;
	// ^ Call( _1663 = "unchecked_shl"::<u16,>( _39, 0x8 u16, ), bb970, bb399)
	var1661 = var1662 * var1663;	// _1661 = BinOp(_1662 MUL _1663)
	var1664 = (uint8_t )var1661;	// _1664 = Cast(_1661 as u8)
	__builtin_mul_overflow(0x7a, 0xbf, &var5245);
	// ^ Call( _5245 = "overflowing_mul"::<u8,>( 0x7a u8, 0xbf u8, ), bb971, bb399)
	__builtin_sub_overflow(var5245, var120, &var1666);
	// ^ Call( _1666 = "overflowing_sub"::<u8,>( _5245, _120, ), bb972, bb399)
	__builtin_sub_overflow(var202, 0xfb, &var5248);
	// ^ Call( _5248 = "overflowing_sub"::<u8,>( _202, 0xfb u8, ), bb973, bb399)
	var5249 = 0xeabc6a7b & var71;	// _5249 = BinOp(0xeabc6a7b u32 BIT_AND _71)
	var5246 = var5249 & 0x7;	// _5246 = BinOp(_5249 BIT_AND 0x7 u32)
	var5247 = (uint8_t )var5246;	// _5247 = Cast(_5246 as u8)
	var1667 = var5248 >> var5247;
	// ^ Call( _1667 = "unchecked_shr"::<u8,>( _5248, _5247, ), bb974, bb399)
	var1665 = var1666 / var1667;	// _1665 = BinOp(_1666 DIV _1667)
	var1660 = var1664 | var1665;	// _1660 = BinOp(_1664 BIT_OR _1665)
	var208 = (uint32_t )var1660;	// _208 = Cast(_1660 as u32)
	var1668 = -20814 + var207;	// _1668 = BinOp(-20814 i16 ADD _207)
	var1669 = -var1668;	// _1669 = UniOp(_1668 NEG)
	var5253 = -var1669;	// _5253 = UniOp(_1669 NEG)
	var5252 = var92 / 0x4de20ff;	// _5252 = BinOp(_92 DIV 0x4de20ff u32)
	var5250 = var5252 & 0xf;	// _5250 = BinOp(_5252 BIT_AND 0xf u32)
	var5251 = (uint16_t )var5250;	// _5251 = Cast(_5250 as u16)
	var1670 = 0x59 << var5251;
	// ^ Call( _1670 = "unchecked_shl"::<u16,>( 0x59 u16, _5251, ), bb975, bb399)
	var5254 = (int16_t )var1670;	// _5254 = Cast(_1670 as i16)
	__builtin_mul_overflow(var5253, var5254, &var1671);
	// ^ Call( _1671 = "overflowing_mul"::<i16,>( _5253, _5254, ), bb976, bb399)
	__builtin_sub_overflow(-21851, 3929, &var1672);
	// ^ Call( _1672 = "overflowing_sub"::<i16,>( -21851 i16, +3929 i16, ), bb977, bb399)
	var209 = var208;	// _209 = Use(_208)
	__builtin_mul_overflow(var142, var50, &var5256);
	// ^ Call( _5256 = "overflowing_mul"::<i16,>( _142, _50, ), bb978, bb399)
	var5255 = ZRICd15overflowing_rem0g( var5256, -21973 );
	// ^ Call( _5255 = <i16 /*- */>::overflowing_rem( _5256, -21973 i16, ), bb979, bb399)
	var1674 = -var5255._0;	// _1674 = UniOp(_5255.0 NEG)
	var1673 = var1674 ^ var52;	// _1673 = BinOp(_1674 BIT_XOR _52)
	var210 = -var1673;	// _210 = UniOp(_1673 NEG)
	__builtin_sub_overflow(var2, var25, &var1676);
	// ^ Call( _1676 = "overflowing_sub"::<u32,>( _2, _25, ), bb980, bb399)
	var5257 = var209 & 0x1f;	// _5257 = BinOp(_209 BIT_AND 0x1f u32)
	var1677 = var157 >> var5257;
	// ^ Call( _1677 = "unchecked_shr"::<u32,>( _157, _5257, ), bb981, bb399)
	var1675 = var1676 & var1677;	// _1675 = BinOp(_1676 BIT_AND _1677)
	var1678 = (int8_t )var1675;	// _1678 = Cast(_1675 as i8)
	var211 = -var1678;	// _211 = UniOp(_1678 NEG)
	var5262 = 0x7;	// _5262 = Constant(0x7 u8)
	var5258 = 0x60;	// _5258 = Constant(0x60 u32)
	__builtin_add_overflow(var49, var92, &var5259);
	// ^ Call( _5259 = "overflowing_add"::<u32,>( _49, _92, ), bb982, bb399)
	__builtin_sub_overflow(var5258, var5259, &var1679);
	// ^ Call( _1679 = "overflowing_sub"::<u32,>( _5258, _5259, ), bb983, bb399)
	var5263 = var1679 - 0x5008e775;	// _5263 = BinOp(_1679 SUB 0x5008e775 u32)
	var5260 = var5263 & 0x7;	// _5260 = BinOp(_5263 BIT_AND 0x7 u32)
	var5261 = (uint8_t )var5260;	// _5261 = Cast(_5260 as u8)
	var1680 = var5262 << var5261;
	// ^ Call( _1680 = "unchecked_shl"::<u8,>( _5262, _5261, ), bb984, bb399)
	var212 = 0x7a / var1680;	// _212 = BinOp(0x7a u8 DIV _1680)
	__builtin_sub_overflow(-10252, -21585, &var1681);
	// ^ Call( _1681 = "overflowing_sub"::<i16,>( -10252 i16, -21585 i16, ), bb985, bb399)
	__builtin_mul_overflow(-1835949758, var84, &var1682);
	// ^ Call( _1682 = "overflowing_mul"::<i32,>( -1835949758 i32, _84, ), bb986, bb399)
	var5266 = 6713 / var72;	// _5266 = BinOp(+6713 i16 DIV _72)
	var5264 = ZRICd15overflowing_rem0g( 573, -30485 );
	// ^ Call( _5264 = <i16 /*- */>::overflowing_rem( +573 i16, -30485 i16, ), bb987, bb399)
	var5265 = ZRICd15overflowing_rem0g( var5266, var5264._0 );
	// ^ Call( _5265 = <i16 /*- */>::overflowing_rem( _5266, _5264.0, ), bb988, bb399)
	var5267 = var127 / 0xa3b08bee;	// _5267 = BinOp(_127 DIV 0xa3b08bee u32)
	var5271 = var5267 % 0x1388ffa7;	// _5271 = BinOp(_5267 MOD 0x1388ffa7 u32)
	var5269 = var168 | 0x1a167471;	// _5269 = BinOp(_168 BIT_OR 0x1a167471 u32)
	var5270 = 0x73192f5d / var208;	// _5270 = BinOp(0x73192f5d u32 DIV _208)
	var5268 = var5270 & 0x1f;	// _5268 = BinOp(_5270 BIT_AND 0x1f u32)
	var5272 = var5269 >> var5268;
	// ^ Call( _5272 = "unchecked_shr"::<u32,>( _5269, _5268, ), bb989, bb399)
	__builtin_mul_overflow(var5271, var5272, &var1684);
	// ^ Call( _1684 = "overflowing_mul"::<u32,>( _5271, _5272, ), bb990, bb399)
	var5273 = var193 % var79;	// _5273 = BinOp(_193 MOD _79)
	var5274 = var34 / 0x643049fb;	// _5274 = BinOp(_34 DIV 0x643049fb u32)
	__builtin_sub_overflow(var5273, var5274, &var1686);
	// ^ Call( _1686 = "overflowing_sub"::<u32,>( _5273, _5274, ), bb991, bb399)
	__builtin_add_overflow(0xf84475b4, var177, &var1687);
	// ^ Call( _1687 = "overflowing_add"::<u32,>( 0xf84475b4 u32, _177, ), bb992, bb399)
	var1685 = var1686 | var1687;	// _1685 = BinOp(_1686 BIT_OR _1687)
	var1683 = var1684 | var1685;	// _1683 = BinOp(_1684 BIT_OR _1685)
	var213 = (uint16_t )var1683;	// _213 = Cast(_1683 as u16)
	__builtin_add_overflow(0x9a86, var11, &var1688);
	// ^ Call( _1688 = "overflowing_add"::<u16,>( 0x9a86 u16, _11, ), bb993, bb399)
	var214 = 0xb169 / var1688;	// _214 = BinOp(0xb169 u16 DIV _1688)
	var1690 = (int8_t )var148;	// _1690 = Cast(_148 as i8)
	var1691 = (int64_t )var1690;	// _1691 = Cast(_1690 as i64)
	var1692 = -var1691;	// _1692 = UniOp(_1691 NEG)
	var5276 = -2155677541753139607ll;	// _5276 = Constant(-2155677541753139607 i64)
	__builtin_add_overflow(3791724279514926939ll, var164, &var5277);
	// ^ Call( _5277 = "overflowing_add"::<i64,>( +3791724279514926939 i64, _164, ), bb994, bb399)
	var5275 = ZRICh15overflowing_div0g( var5276, var5277 );
	// ^ Call( _5275 = <i64 /*- */>::overflowing_div( _5276, _5277, ), bb995, bb399)
	var1694 = var5275._0;	// _1694 = Use(_5275.0)
	__builtin_sub_overflow(var183, var139, &var1696);
	// ^ Call( _1696 = "overflowing_sub"::<i64,>( _183, _139, ), bb996, bb399)
	var1695 = var1696 + -7214842894690911409ll;	// _1695 = BinOp(_1696 ADD -7214842894690911409 i64)
	var1693 = var1694 & var1695;	// _1693 = BinOp(_1694 BIT_AND _1695)
	var1689 = var1692 > var1693;	// _1689 = BinOp(_1692 GT _1693)
	if(var1689) goto bb1000; else goto bb997;
	// ^ If( _1689 : 1000, 997)
bb997:
	var5280 = var151 % 0x59;	// _5280 = BinOp(_151 MOD 0x59 u8)
	var5281 = var163 & var71;	// _5281 = BinOp(_163 BIT_AND _71)
	var5278 = var5281 & 0x7;	// _5278 = BinOp(_5281 BIT_AND 0x7 u32)
	var5279 = (uint8_t )var5278;	// _5279 = Cast(_5278 as u8)
	var1697 = var5280 << var5279;
	// ^ Call( _1697 = "unchecked_shl"::<u8,>( _5280, _5279, ), bb998, bb399)
	__builtin_sub_overflow(0x76, var77, &var5282);
	// ^ Call( _5282 = "overflowing_sub"::<u8,>( 0x76 u8, _77, ), bb999, bb399)
	__builtin_sub_overflow(0x14, var5282, &var1698);
	// ^ Call( _1698 = "overflowing_sub"::<u8,>( 0x14 u8, _5282, ), bb1000, bb399)
bb1000:
	__builtin_add_overflow(-55, 26, &var1700);
	// ^ Call( _1700 = "overflowing_add"::<i8,>( -1847 i8, +26 i8, ), bb1001, bb399)
	var1699 = var1700 | -124;	// _1699 = BinOp(_1700 BIT_OR -124 i8)
	__builtin_mul_overflow(58, var91, &var1703);
	// ^ Call( _1703 = "overflowing_mul"::<i8,>( +58 i8, _91, ), bb1002, bb399)
	var1704 = -51 / var119;	// _1704 = BinOp(-51 i8 DIV _119)
	var1702 = var1703 * var1704;	// _1702 = BinOp(_1703 MUL _1704)
	var1701 = var1702 | 20;	// _1701 = BinOp(_1702 BIT_OR +20 i8)
	var5285 = var1699 ^ var1701;	// _5285 = BinOp(_1699 BIT_XOR _1701)
	var5283 = var111 + 110;	// _5283 = BinOp(_111 ADD +110 i8)
	__builtin_sub_overflow(var80, var5283, &var1705);
	// ^ Call( _1705 = "overflowing_sub"::<i8,>( _80, _5283, ), bb1003, bb399)
	var1706 = -var1705;	// _1706 = UniOp(_1705 NEG)
	var5286 = -var1706;	// _5286 = UniOp(_1706 NEG)
	var5284 = ZRICb15overflowing_rem0g( var5285, var5286 );
	// ^ Call( _5284 = <i8 /*- */>::overflowing_rem( _5285, _5286, ), bb1004, bb399)
	var1707 = -var19;	// _1707 = UniOp(_19 NEG)
	var5290 = -var1707;	// _5290 = UniOp(_1707 NEG)
	var5287 = 0x6febbc16 / var61;	// _5287 = BinOp(0x6febbc16 u32 DIV _61)
	__builtin_sub_overflow(var5287, 0xa21d69b2, &var5291);
	// ^ Call( _5291 = "overflowing_sub"::<u32,>( _5287, 0xa21d69b2 u32, ), bb1005, bb399)
	var5288 = var5291 & 0x7;	// _5288 = BinOp(_5291 BIT_AND 0x7 u32)
	var5289 = (int8_t )var5288;	// _5289 = Cast(_5288 as i8)
	var1708 = var5290 << var5289;
	// ^ Call( _1708 = "unchecked_shl"::<i8,>( _5290, _5289, ), bb1006, bb399)
	var5300 = (uint32_t )var1708;	// _5300 = Cast(_1708 as u32)
	var1710 = (int16_t )var47;	// _1710 = Cast(_47 as i16)
	var1709 = var1710 * -1;	// _1709 = BinOp(_1710 MUL -1 i16)
	var1711 = (uint32_t )var1709;	// _1711 = Cast(_1709 as u32)
	var5292 = var208 & 0x1f;	// _5292 = BinOp(_208 BIT_AND 0x1f u32)
	var5297 = 0xb7478cd9 >> var5292;
	// ^ Call( _5297 = "unchecked_shr"::<u32,>( 0xb7478cd9 u32, _5292, ), bb1007, bb399)
	var5294 = var67 << 0x4;
	// ^ Call( _5294 = "unchecked_shl"::<u32,>( _67, 0x4 u32, ), bb1008, bb399)
	__builtin_sub_overflow(0x291ed73, 0xd0b36f08, &var5295);
	// ^ Call( _5295 = "overflowing_sub"::<u32,>( 0x291ed73 u32, 0xd0b36f08 u32, ), bb1009, bb399)
	var5293 = var5295 & 0x1f;	// _5293 = BinOp(_5295 BIT_AND 0x1f u32)
	var5298 = var5294 >> var5293;
	// ^ Call( _5298 = "unchecked_shr"::<u32,>( _5294, _5293, ), bb1010, bb399)
	var5296 = var5298 & 0x1f;	// _5296 = BinOp(_5298 BIT_AND 0x1f u32)
	var1712 = var5297 << var5296;
	// ^ Call( _1712 = "unchecked_shl"::<u32,>( _5297, _5296, ), bb1011, bb399)
	var5301 = var1711 ^ var1712;	// _5301 = BinOp(_1711 BIT_XOR _1712)
	var5299 = var5301 & 0x1f;	// _5299 = BinOp(_5301 BIT_AND 0x1f u32)
	var1713 = var5300 >> var5299;
	// ^ Call( _1713 = "unchecked_shr"::<u32,>( _5300, _5299, ), bb1012, bb399)
	var1715 = (int16_t )var193;	// _1715 = Cast(_193 as i16)
	var1717 = 24320;	// _1717 = Constant(+24320 i16)
	__builtin_sub_overflow(var44, 23036, &var1718);
	// ^ Call( _1718 = "overflowing_sub"::<i16,>( _44, +23036 i16, ), bb1013, bb399)
	var1716 = var1717 & var1718;	// _1716 = BinOp(_1717 BIT_AND _1718)
	var1714 = var1715 <= var1716;	// _1714 = BinOp(_1715 LE _1716)
	var1719 = !var1714;	// _1719 = UniOp(_1714 INV)
	if(var1719) goto bb1014; else goto bb1015;
	// ^ If( _1719 : 1014, 1015)
bb1014:
	var215 = true;	// _215 = Constant(true)
	goto bb1020;
	// ^ Goto(1020)
bb1015:
	__builtin_mul_overflow(var148, var183, &var1722);
	// ^ Call( _1722 = "overflowing_mul"::<i64,>( _148, _183, ), bb1016, bb399)
	__builtin_mul_overflow(-1625265610192610992ll, var164, &var1723);
	// ^ Call( _1723 = "overflowing_mul"::<i64,>( -1625265610192610992 i64, _164, ), bb1017, bb399)
	var1721 = var1722 * var1723;	// _1721 = BinOp(_1722 MUL _1723)
	__builtin_sub_overflow(2397880670541102214ll, -280029038736012737ll, &var5303);
	// ^ Call( _5303 = "overflowing_sub"::<i64,>( +2397880670541102214 i64, -280029038736012737 i64, ), bb1018, bb399)
	var5304 = var195 / -4015576967913818113ll;	// _5304 = BinOp(_195 DIV -4015576967913818113 i64)
	var5302 = ZRICh15overflowing_div0g( var5303, var5304 );
	// ^ Call( _5302 = <i64 /*- */>::overflowing_div( _5303, _5304, ), bb1019, bb399)
	var1720 = var1721 > var5302._0;	// _1720 = BinOp(_1721 GT _5302.0)
	var215 = !var1720;	// _215 = UniOp(_1720 INV)
	// ^ Goto(1020)
bb1020:
	var5308 = 2598066211ll;	// _5308 = Constant(+2598066211 isize)
	var5305 = var25 & 0x3f;	// _5305 = BinOp(_25 BIT_AND 0x3f u32)
	var5306 = (intptr_t )var5305;	// _5306 = Cast(_5305 as isize)
	var1724 = -1287570303028294917ll >> var5306;
	// ^ Call( _1724 = "unchecked_shr"::<isize,>( -1287570303028294917 isize, _5306, ), bb1021, bb399)
	var5309 = var1724 / -1161999108049322245ll;	// _5309 = BinOp(_1724 DIV -1161999108049322245 isize)
	var5307 = ZRICv15overflowing_rem0g( var5308, var5309 );
	// ^ Call( _5307 = <isize /*- */>::overflowing_rem( _5308, _5309, ), bb1022, bb399)
	var1725 = (intptr_t )var152;	// _1725 = Cast(_152 as isize)
	var5310 = -var1725;	// _5310 = UniOp(_1725 NEG)
	__builtin_sub_overflow(var5307._0, var5310, &var1726);
	// ^ Call( _1726 = "overflowing_sub"::<isize,>( _5307.0, _5310, ), bb1023, bb399)
	var5315 = -273448415218131131ll;	// _5315 = Constant(-273448415218131131 isize)
	var5311 = 0x1;	// _5311 = Constant(0x1 u32)
	__builtin_sub_overflow(0x7a82fe27, 0xb97bf94b, &var5312);
	// ^ Call( _5312 = "overflowing_sub"::<u32,>( 0x7a82fe27 u32, 0xb97bf94b u32, ), bb1024, bb399)
	__builtin_sub_overflow(var5311, var5312, &var5316);
	// ^ Call( _5316 = "overflowing_sub"::<u32,>( _5311, _5312, ), bb1025, bb399)
	var5313 = var5316 & 0x3f;	// _5313 = BinOp(_5316 BIT_AND 0x3f u32)
	var5314 = (intptr_t )var5313;	// _5314 = Cast(_5313 as isize)
	var5318 = var5315 >> var5314;
	// ^ Call( _5318 = "unchecked_shr"::<isize,>( _5315, _5314, ), bb1026, bb399)
	var1727 = 4589684755588971903ll;	// _1727 = Constant(+4589684755588971903 isize)
	var5317 = ZRICv15overflowing_div0g( var32, 6855891481543891893ll );
	// ^ Call( _5317 = <isize /*- */>::overflowing_div( _32, +6855891481543891893 isize, ), bb1027, bb399)
	var1728 = var5317._0 | 4737118738615341113ll;	// _1728 = BinOp(_5317.0 BIT_OR +4737118738615341113 isize)
	var5319 = var1727 / var1728;	// _5319 = BinOp(_1727 DIV _1728)
	__builtin_sub_overflow(var5318, var5319, &var1729);
	// ^ Call( _1729 = "overflowing_sub"::<isize,>( _5318, _5319, ), bb1028, bb399)
	var5322 = 0x5e;	// _5322 = Constant(0x5e u8)
	var5320 = var178 - var212;	// _5320 = BinOp(_178 SUB _212)
	var5321 = 0xe * var159;	// _5321 = BinOp(0xe u8 MUL _159)
	__builtin_mul_overflow(var5320, var5321, &var5323);
	// ^ Call( _5323 = "overflowing_mul"::<u8,>( _5320, _5321, ), bb1029, bb399)
	__builtin_sub_overflow(var5322, var5323, &var5327);
	// ^ Call( _5327 = "overflowing_sub"::<u8,>( _5322, _5323, ), bb1030, bb399)
	var5324 = var193 & 0x1f;	// _5324 = BinOp(_193 BIT_AND 0x1f u32)
	var5328 = 0xc6afc82d >> var5324;
	// ^ Call( _5328 = "unchecked_shr"::<u32,>( 0xc6afc82d u32, _5324, ), bb1031, bb399)
	var5325 = var5328 & 0x7;	// _5325 = BinOp(_5328 BIT_AND 0x7 u32)
	var5326 = (uint8_t )var5325;	// _5326 = Cast(_5325 as u8)
	var1730 = var5327 << var5326;
	// ^ Call( _1730 = "unchecked_shl"::<u8,>( _5327, _5326, ), bb1032, bb399)
	var5329 = 0xfd - var96;	// _5329 = BinOp(0xfd u8 SUB _96)
	var1732 = var187 ^ 0x4d;	// _1732 = BinOp(_187 BIT_XOR 0x4d u8)
	var5330 = 0xb3 & var1732;	// _5330 = BinOp(0xb3 u8 BIT_AND _1732)
	var1733 = var5329 / var5330;	// _1733 = BinOp(_5329 DIV _5330)
	var5331 = 0xe6 + var175;	// _5331 = BinOp(0xe6 u8 ADD _175)
	var1734 = var126 / var5331;	// _1734 = BinOp(_126 DIV _5331)
	var1731 = var1733 * var1734;	// _1731 = BinOp(_1733 MUL _1734)
	var216 = var1730 - var1731;	// _216 = BinOp(_1730 SUB _1731)
	var217 = 709278072;	// _217 = Constant(+709278072 i32)
	__builtin_mul_overflow(0xcb0, var214, &var5332);
	// ^ Call( _5332 = "overflowing_mul"::<u16,>( 0xcb0 u16, _214, ), bb1033, bb399)
	__builtin_mul_overflow(var5332, var124, &var5335);
	// ^ Call( _5335 = "overflowing_mul"::<u16,>( _5332, _124, ), bb1034, bb399)
	__builtin_sub_overflow(0xeb0e0a69, 0xae7d8eb4, &var1735);
	// ^ Call( _1735 = "overflowing_sub"::<u32,>( 0xeb0e0a69 u32, 0xae7d8eb4 u32, ), bb1035, bb399)
	var1736 = var168 / 0x70d41bf5;	// _1736 = BinOp(_168 DIV 0x70d41bf5 u32)
	var5336 = var1735 + var1736;	// _5336 = BinOp(_1735 ADD _1736)
	var5333 = var5336 & 0xf;	// _5333 = BinOp(_5336 BIT_AND 0xf u32)
	var5334 = (uint16_t )var5333;	// _5334 = Cast(_5333 as u16)
	var1737 = var5335 << var5334;
	// ^ Call( _1737 = "unchecked_shl"::<u16,>( _5335, _5334, ), bb1036, bb399)
	var5341 = 0xf28b / var1737;	// _5341 = BinOp(0xf28b u16 DIV _1737)
	__builtin_mul_overflow(0x3c85d742, 0xdebd9a07, &var1738);
	// ^ Call( _1738 = "overflowing_mul"::<u32,>( 0x3c85d742 u32, 0xdebd9a07 u32, ), bb1037, bb399)
	var1739 = 0x4da1889c / var168;	// _1739 = BinOp(0x4da1889c u32 DIV _168)
	var5339 = var1738 * var1739;	// _5339 = BinOp(_1738 MUL _1739)
	var5337 = var5339 & 0xf;	// _5337 = BinOp(_5339 BIT_AND 0xf u32)
	var5338 = (uint16_t )var5337;	// _5338 = Cast(_5337 as u16)
	var1740 = var11 >> var5338;
	// ^ Call( _1740 = "unchecked_shr"::<u16,>( _11, _5338, ), bb1038, bb399)
	var1741 = 0x486;	// _1741 = Constant(0x486 u16)
	__builtin_mul_overflow(var106, var166, &var1742);
	// ^ Call( _1742 = "overflowing_mul"::<u16,>( _106, _166, ), bb1039, bb399)
	var5340 = var1741 * var1742;	// _5340 = BinOp(_1741 MUL _1742)
	__builtin_mul_overflow(var5340, var46, &var1743);
	// ^ Call( _1743 = "overflowing_mul"::<u16,>( _5340, _46, ), bb1040, bb399)
	var5342 = var1740 - var1743;	// _5342 = BinOp(_1740 SUB _1743)
	__builtin_mul_overflow(var5341, var5342, &var1744);
	// ^ Call( _1744 = "overflowing_mul"::<u16,>( _5341, _5342, ), bb1041, bb399)
	var5343 = ZRICf15overflowing_rem0g( var158, -1236831128 );
	// ^ Call( _5343 = <i32 /*- */>::overflowing_rem( _158, -1236831128 i32, ), bb1042, bb399)
	var5344 = (int32_t )var214;	// _5344 = Cast(_214 as i32)
	__builtin_sub_overflow(var5344, -1813809319, &var1745);
	// ^ Call( _1745 = "overflowing_sub"::<i32,>( _5344, -1813809319 i32, ), bb1043, bb399)
	var5346 = var145 / 1680675557;	// _5346 = BinOp(_145 DIV +1680675557 i32)
	var5345 = ZRICf15overflowing_div0g( 490061549, var179 );
	// ^ Call( _5345 = <i32 /*- */>::overflowing_div( +490061549 i32, _179, ), bb1044, bb399)
	__builtin_sub_overflow(var5346, var5345._0, &var1746);
	// ^ Call( _1746 = "overflowing_sub"::<i32,>( _5346, _5345.0, ), bb1045, bb399)
	var5348 = -102;	// _5348 = Constant(-102 i8)
	var5347 = ZRICb15overflowing_div0g( -10, 36 );
	// ^ Call( _5347 = <i8 /*- */>::overflowing_div( -10 i8, +36 i8, ), bb1046, bb399)
	var5349 = -var5347._0;	// _5349 = UniOp(_5347.0 NEG)
	__builtin_sub_overflow(var5348, var5349, &var1747);
	// ^ Call( _1747 = "overflowing_sub"::<i8,>( _5348, _5349, ), bb1047, bb399)
	var1748 = -var1747;	// _1748 = UniOp(_1747 NEG)
	var218 = 59 - var1748;	// _218 = BinOp(+59 i8 SUB _1748)
	var5352 = 119 >> 1;
	// ^ Call( _5352 = "unchecked_shr"::<i8,>( +119 i8, +1 i8, ), bb1048, bb399)
	__builtin_mul_overflow(var95, 0x29b6ad92, &var5353);
	// ^ Call( _5353 = "overflowing_mul"::<u32,>( _95, 0x29b6ad92 u32, ), bb1049, bb399)
	var5350 = var5353 & 0x7;	// _5350 = BinOp(_5353 BIT_AND 0x7 u32)
	var5351 = (int8_t )var5350;	// _5351 = Cast(_5350 as i8)
	var1749 = var5352 << var5351;
	// ^ Call( _1749 = "unchecked_shl"::<i8,>( _5352, _5351, ), bb1050, bb399)
	var1750 = -var1749;	// _1750 = UniOp(_1749 NEG)
	var1751 = -var1750;	// _1751 = UniOp(_1750 NEG)
	var219 = var1751 + var128;	// _219 = BinOp(_1751 ADD _128)
	__builtin_add_overflow(0x0, 0x8422, &var5358);
	// ^ Call( _5358 = "overflowing_add"::<u16,>( 0x0 u16, 0x8422 u16, ), bb1051, bb399)
	var5356 = var214 | var106;	// _5356 = BinOp(_214 BIT_OR _106)
	var5354 = var25 & 0xf;	// _5354 = BinOp(_25 BIT_AND 0xf u32)
	var5355 = (uint16_t )var5354;	// _5355 = Cast(_5354 as u16)
	var5357 = var166 >> var5355;
	// ^ Call( _5357 = "unchecked_shr"::<u16,>( _166, _5355, ), bb1052, bb399)
	__builtin_sub_overflow(var5356, var5357, &var5359);
	// ^ Call( _5359 = "overflowing_sub"::<u16,>( _5356, _5357, ), bb1053, bb399)
	__builtin_add_overflow(var5358, var5359, &var1752);
	// ^ Call( _1752 = "overflowing_add"::<u16,>( _5358, _5359, ), bb1054, bb399)
	__builtin_mul_overflow(0x95a7, 0xe352, &var1753);
	// ^ Call( _1753 = "overflowing_mul"::<u16,>( 0x95a7 u16, 0xe352 u16, ), bb1055, bb399)
	var5362 = and128(make128_raw(13648627735187767095ull, 9528190950409780760ull), var144);	// _5362 = BinOp(0xbd69aa9c93693f37843aef2fd7443e18 u128 BIT_AND _144)
	var5363 = 0x8431c1fe >> 0x11;
	// ^ Call( _5363 = "unchecked_shr"::<u32,>( 0x8431c1fe u32, 0x11 u32, ), bb1056, bb399)
	var5360 = var5363 & 0x7f;	// _5360 = BinOp(_5363 BIT_AND 0x7f u32)
	var5361.lo = var5360; var5361.hi = var5360 < 0 ? -1 : 0;	// _5361 = Cast(_5360 as u128)
	var1754 = shl128(var5362, var5361.lo);
	// ^ Call( _1754 = "unchecked_shl"::<u128,>( _5362, _5361, ), bb1057, bb399)
	var5366 = var1754.lo;	// _5366 = Cast(_1754 as u16)
	var5364 = var22 & 0xf;	// _5364 = BinOp(_22 BIT_AND 0xf u32)
	var5365 = (uint16_t )var5364;	// _5365 = Cast(_5364 as u16)
	var5367 = var5366 >> var5365;
	// ^ Call( _5367 = "unchecked_shr"::<u16,>( _5366, _5365, ), bb1058, bb399)
	__builtin_mul_overflow(var105, var5367, &var1755);
	// ^ Call( _1755 = "overflowing_mul"::<u16,>( _105, _5367, ), bb1059, bb399)
	var5368 = 0x1ceeda89 | var25;	// _5368 = BinOp(0x1ceeda89 u32 BIT_OR _25)
	__builtin_sub_overflow(var141, var47, &var5369);
	// ^ Call( _5369 = "overflowing_sub"::<u32,>( _141, _47, ), bb1060, bb399)
	__builtin_add_overflow(var5368, var5369, &var5373);
	// ^ Call( _5373 = "overflowing_add"::<u32,>( _5368, _5369, ), bb1061, bb399)
	var5370 = 0xf0253233;	// _5370 = Constant(0xf0253233 u32)
	__builtin_sub_overflow(0xc4165784, var51, &var5371);
	// ^ Call( _5371 = "overflowing_sub"::<u32,>( 0xc4165784 u32, _51, ), bb1062, bb399)
	__builtin_mul_overflow(var5370, var5371, &var5374);
	// ^ Call( _5374 = "overflowing_mul"::<u32,>( _5370, _5371, ), bb1063, bb399)
	var5372 = var5374 & 0x1f;	// _5372 = BinOp(_5374 BIT_AND 0x1f u32)
	var1756 = var5373 << var5372;
	// ^ Call( _1756 = "unchecked_shl"::<u32,>( _5373, _5372, ), bb1064, bb399)
	var5379 = var1756 & 0x21315367;	// _5379 = BinOp(_1756 BIT_AND 0x21315367 u32)
	var5375 = ZRICb15overflowing_div0g( 107, -15 );
	// ^ Call( _5375 = <i8 /*- */>::overflowing_div( +107 i8, -15 i8, ), bb1065, bb399)
	var5378 = 0x9c7f469e + var67;	// _5378 = BinOp(0x9c7f469e u32 ADD _67)
	var5376 = var5378 & 0x7;	// _5376 = BinOp(_5378 BIT_AND 0x7 u32)
	var5377 = (int8_t )var5376;	// _5377 = Cast(_5376 as i8)
	var1757 = var5375._0 >> var5377;
	// ^ Call( _1757 = "unchecked_shr"::<i8,>( _5375.0, _5377, ), bb1066, bb399)
	var5380 = (uint32_t )var1757;	// _5380 = Cast(_1757 as u32)
	__builtin_sub_overflow(var5379, var5380, &var220);
	// ^ Call( _220 = "overflowing_sub"::<u32,>( _5379, _5380, ), bb1067, bb399)
	var5382 = (int8_t )var106;	// _5382 = Cast(_106 as i8)
	var5381 = ZRICb15overflowing_div0g( var5382, -32 );
	// ^ Call( _5381 = <i8 /*- */>::overflowing_div( _5382, -1238942240 i8, ), bb1068, bb399)
	var5384 = -118 ^ var85;	// _5384 = BinOp(-118 i8 BIT_XOR _85)
	var5383 = ZRICb15overflowing_div0g( -82, var5384 );
	// ^ Call( _5383 = <i8 /*- */>::overflowing_div( -82 i8, _5384, ), bb1069, bb399)
	var1760 = var37 ^ var143;	// _1760 = BinOp(_37 BIT_XOR _143)
	var1761 = var172 * 100;	// _1761 = BinOp(_172 MUL +100 i8)
	var1759 = var1760 * var1761;	// _1759 = BinOp(_1760 MUL _1761)
	var1762 = -var12;	// _1762 = UniOp(_12 NEG)
	var1758 = var1759 * var1762;	// _1758 = BinOp(_1759 MUL _1762)
	var1763 = (uint16_t )var1758;	// _1763 = Cast(_1758 as u16)
	var1765 = var121 * var154;	// _1765 = BinOp(_121 MUL _154)
	var1764 = 0x8d9c * var1765;	// _1764 = BinOp(0x8d9c u16 MUL _1765)
	var1767 = var45 / var68;	// _1767 = BinOp(_45 DIV _68)
	var1768 = 0x49c8 & var153;	// _1768 = BinOp(0x49c8 u16 BIT_AND _153)
	var1766 = var1767 & var1768;	// _1766 = BinOp(_1767 BIT_AND _1768)
	var5385 = var1764 * var1766;	// _5385 = BinOp(_1764 MUL _1766)
	__builtin_add_overflow(var5385, 0xac80, &var1769);
	// ^ Call( _1769 = "overflowing_add"::<u16,>( _5385, 0xac80 u16, ), bb1070, bb399)
	var221 = var1763 ^ var1769;	// _221 = BinOp(_1763 BIT_XOR _1769)
	var1771 = var122 - var145;	// _1771 = BinOp(_122 SUB _145)
	var1772 = var56 & var84;	// _1772 = BinOp(_56 BIT_AND _84)
	var1770 = var1771 & var1772;	// _1770 = BinOp(_1771 BIT_AND _1772)
	var5386 = -var1770;	// _5386 = UniOp(_1770 NEG)
	__builtin_mul_overflow(1885680390, var5386, &var1773);
	// ^ Call( _1773 = "overflowing_mul"::<i32,>( +1885680390 i32, _5386, ), bb1071, bb399)
	var1774 = 0x0;	// _1774 = Constant(0x0 u16)
	__builtin_sub_overflow(0xd6988a1, var193, &var5388);
	// ^ Call( _5388 = "overflowing_sub"::<u32,>( 0xd6988a1 u32, _193, ), bb1072, bb399)
	var5389 = 0x5338b8f6 / var47;	// _5389 = BinOp(0x5338b8f6 u32 DIV _47)
	var5387 = var5389 & 0x1f;	// _5387 = BinOp(_5389 BIT_AND 0x1f u32)
	var5390 = var5388 << var5387;
	// ^ Call( _5390 = "unchecked_shl"::<u32,>( _5388, _5387, ), bb1073, bb399)
	var5391 = 0x5e207429 >> 0x5;
	// ^ Call( _5391 = "unchecked_shr"::<u32,>( 0x5e207429 u32, 0x5 u32, ), bb1074, bb399)
	__builtin_mul_overflow(var5390, var5391, &var5394);
	// ^ Call( _5394 = "overflowing_mul"::<u32,>( _5390, _5391, ), bb1075, bb399)
	var5392 = var5394 & 0xf;	// _5392 = BinOp(_5394 BIT_AND 0xf u32)
	var5393 = (uint16_t )var5392;	// _5393 = Cast(_5392 as u16)
	var1775 = var17 >> var5393;
	// ^ Call( _1775 = "unchecked_shr"::<u16,>( _17, _5393, ), bb1076, bb399)
	var222 = var1774 | var1775;	// _222 = BinOp(_1774 BIT_OR _1775)
	__builtin_sub_overflow(0x2c, 0xf0, &var5395);
	// ^ Call( _5395 = "overflowing_sub"::<u8,>( 0x2c u8, 0xf0 u8, ), bb1077, bb399)
	var5396 = (uint8_t )var5;	// _5396 = Cast(_5 as u8)
	var1776 = var5395 / var5396;	// _1776 = BinOp(_5395 DIV _5396)
	var223 = var1776 | var129;	// _223 = BinOp(_1776 BIT_OR _129)
	var224 = -111;	// _224 = Constant(-111 i8)
	var225 = 0xa352f6d5;	// _225 = Constant(0xa352f6d5 u32)
	var226 = 0x97 | var63;	// _226 = BinOp(0x97 u8 BIT_OR _63)
	var5397 = -var104;	// _5397 = UniOp(_104 NEG)
	__builtin_sub_overflow(-25637, var5397, &var5398);
	// ^ Call( _5398 = "overflowing_sub"::<i16,>( -25637 i16, _5397, ), bb1078, bb399)
	__builtin_sub_overflow(var5398, -23774, &var227);
	// ^ Call( _227 = "overflowing_sub"::<i16,>( _5398, -23774 i16, ), bb1079, bb399)
	__builtin_mul_overflow(1697791409913761512ll, -3884049969868757937ll, &var1779);
	// ^ Call( _1779 = "overflowing_mul"::<isize,>( +1697791409913761512 isize, -3884049969868757937 isize, ), bb1080, bb399)
	var5399 = ZRICv15overflowing_rem0g( 7503368317054867436ll, 1651842131684423769ll );
	// ^ Call( _5399 = <isize /*- */>::overflowing_rem( +7503368317054867436 isize, +1651842131684423769 isize, ), bb1081, bb399)
	var1781 = 8121112407749805123ll ^ var109;	// _1781 = BinOp(+8121112407749805123 isize BIT_XOR _109)
	var1780 = var5399._0 / var1781;	// _1780 = BinOp(_5399.0 DIV _1781)
	var1778 = var1779 & var1780;	// _1778 = BinOp(_1779 BIT_AND _1780)
	__builtin_add_overflow(var109, var109, &var1782);
	// ^ Call( _1782 = "overflowing_add"::<isize,>( _109, _109, ), bb1082, bb399)
	var5405 = -var1782;	// _5405 = UniOp(_1782 NEG)
	var5401 = 0x2f682b80;	// _5401 = Constant(0x2f682b80 u32)
	var5402 = var71 >> 0x9;
	// ^ Call( _5402 = "unchecked_shr"::<u32,>( _71, 0x9 u32, ), bb1083, bb399)
	var5400 = var5402 & 0x1f;	// _5400 = BinOp(_5402 BIT_AND 0x1f u32)
	var5406 = var5401 >> var5400;
	// ^ Call( _5406 = "unchecked_shr"::<u32,>( _5401, _5400, ), bb1084, bb399)
	var5403 = var5406 & 0x3f;	// _5403 = BinOp(_5406 BIT_AND 0x3f u32)
	var5404 = (intptr_t )var5403;	// _5404 = Cast(_5403 as isize)
	var1783 = var5405 << var5404;
	// ^ Call( _1783 = "unchecked_shl"::<isize,>( _5405, _5404, ), bb1085, bb399)
	var1777 = var1778 & var1783;	// _1777 = BinOp(_1778 BIT_AND _1783)
	var228 = -var1777;	// _228 = UniOp(_1777 NEG)
	var5407 = -8229220353095470613ll * var148;	// _5407 = BinOp(-8229220353095470613 i64 MUL _148)
	__builtin_add_overflow(var139, var5407, &var1784);
	// ^ Call( _1784 = "overflowing_add"::<i64,>( _139, _5407, ), bb1086, bb399)
	var5408 = ZRICv15overflowing_div0g( -7146784097043570512ll, -510572058306437767ll );
	// ^ Call( _5408 = <isize /*- */>::overflowing_div( -7146784097043570512 isize, -510572058306437767 isize, ), bb1087, bb399)
	var5410 = -var50;	// _5410 = UniOp(_50 NEG)
	var5409 = ZRICd15overflowing_rem0g( var5410, 11249 );
	// ^ Call( _5409 = <i16 /*- */>::overflowing_rem( _5410, +11249 i16, ), bb1088, bb399)
	var229 = 197602942;	// _229 = Constant(+197602942 i32)
	__builtin_add_overflow(990154998, var26, &var1785);
	// ^ Call( _1785 = "overflowing_add"::<i32,>( +990154998 i32, _26, ), bb1089, bb399)
	var5411 = -var1785;	// _5411 = UniOp(_1785 NEG)
	__builtin_mul_overflow(var1, var5411, &var1786);
	// ^ Call( _1786 = "overflowing_mul"::<i32,>( _1, _5411, ), bb1090, bb399)
	var1788 = -var229;	// _1788 = UniOp(_229 NEG)
	var1790 = var224 & var91;	// _1790 = BinOp(_224 BIT_AND _91)
	var1791 = (int32_t )var1790;	// _1791 = Cast(_1790 as i32)
	var1789 = var1791 | -658701812;	// _1789 = BinOp(_1791 BIT_OR -658701812 i32)
	var1787 = var1788 / var1789;	// _1787 = BinOp(_1788 DIV _1789)
	var230 = var1786 - var1787;	// _230 = BinOp(_1786 SUB _1787)
	var231 = 0x3c9a;	// _231 = Constant(0x3c9a u16)
	__builtin_add_overflow(65856035ll, 6513014576009460953ll, &var1792);
	// ^ Call( _1792 = "overflowing_add"::<i64,>( +65856035 i64, +6513014576009460953 i64, ), bb1091, bb399)
	var1794 = (int16_t )var143;	// _1794 = Cast(_143 as i16)
	var1795 = (uintptr_t )var1794;	// _1795 = Cast(_1794 as usize)
	__builtin_sub_overflow(0xd78dcede8177a2full, 0x64a786ee831cec8dull, &var5412);
	// ^ Call( _5412 = "overflowing_sub"::<usize,>( 0xd78dcede8177a2f usize, 0x64a786ee831cec8d usize, ), bb1092, bb399)
	__builtin_add_overflow(0x28784b9e9f2df843ull, var5412, &var1796);
	// ^ Call( _1796 = "overflowing_add"::<usize,>( 0x28784b9e9f2df843 usize, _5412, ), bb1093, bb399)
	var1793 = var1795 + var1796;	// _1793 = BinOp(_1795 ADD _1796)
	var5413 = 0x93494d2a92a3667eull | var1793;	// _5413 = BinOp(0x93494d2a92a3667e usize BIT_OR _1793)
	var232 = var5413 / 0xcd656a9fe13ec7e4ull;	// _232 = BinOp(_5413 DIV 0xcd656a9fe13ec7e4 usize)
	var1797 = -32;	// _1797 = Constant(-32 i8)
	var5415 = var224 - -55;	// _5415 = BinOp(_224 SUB -55 i8)
	var5414 = ZRICb15overflowing_rem0g( var5415, 90 );
	// ^ Call( _5414 = <i8 /*- */>::overflowing_rem( _5415, +90 i8, ), bb1094, bb399)
	var5417 = var5414._0 | 11;	// _5417 = BinOp(_5414.0 BIT_OR +11 i8)
	var1798 = (int8_t )var221;	// _1798 = Cast(_221 as i8)
	var1799 = -var89;	// _1799 = UniOp(_89 NEG)
	var1800 = (int8_t )var1799;	// _1800 = Cast(_1799 as i8)
	var5418 = var1798 + var1800;	// _5418 = BinOp(_1798 ADD _1800)
	var5416 = ZRICb15overflowing_div0g( var5417, var5418 );
	// ^ Call( _5416 = <i8 /*- */>::overflowing_div( _5417, _5418, ), bb1095, bb399)
	var233 = var1797 | var5416._0;	// _233 = BinOp(_1797 BIT_OR _5416.0)
	var1802 = var152 % 0xa2796ac9;	// _1802 = BinOp(_152 MOD 0xa2796ac9 u32)
	var1803 = var168 / 0xf3b30bae;	// _1803 = BinOp(_168 DIV 0xf3b30bae u32)
	var1801 = var1802 * var1803;	// _1801 = BinOp(_1802 MUL _1803)
	var5419 = 0xfe72763f * var1801;	// _5419 = BinOp(0xfe72763f u32 MUL _1801)
	__builtin_add_overflow(0x8a47a8be, var5419, &var5422);
	// ^ Call( _5422 = "overflowing_add"::<u32,>( 0x8a47a8be u32, _5419, ), bb1096, bb399)
	var5420 = var5422 & 0x7;	// _5420 = BinOp(_5422 BIT_AND 0x7 u32)
	var5421 = (int8_t )var5420;	// _5421 = Cast(_5420 as i8)
	var1804 = var37 << var5421;
	// ^ Call( _1804 = "unchecked_shl"::<i8,>( _37, _5421, ), bb1097, bb399)
	__builtin_sub_overflow(var27, var76, &var234);
	// ^ Call( _234 = "overflowing_sub"::<usize,>( _27, _76, ), bb1098, bb399)
	var5428 = neg128s(var194);	// _5428 = UniOp(_194 NEG)
	var1807 = make128s_raw(18033536538742167573ull, 1515559131536272850ull);	// _1807 = Constant(-7622333646871723916188951862466990638 i128)
	mul128s_o(var35, var20, &var1808);
	// ^ Call( _1808 = "overflowing_mul"::<i128,>( _35, _20, ), bb1099, bb399)
	var1806 = mul128s(var1807, var1808);	// _1806 = BinOp(_1807 MUL _1808)
	var5423 = neg128s(var194);	// _5423 = UniOp(_194 NEG)
	var1809 = shl128s(var5423, make128s_raw(0ull, 111ull).lo);
	// ^ Call( _1809 = "unchecked_shl"::<i128,>( _5423, +111 i128, ), bb1100, bb399)
	var1805 = mul128s(var1806, var1809);	// _1805 = BinOp(_1806 MUL _1809)
	var5426 = neg128s(var29);	// _5426 = UniOp(_29 NEG)
	var5427 = var108 - var108;	// _5427 = BinOp(_108 SUB _108)
	var5424 = var5427 & 0x7f;	// _5424 = BinOp(_5427 BIT_AND 0x7f u32)
	var5425.lo = var5424; var5425.hi = var5424 < 0 ? -1 : 0;	// _5425 = Cast(_5424 as i128)
	var1810 = shl128s(var5426, var5425.lo);
	// ^ Call( _1810 = "unchecked_shl"::<i128,>( _5426, _5425, ), bb1101, bb399)
	var1811 = neg128s(var1810);	// _1811 = UniOp(_1810 NEG)
	var5429 = mul128s(var1805, var1811);	// _5429 = BinOp(_1805 MUL _1811)
	sub128s_o(var5428, var5429, &var235);
	// ^ Call( _235 = "overflowing_sub"::<i128,>( _5428, _5429, ), bb1102, bb399)
	__builtin_mul_overflow(0xfd7dc451, var25, &var5431);
	// ^ Call( _5431 = "overflowing_mul"::<u32,>( 0xfd7dc451 u32, _25, ), bb1103, bb399)
	var5430 = var47 & 0x1f;	// _5430 = BinOp(_47 BIT_AND 0x1f u32)
	var5432 = var168 << var5430;
	// ^ Call( _5432 = "unchecked_shl"::<u32,>( _168, _5430, ), bb1104, bb399)
	__builtin_sub_overflow(var5431, var5432, &var1812);
	// ^ Call( _1812 = "overflowing_sub"::<u32,>( _5431, _5432, ), bb1105, bb399)
	var5433 = var1812 / 0x4a7d87a2;	// _5433 = BinOp(_1812 DIV 0x4a7d87a2 u32)
	__builtin_sub_overflow(var5433, var168, &var5436);
	// ^ Call( _5436 = "overflowing_sub"::<u32,>( _5433, _168, ), bb1106, bb399)
	var5434 = var5436 & 0xf;	// _5434 = BinOp(_5436 BIT_AND 0xf u32)
	var5435 = (uint16_t )var5434;	// _5435 = Cast(_5434 as u16)
	var236 = var222 << var5435;
	// ^ Call( _236 = "unchecked_shl"::<u16,>( _222, _5435, ), bb1107, bb399)
	var1813 = (intptr_t )var41;	// _1813 = Cast(_41 as isize)
	var1814 = -var1813;	// _1814 = UniOp(_1813 NEG)
	var237 = -var1814;	// _237 = UniOp(_1814 NEG)
	var1815 = var83 & var56;	// _1815 = BinOp(_83 BIT_AND _56)
	var1816 = -var1815;	// _1816 = UniOp(_1815 NEG)
	var5438 = -var145;	// _5438 = UniOp(_145 NEG)
	var5437 = ZRICf15overflowing_div0g( var5438, -1340739812 );
	// ^ Call( _5437 = <i32 /*- */>::overflowing_div( _5438, -1340739812 i32, ), bb1108, bb399)
	var5440 = var1816 + var5437._0;	// _5440 = BinOp(_1816 ADD _5437.0)
	var5439 = ZRICf15overflowing_rem0g( var5440, 134151488 );
	// ^ Call( _5439 = <i32 /*- */>::overflowing_rem( _5440, +134151488 i32, ), bb1109, bb399)
	var238 = -var5439._0;	// _238 = UniOp(_5439.0 NEG)
	var5441 = var193 & 0x3f;	// _5441 = BinOp(_193 BIT_AND 0x3f u32)
	var5442 = (intptr_t )var5441;	// _5442 = Cast(_5441 as isize)
	var1817 = var32 >> var5442;
	// ^ Call( _1817 = "unchecked_shr"::<isize,>( _32, _5442, ), bb1110, bb399)
	var5443 = ZRICv15overflowing_rem0g( var228, var237 );
	// ^ Call( _5443 = <isize /*- */>::overflowing_rem( _228, _237, ), bb1111, bb399)
	var5444 = ZRICv15overflowing_rem0g( 2420514922230714918ll, 4387874771827428265ll );
	// ^ Call( _5444 = <isize /*- */>::overflowing_rem( +2420514922230714918 isize, +4387874771827428265 isize, ), bb1112, bb399)
	__builtin_add_overflow(var5444._0, -3848514806290924610ll, &var1818);
	// ^ Call( _1818 = "overflowing_add"::<isize,>( _5444.0, -3848514806290924610 isize, ), bb1113, bb399)
	__builtin_add_overflow(-4083253103668092495ll, 8814783595252671461ll, &var1819);
	// ^ Call( _1819 = "overflowing_add"::<isize,>( -4083253103668092495 isize, +8814783595252671461 isize, ), bb1114, bb399)
	var5450 = 0x7112b5e1 | var108;	// _5450 = BinOp(0x7112b5e1 u32 BIT_OR _108)
	__builtin_add_overflow(0x60177b3e, var141, &var5447);
	// ^ Call( _5447 = "overflowing_add"::<u32,>( 0x60177b3e u32, _141, ), bb1115, bb399)
	var5445 = var92 & 0x1f;	// _5445 = BinOp(_92 BIT_AND 0x1f u32)
	var5448 = 0x4a437210 >> var5445;
	// ^ Call( _5448 = "unchecked_shr"::<u32,>( 0x4a437210 u32, _5445, ), bb1116, bb399)
	var5446 = var5448 & 0x1f;	// _5446 = BinOp(_5448 BIT_AND 0x1f u32)
	var1820 = var5447 << var5446;
	// ^ Call( _1820 = "unchecked_shl"::<u32,>( _5447, _5446, ), bb1117, bb399)
	__builtin_mul_overflow(0xbb1a079b, var209, &var1822);
	// ^ Call( _1822 = "overflowing_mul"::<u32,>( 0xbb1a079b u32, _209, ), bb1118, bb399)
	var1823 = var25 & var67;	// _1823 = BinOp(_25 BIT_AND _67)
	var1821 = var1822 & var1823;	// _1821 = BinOp(_1822 BIT_AND _1823)
	var5451 = var1820 + var1821;	// _5451 = BinOp(_1820 ADD _1821)
	var5449 = var5451 & 0x1f;	// _5449 = BinOp(_5451 BIT_AND 0x1f u32)
	var1824 = var5450 << var5449;
	// ^ Call( _1824 = "unchecked_shl"::<u32,>( _5450, _5449, ), bb1119, bb399)
	var5452 = var168 / 0x5890c5bd;	// _5452 = BinOp(_168 DIV 0x5890c5bd u32)
	__builtin_sub_overflow(var5452, var25, &var5453);
	// ^ Call( _5453 = "overflowing_sub"::<u32,>( _5452, _25, ), bb1120, bb399)
	__builtin_add_overflow(var5453, var177, &var1825);
	// ^ Call( _1825 = "overflowing_add"::<u32,>( _5453, _177, ), bb1121, bb399)
	__builtin_mul_overflow(0x780f0d42, var152, &var1826);
	// ^ Call( _1826 = "overflowing_mul"::<u32,>( 0x780f0d42 u32, _152, ), bb1122, bb399)
	var5455 = var174 ^ var113;	// _5455 = BinOp(_174 BIT_XOR _113)
	var5454 = ZRICv15overflowing_rem0g( var5455, 3040708217639747207ll );
	// ^ Call( _5454 = <isize /*- */>::overflowing_rem( _5455, +3040708217639747207 isize, ), bb1123, bb399)
	var1827 = 6217644266478015324ll - var32;	// _1827 = BinOp(+6217644266478015324 isize SUB _32)
	var5456 = -var1827;	// _5456 = UniOp(_1827 NEG)
	__builtin_sub_overflow(var5454._0, var5456, &var1828);
	// ^ Call( _1828 = "overflowing_sub"::<isize,>( _5454.0, _5456, ), bb1124, bb399)
	var1829 = -var1828;	// _1829 = UniOp(_1828 NEG)
	__builtin_sub_overflow(var228, -7936746532674293629ll, &var5458);
	// ^ Call( _5458 = "overflowing_sub"::<isize,>( _228, -7936746532674293629 isize, ), bb1125, bb399)
	var5459 = (intptr_t )var56;	// _5459 = Cast(_56 as isize)
	var5457 = ZRICv15overflowing_div0g( var5458, var5459 );
	// ^ Call( _5457 = <isize /*- */>::overflowing_div( _5458, _5459, ), bb1126, bb399)
	var5460 = var220 & 0x1f;	// _5460 = BinOp(_220 BIT_AND 0x1f u32)
	var5462 = 0x5a0422b1 >> var5460;
	// ^ Call( _5462 = "unchecked_shr"::<u32,>( 0x5a0422b1 u32, _5460, ), bb1127, bb399)
	var5461 = var157 & 0x1f;	// _5461 = BinOp(_157 BIT_AND 0x1f u32)
	var5465 = var5462 >> var5461;
	// ^ Call( _5465 = "unchecked_shr"::<u32,>( _5462, _5461, ), bb1128, bb399)
	var5463 = var5465 & 0x3f;	// _5463 = BinOp(_5465 BIT_AND 0x3f u32)
	var5464 = (intptr_t )var5463;	// _5464 = Cast(_5463 as isize)
	var1831 = var5457._0 >> var5464;
	// ^ Call( _1831 = "unchecked_shr"::<isize,>( _5457.0, _5464, ), bb1129, bb399)
	var1832 = var9.lo;	// _1832 = Cast(_9 as isize)
	var1830 = var1831 ^ var1832;	// _1830 = BinOp(_1831 BIT_XOR _1832)
	var239 = var1829 / var1830;	// _239 = BinOp(_1829 DIV _1830)
	var5466 = ZRICj15overflowing_div0g( make128s_raw(1056207744919201512ull, 2396803066227298104ull), make128s_raw(9232022121927448309ull, 2451395845201218968ull) );
	// ^ Call( _5466 = <i128 /*- */>::overflowing_div( +19483593959194410270014576664496541496 i128, -169981617554917826815302219047159575144 i128, ), bb1130, bb399)
	var1833 = neg128s(var20);	// _1833 = UniOp(_20 NEG)
	var5468 = mul128s(var5466._0, var1833);	// _5468 = BinOp(_5466.0 MUL _1833)
	var5467 = neg128s(var29);	// _5467 = UniOp(_29 NEG)
	var5469 = shl128s(var5467, make128s_raw(0ull, 14ull).lo);
	// ^ Call( _5469 = "unchecked_shl"::<i128,>( _5467, +14 i128, ), bb1131, bb399)
	add128s_o(var5468, var5469, &var1834);
	// ^ Call( _1834 = "overflowing_add"::<i128,>( _5468, _5469, ), bb1132, bb399)
	var1835.lo = var175; var1835.hi = var175 < 0 ? -1 : 0;	// _1835 = Cast(_175 as i128)
	var5471 = div128s(var1835, make128s_raw(6858286325691680310ull, 1753217861172329697ull));	// _5471 = BinOp(_1835 DIV +126513052634256259531041754572888210657 i128)
	var5470 = ZRICj15overflowing_div0g( var5471, make128s_raw(5228401350720864668ull, 17335778045240901254ull) );
	// ^ Call( _5470 = <i128 /*- */>::overflowing_div( _5471, +96446981631385125236700463099337604742 i128, ), bb1133, bb399)
	var1836.lo = var184; var1836.hi = var184 < 0 ? -1 : 0;	// _1836 = Cast(_184 as i128)
	var1837 = add128s(make128s_raw(10965531290292147368ull, 15174090948747368560ull), var48);	// _1837 = BinOp(-138004017576665141101778608341946296208 i128 ADD _48)
	var5475 = and128s(var1836, var1837);	// _5475 = BinOp(_1836 BIT_AND _1837)
	var5472 = var157 / 0xb34ee891;	// _5472 = BinOp(_157 DIV 0xb34ee891 u32)
	__builtin_add_overflow(var5472, var193, &var5476);
	// ^ Call( _5476 = "overflowing_add"::<u32,>( _5472, _193, ), bb1134, bb399)
	var5473 = var5476 & 0x7f;	// _5473 = BinOp(_5476 BIT_AND 0x7f u32)
	var5474.lo = var5473; var5474.hi = var5473 < 0 ? -1 : 0;	// _5474 = Cast(_5473 as i128)
	var1838 = shr128s(var5475, var5474.lo);
	// ^ Call( _1838 = "unchecked_shr"::<i128,>( _5475, _5474, ), bb1135, bb399)
	var1839 = div128(make128_raw(0ull, 73ull), var160);	// _1839 = BinOp(0x49 u128 DIV _160)
	var5481 = var1839.lo;	// _5481 = Cast(_1839 as u32)
	__builtin_mul_overflow(0xc97b, 0xc091, &var1840);
	// ^ Call( _1840 = "overflowing_mul"::<u16,>( 0xc97b u16, 0xc091 u16, ), bb1136, bb399)
	var5477 = (uint32_t )var1840;	// _5477 = Cast(_1840 as u32)
	__builtin_mul_overflow(0x37ccc6e6, 0xbc0f4b01, &var5478);
	// ^ Call( _5478 = "overflowing_mul"::<u32,>( 0x37ccc6e6 u32, 0xbc0f4b01 u32, ), bb1137, bb399)
	__builtin_sub_overflow(var5477, var5478, &var5480);
	// ^ Call( _5480 = "overflowing_sub"::<u32,>( _5477, _5478, ), bb1138, bb399)
	var5479 = var5480 & 0x1f;	// _5479 = BinOp(_5480 BIT_AND 0x1f u32)
	var5482 = 0xab8a3258 >> var5479;
	// ^ Call( _5482 = "unchecked_shr"::<u32,>( 0xab8a3258 u32, _5479, ), bb1139, bb399)
	__builtin_sub_overflow(var5481, var5482, &var1841);
	// ^ Call( _1841 = "overflowing_sub"::<u32,>( _5481, _5482, ), bb1140, bb399)
	var5483 = 9026422915799543135ll;	// _5483 = Constant(+5435372899953359885332496793484488031 isize)
	var1842 = -622885938570689444ll - var32;	// _1842 = BinOp(-622885938570689444 isize SUB _32)
	__builtin_add_overflow(-5912756140503688729ll, -6202384636870931354ll, &var1843);
	// ^ Call( _1843 = "overflowing_add"::<isize,>( -5912756140503688729 isize, -6202384636870931354 isize, ), bb1141, bb399)
	var5484 = var1842 / var1843;	// _5484 = BinOp(_1842 DIV _1843)
	__builtin_mul_overflow(var5483, var5484, &var1844);
	// ^ Call( _1844 = "overflowing_mul"::<isize,>( _5483, _5484, ), bb1142, bb399)
	var5490 = (int32_t )var1844;	// _5490 = Cast(_1844 as i32)
	var1845 = var168 % var47;	// _1845 = BinOp(_168 MOD _47)
	var5486 = 0xedfa2bff / var25;	// _5486 = BinOp(0xedfa2bff u32 DIV _25)
	var1846 = 0x9022960e | var168;	// _1846 = BinOp(0x9022960e u32 BIT_OR _168)
	var1847 = 0x6721dbef / var177;	// _1847 = BinOp(0x6721dbef u32 DIV _177)
	var5487 = var1846 + var1847;	// _5487 = BinOp(_1846 ADD _1847)
	var5485 = var5487 & 0x1f;	// _5485 = BinOp(_5487 BIT_AND 0x1f u32)
	var1848 = var5486 << var5485;
	// ^ Call( _1848 = "unchecked_shl"::<u32,>( _5486, _5485, ), bb1143, bb399)
	var5491 = var1845 + var1848;	// _5491 = BinOp(_1845 ADD _1848)
	var5488 = var5491 & 0x1f;	// _5488 = BinOp(_5491 BIT_AND 0x1f u32)
	var5489 = (int32_t )var5488;	// _5489 = Cast(_5488 as i32)
	var240 = var5490 >> var5489;
	// ^ Call( _240 = "unchecked_shr"::<i32,>( _5490, _5489, ), bb1144, bb399)
	var1849 = var43 >> 6;
	// ^ Call( _1849 = "unchecked_shr"::<i16,>( _43, +6 i16, ), bb1145, bb399)
	__builtin_sub_overflow(0x64f9c82a, 0x7d122df8, &var1851);
	// ^ Call( _1851 = "overflowing_sub"::<u32,>( 0x64f9c82a u32, 0x7d122df8 u32, ), bb1146, bb399)
	var1850 = var1851 | 0x875ffa0a;	// _1850 = BinOp(_1851 BIT_OR 0x875ffa0a u32)
	var1853 = 0x4c12c9d2 & var6;	// _1853 = BinOp(0x4c12c9d2 u32 BIT_AND _6)
	var1854 = var47 / var6;	// _1854 = BinOp(_47 DIV _6)
	var1852 = var1853 | var1854;	// _1852 = BinOp(_1853 BIT_OR _1854)
	var5492 = var1850 & var1852;	// _5492 = BinOp(_1850 BIT_AND _1852)
	var5493 = 0x8362824b ^ var92;	// _5493 = BinOp(0x8362824b u32 BIT_XOR _92)
	var1855 = var5492 % var5493;	// _1855 = BinOp(_5492 MOD _5493)
	var241 = var1855 / var95;	// _241 = BinOp(_1855 DIV _95)
	var5494 = ZRICb15overflowing_div0g( 101, -59 );
	// ^ Call( _5494 = <i8 /*- */>::overflowing_div( +101 i8, -59 i8, ), bb1147, bb399)
	var242 = -var5494._0;	// _242 = UniOp(_5494.0 NEG)
	var243 = var193;	// _243 = Use(_193)
	var1856 = var71 * var241;	// _1856 = BinOp(_71 MUL _241)
	var5497 = var193 * var1856;	// _5497 = BinOp(_193 MUL _1856)
	var5495 = var5497 & 0x7;	// _5495 = BinOp(_5497 BIT_AND 0x7 u32)
	var5496 = (uint8_t )var5495;	// _5496 = Cast(_5495 as u8)
	var1857 = 0x25 >> var5496;
	// ^ Call( _1857 = "unchecked_shr"::<u8,>( 0x25 u8, _5496, ), bb1148, bb399)
	__builtin_add_overflow(var202, 0x1c, &var1858);
	// ^ Call( _1858 = "overflowing_add"::<u8,>( _202, 0x1c u8, ), bb1149, bb399)
	__builtin_sub_overflow(var216, 0x95, &var1859);
	// ^ Call( _1859 = "overflowing_sub"::<u8,>( _216, 0x95 u8, ), bb1150, bb399)
	var1860 = 0x9d >> 0x5;
	// ^ Call( _1860 = "unchecked_shr"::<u8,>( 0x9d u8, 0x5 u8, ), bb1151, bb399)
	__builtin_sub_overflow(0x5d, var198, &var1861);
	// ^ Call( _1861 = "overflowing_sub"::<u8,>( 0x5d u8, _198, ), bb1152, bb399)
	__builtin_add_overflow(0xe1, var120, &var1862);
	// ^ Call( _1862 = "overflowing_add"::<u8,>( 0xe1 u8, _120, ), bb1153, bb399)
	__builtin_sub_overflow(var97, var197, &var1863);
	// ^ Call( _1863 = "overflowing_sub"::<u8,>( _97, _197, ), bb1154, bb399)
	var5498 = var209 & 0x7;	// _5498 = BinOp(_209 BIT_AND 0x7 u32)
	var5499 = (int8_t )var5498;	// _5499 = Cast(_5498 as i8)
	var1864 = var62 << var5499;
	// ^ Call( _1864 = "unchecked_shl"::<i8,>( _62, _5499, ), bb1155, bb399)
	var5500 = ZRICf15overflowing_rem0g( -1522182205, -2090819353 );
	// ^ Call( _5500 = <i32 /*- */>::overflowing_rem( -1522182205 i32, -2090819353 i32, ), bb1156, bb399)
	var5501 = var67 & 0x1f;	// _5501 = BinOp(_67 BIT_AND 0x1f u32)
	var5504 = 0xcb5ce3b2 >> var5501;
	// ^ Call( _5504 = "unchecked_shr"::<u32,>( 0xcb5ce3b2 u32, _5501, ), bb1157, bb399)
	var5502 = var5504 & 0x1f;	// _5502 = BinOp(_5504 BIT_AND 0x1f u32)
	var5503 = (int32_t )var5502;	// _5503 = Cast(_5502 as i32)
	var5507 = var5500._0 << var5503;
	// ^ Call( _5507 = "unchecked_shl"::<i32,>( _5500.0, _5503, ), bb1158, bb399)
	var5505 = ZRICf15overflowing_rem0g( -1547094847, -1073167827 );
	// ^ Call( _5505 = <i32 /*- */>::overflowing_rem( -1547094847 i32, -1073167827 i32, ), bb1159, bb399)
	var5508 = -var5505._0;	// _5508 = UniOp(_5505.0 NEG)
	var5506 = ZRICf15overflowing_div0g( var5507, var5508 );
	// ^ Call( _5506 = <i32 /*- */>::overflowing_div( _5507, _5508, ), bb1160, bb399)
	var1866 = var5506._0;	// _1866 = Use(_5506.0)
	var5509 = ZRICf15overflowing_div0g( -1642292806, 1369485667 );
	// ^ Call( _5509 = <i32 /*- */>::overflowing_div( -1642292806 i32, +1369485667 i32, ), bb1161, bb399)
	var1867 = var94 / var179;	// _1867 = BinOp(_94 DIV _179)
	var5511 = var5509._0 | var1867;	// _5511 = BinOp(_5509.0 BIT_OR _1867)
	var5510 = ZRICf15overflowing_rem0g( var5511, -532520843 );
	// ^ Call( _5510 = <i32 /*- */>::overflowing_rem( _5511, -532520843 i32, ), bb1162, bb399)
	var1865 = var1866 * var5510._0;	// _1865 = BinOp(_1866 MUL _5510.0)
	var244 = -var1865;	// _244 = UniOp(_1865 NEG)
	var5512 = ZRICd15overflowing_rem0g( var181, -11746 );
	// ^ Call( _5512 = <i16 /*- */>::overflowing_rem( _181, -11746 i16, ), bb1163, bb399)
	var5513 = 0x579f38c6 / var141;	// _5513 = BinOp(0x579f38c6 u32 DIV _141)
	var5514 = var168 / var22;	// _5514 = BinOp(_168 DIV _22)
	__builtin_add_overflow(var5513, var5514, &var5517);
	// ^ Call( _5517 = "overflowing_add"::<u32,>( _5513, _5514, ), bb1164, bb399)
	var5515 = var5517 & 0xf;	// _5515 = BinOp(_5517 BIT_AND 0xf u32)
	var5516 = (int16_t )var5515;	// _5516 = Cast(_5515 as i16)
	var5519 = var5512._0 << var5516;
	// ^ Call( _5519 = "unchecked_shl"::<i16,>( _5512.0, _5516, ), bb1165, bb399)
	var1869 = var60 / var72;	// _1869 = BinOp(_60 DIV _72)
	var1868 = var10 - var1869;	// _1868 = BinOp(_10 SUB _1869)
	var5520 = -var1868;	// _5520 = UniOp(_1868 NEG)
	var5518 = ZRICd15overflowing_rem0g( var5519, var5520 );
	// ^ Call( _5518 = <i16 /*- */>::overflowing_rem( _5519, _5520, ), bb1166, bb399)
	var1870 = -var113;	// _1870 = UniOp(_113 NEG)
	var5521 = var1870 ^ -3675764465530141513ll;	// _5521 = BinOp(_1870 BIT_XOR -3675764465530141513 isize)
	__builtin_sub_overflow(3985479941044665721ll, var5521, &var5522);
	// ^ Call( _5522 = "overflowing_sub"::<isize,>( +3985479941044665721 isize, _5521, ), bb1167, bb399)
	__builtin_add_overflow(var32, var5522, &var245);
	// ^ Call( _245 = "overflowing_add"::<isize,>( _32, _5522, ), bb1168, bb399)
	var246 = -11430;	// _246 = Constant(-11430 i16)
	var1873 = -var104;	// _1873 = UniOp(_104 NEG)
	var1874 = -var210;	// _1874 = UniOp(_210 NEG)
	var1872 = var1873 | var1874;	// _1872 = BinOp(_1873 BIT_OR _1874)
	var1871 = 10340 + var1872;	// _1871 = BinOp(-1760352156 i16 ADD _1872)
	var1875 = (uint32_t )var1871;	// _1875 = Cast(_1871 as u32)
	var247 = var193 / var1875;	// _247 = BinOp(_193 DIV _1875)
	__builtin_mul_overflow(0xaa06454e829ed418ull, 0x60547780e67be970ull, &var1876);
	// ^ Call( _1876 = "overflowing_mul"::<usize,>( 0xaa06454e829ed418 usize, 0x60547780e67be970 usize, ), bb1169, bb399)
	var1878 = -125 ^ var219;	// _1878 = BinOp(-125 i8 BIT_XOR _219)
	var1877 = 76 ^ var1878;	// _1877 = BinOp(+76 i8 BIT_XOR _1878)
	var1879 = -var1877;	// _1879 = UniOp(_1877 NEG)
	var5524 = (int8_t )var24;	// _5524 = Cast(_24 as i8)
	var5523 = ZRICb15overflowing_div0g( var5524, 43 );
	// ^ Call( _5523 = <i8 /*- */>::overflowing_div( _5524, +43 i8, ), bb1170, bb399)
	var1881 = (uint16_t )var97;	// _1881 = Cast(_97 as u16)
	var1882 = (int8_t )var1881;	// _1882 = Cast(_1881 as i8)
	var1880 = var5523._0 | var1882;	// _1880 = BinOp(_5523.0 BIT_OR _1882)
	var5525 = var1879 / var1880;	// _5525 = BinOp(_1879 DIV _1880)
	var1883 = var5525 << 0;
	// ^ Call( _1883 = "unchecked_shl"::<i8,>( _5525, +0 i8, ), bb1171, bb399)
	var5526 = -var119;	// _5526 = UniOp(_119 NEG)
	__builtin_mul_overflow(-36, var5526, &var1884);
	// ^ Call( _1884 = "overflowing_mul"::<i8,>( -36 i8, _5526, ), bb1172, bb399)
	var5528 = var173 / var122;	// _5528 = BinOp(_173 DIV _122)
	var5527 = ZRICf15overflowing_div0g( 1710105844, var94 );
	// ^ Call( _5527 = <i32 /*- */>::overflowing_div( +1710105844 i32, _94, ), bb1173, bb399)
	__builtin_mul_overflow(var5528, var5527._0, &var5531);
	// ^ Call( _5531 = "overflowing_mul"::<i32,>( _5528, _5527.0, ), bb1174, bb399)
	var5532 = 0x63091a2d << 0x1a;
	// ^ Call( _5532 = "unchecked_shl"::<u32,>( 0x63091a2d u32, 0x1a u32, ), bb1175, bb399)
	var5529 = var5532 & 0x1f;	// _5529 = BinOp(_5532 BIT_AND 0x1f u32)
	var5530 = (int32_t )var5529;	// _5530 = Cast(_5529 as i32)
	var1885 = var5531 >> var5530;
	// ^ Call( _1885 = "unchecked_shr"::<i32,>( _5531, _5530, ), bb1176, bb399)
	var5533 = ZRICf15overflowing_rem0g( 1905772927, var56 );
	// ^ Call( _5533 = <i32 /*- */>::overflowing_rem( +1905772927 i32, _56, ), bb1177, bb399)
	__builtin_add_overflow(var5533._0, var15, &var1886);
	// ^ Call( _1886 = "overflowing_add"::<i32,>( _5533.0, _15, ), bb1178, bb399)
	__builtin_sub_overflow(1632066817, var26, &var1889);
	// ^ Call( _1889 = "overflowing_sub"::<i32,>( +1632066817 i32, _26, ), bb1179, bb399)
	__builtin_add_overflow(var173, var84, &var1890);
	// ^ Call( _1890 = "overflowing_add"::<i32,>( _173, _84, ), bb1180, bb399)
	var1888 = var1889 + var1890;	// _1888 = BinOp(_1889 ADD _1890)
	var5534 = var34 & 0x1f;	// _5534 = BinOp(_34 BIT_AND 0x1f u32)
	var5535 = (int32_t )var5534;	// _5535 = Cast(_5534 as i32)
	var1891 = var89 << var5535;
	// ^ Call( _1891 = "unchecked_shl"::<i32,>( _89, _5535, ), bb1181, bb399)
	var1892 = -var1891;	// _1892 = UniOp(_1891 NEG)
	var1887 = var1888 * var1892;	// _1887 = BinOp(_1888 MUL _1892)
	var1893 = -var1887;	// _1893 = UniOp(_1887 NEG)
	var248 = -var1893;	// _248 = UniOp(_1893 NEG)
	var1895 = 0xf039 & var214;	// _1895 = BinOp(0xf039 u16 BIT_AND _214)
	var5536 = var1895 ^ 0x9f3d;	// _5536 = BinOp(_1895 BIT_XOR 0x9f3d u16)
	var1896 = var214 / var5536;	// _1896 = BinOp(_214 DIV _5536)
	var1894 = var116 * var1896;	// _1894 = BinOp(_116 MUL _1896)
	var5539 = 0x850c;	// _5539 = Constant(0x850c u16)
	var1897 = 0x17b204c3;	// _1897 = Constant(0x17b204c3 u32)
	var1898 = var2 >> 0x6;
	// ^ Call( _1898 = "unchecked_shr"::<u32,>( _2, 0x6 u32, ), bb1182, bb399)
	var5540 = var1897 * var1898;	// _5540 = BinOp(_1897 MUL _1898)
	var5537 = var5540 & 0xf;	// _5537 = BinOp(_5540 BIT_AND 0xf u32)
	var5538 = (uint16_t )var5537;	// _5538 = Cast(_5537 as u16)
	var5547 = var5539 >> var5538;
	// ^ Call( _5547 = "unchecked_shr"::<u16,>( _5539, _5538, ), bb1183, bb399)
	var1899 = 0x43c7 & var23;	// _1899 = BinOp(0x43c7 u16 BIT_AND _23)
	var5545 = 0x79fa ^ var1899;	// _5545 = BinOp(0x79fa u16 BIT_XOR _1899)
	__builtin_mul_overflow(0x164f5f27, 0x8bd0d88d, &var5541);
	// ^ Call( _5541 = "overflowing_mul"::<u32,>( 0x164f5f27 u32, 0x8bd0d88d u32, ), bb1184, bb399)
	__builtin_sub_overflow(0x3bafe835, 0x6c18b62d, &var5542);
	// ^ Call( _5542 = "overflowing_sub"::<u32,>( 0x3bafe835 u32, 0x6c18b62d u32, ), bb1185, bb399)
	__builtin_sub_overflow(var5541, var5542, &var5546);
	// ^ Call( _5546 = "overflowing_sub"::<u32,>( _5541, _5542, ), bb1186, bb399)
	var5543 = var5546 & 0xf;	// _5543 = BinOp(_5546 BIT_AND 0xf u32)
	var5544 = (uint16_t )var5543;	// _5544 = Cast(_5543 as u16)
	var5548 = var5545 >> var5544;
	// ^ Call( _5548 = "unchecked_shr"::<u16,>( _5545, _5544, ), bb1187, bb399)
	var1900 = var5547 / var5548;	// _1900 = BinOp(_5547 DIV _5548)
	var249 = var1894 / var1900;	// _249 = BinOp(_1894 DIV _1900)
	var250 = var20;	// _250 = Use(_20)
	var5549 = var131 ^ 0x1cd5;	// _5549 = BinOp(_131 BIT_XOR 0x1cd5 u16)
	__builtin_sub_overflow(var153, var5549, &var1902);
	// ^ Call( _1902 = "overflowing_sub"::<u16,>( _153, _5549, ), bb1188, bb399)
	var1901 = var162 + var1902;	// _1901 = BinOp(_162 ADD _1902)
	var5550 = 0xf11a / var1901;	// _5550 = BinOp(0xf11a u16 DIV _1901)
	__builtin_sub_overflow(var5550, var121, &var1903);
	// ^ Call( _1903 = "overflowing_sub"::<u16,>( _5550, _121, ), bb1189, bb399)
	__builtin_sub_overflow(var210, 410, &var1904);
	// ^ Call( _1904 = "overflowing_sub"::<i16,>( _210, +410 i16, ), bb1190, bb399)
	var5553 = 0x91e6d113 >> 0x12;
	// ^ Call( _5553 = "unchecked_shr"::<u32,>( 0x91e6d113 u32, 0x12 u32, ), bb1191, bb399)
	var5551 = var5553 & 0xf;	// _5551 = BinOp(_5553 BIT_AND 0xf u32)
	var5552 = (uint16_t )var5551;	// _5552 = Cast(_5551 as u16)
	var1905 = var18 << var5552;
	// ^ Call( _1905 = "unchecked_shl"::<u16,>( _18, _5552, ), bb1192, bb399)
	var5556 = var243 / var209;	// _5556 = BinOp(_243 DIV _209)
	var5554 = var5556 & 0xf;	// _5554 = BinOp(_5556 BIT_AND 0xf u32)
	var5555 = (uint16_t )var5554;	// _5555 = Cast(_5554 as u16)
	var1906 = 0x417c << var5555;
	// ^ Call( _1906 = "unchecked_shl"::<u16,>( 0x417c u16, _5555, ), bb1193, bb399)
	var1907 = 0x4d << 0x0;
	// ^ Call( _1907 = "unchecked_shl"::<u8,>( 0x4d u8, 0x0 u8, ), bb1194, bb399)
	__builtin_sub_overflow(0x58, 0xc8, &var5559);
	// ^ Call( _5559 = "overflowing_sub"::<u8,>( 0x58 u8, 0xc8 u8, ), bb1195, bb399)
	__builtin_sub_overflow(var208, 0xbf8c90bd, &var5560);
	// ^ Call( _5560 = "overflowing_sub"::<u32,>( _208, 0xbf8c90bd u32, ), bb1196, bb399)
	var5557 = var5560 & 0x7;	// _5557 = BinOp(_5560 BIT_AND 0x7 u32)
	var5558 = (uint8_t )var5557;	// _5558 = Cast(_5557 as u8)
	var1908 = var5559 << var5558;
	// ^ Call( _1908 = "unchecked_shl"::<u8,>( _5559, _5558, ), bb1197, bb399)
	var5563 = var1907 & var1908;	// _5563 = BinOp(_1907 BIT_AND _1908)
	var5561 = var41 & 0x7;	// _5561 = BinOp(_41 BIT_AND 0x7 u32)
	var5562 = (uint8_t )var5561;	// _5562 = Cast(_5561 as u8)
	var1909 = var5563 >> var5562;
	// ^ Call( _1909 = "unchecked_shr"::<u8,>( _5563, _5562, ), bb1198, bb399)
	var251 = (int8_t )var1909;	// _251 = Cast(_1909 as i8)
	var5565 = -var245;	// _5565 = UniOp(_245 NEG)
	var5564 = ZRICv15overflowing_div0g( 985072865184589245ll, var5565 );
	// ^ Call( _5564 = <isize /*- */>::overflowing_div( +985072865184589245 isize, _5565, ), bb1199, bb399)
	var1910 = -var5564._0;	// _1910 = UniOp(_5564.0 NEG)
	var1911 = -var1910;	// _1911 = UniOp(_1910 NEG)
	var252 = (int8_t )var1911;	// _252 = Cast(_1911 as i8)
	var253 = var134;	// _253 = Use(_134)
	var1912 = -var139;	// _1912 = UniOp(_139 NEG)
	var1913 = -var1912;	// _1913 = UniOp(_1912 NEG)
	var5576 = (uint8_t )var1913;	// _5576 = Cast(_1913 as u8)
	__builtin_sub_overflow(0xd9, 0xdb, &var5566);
	// ^ Call( _5566 = "overflowing_sub"::<u8,>( 0xd9 u8, 0xdb u8, ), bb1200, bb399)
	mul128_o(make128_raw(10283645290678821465ull, 14078929637075490533ull), make128_raw(8449699032621953486ull, 6371232043324819337ull), &var1914);
	// ^ Call( _1914 = "overflowing_mul"::<u128,>( 0x8eb6d8e82307a259c36267e95b9a96e5 u128, 0x75435c807264b1ce586b29c983f64789 u128, ), bb1201, bb399)
	var5567 = var1914.lo;	// _5567 = Cast(_1914 as u8)
	__builtin_sub_overflow(var5566, var5567, &var5574);
	// ^ Call( _5574 = "overflowing_sub"::<u8,>( _5566, _5567, ), bb1202, bb399)
	__builtin_sub_overflow(0xfc, 0x7a, &var5568);
	// ^ Call( _5568 = "overflowing_sub"::<u8,>( 0xfc u8, 0x7a u8, ), bb1203, bb399)
	var5569 = 0x91 / var117;	// _5569 = BinOp(0x91 u8 DIV _117)
	__builtin_sub_overflow(var5568, var5569, &var5572);
	// ^ Call( _5572 = "overflowing_sub"::<u8,>( _5568, _5569, ), bb1204, bb399)
	var1915 = 0x11616f53 / var108;	// _1915 = BinOp(0x11616f53 u32 DIV _108)
	var5573 = 0x481183e ^ var1915;	// _5573 = BinOp(0x481183e u32 BIT_XOR _1915)
	var5570 = var5573 & 0x7;	// _5570 = BinOp(_5573 BIT_AND 0x7 u32)
	var5571 = (uint8_t )var5570;	// _5571 = Cast(_5570 as u8)
	var5575 = var5572 >> var5571;
	// ^ Call( _5575 = "unchecked_shr"::<u8,>( _5572, _5571, ), bb1205, bb399)
	var5577 = var5574 % var5575;	// _5577 = BinOp(_5574 MOD _5575)
	__builtin_mul_overflow(var5576, var5577, &var1916);
	// ^ Call( _1916 = "overflowing_mul"::<u8,>( _5576, _5577, ), bb1206, bb399)
	__builtin_sub_overflow(var108, var47, &var5578);
	// ^ Call( _5578 = "overflowing_sub"::<u32,>( _108, _47, ), bb1207, bb399)
	var5581 = 0xabf06838 / var5578;	// _5581 = BinOp(0xabf06838 u32 DIV _5578)
	var5580 = 0xc714154e / var127;	// _5580 = BinOp(0xc714154e u32 DIV _127)
	var5579 = var5580 & 0x1f;	// _5579 = BinOp(_5580 BIT_AND 0x1f u32)
	var5582 = var71 << var5579;
	// ^ Call( _5582 = "unchecked_shl"::<u32,>( _71, _5579, ), bb1208, bb399)
	var5584 = var5581 % var5582;	// _5584 = BinOp(_5581 MOD _5582)
	var5583 = (uint32_t )var53;	// _5583 = Cast(_53 as u32)
	var5585 = 0xc7d8c30f % var5583;	// _5585 = BinOp(0xc7d8c30f u32 MOD _5583)
	__builtin_add_overflow(var5584, var5585, &var5588);
	// ^ Call( _5588 = "overflowing_add"::<u32,>( _5584, _5585, ), bb1209, bb399)
	var5586 = var5588 & 0xf;	// _5586 = BinOp(_5588 BIT_AND 0xf u32)
	var5587 = (int16_t )var5586;	// _5587 = Cast(_5586 as i16)
	var254 = 8240 >> var5587;
	// ^ Call( _254 = "unchecked_shr"::<i16,>( +8240 i16, _5587, ), bb1210, bb399)
	var1918 = (uint16_t )var171;	// _1918 = Cast(_171 as u16)
	var5589 = (int16_t )var1918;	// _5589 = Cast(_1918 as i16)
	__builtin_mul_overflow(var38, var5589, &var1919);
	// ^ Call( _1919 = "overflowing_mul"::<i16,>( _38, _5589, ), bb1211, bb399)
	var1917 = var1919 / var210;	// _1917 = BinOp(_1919 DIV _210)
	var255 = -var1917;	// _255 = UniOp(_1917 NEG)
	__builtin_mul_overflow(0x372f6d4d, var163, &var1920);
	// ^ Call( _1920 = "overflowing_mul"::<u32,>( 0x372f6d4d u32, _163, ), bb1212, bb399)
	var5592 = 0x5eddbd92 * var1920;	// _5592 = BinOp(0x5eddbd92 u32 MUL _1920)
	var5590 = var5592 & 0x7;	// _5590 = BinOp(_5592 BIT_AND 0x7 u32)
	var5591 = (uint8_t )var5590;	// _5591 = Cast(_5590 as u8)
	var1921 = 0xa3 >> var5591;
	// ^ Call( _1921 = "unchecked_shr"::<u8,>( 0xa3 u8, _5591, ), bb1213, bb399)
	__builtin_sub_overflow(var78, 0xf0, &var1922);
	// ^ Call( _1922 = "overflowing_sub"::<u8,>( _78, 0xf0 u8, ), bb1214, bb399)
	var5593 = var33 - var33;	// _5593 = BinOp(_33 SUB _33)
	__builtin_add_overflow(532467670, var56, &var5594);
	// ^ Call( _5594 = "overflowing_add"::<i32,>( +532467670 i32, _56, ), bb1215, bb399)
	__builtin_sub_overflow(var5593, var5594, &var1924);
	// ^ Call( _1924 = "overflowing_sub"::<i32,>( _5593, _5594, ), bb1216, bb399)
	var5595 = var122 ^ var90;	// _5595 = BinOp(_122 BIT_XOR _90)
	__builtin_mul_overflow(var5595, 1444703683, &var1925);
	// ^ Call( _1925 = "overflowing_mul"::<i32,>( _5595, +1444703683 i32, ), bb1217, bb399)
	var1923 = var1924 / var1925;	// _1923 = BinOp(_1924 DIV _1925)
	var1926 = -var1923;	// _1926 = UniOp(_1923 NEG)
	var256 = -var1926;	// _256 = UniOp(_1926 NEG)
	__builtin_add_overflow(569759643, 1514523327, &var1927);
	// ^ Call( _1927 = "overflowing_add"::<i32,>( +569759643 i32, +1514523327 i32, ), bb1218, bb399)
	var5596 = 0xe687 - var98;	// _5596 = BinOp(0xe687 u16 SUB _98)
	var1928 = var166 % var5596;	// _1928 = BinOp(_166 MOD _5596)
	var5599 = 0xa6c2 & var1928;	// _5599 = BinOp(0xa6c2 u16 BIT_AND _1928)
	var1929 = (uint32_t )var222;	// _1929 = Cast(_222 as u32)
	var1930 = var161 * var205;	// _1930 = BinOp(_161 MUL _205)
	var1931 = (uint32_t )var1930;	// _1931 = Cast(_1930 as u32)
	var5600 = var1929 * var1931;	// _5600 = BinOp(_1929 MUL _1931)
	var5597 = var5600 & 0xf;	// _5597 = BinOp(_5600 BIT_AND 0xf u32)
	var5598 = (uint16_t )var5597;	// _5598 = Cast(_5597 as u16)
	var1932 = var5599 >> var5598;
	// ^ Call( _1932 = "unchecked_shr"::<u16,>( _5599, _5598, ), bb1219, bb399)
	var5601 = 0xde47f176 | var163;	// _5601 = BinOp(0xde47f176 u32 BIT_OR _163)
	__builtin_add_overflow(0xdb3716df, var5601, &var5602);
	// ^ Call( _5602 = "overflowing_add"::<u32,>( 0xdb3716df u32, _5601, ), bb1220, bb399)
	var5603 = var193 | var177;	// _5603 = BinOp(_193 BIT_OR _177)
	var1933 = var5602 / var5603;	// _1933 = BinOp(_5602 DIV _5603)
	var1934 = var234 - var234;	// _1934 = BinOp(_234 SUB _234)
	var5604 = (uint32_t )var1934;	// _5604 = Cast(_1934 as u32)
	__builtin_mul_overflow(var5604, 0xaf81741c, &var1935);
	// ^ Call( _1935 = "overflowing_mul"::<u32,>( _5604, 0xaf81741c u32, ), bb1221, bb399)
	var5606 = var1933 - var1935;	// _5606 = BinOp(_1933 SUB _1935)
	var5605 = var5606 & 0x1f;	// _5605 = BinOp(_5606 BIT_AND 0x1f u32)
	var1936 = 0xd401dbc8 >> var5605;
	// ^ Call( _1936 = "unchecked_shr"::<u32,>( 0xd401dbc8 u32, _5605, ), bb1222, bb399)
	var1937 = -var70;	// _1937 = UniOp(_70 NEG)
	var1938 = -var1937;	// _1938 = UniOp(_1937 NEG)
	var5608 = -var1938;	// _5608 = UniOp(_1938 NEG)
	var5607 = ZRICd15overflowing_div0g( 21944, var5608 );
	// ^ Call( _5607 = <i16 /*- */>::overflowing_div( +21944 i16, _5608, ), bb1223, bb399)
	var1939 = var216 / 0xec;	// _1939 = BinOp(_216 DIV 0xec u8)
	var1940 = (int16_t )var1939;	// _1940 = Cast(_1939 as i16)
	var5609 = var227 * var1940;	// _5609 = BinOp(_227 MUL _1940)
	__builtin_add_overflow(var5609, var75, &var5617);
	// ^ Call( _5617 = "overflowing_add"::<i16,>( _5609, _75, ), bb1224, bb399)
	var5612 = -var190;	// _5612 = UniOp(_190 NEG)
	var5613 = var41 | var141;	// _5613 = BinOp(_41 BIT_OR _141)
	var5610 = var5613 & 0xf;	// _5610 = BinOp(_5613 BIT_AND 0xf u32)
	var5611 = (int16_t )var5610;	// _5611 = Cast(_5610 as i16)
	var1941 = var5612 >> var5611;
	// ^ Call( _1941 = "unchecked_shr"::<i16,>( _5612, _5611, ), bb1225, bb399)
	var1942 = -var1941;	// _1942 = UniOp(_1941 NEG)
	var5614 = (int16_t )var129;	// _5614 = Cast(_129 as i16)
	__builtin_add_overflow(var5614, -6, &var5616);
	// ^ Call( _5616 = "overflowing_add"::<i16,>( _5614, -6 i16, ), bb1226, bb399)
	var5615 = ZRICd15overflowing_div0g( var5616, -18377 );
	// ^ Call( _5615 = <i16 /*- */>::overflowing_div( _5616, -18377 i16, ), bb1227, bb399)
	var5618 = var1942 * var5615._0;	// _5618 = BinOp(_1942 MUL _5615.0)
	__builtin_sub_overflow(var5617, var5618, &var1943);
	// ^ Call( _1943 = "overflowing_sub"::<i16,>( _5617, _5618, ), bb1228, bb399)
	var1944 = 2510874399657524157ll ^ var164;	// _1944 = BinOp(+2510874399657524157 i64 BIT_XOR _164)
	var1945 = -var1944;	// _1945 = UniOp(_1944 NEG)
	var5620 = -var1945;	// _5620 = UniOp(_1945 NEG)
	var5619 = -var181;	// _5619 = UniOp(_181 NEG)
	__builtin_add_overflow(var52, var5619, &var1946);
	// ^ Call( _1946 = "overflowing_add"::<i16,>( _52, _5619, ), bb1229, bb399)
	var5621 = (int64_t )var1946;	// _5621 = Cast(_1946 as i64)
	__builtin_mul_overflow(var5620, var5621, &var1947);
	// ^ Call( _1947 = "overflowing_mul"::<i64,>( _5620, _5621, ), bb1230, bb399)
	__builtin_sub_overflow(-1606585428695858633ll, -1883748297913019148ll, &var1948);
	// ^ Call( _1948 = "overflowing_sub"::<i64,>( -1606585428695858633 i64, -1883748297913019148 i64, ), bb1231, bb399)
	var5622 = -var1948;	// _5622 = UniOp(_1948 NEG)
	__builtin_sub_overflow(2385401463184822969ll, var5622, &var1949);
	// ^ Call( _1949 = "overflowing_sub"::<i64,>( +2385401463184822969 i64, _5622, ), bb1232, bb399)
	var5625 = -var195;	// _5625 = UniOp(_195 NEG)
	var5623 = var95 & 0x3f;	// _5623 = BinOp(_95 BIT_AND 0x3f u32)
	var5624 = (int64_t )var5623;	// _5624 = Cast(_5623 as i64)
	var1950 = var5625 >> var5624;
	// ^ Call( _1950 = "unchecked_shr"::<i64,>( _5625, _5624, ), bb1233, bb399)
	var257 = 0x2d;	// _257 = Constant(0x2d u8)
	var5626 = -7604677332460868281ll / var245;	// _5626 = BinOp(-7604677332460868281 isize DIV _245)
	__builtin_sub_overflow(var245, var239, &var5627);
	// ^ Call( _5627 = "overflowing_sub"::<isize,>( _245, _239, ), bb1234, bb399)
	__builtin_add_overflow(var5626, var5627, &var5632);
	// ^ Call( _5632 = "overflowing_add"::<isize,>( _5626, _5627, ), bb1235, bb399)
	__builtin_sub_overflow(0x828107db, 0x9bcb9350, &var5629);
	// ^ Call( _5629 = "overflowing_sub"::<u32,>( 0x828107db u32, 0x9bcb9350 u32, ), bb1236, bb399)
	var5628 = var243 & 0x1f;	// _5628 = BinOp(_243 BIT_AND 0x1f u32)
	var5633 = var5629 << var5628;
	// ^ Call( _5633 = "unchecked_shl"::<u32,>( _5629, _5628, ), bb1237, bb399)
	var5630 = var5633 & 0x3f;	// _5630 = BinOp(_5633 BIT_AND 0x3f u32)
	var5631 = (intptr_t )var5630;	// _5631 = Cast(_5630 as isize)
	var1951 = var5632 << var5631;
	// ^ Call( _1951 = "unchecked_shl"::<isize,>( _5632, _5631, ), bb1238, bb399)
	var5634 = var47 & 0x3f;	// _5634 = BinOp(_47 BIT_AND 0x3f u32)
	var5635 = (intptr_t )var5634;	// _5635 = Cast(_5634 as isize)
	var1952 = var109 >> var5635;
	// ^ Call( _1952 = "unchecked_shr"::<isize,>( _109, _5635, ), bb1239, bb399)
	__builtin_sub_overflow(var245, var64, &var1953);
	// ^ Call( _1953 = "overflowing_sub"::<isize,>( _245, _64, ), bb1240, bb399)
	__builtin_add_overflow(var79, 0xb0c99e93, &var1954);
	// ^ Call( _1954 = "overflowing_add"::<u32,>( _79, 0xb0c99e93 u32, ), bb1241, bb399)
	__builtin_mul_overflow(var143, -74, &var1955);
	// ^ Call( _1955 = "overflowing_mul"::<i8,>( _143, -74 i8, ), bb1242, bb399)
	var1956 = (uint32_t )var1955;	// _1956 = Cast(_1955 as u32)
	var5638 = var1954 / var1956;	// _5638 = BinOp(_1954 DIV _1956)
	var5636 = var241 & 0x7f;	// _5636 = BinOp(_241 BIT_AND 0x7f u32)
	var5637.lo = var5636; var5637.hi = var5636 < 0 ? -1 : 0;	// _5637 = Cast(_5636 as u128)
	var1958 = shr128(make128_raw(9311808217615397138ull, 13262096393461216632ull), var5637.lo);
	// ^ Call( _1958 = "unchecked_shr"::<u128,>( 0x813a303ce3877112b80c6e677d3eb578 u128, _5637, ), bb1243, bb399)
	var1959.lo = var88; var1959.hi = var88 < 0 ? -1 : 0;	// _1959 = Cast(_88 as u128)
	var1957 = or128(var1958, var1959);	// _1957 = BinOp(_1958 BIT_OR _1959)
	var5639 = var1957.lo;	// _5639 = Cast(_1957 as u32)
	__builtin_mul_overflow(var5638, var5639, &var1960);
	// ^ Call( _1960 = "overflowing_mul"::<u32,>( _5638, _5639, ), bb1244, bb399)
	var1961 = (uint32_t )var124;	// _1961 = Cast(_124 as u32)
	var1962 = var141 - 0x1d107102;	// _1962 = BinOp(_141 SUB 0x1d107102 u32)
	var5640 = var1961 | var1962;	// _5640 = BinOp(_1961 BIT_OR _1962)
	var5642 = 0xf22e2bed % var5640;	// _5642 = BinOp(0xf22e2bed u32 MOD _5640)
	__builtin_sub_overflow(var41, var25, &var5641);
	// ^ Call( _5641 = "overflowing_sub"::<u32,>( _41, _25, ), bb1245, bb399)
	__builtin_add_overflow(var5641, 0x3c59caf9, &var1963);
	// ^ Call( _1963 = "overflowing_add"::<u32,>( _5641, 0x3c59caf9 u32, ), bb1246, bb399)
	var5643 = var1963 ^ 0x76d32d94;	// _5643 = BinOp(_1963 BIT_XOR 0x76d32d94 u32)
	__builtin_mul_overflow(var5642, var5643, &var1964);
	// ^ Call( _1964 = "overflowing_mul"::<u32,>( _5642, _5643, ), bb1247, bb399)
	var5644 = var67 & 0x3f;	// _5644 = BinOp(_67 BIT_AND 0x3f u32)
	var5645 = (uint64_t )var5644;	// _5645 = Cast(_5644 as u64)
	var5647 = 0x5b7717d9c54450d9ull << var5645;
	// ^ Call( _5647 = "unchecked_shl"::<u64,>( 0x5b7717d9c54450d9 u64, _5645, ), bb1248, bb399)
	__builtin_sub_overflow(var31, var137, &var5646);
	// ^ Call( _5646 = "overflowing_sub"::<u64,>( _31, _137, ), bb1249, bb399)
	__builtin_add_overflow(var5646, 0x899263216a7bfbebull, &var5648);
	// ^ Call( _5648 = "overflowing_add"::<u64,>( _5646, 0x899263216a7bfbeb u64, ), bb1250, bb399)
	__builtin_sub_overflow(var5647, var5648, &var1965);
	// ^ Call( _1965 = "overflowing_sub"::<u64,>( _5647, _5648, ), bb1251, bb399)
	__builtin_add_overflow(var95, 0x0, &var5649);
	// ^ Call( _5649 = "overflowing_add"::<u32,>( _95, 0x0 u32, ), bb1252, bb399)
	__builtin_mul_overflow(0x938e09a1, var5649, &var1966);
	// ^ Call( _1966 = "overflowing_mul"::<u32,>( 0x938e09a1 u32, _5649, ), bb1253, bb399)
	var5650 = var208 / 0x5c47ddf6;	// _5650 = BinOp(_208 DIV 0x5c47ddf6 u32)
	var1967 = var5650 << 0xe;
	// ^ Call( _1967 = "unchecked_shl"::<u32,>( _5650, 0xe u32, ), bb1254, bb399)
	__builtin_mul_overflow(var209, var157, &var1968);
	// ^ Call( _1968 = "overflowing_mul"::<u32,>( _209, _157, ), bb1255, bb399)
	__builtin_add_overflow(var236, var46, &var5651);
	// ^ Call( _5651 = "overflowing_add"::<u16,>( _236, _46, ), bb1256, bb399)
	var5652 = 0xcda2 % var5651;	// _5652 = BinOp(0xcda2 u16 MOD _5651)
	var258 = var5652 % 0xb7c2;	// _258 = BinOp(_5652 MOD 0xb7c2 u16)
	var1970 = add128s(make128s_raw(17388248488546563721ull, 14526580862071201787ull), var235);	// _1970 = BinOp(-19525797162653070929516679157214486533 i128 ADD _235)
	var1969 = div128s(make128s_raw(943776330820659237ull, 12905993693120998432ull), var1970);	// _1969 = BinOp(+17409600437473341039664795361919675424 i128 DIV _1970)
	var5653.lo = var183; var5653.hi = var183 < 0 ? -1 : 0;	// _5653 = Cast(_183 as i128)
	var1971 = shr128s(var5653, make128s_raw(0ull, 70ull).lo);
	// ^ Call( _1971 = "unchecked_shr"::<i128,>( _5653, +70 i128, ), bb1257, bb399)
	var5656 = or128s(var1969, var1971);	// _5656 = BinOp(_1969 BIT_OR _1971)
	var5654 = var220 & 0x7f;	// _5654 = BinOp(_220 BIT_AND 0x7f u32)
	var5655.lo = var5654; var5655.hi = var5654 < 0 ? -1 : 0;	// _5655 = Cast(_5654 as i128)
	var5657 = shr128s(make128s_raw(8644096495588318919ull, 17867747486277235162ull), var5655.lo);
	// ^ Call( _5657 = "unchecked_shr"::<i128,>( +159455435802567325322269393132977058266 i128, _5655, ), bb1258, bb399)
	sub128s_o(var5656, var5657, &var1972);
	// ^ Call( _1972 = "overflowing_sub"::<i128,>( _5656, _5657, ), bb1259, bb399)
	var259 = var212;	// _259 = Use(_212)
	var260 = var157;	// _260 = Use(_157)
	var1973 = -var172;	// _1973 = UniOp(_172 NEG)
	var5661 = -var1973;	// _5661 = UniOp(_1973 NEG)
	var5658 = var22 - var157;	// _5658 = BinOp(_22 SUB _157)
	__builtin_add_overflow(var243, var5658, &var5662);
	// ^ Call( _5662 = "overflowing_add"::<u32,>( _243, _5658, ), bb1260, bb399)
	var5659 = var5662 & 0x7;	// _5659 = BinOp(_5662 BIT_AND 0x7 u32)
	var5660 = (int8_t )var5659;	// _5660 = Cast(_5659 as i8)
	var1974 = var5661 << var5660;
	// ^ Call( _1974 = "unchecked_shl"::<i8,>( _5661, _5660, ), bb1261, bb399)
	var5665 = var118 * 0xe8;	// _5665 = BinOp(_118 MUL 0xe8 u8)
	var5666 = (uint32_t )var7;	// _5666 = Cast(_7 as u32)
	var5663 = var5666 & 0x7;	// _5663 = BinOp(_5666 BIT_AND 0x7 u32)
	var5664 = (uint8_t )var5663;	// _5664 = Cast(_5663 as u8)
	var5669 = var5665 << var5664;
	// ^ Call( _5669 = "unchecked_shl"::<u8,>( _5665, _5664, ), bb1262, bb399)
	var5667 = 0x3a << 0x7;
	// ^ Call( _5667 = "unchecked_shl"::<u8,>( 0x3a u8, 0x7 u8, ), bb1263, bb399)
	var5668 = var180 << 0x0;
	// ^ Call( _5668 = "unchecked_shl"::<u8,>( _180, 0x0 u8, ), bb1264, bb399)
	__builtin_mul_overflow(var5667, var5668, &var5670);
	// ^ Call( _5670 = "overflowing_mul"::<u8,>( _5667, _5668, ), bb1265, bb399)
	__builtin_mul_overflow(var5669, var5670, &var5671);
	// ^ Call( _5671 = "overflowing_mul"::<u8,>( _5669, _5670, ), bb1266, bb399)
	var1976 = var144.lo;	// _1976 = Cast(_144 as u8)
	var1975 = var7 + var1976;	// _1975 = BinOp(_7 ADD _1976)
	var5672 = 0xc / var1975;	// _5672 = BinOp(0xc u8 DIV _1975)
	__builtin_sub_overflow(var5671, var5672, &var1977);
	// ^ Call( _1977 = "overflowing_sub"::<u8,>( _5671, _5672, ), bb1267, bb399)
	var5674 = 0xaeb6e50a / var41;	// _5674 = BinOp(0xaeb6e50a u32 DIV _41)
	var5673 = var5674 & 0x1f;	// _5673 = BinOp(_5674 BIT_AND 0x1f u32)
	var1978 = 0xee9f1861 >> var5673;
	// ^ Call( _1978 = "unchecked_shr"::<u32,>( 0xee9f1861 u32, _5673, ), bb1268, bb399)
	var5677 = var1978 / var225;	// _5677 = BinOp(_1978 DIV _225)
	var1980 = var67 / 0xe2a16a09;	// _1980 = BinOp(_67 DIV 0xe2a16a09 u32)
	var1981 = 0xfb4e612f << 0xe;
	// ^ Call( _1981 = "unchecked_shl"::<u32,>( 0xfb4e612f u32, 0xe u32, ), bb1269, bb399)
	var1979 = var1980 | var1981;	// _1979 = BinOp(_1980 BIT_OR _1981)
	var5675 = var208 ^ var41;	// _5675 = BinOp(_208 BIT_XOR _41)
	__builtin_add_overflow(var108, var5675, &var1982);
	// ^ Call( _1982 = "overflowing_add"::<u32,>( _108, _5675, ), bb1270, bb399)
	var5678 = var1979 & var1982;	// _5678 = BinOp(_1979 BIT_AND _1982)
	var5676 = var5678 & 0x1f;	// _5676 = BinOp(_5678 BIT_AND 0x1f u32)
	var5679 = var5677 << var5676;
	// ^ Call( _5679 = "unchecked_shl"::<u32,>( _5677, _5676, ), bb1271, bb399)
	var5680 = 0xb7ffddaf % var25;	// _5680 = BinOp(0xb7ffddaf u32 MOD _25)
	var261 = var5679 / var5680;	// _261 = BinOp(_5679 DIV _5680)
	var1983 = -1403225222 | var89;	// _1983 = BinOp(-1403225222 i32 BIT_OR _89)
	var1984.lo = var1983; var1984.hi = var1983 < 0 ? -1 : 0;	// _1984 = Cast(_1983 as i128)
	var1985 = neg128s(var1984);	// _1985 = UniOp(_1984 NEG)
	var5682 = neg128s(var1985);	// _5682 = UniOp(_1985 NEG)
	var1986 = xor128s(make128s_raw(3292836595580458359ull, 10169859506514409621ull), var48);	// _1986 = BinOp(+60742113955217755766294468400163567765 i128 BIT_XOR _48)
	var1987 = neg128s(var1986);	// _1987 = UniOp(_1986 NEG)
	var1989 = neg128s(var48);	// _1989 = UniOp(_48 NEG)
	var1988 = and128s(make128s_raw(125251811143808997ull, 11384093251223136530ull), var1989);	// _1988 = BinOp(+2310488104938446602441934514439825682 i128 BIT_AND _1989)
	var5683 = or128s(var1987, var1988);	// _5683 = BinOp(_1987 BIT_OR _1988)
	var5681 = ZRICj15overflowing_rem0g( var5682, var5683 );
	// ^ Call( _5681 = <i128 /*- */>::overflowing_rem( _5682, _5683, ), bb1272, bb399)
	var5687 = -var174;	// _5687 = UniOp(_174 NEG)
	__builtin_sub_overflow(0x4ba5bae6, 0x55f06e61, &var1990);
	// ^ Call( _1990 = "overflowing_sub"::<u32,>( 0x4ba5bae6 u32, 0x55f06e61 u32, ), bb1273, bb399)
	var5686 = var22 / var1990;	// _5686 = BinOp(_22 DIV _1990)
	var5684 = var5686 & 0x3f;	// _5684 = BinOp(_5686 BIT_AND 0x3f u32)
	var5685 = (intptr_t )var5684;	// _5685 = Cast(_5684 as isize)
	var5688 = 383037043350795430ll << var5685;
	// ^ Call( _5688 = "unchecked_shl"::<isize,>( +383037043350795430 isize, _5685, ), bb1274, bb399)
	__builtin_mul_overflow(var5687, var5688, &var5693);
	// ^ Call( _5693 = "overflowing_mul"::<isize,>( _5687, _5688, ), bb1275, bb399)
	var1991 = var237 | var64;	// _1991 = BinOp(_237 BIT_OR _64)
	var1992 = var174 - var239;	// _1992 = BinOp(_174 SUB _239)
	var5690 = var1991 ^ var1992;	// _5690 = BinOp(_1991 BIT_XOR _1992)
	var1993 = -var55;	// _1993 = UniOp(_55 NEG)
	var5691 = -var1993;	// _5691 = UniOp(_1993 NEG)
	var5689 = ZRICv15overflowing_rem0g( var5690, var5691 );
	// ^ Call( _5689 = <isize /*- */>::overflowing_rem( _5690, _5691, ), bb1276, bb399)
	var5692 = ZRICv15overflowing_div0g( 3492801522574809253ll, -5928040872206033327ll );
	// ^ Call( _5692 = <isize /*- */>::overflowing_div( +3492801522574809253 isize, -5928040872206033327 isize, ), bb1277, bb399)
	__builtin_sub_overflow(var5689._0, var5692._0, &var5694);
	// ^ Call( _5694 = "overflowing_sub"::<isize,>( _5689.0, _5692.0, ), bb1278, bb399)
	__builtin_mul_overflow(var5693, var5694, &var262);
	// ^ Call( _262 = "overflowing_mul"::<isize,>( _5693, _5694, ), bb1279, bb399)
	var1997 = var53 ^ 0xeefcfee56ff7ccebull;	// _1997 = BinOp(_53 BIT_XOR 0xeefcfee56ff7cceb usize)
	var1996 = var1997 - var112;	// _1996 = BinOp(_1997 SUB _112)
	var1995 = 0xd10e3dff2e9f43d7ull - var1996;	// _1995 = BinOp(0xd10e3dff2e9f43d7 usize SUB _1996)
	var1999 = 0xedcff9990664c0efull & var76;	// _1999 = BinOp(0xedcff9990664c0ef usize BIT_AND _76)
	var5695 = 0xbcb846bb3f4d7acaull + var205;	// _5695 = BinOp(0xbcb846bb3f4d7aca usize ADD _205)
	__builtin_sub_overflow(0x0ull, var5695, &var2000);
	// ^ Call( _2000 = "overflowing_sub"::<usize,>( 0x0 usize, _5695, ), bb1280, bb399)
	var1998 = var1999 / var2000;	// _1998 = BinOp(_1999 DIV _2000)
	var1994 = var1995 * var1998;	// _1994 = BinOp(_1995 MUL _1998)
	var263 = (uint16_t )var1994;	// _263 = Cast(_1994 as u16)
	var5696 = var209 & 0x7;	// _5696 = BinOp(_209 BIT_AND 0x7 u32)
	var5697 = (uint8_t )var5696;	// _5697 = Cast(_5696 as u8)
	var5700 = 0xf5 >> var5697;
	// ^ Call( _5700 = "unchecked_shr"::<u8,>( 0xf5 u8, _5697, ), bb1281, bb399)
	var5701 = var2 ^ var260;	// _5701 = BinOp(_2 BIT_XOR _260)
	var5698 = var5701 & 0x7;	// _5698 = BinOp(_5701 BIT_AND 0x7 u32)
	var5699 = (uint8_t )var5698;	// _5699 = Cast(_5698 as u8)
	var2002 = var5700 << var5699;
	// ^ Call( _2002 = "unchecked_shl"::<u8,>( _5700, _5699, ), bb1282, bb399)
	__builtin_sub_overflow(0xf3, var129, &var2004);
	// ^ Call( _2004 = "overflowing_sub"::<u8,>( 0xf3 u8, _129, ), bb1283, bb399)
	var2005 = var78 | var197;	// _2005 = BinOp(_78 BIT_OR _197)
	var2003 = var2004 | var2005;	// _2003 = BinOp(_2004 BIT_OR _2005)
	var2001 = var2002 / var2003;	// _2001 = BinOp(_2002 DIV _2003)
	var5702 = var257 * var2001;	// _5702 = BinOp(_257 MUL _2001)
	__builtin_sub_overflow(var5702, var212, &var2006);
	// ^ Call( _2006 = "overflowing_sub"::<u8,>( _5702, _212, ), bb1284, bb399)
	var5704 = 1871957626 + var84;	// _5704 = BinOp(+1871957626 i32 ADD _84)
	__builtin_mul_overflow(var5, var5, &var5705);
	// ^ Call( _5705 = "overflowing_mul"::<i32,>( _5, _5, ), bb1285, bb399)
	var5703 = ZRICf15overflowing_div0g( var5704, var5705 );
	// ^ Call( _5703 = <i32 /*- */>::overflowing_div( _5704, _5705, ), bb1286, bb399)
	var264 = -var91;	// _264 = UniOp(_91 NEG)
	var5708 = -1679508994;	// _5708 = Constant(-1679508994 i32)
	__builtin_sub_overflow(var49, var92, &var5709);
	// ^ Call( _5709 = "overflowing_sub"::<u32,>( _49, _92, ), bb1287, bb399)
	var5706 = var5709 & 0x1f;	// _5706 = BinOp(_5709 BIT_AND 0x1f u32)
	var5707 = (int32_t )var5706;	// _5707 = Cast(_5706 as i32)
	var5714 = var5708 << var5707;
	// ^ Call( _5714 = "unchecked_shl"::<i32,>( _5708, _5707, ), bb1288, bb399)
	var5710 = var71 & 0x1f;	// _5710 = BinOp(_71 BIT_AND 0x1f u32)
	var5711 = (int32_t )var5710;	// _5711 = Cast(_5710 as i32)
	var5712 = var229 << var5711;
	// ^ Call( _5712 = "unchecked_shl"::<i32,>( _229, _5711, ), bb1289, bb399)
	var5713 = -var86;	// _5713 = UniOp(_86 NEG)
	__builtin_mul_overflow(var5712, var5713, &var5715);
	// ^ Call( _5715 = "overflowing_mul"::<i32,>( _5712, _5713, ), bb1290, bb399)
	__builtin_mul_overflow(var5714, var5715, &var2007);
	// ^ Call( _2007 = "overflowing_mul"::<i32,>( _5714, _5715, ), bb1291, bb399)
	var5716 = var67 & 0x1f;	// _5716 = BinOp(_67 BIT_AND 0x1f u32)
	var5717 = (int32_t )var5716;	// _5717 = Cast(_5716 as i32)
	var5718 = var240 >> var5717;
	// ^ Call( _5718 = "unchecked_shr"::<i32,>( _240, _5717, ), bb1292, bb399)
	__builtin_mul_overflow(var5718, -1520720650, &var2008);
	// ^ Call( _2008 = "overflowing_mul"::<i32,>( _5718, -1520720650 i32, ), bb1293, bb399)
	var2009 = -var2008;	// _2009 = UniOp(_2008 NEG)
	var5720 = var2007 + var2009;	// _5720 = BinOp(_2007 ADD _2009)
	var2010 = var248 | -217112541;	// _2010 = BinOp(_248 BIT_OR -217112541 i32)
	var2011 = -var2010;	// _2011 = UniOp(_2010 NEG)
	var2012 = -var2011;	// _2012 = UniOp(_2011 NEG)
	var5721 = var2012 | 860832059;	// _5721 = BinOp(_2012 BIT_OR +860832059 i32)
	var5719 = ZRICf15overflowing_div0g( var5720, var5721 );
	// ^ Call( _5719 = <i32 /*- */>::overflowing_div( _5720, _5721, ), bb1294, bb399)
	var265 = 0xac9c3417;	// _265 = Constant(0xac9c3417 u32)
	var266 = var157;	// _266 = Use(_157)
	__builtin_add_overflow(0xa6, var63, &var2013);
	// ^ Call( _2013 = "overflowing_add"::<u8,>( 0xa6 u8, _63, ), bb1295, bb399)
	var5725 = var147 + var2013;	// _5725 = BinOp(_147 ADD _2013)
	var5722 = var29.lo;	// _5722 = Cast(_29 as u32)
	__builtin_sub_overflow(0x66624938, var5722, &var5726);
	// ^ Call( _5726 = "overflowing_sub"::<u32,>( 0x66624938 u32, _5722, ), bb1296, bb399)
	var5723 = var5726 & 0x7;	// _5723 = BinOp(_5726 BIT_AND 0x7 u32)
	var5724 = (uint8_t )var5723;	// _5724 = Cast(_5723 as u8)
	var5727 = var5725 >> var5724;
	// ^ Call( _5727 = "unchecked_shr"::<u8,>( _5725, _5724, ), bb1297, bb399)
	__builtin_add_overflow(0x10, var5727, &var5728);
	// ^ Call( _5728 = "overflowing_add"::<u8,>( 0x10 u8, _5727, ), bb1298, bb399)
	var2015 = var52 | -14758;	// _2015 = BinOp(_52 BIT_OR -14758 i16)
	var5732 = (int16_t )var230;	// _5732 = Cast(_230 as i16)
	var2016 = var25 / 0x8475f12d;	// _2016 = BinOp(_25 DIV 0x8475f12d u32)
	var5729 = var163 & 0x1f;	// _5729 = BinOp(_163 BIT_AND 0x1f u32)
	var2017 = 0xb0a8a07c << var5729;
	// ^ Call( _2017 = "unchecked_shl"::<u32,>( 0xb0a8a07c u32, _5729, ), bb1299, bb399)
	var5733 = var2016 | var2017;	// _5733 = BinOp(_2016 BIT_OR _2017)
	var5730 = var5733 & 0xf;	// _5730 = BinOp(_5733 BIT_AND 0xf u32)
	var5731 = (int16_t )var5730;	// _5731 = Cast(_5730 as i16)
	var2018 = var5732 >> var5731;
	// ^ Call( _2018 = "unchecked_shr"::<i16,>( _5732, _5731, ), bb1300, bb399)
	var2014 = var2015 & var2018;	// _2014 = BinOp(_2015 BIT_AND _2018)
	var267 = (uintptr_t )var2014;	// _267 = Cast(_2014 as usize)
	var5734 = (uint16_t )var111;	// _5734 = Cast(_111 as u16)
	__builtin_sub_overflow(var5734, 0x1099, &var5736);
	// ^ Call( _5736 = "overflowing_sub"::<u16,>( _5734, 0x1099 u16, ), bb1301, bb399)
	var5735 = var25 & 0x1f;	// _5735 = BinOp(_25 BIT_AND 0x1f u32)
	var2019 = var225 >> var5735;
	// ^ Call( _2019 = "unchecked_shr"::<u32,>( _225, _5735, ), bb1302, bb399)
	var5737 = (uint16_t )var2019;	// _5737 = Cast(_2019 as u16)
	__builtin_sub_overflow(var5736, var5737, &var5738);
	// ^ Call( _5738 = "overflowing_sub"::<u16,>( _5736, _5737, ), bb1303, bb399)
	__builtin_sub_overflow(0xe332, var5738, &var2020);
	// ^ Call( _2020 = "overflowing_sub"::<u16,>( 0xe332 u16, _5738, ), bb1304, bb399)
	var2022 = 0xf312 & var24;	// _2022 = BinOp(0xf312 u16 BIT_AND _24)
	var5739 = var68 | var11;	// _5739 = BinOp(_68 BIT_OR _11)
	__builtin_add_overflow(var5739, 0xc877, &var2024);
	// ^ Call( _2024 = "overflowing_add"::<u16,>( _5739, 0xc877 u16, ), bb1305, bb399)
	var2025 = 0xb3d5 * var135;	// _2025 = BinOp(0xb3d5 u16 MUL _135)
	var2023 = var2024 * var2025;	// _2023 = BinOp(_2024 MUL _2025)
	var2021 = var2022 * var2023;	// _2021 = BinOp(_2022 MUL _2023)
	var268 = var2020 & var2021;	// _268 = BinOp(_2020 BIT_AND _2021)
	var269 = -var173;	// _269 = UniOp(_173 NEG)
	__builtin_mul_overflow(0x79, 0xb1, &var2026);
	// ^ Call( _2026 = "overflowing_mul"::<u8,>( 0x79 u8, 0xb1 u8, ), bb1306, bb399)
	var2027 = 103;	// _2027 = Constant(+103 i8)
	var2029 = var219 << 3;
	// ^ Call( _2029 = "unchecked_shl"::<i8,>( _219, +3 i8, ), bb1307, bb399)
	__builtin_sub_overflow(0x5d2a, 0xa19d, &var5740);
	// ^ Call( _5740 = "overflowing_sub"::<u16,>( 0x5d2a u16, 0xa19d u16, ), bb1308, bb399)
	var5741 = var121 - var135;	// _5741 = BinOp(_121 SUB _135)
	var2030 = var5740 % var5741;	// _2030 = BinOp(_5740 MOD _5741)
	var2031 = (int8_t )var2030;	// _2031 = Cast(_2030 as i8)
	var2028 = var2029 & var2031;	// _2028 = BinOp(_2029 BIT_AND _2031)
	var270 = var2027 - var2028;	// _270 = BinOp(_2027 SUB _2028)
	var2032 = 0x5b5bed43 * var34;	// _2032 = BinOp(0x5b5bed43 u32 MUL _34)
	var2033 = var241 / 0x9574b322;	// _2033 = BinOp(_241 DIV 0x9574b322 u32)
	var5742 = var2032 * var2033;	// _5742 = BinOp(_2032 MUL _2033)
	__builtin_mul_overflow(var5742, 0xad73c9e7, &var5745);
	// ^ Call( _5745 = "overflowing_mul"::<u32,>( _5742, 0xad73c9e7 u32, ), bb1309, bb399)
	var5743 = var71 / 0xc7384b1a;	// _5743 = BinOp(_71 DIV 0xc7384b1a u32)
	__builtin_add_overflow(var193, var5743, &var5744);
	// ^ Call( _5744 = "overflowing_add"::<u32,>( _193, _5743, ), bb1310, bb399)
	__builtin_sub_overflow(var5744, 0xc4dc87e7, &var5746);
	// ^ Call( _5746 = "overflowing_sub"::<u32,>( _5744, 0xc4dc87e7 u32, ), bb1311, bb399)
	__builtin_sub_overflow(var5745, var5746, &var5749);
	// ^ Call( _5749 = "overflowing_sub"::<u32,>( _5745, _5746, ), bb1312, bb399)
	var5747 = var5749 & 0x3f;	// _5747 = BinOp(_5749 BIT_AND 0x3f u32)
	var5748 = (uint64_t )var5747;	// _5748 = Cast(_5747 as u64)
	var2034 = 0xb9ed4835776df045ull << var5748;
	// ^ Call( _2034 = "unchecked_shl"::<u64,>( 0xb9ed4835776df045 u64, _5748, ), bb1313, bb399)
	var2035.lo = var6; var2035.hi = var6 < 0 ? -1 : 0;	// _2035 = Cast(_6 as u128)
	var2037 = shr128(make128_raw(1756259675918932864ull, 13238672504320378635ull), make128_raw(0ull, 15ull).lo);
	// ^ Call( _2037 = "unchecked_shr"::<u128,>( 0x185f7cdec47d9b80b7b936804dbf470b u128, 0xf u128, ), bb1314, bb399)
	var5752 = and128(make128_raw(17055862237953583078ull, 1953509335429376412ull), var57);	// _5752 = BinOp(0xecb29856ef38e7e61b1c4263f3ad699c u128 BIT_AND _57)
	var5750 = var22 & 0x7f;	// _5750 = BinOp(_22 BIT_AND 0x7f u32)
	var5751.lo = var5750; var5751.hi = var5750 < 0 ? -1 : 0;	// _5751 = Cast(_5750 as u128)
	var5753 = shr128(var3, var5751.lo);
	// ^ Call( _5753 = "unchecked_shr"::<u128,>( _3, _5751, ), bb1315, bb399)
	var2038 = div128(var5752, var5753);	// _2038 = BinOp(_5752 DIV _5753)
	var2036 = add128(var2037, var2038);	// _2036 = BinOp(_2037 ADD _2038)
	var5756 = add128(var2035, var2036);	// _5756 = BinOp(_2035 ADD _2036)
	var5754 = mod128(make128_raw(15808110958624322329ull, 2785137545202334615ull), var9);	// _5754 = BinOp(0xdb61b12972c3331926a6cbd750637b97 u128 MOD _9)
	mul128_o(make128_raw(9649770729840971294ull, 4017926334420730841ull), make128_raw(13434988753676233576ull, 12697205675830286275ull), &var2039);
	// ^ Call( _2039 = "overflowing_mul"::<u128,>( 0x85eadf5a24220e1e37c28ab698d5c3d9 u128, 0xba72ab17003d6b68b035894a1bf017c3 u128, ), bb1316, bb399)
	add128_o(make128_raw(3573878531032039201ull, 11104966955631342260ull), make128_raw(8643444796913802268ull, 10341018751818752180ull), &var2040);
	// ^ Call( _2040 = "overflowing_add"::<u128,>( 0x3198f796b88f3f219a1cc49c08db72b4 u128, 0x77f3af3f73bedc1c8f82adc405cf60b4 u128, ), bb1317, bb399)
	var5755 = sub128(var2039, var2040);	// _5755 = BinOp(_2039 SUB _2040)
	sub128_o(var5754, var5755, &var2041);
	// ^ Call( _2041 = "overflowing_sub"::<u128,>( _5754, _5755, ), bb1318, bb399)
	add128_o(make128_raw(13749768999772694708ull, 14315275870124425127ull), make128_raw(11400393981170043726ull, 16878586113288205661ull), &var2044);
	// ^ Call( _2044 = "overflowing_add"::<u128,>( 0xbed0fe0e4f2128b4c6aa138eec7cbfa7 u128, 0x9e3655ec8b244b4eea3cc8a4b962755d u128, ), bb1319, bb399)
	var2043 = div128(var2044, var57);	// _2043 = BinOp(_2044 DIV _57)
	var2042 = sub128(var160, var2043);	// _2042 = BinOp(_160 SUB _2043)
	var5757 = div128(var2041, var2042);	// _5757 = BinOp(_2041 DIV _2042)
	add128_o(var5756, var5757, &var2045);
	// ^ Call( _2045 = "overflowing_add"::<u128,>( _5756, _5757, ), bb1320, bb399)
	var5759 = (uint32_t )var150;	// _5759 = Cast(_150 as u32)
	var5758 = var6 & 0x1f;	// _5758 = BinOp(_6 BIT_AND 0x1f u32)
	var5760 = 0xb40536c5 >> var5758;
	// ^ Call( _5760 = "unchecked_shr"::<u32,>( 0xb40536c5 u32, _5758, ), bb1321, bb399)
	var5763 = var5759 % var5760;	// _5763 = BinOp(_5759 MOD _5760)
	var5761 = var5763 & 0x3f;	// _5761 = BinOp(_5763 BIT_AND 0x3f u32)
	var5762 = (uintptr_t )var5761;	// _5762 = Cast(_5761 as usize)
	var2046 = 0x238b6ab69df4d62full >> var5762;
	// ^ Call( _2046 = "unchecked_shr"::<usize,>( 0x238b6ab69df4d62f usize, _5762, ), bb1322, bb399)
	var2047 = (uint16_t )var2046;	// _2047 = Cast(_2046 as u16)
	var271 = (uint64_t )var2047;	// _271 = Cast(_2047 as u64)
	var272 = -10;	// _272 = Constant(-10 i16)
	var273 = 0xcfe683ba75569c75ull;	// _273 = Constant(0xcfe683ba75569c75 usize)
	var274 = 0x7c2d;	// _274 = Constant(0x7c2d u16)
	var2049 = var133 + 0xcab7d464c6ef0ed7ull;	// _2049 = BinOp(_133 ADD 0xcab7d464c6ef0ed7 u64)
	var2048 = var2049 - var155;	// _2048 = BinOp(_2049 SUB _155)
	var5764 = 0x4c9be06full + var2048;	// _5764 = BinOp(0x4c9be06f u64 ADD _2048)
	var2050 = var156 % var5764;	// _2050 = BinOp(_156 MOD _5764)
	var275 = (uint8_t )var2050;	// _275 = Cast(_2050 as u8)
	var5765 = var247 & 0x1f;	// _5765 = BinOp(_247 BIT_AND 0x1f u32)
	var2053 = 0x582b4cd0 << var5765;
	// ^ Call( _2053 = "unchecked_shl"::<u32,>( 0x582b4cd0 u32, _5765, ), bb1323, bb399)
	var2054 = var156 & var31;	// _2054 = BinOp(_156 BIT_AND _31)
	var2055 = (uint32_t )var2054;	// _2055 = Cast(_2054 as u32)
	var2052 = var2053 - var2055;	// _2052 = BinOp(_2053 SUB _2055)
	__builtin_sub_overflow(var265, 0xaffff02a, &var5767);
	// ^ Call( _5767 = "overflowing_sub"::<u32,>( _265, 0xaffff02a u32, ), bb1324, bb399)
	var5768 = var92 / var141;	// _5768 = BinOp(_92 DIV _141)
	var5766 = var5768 & 0x1f;	// _5766 = BinOp(_5768 BIT_AND 0x1f u32)
	var5769 = var5767 >> var5766;
	// ^ Call( _5769 = "unchecked_shr"::<u32,>( _5767, _5766, ), bb1325, bb399)
	var2056 = var5769 << 0x18;
	// ^ Call( _2056 = "unchecked_shl"::<u32,>( _5769, 0x18 u32, ), bb1326, bb399)
	var2051 = var2052 / var2056;	// _2051 = BinOp(_2052 DIV _2056)
	var276 = var2051 | 0xe8336453;	// _276 = BinOp(_2051 BIT_OR 0xe8336453 u32)
	var277 = 0x8dd0f462;	// _277 = Constant(0x8dd0f462 u32)
	var2058 = 805854944643760972ll | var113;	// _2058 = BinOp(+805854944643760972 isize BIT_OR _113)
	var2059 = -var228;	// _2059 = UniOp(_228 NEG)
	var2057 = var2058 + var2059;	// _2057 = BinOp(_2058 ADD _2059)
	var5770 = (uint16_t )var2057;	// _5770 = Cast(_2057 as u16)
	__builtin_mul_overflow(var5770, 0x248f, &var5771);
	// ^ Call( _5771 = "overflowing_mul"::<u16,>( _5770, 0x248f u16, ), bb1327, bb399)
	var278 = var5771 % 0xb8a;	// _278 = BinOp(_5771 MOD 0xb8a u16)
	var279 = 0xddc3;	// _279 = Constant(0xddc3 u16)
	var280 = div128(var160, make128_raw(12235787466787050964ull, 14121905032072605755ull));	// _280 = BinOp(_160 DIV 0xa9ce3fdf8104d5d4c3fb15ce3c7d303b u128)
	var281 = (int32_t )var105;	// _281 = Cast(_105 as i32)
	var2060 = -var188;	// _2060 = UniOp(_188 NEG)
	var5777 = -var2060;	// _5777 = UniOp(_2060 NEG)
	var5774 = (int32_t )var80;	// _5774 = Cast(_80 as i32)
	var5775 = var51 & 0x6fd83832;	// _5775 = BinOp(_51 BIT_AND 0x6fd83832 u32)
	var5772 = var5775 & 0x1f;	// _5772 = BinOp(_5775 BIT_AND 0x1f u32)
	var5773 = (int32_t )var5772;	// _5773 = Cast(_5772 as i32)
	var2061 = var5774 << var5773;
	// ^ Call( _2061 = "unchecked_shl"::<i32,>( _5774, _5773, ), bb1328, bb399)
	var5776 = ZRICf15overflowing_rem0g( var281, 514028095 );
	// ^ Call( _5776 = <i32 /*- */>::overflowing_rem( _281, +514028095 i32, ), bb1329, bb399)
	var2062 = -var5776._0;	// _2062 = UniOp(_5776.0 NEG)
	var5778 = var2061 * var2062;	// _5778 = BinOp(_2061 MUL _2062)
	__builtin_sub_overflow(var5777, var5778, &var2063);
	// ^ Call( _2063 = "overflowing_sub"::<i32,>( _5777, _5778, ), bb1330, bb399)
	var2064 = -var140;	// _2064 = UniOp(_140 NEG)
	var5779 = 92;	// _5779 = Constant(+92 i8)
	var2066 = -var21;	// _2066 = UniOp(_21 NEG)
	__builtin_add_overflow(-13, -92, &var2067);
	// ^ Call( _2067 = "overflowing_add"::<i8,>( -13 i8, -92 i8, ), bb1331, bb399)
	var5780 = var2066 * var2067;	// _5780 = BinOp(_2066 MUL _2067)
	__builtin_sub_overflow(var5779, var5780, &var2068);
	// ^ Call( _2068 = "overflowing_sub"::<i8,>( _5779, _5780, ), bb1332, bb399)
	var2065 = var80 / var2068;	// _2065 = BinOp(_80 DIV _2068)
	var282 = var2064 & var2065;	// _282 = BinOp(_2064 BIT_AND _2065)
	__builtin_sub_overflow(var126, 0x9b, &var2072);
	// ^ Call( _2072 = "overflowing_sub"::<u8,>( _126, 0x9b u8, ), bb1333, bb399)
	var2071 = 0xb6 & var2072;	// _2071 = BinOp(0xb6 u8 BIT_AND _2072)
	var2070 = var126 & var2071;	// _2070 = BinOp(_126 BIT_AND _2071)
	var2069 = var2070 + 0xf4;	// _2069 = BinOp(_2070 ADD 0xf4 u8)
	var5781 = var201 ^ 0xa7;	// _5781 = BinOp(_201 BIT_XOR 0xa7 u8)
	__builtin_add_overflow(0x6b, var5781, &var5785);
	// ^ Call( _5785 = "overflowing_add"::<u8,>( 0x6b u8, _5781, ), bb1334, bb399)
	__builtin_mul_overflow(var209, 0xc2da545d, &var5784);
	// ^ Call( _5784 = "overflowing_mul"::<u32,>( _209, 0xc2da545d u32, ), bb1335, bb399)
	var5782 = var5784 & 0x7;	// _5782 = BinOp(_5784 BIT_AND 0x7 u32)
	var5783 = (uint8_t )var5782;	// _5783 = Cast(_5782 as u8)
	var5786 = var120 >> var5783;
	// ^ Call( _5786 = "unchecked_shr"::<u8,>( _120, _5783, ), bb1336, bb399)
	var2074 = var5785 / var5786;	// _2074 = BinOp(_5785 DIV _5786)
	var2076 = var129 << 0x3;
	// ^ Call( _2076 = "unchecked_shl"::<u8,>( _129, 0x3 u8, ), bb1337, bb399)
	var2078 = var63 % 0x64;	// _2078 = BinOp(_63 MOD 0x64 u8)
	var2077 = 0x14 / var2078;	// _2077 = BinOp(0x14 u8 DIV _2078)
	var2075 = var2076 * var2077;	// _2075 = BinOp(_2076 MUL _2077)
	var2073 = var2074 & var2075;	// _2073 = BinOp(_2074 BIT_AND _2075)
	var283 = var2069 & var2073;	// _283 = BinOp(_2069 BIT_AND _2073)
	var2080 = 0x6ae7b5e4a3127f0full & var27;	// _2080 = BinOp(0x6ae7b5e4a3127f0f usize BIT_AND _27)
	var5792 = var267 % 0x80936c51a81f0d35ull;	// _5792 = BinOp(_267 MOD 0x80936c51a81f0d35 usize)
	var5788 = 0x13dd8b6b / var108;	// _5788 = BinOp(0x13dd8b6b u32 DIV _108)
	var5789 = var193 * var261;	// _5789 = BinOp(_193 MUL _261)
	var5787 = var5789 & 0x1f;	// _5787 = BinOp(_5789 BIT_AND 0x1f u32)
	var5793 = var5788 >> var5787;
	// ^ Call( _5793 = "unchecked_shr"::<u32,>( _5788, _5787, ), bb1338, bb399)
	var5790 = var5793 & 0x3f;	// _5790 = BinOp(_5793 BIT_AND 0x3f u32)
	var5791 = (uintptr_t )var5790;	// _5791 = Cast(_5790 as usize)
	var2081 = var5792 >> var5791;
	// ^ Call( _2081 = "unchecked_shr"::<usize,>( _5792, _5791, ), bb1339, bb399)
	var2079 = var2080 & var2081;	// _2079 = BinOp(_2080 BIT_AND _2081)
	var284 = 0x47370ba980693accull * var2079;	// _284 = BinOp(0x47370ba980693acc usize MUL _2079)
	__builtin_sub_overflow(var168, var22, &var5794);
	// ^ Call( _5794 = "overflowing_sub"::<u32,>( _168, _22, ), bb1340, bb399)
	__builtin_sub_overflow(var5794, 0xb8baa8f0, &var285);
	// ^ Call( _285 = "overflowing_sub"::<u32,>( _5794, 0xb8baa8f0 u32, ), bb1341, bb399)
	__builtin_add_overflow(var91, var19, &var2082);
	// ^ Call( _2082 = "overflowing_add"::<i8,>( _91, _19, ), bb1342, bb399)
	var5795 = 0x242e;	// _5795 = Constant(0x242e u32)
	__builtin_sub_overflow(var67, 0x7ccd6038, &var2084);
	// ^ Call( _2084 = "overflowing_sub"::<u32,>( _67, 0x7ccd6038 u32, ), bb1343, bb399)
	var2083 = var2084 & 0x77ef5f7f;	// _2083 = BinOp(_2084 BIT_AND 0x77ef5f7f u32)
	__builtin_mul_overflow(0x461c5a69, 0xd5eb1e05, &var2085);
	// ^ Call( _2085 = "overflowing_mul"::<u32,>( 0x461c5a69 u32, 0xd5eb1e05 u32, ), bb1344, bb399)
	var5796 = var2083 / var2085;	// _5796 = BinOp(_2083 DIV _2085)
	__builtin_sub_overflow(var5795, var5796, &var5799);
	// ^ Call( _5799 = "overflowing_sub"::<u32,>( _5795, _5796, ), bb1345, bb399)
	var5797 = var5799 & 0x3f;	// _5797 = BinOp(_5799 BIT_AND 0x3f u32)
	var5798 = (intptr_t )var5797;	// _5798 = Cast(_5797 as isize)
	var2086 = var109 << var5798;
	// ^ Call( _2086 = "unchecked_shl"::<isize,>( _109, _5798, ), bb1346, bb399)
	var2087 = -var70;	// _2087 = UniOp(_70 NEG)
	var2088 = -var2087;	// _2088 = UniOp(_2087 NEG)
	var5800 = -var2088;	// _5800 = UniOp(_2088 NEG)
	__builtin_mul_overflow(var5800, 32634, &var5801);
	// ^ Call( _5801 = "overflowing_mul"::<i16,>( _5800, +32634 i16, ), bb1347, bb399)
	var2089 = var210 / var60;	// _2089 = BinOp(_210 DIV _60)
	var2090 = -var2089;	// _2090 = UniOp(_2089 NEG)
	var5802 = -var2090;	// _5802 = UniOp(_2090 NEG)
	__builtin_mul_overflow(var5801, var5802, &var286);
	// ^ Call( _286 = "overflowing_mul"::<i16,>( _5801, _5802, ), bb1348, bb399)
	var5809 = (int8_t )var254;	// _5809 = Cast(_254 as i8)
	var5804 = var61 / 0xe45cbb70;	// _5804 = BinOp(_61 DIV 0xe45cbb70 u32)
	var5805 = var49 >> 0x6;
	// ^ Call( _5805 = "unchecked_shr"::<u32,>( _49, 0x6 u32, ), bb1349, bb399)
	var5803 = var5805 & 0x1f;	// _5803 = BinOp(_5805 BIT_AND 0x1f u32)
	var5806 = var5804 << var5803;
	// ^ Call( _5806 = "unchecked_shl"::<u32,>( _5804, _5803, ), bb1350, bb399)
	var5810 = var5806 >> 0x0;
	// ^ Call( _5810 = "unchecked_shr"::<u32,>( _5806, 0x0 u32, ), bb1351, bb399)
	var5807 = var5810 & 0x7;	// _5807 = BinOp(_5810 BIT_AND 0x7 u32)
	var5808 = (int8_t )var5807;	// _5808 = Cast(_5807 as i8)
	var2091 = var5809 << var5808;
	// ^ Call( _2091 = "unchecked_shl"::<i8,>( _5809, _5808, ), bb1352, bb399)
	var5811 = -var84;	// _5811 = UniOp(_84 NEG)
	__builtin_sub_overflow(var5811, -1798054103, &var2092);
	// ^ Call( _2092 = "overflowing_sub"::<i32,>( _5811, -1798054103 i32, ), bb1353, bb399)
	var5812 = var163 & 0x1f;	// _5812 = BinOp(_163 BIT_AND 0x1f u32)
	var5813 = (int32_t )var5812;	// _5813 = Cast(_5812 as i32)
	var2093 = var56 << var5813;
	// ^ Call( _2093 = "unchecked_shl"::<i32,>( _56, _5813, ), bb1354, bb399)
	__builtin_add_overflow(0x1, 0x65afbc21, &var5814);
	// ^ Call( _5814 = "overflowing_add"::<u32,>( 0x1 u32, 0x65afbc21 u32, ), bb1355, bb399)
	__builtin_mul_overflow(var5814, var95, &var5817);
	// ^ Call( _5817 = "overflowing_mul"::<u32,>( _5814, _95, ), bb1356, bb399)
	var5815 = var5817 & 0xf;	// _5815 = BinOp(_5817 BIT_AND 0xf u32)
	var5816 = (uint16_t )var5815;	// _5816 = Cast(_5815 as u16)
	var2094 = var278 << var5816;
	// ^ Call( _2094 = "unchecked_shl"::<u16,>( _278, _5816, ), bb1357, bb399)
	__builtin_sub_overflow(77, 127, &var287);
	// ^ Call( _287 = "overflowing_sub"::<i8,>( +77 i8, +127 i8, ), bb1358, bb399)
	__builtin_add_overflow(var11, 0x5789, &var5818);
	// ^ Call( _5818 = "overflowing_add"::<u16,>( _11, 0x5789 u16, ), bb1359, bb399)
	var5821 = var5818 / 0x31dc;	// _5821 = BinOp(_5818 DIV 0x31dc u16)
	var5819 = var260 & 0xf;	// _5819 = BinOp(_260 BIT_AND 0xf u32)
	var5820 = (uint16_t )var5819;	// _5820 = Cast(_5819 as u16)
	var2095 = var124 >> var5820;
	// ^ Call( _2095 = "unchecked_shr"::<u16,>( _124, _5820, ), bb1360, bb399)
	var5822 = var39 | var2095;	// _5822 = BinOp(_39 BIT_OR _2095)
	__builtin_mul_overflow(var5821, var5822, &var2096);
	// ^ Call( _2096 = "overflowing_mul"::<u16,>( _5821, _5822, ), bb1361, bb399)
	var5827 = var39 + var2096;	// _5827 = BinOp(_39 ADD _2096)
	var5823 = (uint32_t )var200;	// _5823 = Cast(_200 as u32)
	__builtin_mul_overflow(0xec861111, var51, &var2097);
	// ^ Call( _2097 = "overflowing_mul"::<u32,>( 0xec861111 u32, _51, ), bb1362, bb399)
	var5824 = var209 ^ var2097;	// _5824 = BinOp(_209 BIT_XOR _2097)
	var5828 = var5823 % var5824;	// _5828 = BinOp(_5823 MOD _5824)
	var5825 = var5828 & 0xf;	// _5825 = BinOp(_5828 BIT_AND 0xf u32)
	var5826 = (uint16_t )var5825;	// _5826 = Cast(_5825 as u16)
	var2098 = var5827 >> var5826;
	// ^ Call( _2098 = "unchecked_shr"::<u16,>( _5827, _5826, ), bb1363, bb399)
	var5829 = var214 ^ var153;	// _5829 = BinOp(_214 BIT_XOR _153)
	var5830 = var236 * var134;	// _5830 = BinOp(_236 MUL _134)
	__builtin_mul_overflow(var5829, var5830, &var2100);
	// ^ Call( _2100 = "overflowing_mul"::<u16,>( _5829, _5830, ), bb1364, bb399)
	var2102 = var23 / var222;	// _2102 = BinOp(_23 DIV _222)
	var2103 = var46 & 0xeda7;	// _2103 = BinOp(_46 BIT_AND 0xeda7 u16)
	var2101 = var2102 * var2103;	// _2101 = BinOp(_2102 MUL _2103)
	var2099 = var2100 * var2101;	// _2099 = BinOp(_2100 MUL _2101)
	var2106 = 0x5615;	// _2106 = Constant(0x5615 u16)
	__builtin_sub_overflow(var134, var279, &var2107);
	// ^ Call( _2107 = "overflowing_sub"::<u16,>( _134, _279, ), bb1365, bb399)
	var2105 = var2106 + var2107;	// _2105 = BinOp(_2106 ADD _2107)
	var2109 = var166 ^ var124;	// _2109 = BinOp(_166 BIT_XOR _124)
	var2108 = 0x759 + var2109;	// _2108 = BinOp(0x759 u16 ADD _2109)
	var2104 = var2105 / var2108;	// _2104 = BinOp(_2105 DIV _2108)
	var5840 = var2099 & var2104;	// _5840 = BinOp(_2099 BIT_AND _2104)
	var2111 = 0xd28d | var135;	// _2111 = BinOp(0xd28d u16 BIT_OR _135)
	var2110 = var2111 | 0xc37a;	// _2110 = BinOp(_2111 BIT_OR 0xc37a u16)
	var5833 = var149 / 0xfa1c;	// _5833 = BinOp(_149 DIV 0xfa1c u16)
	var5834 = var208 % var209;	// _5834 = BinOp(_208 MOD _209)
	var5831 = var5834 & 0xf;	// _5831 = BinOp(_5834 BIT_AND 0xf u32)
	var5832 = (uint16_t )var5831;	// _5832 = Cast(_5831 as u16)
	var5838 = var5833 >> var5832;
	// ^ Call( _5838 = "unchecked_shr"::<u16,>( _5833, _5832, ), bb1366, bb399)
	var5835 = 0x58c49421 / var47;	// _5835 = BinOp(0x58c49421 u32 DIV _47)
	__builtin_add_overflow(0x33397c32, var5835, &var5839);
	// ^ Call( _5839 = "overflowing_add"::<u32,>( 0x33397c32 u32, _5835, ), bb1367, bb399)
	var5836 = var5839 & 0xf;	// _5836 = BinOp(_5839 BIT_AND 0xf u32)
	var5837 = (uint16_t )var5836;	// _5837 = Cast(_5836 as u16)
	var2112 = var5838 << var5837;
	// ^ Call( _2112 = "unchecked_shl"::<u16,>( _5838, _5837, ), bb1368, bb399)
	var5841 = var2110 + var2112;	// _5841 = BinOp(_2110 ADD _2112)
	var288 = var5840 / var5841;	// _288 = BinOp(_5840 DIV _5841)
	var5842 = -var148;	// _5842 = UniOp(_148 NEG)
	var2113 = -var195;	// _2113 = UniOp(_195 NEG)
	var2114 = -var2113;	// _2114 = UniOp(_2113 NEG)
	__builtin_add_overflow(-8745983510242974869ll, -4544674427949937267ll, &var2115);
	// ^ Call( _2115 = "overflowing_add"::<i64,>( -8745983510242974869 i64, -4544674427949937267 i64, ), bb1369, bb399)
	var2116 = -var2115;	// _2116 = UniOp(_2115 NEG)
	var5843 = var2114 | var2116;	// _5843 = BinOp(_2114 BIT_OR _2116)
	__builtin_sub_overflow(var5842, var5843, &var2117);
	// ^ Call( _2117 = "overflowing_sub"::<i64,>( _5842, _5843, ), bb1370, bb399)
	var289 = var76;	// _289 = Use(_76)
	var290 = 8065;	// _290 = Constant(+13583968662754303873 i16)
	var291 = -10991;	// _291 = Constant(-10991 i16)
	var2119 = var155 / 0xf9813d606e110f69ull;	// _2119 = BinOp(_155 DIV 0xf9813d606e110f69 u64)
	var2120 = var137 | 0xb5722d58f47c86ffull;	// _2120 = BinOp(_137 BIT_OR 0xb5722d58f47c86ff u64)
	var2118 = var2119 / var2120;	// _2118 = BinOp(_2119 DIV _2120)
	var5851 = (uint16_t )var2118;	// _5851 = Cast(_2118 as u16)
	var2121 = var183 + var139;	// _2121 = BinOp(_183 ADD _139)
	var5847 = (uint32_t )var2121;	// _5847 = Cast(_2121 as u32)
	var5844 = 0x19;	// _5844 = Constant(0x19 u32)
	__builtin_sub_overflow(var108, var243, &var5845);
	// ^ Call( _5845 = "overflowing_sub"::<u32,>( _108, _243, ), bb1371, bb399)
	__builtin_sub_overflow(var5844, var5845, &var5848);
	// ^ Call( _5848 = "overflowing_sub"::<u32,>( _5844, _5845, ), bb1372, bb399)
	var5846 = var5848 & 0x1f;	// _5846 = BinOp(_5848 BIT_AND 0x1f u32)
	var5852 = var5847 << var5846;
	// ^ Call( _5852 = "unchecked_shl"::<u32,>( _5847, _5846, ), bb1373, bb399)
	var5849 = var5852 & 0xf;	// _5849 = BinOp(_5852 BIT_AND 0xf u32)
	var5850 = (uint16_t )var5849;	// _5850 = Cast(_5849 as u16)
	var2122 = var5851 << var5850;
	// ^ Call( _2122 = "unchecked_shl"::<u16,>( _5851, _5850, ), bb1374, bb399)
	var5853 = var11 / 0xc645;	// _5853 = BinOp(_11 DIV 0xc645 u16)
	var5854 = 0x8211 & var213;	// _5854 = BinOp(0x8211 u16 BIT_AND _213)
	__builtin_sub_overflow(var5853, var5854, &var2123);
	// ^ Call( _2123 = "overflowing_sub"::<u16,>( _5853, _5854, ), bb1375, bb399)
	var292 = make128_raw(4385843232430130629ull, 12547307914963535197ull);	// _292 = Constant(0x3cdda52ec58c85c5ae20fe11f6d9455d u128)
	var2124 = div128s(var250, make128s_raw(6726577497712839842ull, 12138706825784274558ull));	// _2124 = BinOp(_250 DIV +124083453592282353357201845105624559230 i128)
	var2125 = var2124.lo;	// _2125 = Cast(_2124 as i16)
	var5855 = -var2125;	// _5855 = UniOp(_2125 NEG)
	__builtin_sub_overflow(var75, var142, &var2127);
	// ^ Call( _2127 = "overflowing_sub"::<i16,>( _75, _142, ), bb1376, bb399)
	var2126 = var2127 & -2893;	// _2126 = BinOp(_2127 BIT_AND -2893 i16)
	var5856 = -var2126;	// _5856 = UniOp(_2126 NEG)
	__builtin_add_overflow(var5855, var5856, &var2128);
	// ^ Call( _2128 = "overflowing_add"::<i16,>( _5855, _5856, ), bb1377, bb399)
	var293 = -var2128;	// _293 = UniOp(_2128 NEG)
	var2129 = var90 / var230;	// _2129 = BinOp(_90 DIV _230)
	var2130 = -var2129;	// _2130 = UniOp(_2129 NEG)
	var5859 = (uint32_t )var2130;	// _5859 = Cast(_2130 as u32)
	var5857 = var5859 & 0x7;	// _5857 = BinOp(_5859 BIT_AND 0x7 u32)
	var5858 = (uint8_t )var5857;	// _5858 = Cast(_5857 as u8)
	var5860 = 0xb9 >> var5858;
	// ^ Call( _5860 = "unchecked_shr"::<u8,>( 0xb9 u8, _5858, ), bb1378, bb399)
	__builtin_add_overflow(var54, var259, &var5861);
	// ^ Call( _5861 = "overflowing_add"::<u8,>( _54, _259, ), bb1379, bb399)
	__builtin_sub_overflow(var5860, var5861, &var2131);
	// ^ Call( _2131 = "overflowing_sub"::<u8,>( _5860, _5861, ), bb1380, bb399)
	__builtin_add_overflow(var218, -21, &var2132);
	// ^ Call( _2132 = "overflowing_add"::<i8,>( _218, -21 i8, ), bb1381, bb399)
	var5863 = 52 - var2132;	// _5863 = BinOp(+52 i8 SUB _2132)
	var2133 = var80 ^ -13;	// _2133 = BinOp(_80 BIT_XOR -13 i8)
	var5864 = var2133 | -93;	// _5864 = BinOp(_2133 BIT_OR -93 i8)
	var5862 = ZRICb15overflowing_rem0g( var5863, var5864 );
	// ^ Call( _5862 = <i8 /*- */>::overflowing_rem( _5863, _5864, ), bb1382, bb399)
	var2134 = -var5862._0;	// _2134 = UniOp(_5862.0 NEG)
	var5865 = var164 | 3487461146917812249ll;	// _5865 = BinOp(_164 BIT_OR +3487461146917812249 i64)
	__builtin_mul_overflow(var195, var5865, &var2136);
	// ^ Call( _2136 = "overflowing_mul"::<i64,>( _195, _5865, ), bb1383, bb399)
	var2138 = 636385737388061934ll;	// _2138 = Constant(+636385737388061934 i64)
	var5866 = ZRICh15overflowing_div0g( 236136493423090872ll, var183 );
	// ^ Call( _5866 = <i64 /*- */>::overflowing_div( +236136493423090872 i64, _183, ), bb1384, bb399)
	var2137 = var2138 | var5866._0;	// _2137 = BinOp(_2138 BIT_OR _5866.0)
	var2135 = var2136 / var2137;	// _2135 = BinOp(_2136 DIV _2137)
	var2139 = (int8_t )var2135;	// _2139 = Cast(_2135 as i8)
	var294 = var2134 / var2139;	// _294 = BinOp(_2134 DIV _2139)
	var5867 = (uint32_t )var109;	// _5867 = Cast(_109 as u32)
	var5869 = var5867 / 0x6406ddd5;	// _5869 = BinOp(_5867 DIV 0x6406ddd5 u32)
	var5868 = ZRICd15overflowing_rem0g( 17187, -28615 );
	// ^ Call( _5868 = <i16 /*- */>::overflowing_rem( +17187 i16, -28615 i16, ), bb1385, bb399)
	var2140 = -var5868._0;	// _2140 = UniOp(_5868.0 NEG)
	var2141 = (uint32_t )var2140;	// _2141 = Cast(_2140 as u32)
	var5870 = var2141 - 0xdcafcec9;	// _5870 = BinOp(_2141 SUB 0xdcafcec9 u32)
	__builtin_add_overflow(var5869, var5870, &var295);
	// ^ Call( _295 = "overflowing_add"::<u32,>( _5869, _5870, ), bb1386, bb399)
	var2142 = -var255;	// _2142 = UniOp(_255 NEG)
	var2143 = -var2142;	// _2143 = UniOp(_2142 NEG)
	var5871 = -var2143;	// _5871 = UniOp(_2143 NEG)
	var5872 = -var142;	// _5872 = UniOp(_142 NEG)
	__builtin_sub_overflow(var5871, var5872, &var2144);
	// ^ Call( _2144 = "overflowing_sub"::<i16,>( _5871, _5872, ), bb1387, bb399)
	var296 = var2144 - var38;	// _296 = BinOp(_2144 SUB _38)
	var2146 = 0x95 ^ var78;	// _2146 = BinOp(0x95 u8 BIT_XOR _78)
	var2145 = var2146 - 0x3f;	// _2145 = BinOp(_2146 SUB 0x3f u8)
	var5876 = var2145 / 0xe7;	// _5876 = BinOp(_2145 DIV 0xe7 u8)
	var2147 = var31 - 0x23fd413f70d6dc2eull;	// _2147 = BinOp(_31 SUB 0x23fd413f70d6dc2e u64)
	var2148 = (uint32_t )var2147;	// _2148 = Cast(_2147 as u32)
	var5873 = var2 / 0x1ec403df;	// _5873 = BinOp(_2 DIV 0x1ec403df u32)
	__builtin_sub_overflow(var5873, 0x3a6a8053, &var2149);
	// ^ Call( _2149 = "overflowing_sub"::<u32,>( _5873, 0x3a6a8053 u32, ), bb1388, bb399)
	var5877 = var2148 / var2149;	// _5877 = BinOp(_2148 DIV _2149)
	var5874 = var5877 & 0x7;	// _5874 = BinOp(_5877 BIT_AND 0x7 u32)
	var5875 = (uint8_t )var5874;	// _5875 = Cast(_5874 as u8)
	var5884 = var5876 << var5875;
	// ^ Call( _5884 = "unchecked_shl"::<u8,>( _5876, _5875, ), bb1389, bb399)
	var5878 = 0x9ec192ab % var79;	// _5878 = BinOp(0x9ec192ab u32 MOD _79)
	__builtin_add_overflow(0x2b079b44, var5878, &var5881);
	// ^ Call( _5881 = "overflowing_add"::<u32,>( 0x2b079b44 u32, _5878, ), bb1390, bb399)
	var5879 = var5881 & 0x7;	// _5879 = BinOp(_5881 BIT_AND 0x7 u32)
	var5880 = (uint8_t )var5879;	// _5880 = Cast(_5879 as u8)
	var2150 = var202 >> var5880;
	// ^ Call( _2150 = "unchecked_shr"::<u8,>( _202, _5880, ), bb1391, bb399)
	var5882 = var283 % 0x84;	// _5882 = BinOp(_283 MOD 0x84 u8)
	__builtin_mul_overflow(var130, var5882, &var5883);
	// ^ Call( _5883 = "overflowing_mul"::<u8,>( _130, _5882, ), bb1392, bb399)
	__builtin_add_overflow(0x60, var5883, &var2151);
	// ^ Call( _2151 = "overflowing_add"::<u8,>( 0x60 u8, _5883, ), bb1393, bb399)
	var5885 = var2150 ^ var2151;	// _5885 = BinOp(_2150 BIT_XOR _2151)
	var297 = var5884 / var5885;	// _297 = BinOp(_5884 DIV _5885)
	var2153 = var245 << 26ll;
	// ^ Call( _2153 = "unchecked_shl"::<isize,>( _245, +26 isize, ), bb1394, bb399)
	var5886 = -var2153;	// _5886 = UniOp(_2153 NEG)
	var2154 = var5886 >> 20ll;
	// ^ Call( _2154 = "unchecked_shr"::<isize,>( _5886, +20 isize, ), bb1395, bb399)
	var2157 = -var262;	// _2157 = UniOp(_262 NEG)
	var2156 = var2157 - var239;	// _2156 = BinOp(_2157 SUB _239)
	var2159 = 7214405425217767204ll * var228;	// _2159 = BinOp(+7214405425217767204 isize MUL _228)
	var2158 = var2159 * var228;	// _2158 = BinOp(_2159 MUL _228)
	var2155 = var2156 & var2158;	// _2155 = BinOp(_2156 BIT_AND _2158)
	var2152 = var2154 * var2155;	// _2152 = BinOp(_2154 MUL _2155)
	var298 = -var2152;	// _298 = UniOp(_2152 NEG)
	var5887 = ZRICd15overflowing_div0g( 26094, 11160 );
	// ^ Call( _5887 = <i16 /*- */>::overflowing_div( +26094 i16, +11160 i16, ), bb1396, bb399)
	var5888 = ZRICd15overflowing_div0g( var5887._0, 22496 );
	// ^ Call( _5888 = <i16 /*- */>::overflowing_div( _5887.0, +22496 i16, ), bb1397, bb399)
	var5889 = 0x286 | var191;	// _5889 = BinOp(0x286 u16 BIT_OR _191)
	var5890 = 0x5fd6 % var5889;	// _5890 = BinOp(0x5fd6 u16 MOD _5889)
	__builtin_add_overflow(0x0, var258, &var5891);
	// ^ Call( _5891 = "overflowing_add"::<u16,>( 0x0 u16, _258, ), bb1398, bb399)
	var2160 = var5890 / var5891;	// _2160 = BinOp(_5890 DIV _5891)
	var5892 = mul128(var132, var292);	// _5892 = BinOp(_132 MUL _292)
	var5893 = mul128(var132, var9);	// _5893 = BinOp(_132 MUL _9)
	sub128_o(var5892, var5893, &var2162);
	// ^ Call( _2162 = "overflowing_sub"::<u128,>( _5892, _5893, ), bb1399, bb399)
	var2161 = div128(var2162, make128_raw(17727251397540123858ull, 10396186617906807796ull));	// _2161 = BinOp(_2162 DIV 0xf603d9391a6d14d29046aca5cb0143f4 u128)
	var2163 = var2161.lo;	// _2163 = Cast(_2161 as u16)
	var299 = var2160 + var2163;	// _299 = BinOp(_2160 ADD _2163)
	__builtin_sub_overflow(var69, var175, &var5894);
	// ^ Call( _5894 = "overflowing_sub"::<u8,>( _69, _175, ), bb1400, bb399)
	var2164 = 0x8a / var5894;	// _2164 = BinOp(0x8a u8 DIV _5894)
	var5899 = (uint16_t )var2164;	// _5899 = Cast(_2164 as u16)
	var2165 = 0x9627a760 | var225;	// _2165 = BinOp(0x9627a760 u32 BIT_OR _225)
	var5895 = var47 & 0x1f;	// _5895 = BinOp(_47 BIT_AND 0x1f u32)
	var2166 = 0xd42438e1 >> var5895;
	// ^ Call( _2166 = "unchecked_shr"::<u32,>( 0xd42438e1 u32, _5895, ), bb1401, bb399)
	var5896 = var2165 / var2166;	// _5896 = BinOp(_2165 DIV _2166)
	__builtin_sub_overflow(var5896, 0xd209322b, &var5900);
	// ^ Call( _5900 = "overflowing_sub"::<u32,>( _5896, 0xd209322b u32, ), bb1402, bb399)
	var5897 = var5900 & 0xf;	// _5897 = BinOp(_5900 BIT_AND 0xf u32)
	var5898 = (uint16_t )var5897;	// _5898 = Cast(_5897 as u16)
	var2167 = var5899 >> var5898;
	// ^ Call( _2167 = "unchecked_shr"::<u16,>( _5899, _5898, ), bb1403, bb399)
	__builtin_sub_overflow(0x488034fa, 0x6dc35ec8, &var2168);
	// ^ Call( _2168 = "overflowing_sub"::<u32,>( 0x488034fa u32, 0x6dc35ec8 u32, ), bb1404, bb399)
	var5903 = var2168 + var209;	// _5903 = BinOp(_2168 ADD _209)
	var5901 = var5903 & 0xf;	// _5901 = BinOp(_5903 BIT_AND 0xf u32)
	var5902 = (uint16_t )var5901;	// _5902 = Cast(_5901 as u16)
	var5910 = var106 >> var5902;
	// ^ Call( _5910 = "unchecked_shr"::<u16,>( _106, _5902, ), bb1405, bb399)
	var5906 = var26 - 403786679;	// _5906 = BinOp(_26 SUB +403786679 i32)
	__builtin_mul_overflow(0x8a6e7abc, 0xf0f19413, &var5907);
	// ^ Call( _5907 = "overflowing_mul"::<u32,>( 0x8a6e7abc u32, 0xf0f19413 u32, ), bb1406, bb399)
	var5904 = var5907 & 0x1f;	// _5904 = BinOp(_5907 BIT_AND 0x1f u32)
	var5905 = (int32_t )var5904;	// _5905 = Cast(_5904 as i32)
	var2169 = var5906 << var5905;
	// ^ Call( _2169 = "unchecked_shl"::<i32,>( _5906, _5905, ), bb1407, bb399)
	var5911 = (uint32_t )var2169;	// _5911 = Cast(_2169 as u32)
	var5908 = var5911 & 0xf;	// _5908 = BinOp(_5911 BIT_AND 0xf u32)
	var5909 = (uint16_t )var5908;	// _5909 = Cast(_5908 as u16)
	var2170 = var5910 >> var5909;
	// ^ Call( _2170 = "unchecked_shr"::<u16,>( _5910, _5909, ), bb1408, bb399)
	var5913 = var146 - var146;	// _5913 = BinOp(_146 SUB _146)
	var5912 = ZRICb15overflowing_rem0g( var5913, -24 );
	// ^ Call( _5912 = <i8 /*- */>::overflowing_rem( _5913, -24 i8, ), bb1409, bb399)
	__builtin_sub_overflow(var202, var129, &var2171);
	// ^ Call( _2171 = "overflowing_sub"::<u8,>( _202, _129, ), bb1410, bb399)
	var5914 = 0x95 | var2171;	// _5914 = BinOp(0x95 u8 BIT_OR _2171)
	__builtin_sub_overflow(var178, var5914, &var5915);
	// ^ Call( _5915 = "overflowing_sub"::<u8,>( _178, _5914, ), bb1411, bb399)
	var2172 = (uint8_t )var206;	// _2172 = Cast(_206 as u8)
	var5916 = var2172 - var118;	// _5916 = BinOp(_2172 SUB _118)
	__builtin_mul_overflow(var5915, var5916, &var5922);
	// ^ Call( _5922 = "overflowing_mul"::<u8,>( _5915, _5916, ), bb1412, bb399)
	var5917 = var127 - var168;	// _5917 = BinOp(_127 SUB _168)
	__builtin_sub_overflow(var260, var243, &var5918);
	// ^ Call( _5918 = "overflowing_sub"::<u32,>( _260, _243, ), bb1413, bb399)
	__builtin_add_overflow(var5917, var5918, &var5919);
	// ^ Call( _5919 = "overflowing_add"::<u32,>( _5917, _5918, ), bb1414, bb399)
	__builtin_mul_overflow(var5919, 0xb0, &var2173);
	// ^ Call( _2173 = "overflowing_mul"::<u32,>( _5919, 0xb0 u32, ), bb1415, bb399)
	var5923 = var2173 & 0x4581ecc7;	// _5923 = BinOp(_2173 BIT_AND 0x4581ecc7 u32)
	var5920 = var5923 & 0x7;	// _5920 = BinOp(_5923 BIT_AND 0x7 u32)
	var5921 = (uint8_t )var5920;	// _5921 = Cast(_5920 as u8)
	var300 = var5922 >> var5921;
	// ^ Call( _300 = "unchecked_shr"::<u8,>( _5922, _5921, ), bb1416, bb399)
	var301 = var2;	// _301 = Use(_2)
	var2175 = -var50;	// _2175 = UniOp(_50 NEG)
	var5925 = var2175 & -4779;	// _5925 = BinOp(_2175 BIT_AND -4779 i16)
	var5926 = -11467 >> 12;
	// ^ Call( _5926 = "unchecked_shr"::<i16,>( -11467 i16, +12 i16, ), bb1417, bb399)
	var5924 = ZRICd15overflowing_div0g( var5925, var5926 );
	// ^ Call( _5924 = <i16 /*- */>::overflowing_div( _5925, _5926, ), bb1418, bb399)
	var2174 = var5924._0 + var272;	// _2174 = BinOp(_5924.0 ADD _272)
	__builtin_mul_overflow(19003, -3337, &var2178);
	// ^ Call( _2178 = "overflowing_mul"::<i16,>( +19003 i16, -3337 i16, ), bb1419, bb399)
	var2180 = -var293;	// _2180 = UniOp(_293 NEG)
	var2179 = var2180 - -18429;	// _2179 = BinOp(_2180 SUB -18429 i16)
	var2177 = var2178 + var2179;	// _2177 = BinOp(_2178 ADD _2179)
	var2176 = var2177 | -18681;	// _2176 = BinOp(_2177 BIT_OR -18681 i16)
	var302 = var2174 / var2176;	// _302 = BinOp(_2174 DIV _2176)
	var303 = var186;	// _303 = Use(_186)
	var5927 = ZRICb15overflowing_rem0g( -9, -47 );
	// ^ Call( _5927 = <i8 /*- */>::overflowing_rem( -9 i8, -47 i8, ), bb1420, bb399)
	var2181 = -var5927._0;	// _2181 = UniOp(_5927.0 NEG)
	var5932 = -var2181;	// _5932 = UniOp(_2181 NEG)
	var2182 = 10 * var264;	// _2182 = BinOp(+10 i8 MUL _264)
	var5930 = -var2182;	// _5930 = UniOp(_2182 NEG)
	var2183 = (uint32_t )var281;	// _2183 = Cast(_281 as u32)
	var5931 = 0xadac235b - var2183;	// _5931 = BinOp(0xadac235b u32 SUB _2183)
	var5928 = var5931 & 0x7;	// _5928 = BinOp(_5931 BIT_AND 0x7 u32)
	var5929 = (int8_t )var5928;	// _5929 = Cast(_5928 as i8)
	var5933 = var5930 << var5929;
	// ^ Call( _5933 = "unchecked_shl"::<i8,>( _5930, _5929, ), bb1421, bb399)
	__builtin_sub_overflow(var5932, var5933, &var5935);
	// ^ Call( _5935 = "overflowing_sub"::<i8,>( _5932, _5933, ), bb1422, bb399)
	var5934 = ZRICb15overflowing_div0g( 18, var5935 );
	// ^ Call( _5934 = <i8 /*- */>::overflowing_div( +18 i8, _5935, ), bb1423, bb399)
	var304 = var5934._0;	// _304 = Use(_5934.0)
	var5936 = 0xfed3 / var149;	// _5936 = BinOp(0xfed3 u16 DIV _149)
	var5937 = var5936 % 0xff76;	// _5937 = BinOp(_5936 MOD 0xff76 u16)
	__builtin_mul_overflow(var5937, var222, &var305);
	// ^ Call( _305 = "overflowing_mul"::<u16,>( _5937, _222, ), bb1424, bb399)
	var2184 = (uint32_t )var24;	// _2184 = Cast(_24 as u32)
	var2185 = var127 / var6;	// _2185 = BinOp(_127 DIV _6)
	var5938 = var2184 * var2185;	// _5938 = BinOp(_2184 MUL _2185)
	var2186 = 0x64fd13b1 / var220;	// _2186 = BinOp(0x64fd13b1 u32 DIV _220)
	var5939 = 0x0 & var2186;	// _5939 = BinOp(0x0 u32 BIT_AND _2186)
	__builtin_sub_overflow(var5938, var5939, &var2187);
	// ^ Call( _2187 = "overflowing_sub"::<u32,>( _5938, _5939, ), bb1425, bb399)
	__builtin_sub_overflow(0x43cebf34, 0x667fbf65, &var5941);
	// ^ Call( _5941 = "overflowing_sub"::<u32,>( 0x43cebf34 u32, 0x667fbf65 u32, ), bb1426, bb399)
	__builtin_add_overflow(0xdc316122, 0xe4d34f74, &var5942);
	// ^ Call( _5942 = "overflowing_add"::<u32,>( 0xdc316122 u32, 0xe4d34f74 u32, ), bb1427, bb399)
	var5940 = var5942 & 0x1f;	// _5940 = BinOp(_5942 BIT_AND 0x1f u32)
	var2189 = var5941 << var5940;
	// ^ Call( _2189 = "unchecked_shl"::<u32,>( _5941, _5940, ), bb1428, bb399)
	var2188 = var2189 - 0x8d38f113;	// _2188 = BinOp(_2189 SUB 0x8d38f113 u32)
	var5943 = var2187 + var2188;	// _5943 = BinOp(_2187 ADD _2188)
	__builtin_mul_overflow(var225, var5943, &var306);
	// ^ Call( _306 = "overflowing_mul"::<u32,>( _225, _5943, ), bb1429, bb399)
	var307 = make128s_raw(9683184518434003018ull, 16069641406044962716ull);	// _307 = Constant(-161659140290879939810268325080952471652 i128)
	var5944.lo = var89; var5944.hi = var89 < 0 ? -1 : 0;	// _5944 = Cast(_89 as u128)
	sub128_o(make128_raw(15618478553470729723ull, 16131892446817135126ull), var5944, &var5945);
	// ^ Call( _5945 = "overflowing_sub"::<u128,>( 0xd8bffb7e7fadfdfbdfdffeb5bf57aa16 u128, _5944, ), bb1430, bb399)
	sub128_o(var160, var5945, &var5946);
	// ^ Call( _5946 = "overflowing_sub"::<u128,>( _160, _5945, ), bb1431, bb399)
	var5947 = div128(make128_raw(14405884022715735663ull, 4571265884909667972ull), var5946);	// _5947 = BinOp(0xc7ebfb3169725e6f3f70661a4be70684 u128 DIV _5946)
	var308 = mod128(make128_raw(12245814390014207031ull, 13341944928484628103ull), var5947);	// _308 = BinOp(0xa9f1df4e7e29e437b9281c394b269687 u128 MOD _5947)
	var5950 = -50;	// _5950 = Constant(-50 i8)
	__builtin_add_overflow(0xc7f45c6a, 0xeb9b13b, &var5951);
	// ^ Call( _5951 = "overflowing_add"::<u32,>( 0xc7f45c6a u32, 0xeb9b13b u32, ), bb1432, bb399)
	var5948 = var5951 & 0x7;	// _5948 = BinOp(_5951 BIT_AND 0x7 u32)
	var5949 = (int8_t )var5948;	// _5949 = Cast(_5948 as i8)
	var2190 = var5950 << var5949;
	// ^ Call( _2190 = "unchecked_shl"::<i8,>( _5950, _5949, ), bb1433, bb399)
	var309 = (int32_t )var255;	// _309 = Cast(_255 as i32)
	var5952 = ZRICd15overflowing_div0g( 28171, var142 );
	// ^ Call( _5952 = <i16 /*- */>::overflowing_div( +28171 i16, _142, ), bb1434, bb399)
	var2192 = -var5952._0;	// _2192 = UniOp(_5952.0 NEG)
	var2193 = -var2192;	// _2193 = UniOp(_2192 NEG)
	var2196 = var302 << 5;
	// ^ Call( _2196 = "unchecked_shl"::<i16,>( _302, +5 i16, ), bb1435, bb399)
	var2195 = var2196 | 15457;	// _2195 = BinOp(_2196 BIT_OR +15457 i16)
	var5954 = var38 | 24239;	// _5954 = BinOp(_38 BIT_OR +24239 i16)
	var5953 = ZRICd15overflowing_rem0g( var5954, -22796 );
	// ^ Call( _5953 = <i16 /*- */>::overflowing_rem( _5954, -22796 i16, ), bb1436, bb399)
	var2194 = var2195 / var5953._0;	// _2194 = BinOp(_2195 DIV _5953.0)
	var2191 = var2193 < var2194;	// _2191 = BinOp(_2193 LT _2194)
	if(var2191) goto bb1437; else goto bb1438;
	// ^ If( _2191 : 1437, 1438)
bb1437:
	var5956 = xor128s(var48, var28);	// _5956 = BinOp(_48 BIT_XOR _28)
	var5955 = ZRICj15overflowing_rem0g( var5956, make128s_raw(145833090491886527ull, 15279516323740931205ull) );
	// ^ Call( _5955 = <i128 /*- */>::overflowing_rem( _5956, +2690145697781956566830113114862408837 i128, ), bb1438, bb399)
bb1438:
	var5959 = var47 >> 0x5;
	// ^ Call( _5959 = "unchecked_shr"::<u32,>( _47, 0x5 u32, ), bb1439, bb399)
	var5957 = var5959 & 0xf;	// _5957 = BinOp(_5959 BIT_AND 0xf u32)
	var5958 = (int16_t )var5957;	// _5958 = Cast(_5957 as i16)
	var5961 = 1466 >> var5958;
	// ^ Call( _5961 = "unchecked_shr"::<i16,>( +1466 i16, _5958, ), bb1440, bb399)
	var5960 = ZRICd15overflowing_div0g( var5961, var52 );
	// ^ Call( _5960 = <i16 /*- */>::overflowing_div( _5961, _52, ), bb1441, bb399)
	var5962 = var108 / var127;	// _5962 = BinOp(_108 DIV _127)
	var5963 = var61 / var141;	// _5963 = BinOp(_61 DIV _141)
	__builtin_add_overflow(var5962, var5963, &var5964);
	// ^ Call( _5964 = "overflowing_add"::<u32,>( _5962, _5963, ), bb1442, bb399)
	__builtin_mul_overflow(var5964, 0x6701d74b, &var5967);
	// ^ Call( _5967 = "overflowing_mul"::<u32,>( _5964, 0x6701d74b u32, ), bb1443, bb399)
	var5965 = var5967 & 0xf;	// _5965 = BinOp(_5967 BIT_AND 0xf u32)
	var5966 = (int16_t )var5965;	// _5966 = Cast(_5965 as i16)
	var5968 = var5960._0 >> var5966;
	// ^ Call( _5968 = "unchecked_shr"::<i16,>( _5960.0, _5966, ), bb1444, bb399)
	__builtin_mul_overflow(var272, var5968, &var2197);
	// ^ Call( _2197 = "overflowing_mul"::<i16,>( _272, _5968, ), bb1445, bb399)
	var310 = 15637;	// _310 = Constant(+15637 i16)
	var2201 = 0xd7f3;	// _2201 = Constant(0xd7f3 u16)
	__builtin_sub_overflow(0xd059, 0xeb66, &var2202);
	// ^ Call( _2202 = "overflowing_sub"::<u16,>( 0xd059 u16, 0xeb66 u16, ), bb1446, bb399)
	var2200 = var2201 ^ var2202;	// _2200 = BinOp(_2201 BIT_XOR _2202)
	var2199 = var153 / var2200;	// _2199 = BinOp(_153 DIV _2200)
	var2198 = 0xc2c7 - var2199;	// _2198 = BinOp(0xc2c7 u16 SUB _2199)
	var2206 = 0x7a3b % var169;	// _2206 = BinOp(0x7a3b u16 MOD _169)
	var2207 = var258 / var149;	// _2207 = BinOp(_258 DIV _149)
	var2205 = var2206 * var2207;	// _2205 = BinOp(_2206 MUL _2207)
	var2204 = var274 | var2205;	// _2204 = BinOp(_274 BIT_OR _2205)
	var5969 = var301 & 0xf;	// _5969 = BinOp(_301 BIT_AND 0xf u32)
	var5970 = (uint16_t )var5969;	// _5970 = Cast(_5969 as u16)
	var2210 = 0x4d25 << var5970;
	// ^ Call( _2210 = "unchecked_shl"::<u16,>( 0x4d25 u16, _5970, ), bb1447, bb399)
	__builtin_mul_overflow(0x1867, 0x7b5, &var2211);
	// ^ Call( _2211 = "overflowing_mul"::<u16,>( 0x1867 u16, 0x7b5 u16, ), bb1448, bb399)
	var2209 = var2210 | var2211;	// _2209 = BinOp(_2210 BIT_OR _2211)
	var5971 = var213 - var167;	// _5971 = BinOp(_213 SUB _167)
	__builtin_add_overflow(var5971, 0x6546, &var2212);
	// ^ Call( _2212 = "overflowing_add"::<u16,>( _5971, 0x6546 u16, ), bb1449, bb399)
	var2208 = var2209 & var2212;	// _2208 = BinOp(_2209 BIT_AND _2212)
	var2203 = var2204 & var2208;	// _2203 = BinOp(_2204 BIT_AND _2208)
	var311 = var2198 + var2203;	// _311 = BinOp(_2198 ADD _2203)
	var5972 = (uint64_t )var45;	// _5972 = Cast(_45 as u64)
	__builtin_sub_overflow(var5972, 0xa9536c405754d5ddull, &var5978);
	// ^ Call( _5978 = "overflowing_sub"::<u64,>( _5972, 0xa9536c405754d5dd u64, ), bb1450, bb399)
	var5974 = var306 - 0x54ab8579;	// _5974 = BinOp(_306 SUB 0x54ab8579 u32)
	__builtin_mul_overflow(0x6ef25055, var220, &var5975);
	// ^ Call( _5975 = "overflowing_mul"::<u32,>( 0x6ef25055 u32, _220, ), bb1451, bb399)
	var5973 = var5975 & 0x1f;	// _5973 = BinOp(_5975 BIT_AND 0x1f u32)
	var5979 = var5974 >> var5973;
	// ^ Call( _5979 = "unchecked_shr"::<u32,>( _5974, _5973, ), bb1452, bb399)
	var5976 = var5979 & 0x3f;	// _5976 = BinOp(_5979 BIT_AND 0x3f u32)
	var5977 = (uint64_t )var5976;	// _5977 = Cast(_5976 as u64)
	var2213 = var5978 << var5977;
	// ^ Call( _2213 = "unchecked_shl"::<u64,>( _5978, _5977, ), bb1453, bb399)
	__builtin_sub_overflow(0xe50fdf136f5d343bull, 0x66f37e750b4e2050ull, &var2214);
	// ^ Call( _2214 = "overflowing_sub"::<u64,>( 0xe50fdf136f5d343b u64, 0x66f37e750b4e2050 u64, ), bb1454, bb399)
	var5982 = (uint64_t )var96;	// _5982 = Cast(_96 as u64)
	__builtin_add_overflow(var79, var92, &var5983);
	// ^ Call( _5983 = "overflowing_add"::<u32,>( _79, _92, ), bb1455, bb399)
	var5980 = var5983 & 0x3f;	// _5980 = BinOp(_5983 BIT_AND 0x3f u32)
	var5981 = (uint64_t )var5980;	// _5981 = Cast(_5980 as u64)
	var2215 = var5982 << var5981;
	// ^ Call( _2215 = "unchecked_shl"::<u64,>( _5982, _5981, ), bb1456, bb399)
	var5986 = var74 / 0x586616dbull;	// _5986 = BinOp(_74 DIV 0x586616db u64)
	var5984 = var168 & 0x3f;	// _5984 = BinOp(_168 BIT_AND 0x3f u32)
	var5985 = (uint64_t )var5984;	// _5985 = Cast(_5984 as u64)
	var2216 = var5986 << var5985;
	// ^ Call( _2216 = "unchecked_shl"::<u64,>( _5986, _5985, ), bb1457, bb399)
	var5987 = 0xd24d78e37ee7bfe3ull >> 0x7ull;
	// ^ Call( _5987 = "unchecked_shr"::<u64,>( 0xd24d78e37ee7bfe3 u64, 0x7 u64, ), bb1458, bb399)
	__builtin_mul_overflow(var192, 0x71785220c7e9eed9ull, &var5988);
	// ^ Call( _5988 = "overflowing_mul"::<u64,>( _192, 0x71785220c7e9eed9 u64, ), bb1459, bb399)
	var5991 = var5987 % var5988;	// _5991 = BinOp(_5987 MOD _5988)
	var2217 = var51 >> 0x6;
	// ^ Call( _2217 = "unchecked_shr"::<u32,>( _51, 0x6 u32, ), bb1460, bb399)
	var5992 = 0xb1079842 & var2217;	// _5992 = BinOp(0xb1079842 u32 BIT_AND _2217)
	var5989 = var5992 & 0x3f;	// _5989 = BinOp(_5992 BIT_AND 0x3f u32)
	var5990 = (uint64_t )var5989;	// _5990 = Cast(_5989 as u64)
	var2218 = var5991 >> var5990;
	// ^ Call( _2218 = "unchecked_shr"::<u64,>( _5991, _5990, ), bb1461, bb399)
	var2220 = 0xaf72318 / var209;	// _2220 = BinOp(0xaf72318 u32 DIV _209)
	var2219 = 0x58304599 & var2220;	// _2219 = BinOp(0x58304599 u32 BIT_AND _2220)
	var2221 = (int32_t )var2219;	// _2221 = Cast(_2219 as i32)
	var5995 = -var2221;	// _5995 = UniOp(_2221 NEG)
	var5993 = ZRICf15overflowing_rem0g( 627582702, var94 );
	// ^ Call( _5993 = <i32 /*- */>::overflowing_rem( +627582702 i32, _94, ), bb1462, bb399)
	var5996 = -var5993._0;	// _5996 = UniOp(_5993.0 NEG)
	var5994 = ZRICf15overflowing_rem0g( var5995, var5996 );
	// ^ Call( _5994 = <i32 /*- */>::overflowing_rem( _5995, _5996, ), bb1463, bb399)
	var312 = var5994._0;	// _312 = Use(_5994.0)
	var5997 = var139 * -8868712262683244452ll;	// _5997 = BinOp(_139 MUL -8868712262683244452 i64)
	__builtin_mul_overflow(var195, var5997, &var5998);
	// ^ Call( _5998 = "overflowing_mul"::<i64,>( _195, _5997, ), bb1464, bb399)
	__builtin_sub_overflow(var5998, 3571324898628703294ll, &var2222);
	// ^ Call( _2222 = "overflowing_sub"::<i64,>( _5998, +3571324898628703294 i64, ), bb1465, bb399)
	var6004 = var2222 + var183;	// _6004 = BinOp(_2222 ADD _183)
	var5999 = var141 % var209;	// _5999 = BinOp(_141 MOD _209)
	__builtin_sub_overflow(0x88040401, var5999, &var6000);
	// ^ Call( _6000 = "overflowing_sub"::<u32,>( 0x88040401 u32, _5999, ), bb1466, bb399)
	__builtin_add_overflow(0xd5f85100, var6000, &var2223);
	// ^ Call( _2223 = "overflowing_add"::<u32,>( 0xd5f85100 u32, _6000, ), bb1467, bb399)
	__builtin_mul_overflow(var110, 0x87, &var6001);
	// ^ Call( _6001 = "overflowing_mul"::<u8,>( _110, 0x87 u8, ), bb1468, bb399)
	__builtin_add_overflow(var6001, var120, &var2224);
	// ^ Call( _2224 = "overflowing_add"::<u8,>( _6001, _120, ), bb1469, bb399)
	var2225 = (uint32_t )var2224;	// _2225 = Cast(_2224 as u32)
	var6005 = var2223 / var2225;	// _6005 = BinOp(_2223 DIV _2225)
	var6002 = var6005 & 0x3f;	// _6002 = BinOp(_6005 BIT_AND 0x3f u32)
	var6003 = (int64_t )var6002;	// _6003 = Cast(_6002 as i64)
	var2226 = var6004 >> var6003;
	// ^ Call( _2226 = "unchecked_shr"::<i64,>( _6004, _6003, ), bb1470, bb399)
	__builtin_add_overflow(-522835876, var56, &var6006);
	// ^ Call( _6006 = "overflowing_add"::<i32,>( -522835876 i32, _56, ), bb1471, bb399)
	__builtin_sub_overflow(var6006, 1468710120, &var2228);
	// ^ Call( _2228 = "overflowing_sub"::<i32,>( _6006, +1468710120 i32, ), bb1472, bb399)
	var6007 = -var248;	// _6007 = UniOp(_248 NEG)
	__builtin_sub_overflow(var6007, 2852, &var2229);
	// ^ Call( _2229 = "overflowing_sub"::<i32,>( _6007, +2852 i32, ), bb1473, bb399)
	var2227 = var2228 - var2229;	// _2227 = BinOp(_2228 SUB _2229)
	var6010.lo = var2227; var6010.hi = var2227 < 0 ? -1 : 0;	// _6010 = Cast(_2227 as i128)
	var6011 = (uint32_t )var269;	// _6011 = Cast(_269 as u32)
	var6008 = var6011 & 0x7f;	// _6008 = BinOp(_6011 BIT_AND 0x7f u32)
	var6009.lo = var6008; var6009.hi = var6008 < 0 ? -1 : 0;	// _6009 = Cast(_6008 as i128)
	var313 = shl128s(var6010, var6009.lo);
	// ^ Call( _313 = "unchecked_shl"::<i128,>( _6010, _6009, ), bb1474, bb399)
	var314 = 0x47e5f9f7;	// _314 = Constant(0x47e5f9f7 u32)
	var315 = var88;	// _315 = Use(_88)
	__builtin_mul_overflow(794772509, -1568531187, &var2231);
	// ^ Call( _2231 = "overflowing_mul"::<i32,>( +794772509 i32, -1568531187 i32, ), bb1475, bb399)
	var6013 = -var2231;	// _6013 = UniOp(_2231 NEG)
	var6012 = ZRICf15overflowing_rem0g( var6013, var15 );
	// ^ Call( _6012 = <i32 /*- */>::overflowing_rem( _6013, _15, ), bb1476, bb399)
	var2232 = var6012._0;	// _2232 = Use(_6012.0)
	var2233 = (int32_t )var212;	// _2233 = Cast(_212 as i32)
	var6014 = -var2233;	// _6014 = UniOp(_2233 NEG)
	__builtin_sub_overflow(var6014, 1079843680, &var2234);
	// ^ Call( _2234 = "overflowing_sub"::<i32,>( _6014, +1079843680 i32, ), bb1477, bb399)
	var2230 = var2232 + var2234;	// _2230 = BinOp(_2232 ADD _2234)
	var316 = -var2230;	// _316 = UniOp(_2230 NEG)
	var2235 = -21245;	// _2235 = Constant(-21245 i16)
	__builtin_add_overflow(var286, 10535, &var2238);
	// ^ Call( _2238 = "overflowing_add"::<i16,>( _286, +10535 i16, ), bb1478, bb399)
	var2237 = var2238 | -31736;	// _2237 = BinOp(_2238 BIT_OR -31736 i16)
	var2236 = var2237 / 7507;	// _2236 = BinOp(_2237 DIV +7507 i16)
	var6018 = var2235 / var2236;	// _6018 = BinOp(_2235 DIV _2236)
	var2240 = var142 * 15269;	// _2240 = BinOp(_142 MUL +15269 i16)
	var2239 = var246 + var2240;	// _2239 = BinOp(_246 ADD _2240)
	var6016 = -var2239;	// _6016 = UniOp(_2239 NEG)
	var2242 = var231 / 0x4690;	// _2242 = BinOp(_231 DIV 0x4690 u16)
	var2243 = 0x83 + var299;	// _2243 = BinOp(0x83 u16 ADD _299)
	var2241 = var2242 + var2243;	// _2241 = BinOp(_2242 ADD _2243)
	var6017 = (int16_t )var2241;	// _6017 = Cast(_2241 as i16)
	var6015 = ZRICd15overflowing_rem0g( var6016, var6017 );
	// ^ Call( _6015 = <i16 /*- */>::overflowing_rem( _6016, _6017, ), bb1479, bb399)
	__builtin_mul_overflow(var6018, var6015._0, &var317);
	// ^ Call( _317 = "overflowing_mul"::<i16,>( _6018, _6015.0, ), bb1480, bb399)
	var6021 = var281 - var217;	// _6021 = BinOp(_281 SUB _217)
	var6022 = 0xba1fb509 * var241;	// _6022 = BinOp(0xba1fb509 u32 MUL _241)
	var6019 = var6022 & 0x1f;	// _6019 = BinOp(_6022 BIT_AND 0x1f u32)
	var6020 = (int32_t )var6019;	// _6020 = Cast(_6019 as i32)
	var2244 = var6021 >> var6020;
	// ^ Call( _2244 = "unchecked_shr"::<i32,>( _6021, _6020, ), bb1481, bb399)
	__builtin_add_overflow(936793243, var312, &var2245);
	// ^ Call( _2245 = "overflowing_add"::<i32,>( +936793243 i32, _312, ), bb1482, bb399)
	var318 = var70;	// _318 = Use(_70)
	var6023 = 0x654c % var279;	// _6023 = BinOp(0x654c u16 MOD _279)
	__builtin_mul_overflow(var6023, var221, &var6024);
	// ^ Call( _6024 = "overflowing_mul"::<u16,>( _6023, _221, ), bb1483, bb399)
	__builtin_sub_overflow(var6024, 0xd876, &var6025);
	// ^ Call( _6025 = "overflowing_sub"::<u16,>( _6024, 0xd876 u16, ), bb1484, bb399)
	__builtin_add_overflow(var6025, 0xe179, &var6027);
	// ^ Call( _6027 = "overflowing_add"::<u16,>( _6025, 0xe179 u16, ), bb1485, bb399)
	var6026 = -var188;	// _6026 = UniOp(_188 NEG)
	__builtin_add_overflow(-1740706552, var6026, &var2246);
	// ^ Call( _2246 = "overflowing_add"::<i32,>( -1740706552 i32, _6026, ), bb1486, bb399)
	var6028 = (uint16_t )var2246;	// _6028 = Cast(_2246 as u16)
	__builtin_sub_overflow(var6027, var6028, &var2247);
	// ^ Call( _2247 = "overflowing_sub"::<u16,>( _6027, _6028, ), bb1487, bb399)
	__builtin_add_overflow(var207, var254, &var6029);
	// ^ Call( _6029 = "overflowing_add"::<i16,>( _207, _254, ), bb1488, bb399)
	var2249 = var6029 << 0;
	// ^ Call( _2249 = "unchecked_shl"::<i16,>( _6029, +0 i16, ), bb1489, bb399)
	var2248 = var50 + var2249;	// _2248 = BinOp(_50 ADD _2249)
	var6030 = -var13;	// _6030 = UniOp(_13 NEG)
	__builtin_mul_overflow(-7996, var6030, &var2250);
	// ^ Call( _2250 = "overflowing_mul"::<i16,>( -7996 i16, _6030, ), bb1490, bb399)
	var6036 = var2248 - var2250;	// _6036 = BinOp(_2248 SUB _2250)
	__builtin_sub_overflow(0xe79b8a1c, var276, &var6031);
	// ^ Call( _6031 = "overflowing_sub"::<u32,>( 0xe79b8a1c u32, _276, ), bb1491, bb399)
	var2251 = var6031 << 0xf;
	// ^ Call( _2251 = "unchecked_shl"::<u32,>( _6031, 0xf u32, ), bb1492, bb399)
	var2252 = var50 | var254;	// _2252 = BinOp(_50 BIT_OR _254)
	var2253 = (uint32_t )var2252;	// _2253 = Cast(_2252 as u32)
	var6033 = var2251 | var2253;	// _6033 = BinOp(_2251 BIT_OR _2253)
	var6032 = var6033 & 0x1f;	// _6032 = BinOp(_6033 BIT_AND 0x1f u32)
	var6037 = var61 >> var6032;
	// ^ Call( _6037 = "unchecked_shr"::<u32,>( _61, _6032, ), bb1493, bb399)
	var6034 = var6037 & 0xf;	// _6034 = BinOp(_6037 BIT_AND 0xf u32)
	var6035 = (int16_t )var6034;	// _6035 = Cast(_6034 as i16)
	var2254 = var6036 << var6035;
	// ^ Call( _2254 = "unchecked_shl"::<i16,>( _6036, _6035, ), bb1494, bb399)
	var2255 = 26636;	// _2255 = Constant(+1772840972 i16)
	var2257 = -24692 | var60;	// _2257 = BinOp(-24692 i16 BIT_OR _60)
	__builtin_mul_overflow(6219, var16, &var2258);
	// ^ Call( _2258 = "overflowing_mul"::<i16,>( +6219 i16, _16, ), bb1495, bb399)
	var2256 = var2257 | var2258;	// _2256 = BinOp(_2257 BIT_OR _2258)
	var2259 = -var2256;	// _2259 = UniOp(_2256 NEG)
	var2260 = -var2259;	// _2260 = UniOp(_2259 NEG)
	var319 = var2255 | var2260;	// _319 = BinOp(_2255 BIT_OR _2260)
	var320 = -27015;	// _320 = Constant(-27015 i16)
	var321 = 1197800709;	// _321 = Constant(+1197800709 i32)
	var6042 = make128s_raw(3252831323448444842ull, 14567223575407829522ull);	// _6042 = Constant(+60004146938599397546926407771735794194 i128)
	var6038 = var49 & 0x1f;	// _6038 = BinOp(_49 BIT_AND 0x1f u32)
	var2262 = 0xe2ffacd8 >> var6038;
	// ^ Call( _2262 = "unchecked_shr"::<u32,>( 0xe2ffacd8 u32, _6038, ), bb1496, bb399)
	var2263 = var247 ^ var285;	// _2263 = BinOp(_247 BIT_XOR _285)
	var2261 = var2262 ^ var2263;	// _2261 = BinOp(_2262 BIT_XOR _2263)
	__builtin_sub_overflow(0xd7eb8f7b, 0xfe41e400, &var6039);
	// ^ Call( _6039 = "overflowing_sub"::<u32,>( 0xd7eb8f7b u32, 0xfe41e400 u32, ), bb1497, bb399)
	var2264 = var6039 % 0x8bbdcee9;	// _2264 = BinOp(_6039 MOD 0x8bbdcee9 u32)
	var6043 = var2261 / var2264;	// _6043 = BinOp(_2261 DIV _2264)
	var6040 = var6043 & 0x7f;	// _6040 = BinOp(_6043 BIT_AND 0x7f u32)
	var6041.lo = var6040; var6041.hi = var6040 < 0 ? -1 : 0;	// _6041 = Cast(_6040 as i128)
	var2265 = shl128s(var6042, var6041.lo);
	// ^ Call( _2265 = "unchecked_shl"::<i128,>( _6042, _6041, ), bb1498, bb399)
	var322 = 7072224971463033255ll;	// _322 = Constant(+7072224971463033255 isize)
	__builtin_add_overflow(var249, var305, &var2268);
	// ^ Call( _2268 = "overflowing_add"::<u16,>( _249, _305, ), bb1499, bb399)
	__builtin_mul_overflow(var66, var278, &var2269);
	// ^ Call( _2269 = "overflowing_mul"::<u16,>( _66, _278, ), bb1500, bb399)
	var2267 = var2268 ^ var2269;	// _2267 = BinOp(_2268 BIT_XOR _2269)
	var2271 = var278 + 0xbc9f;	// _2271 = BinOp(_278 ADD 0xbc9f u16)
	var2270 = var2271 * var23;	// _2270 = BinOp(_2271 MUL _23)
	var2266 = var2267 + var2270;	// _2266 = BinOp(_2267 ADD _2270)
	__builtin_sub_overflow(var274, var39, &var2274);
	// ^ Call( _2274 = "overflowing_sub"::<u16,>( _274, _39, ), bb1501, bb399)
	var2273 = var2274 & 0x582a;	// _2273 = BinOp(_2274 BIT_AND 0x582a u16)
	var2272 = 0x6d1f ^ var2273;	// _2272 = BinOp(0x6d1f u16 BIT_XOR _2273)
	var6047 = var2266 - var2272;	// _6047 = BinOp(_2266 SUB _2272)
	var2275 = 0xb65a2c0f / var47;	// _2275 = BinOp(0xb65a2c0f u32 DIV _47)
	var2276 = 0x91d74b06 << 0x3;
	// ^ Call( _2276 = "unchecked_shl"::<u32,>( 0x91d74b06 u32, 0x3 u32, ), bb1502, bb399)
	var6044 = var2275 + var2276;	// _6044 = BinOp(_2275 ADD _2276)
	var2277 = var6044 / 0x2878cc4;	// _2277 = BinOp(_6044 DIV 0x2878cc4 u32)
	var6048 = 0x3bc5992 | var2277;	// _6048 = BinOp(0x3bc5992 u32 BIT_OR _2277)
	var6045 = var6048 & 0xf;	// _6045 = BinOp(_6048 BIT_AND 0xf u32)
	var6046 = (uint16_t )var6045;	// _6046 = Cast(_6045 as u16)
	var323 = var6047 << var6046;
	// ^ Call( _323 = "unchecked_shl"::<u16,>( _6047, _6046, ), bb1503, bb399)
	__builtin_mul_overflow(var102, var271, &var2278);
	// ^ Call( _2278 = "overflowing_mul"::<u64,>( _102, _271, ), bb1504, bb399)
	var2279 = mul128(var308, var9);	// _2279 = BinOp(_308 MUL _9)
	var6049 = mul128(make128_raw(0ull, 8202226313411481776ull), var2279);	// _6049 = BinOp(0x71d4295ff240d0b0 u128 MUL _2279)
	mul128_o(make128_raw(12995701265594460036ull, 7500391460221481453ull), var6049, &var2280);
	// ^ Call( _2280 = "overflowing_mul"::<u128,>( 0xb45a017266da27846816be4b56dff1ed u128, _6049, ), bb1505, bb399)
	var6050 = var105 & var124;	// _6050 = BinOp(_105 BIT_AND _124)
	__builtin_mul_overflow(0xa89c, var6050, &var2281);
	// ^ Call( _2281 = "overflowing_mul"::<u16,>( 0xa89c u16, _6050, ), bb1506, bb399)
	var2282.lo = var2281; var2282.hi = var2281 < 0 ? -1 : 0;	// _2282 = Cast(_2281 as u128)
	var6051 = mul128(var2280, var2282);	// _6051 = BinOp(_2280 MUL _2282)
	var2284.lo = var55; var2284.hi = var55 < 0 ? -1 : 0;	// _2284 = Cast(_55 as u128)
	var2286 = add128(var9, make128_raw(4322524782966409103ull, 11133112552284961527ull));	// _2286 = BinOp(_9 ADD 0x3bfcb1636d89078f9a80c2e16b633af7 u128)
	add128_o(make128_raw(16472178232107179168ull, 14892648320870516300ull), make128_raw(2963141780401898449ull, 9789452823432058717ull), &var2287);
	// ^ Call( _2287 = "overflowing_add"::<u128,>( 0xe498eed429ab9ca0cead50be424e064c u128, 0x291f31bff7f943d187db1f79e61cd75d u128, ), bb1507, bb399)
	var2285 = sub128(var2286, var2287);	// _2285 = BinOp(_2286 SUB _2287)
	var2283 = div128(var2284, var2285);	// _2283 = BinOp(_2284 DIV _2285)
	var6052 = and128(var2283, make128_raw(6649085418379654528ull, 12032367183009945159ull));	// _6052 = BinOp(_2283 BIT_AND 0x5c464bf5abbfb580a6fb8e33e6601647 u128)
	mul128_o(var6051, var6052, &var324);
	// ^ Call( _324 = "overflowing_mul"::<u128,>( _6051, _6052, ), bb1508, bb399)
	__builtin_add_overflow(0x7019e841, 0xefb18ba9, &var2289);
	// ^ Call( _2289 = "overflowing_add"::<u32,>( 0x7019e841 u32, 0xefb18ba9 u32, ), bb1509, bb399)
	var2290 = (uint8_t )var2289;	// _2290 = Cast(_2289 as u8)
	var6053 = -var184;	// _6053 = UniOp(_184 NEG)
	__builtin_mul_overflow(var6053, var40, &var2291);
	// ^ Call( _2291 = "overflowing_mul"::<i8,>( _6053, _40, ), bb1510, bb399)
	var2292 = (uint8_t )var2291;	// _2292 = Cast(_2291 as u8)
	var2288 = var2290 * var2292;	// _2288 = BinOp(_2290 MUL _2292)
	var6054 = (uint32_t )var110;	// _6054 = Cast(_110 as u32)
	__builtin_sub_overflow(var225, var306, &var6055);
	// ^ Call( _6055 = "overflowing_sub"::<u32,>( _225, _306, ), bb1511, bb399)
	__builtin_add_overflow(var6054, var6055, &var2294);
	// ^ Call( _2294 = "overflowing_add"::<u32,>( _6054, _6055, ), bb1512, bb399)
	var2295 = (uint8_t )var2294;	// _2295 = Cast(_2294 as u8)
	var6056 = var180 % 0xcc;	// _6056 = BinOp(_180 MOD 0xcc u8)
	__builtin_add_overflow(var54, 0xb8, &var6057);
	// ^ Call( _6057 = "overflowing_add"::<u8,>( _54, 0xb8 u8, ), bb1513, bb399)
	__builtin_sub_overflow(var6056, var6057, &var2297);
	// ^ Call( _2297 = "overflowing_sub"::<u8,>( _6056, _6057, ), bb1514, bb399)
	var2296 = 0x5b / var2297;	// _2296 = BinOp(0x5b u8 DIV _2297)
	var2293 = var2295 + var2296;	// _2293 = BinOp(_2295 ADD _2296)
	var325 = var2288 + var2293;	// _325 = BinOp(_2288 ADD _2293)
	var6065 = -124;	// _6065 = Constant(-124 i8)
	var6058 = 0x3e9100e8 - var220;	// _6058 = BinOp(0x3e9100e8 u32 SUB _220)
	var2299 = var6058 / 0x893cd75a;	// _2299 = BinOp(_6058 DIV 0x893cd75a u32)
	var2298 = var157 * var2299;	// _2298 = BinOp(_157 MUL _2299)
	__builtin_sub_overflow(var51, var225, &var2300);
	// ^ Call( _2300 = "overflowing_sub"::<u32,>( _51, _225, ), bb1515, bb399)
	var6061 = var2300 * var163;	// _6061 = BinOp(_2300 MUL _163)
	var6059 = var276 << 0x1d;
	// ^ Call( _6059 = "unchecked_shl"::<u32,>( _276, 0x1d u32, ), bb1516, bb399)
	var6060 = var95 / 0xb0c52bce;	// _6060 = BinOp(_95 DIV 0xb0c52bce u32)
	__builtin_sub_overflow(var6059, var6060, &var6062);
	// ^ Call( _6062 = "overflowing_sub"::<u32,>( _6059, _6060, ), bb1517, bb399)
	var2301 = var6061 % var6062;	// _2301 = BinOp(_6061 MOD _6062)
	var6066 = var2298 * var2301;	// _6066 = BinOp(_2298 MUL _2301)
	var6063 = var6066 & 0x7;	// _6063 = BinOp(_6066 BIT_AND 0x7 u32)
	var6064 = (int8_t )var6063;	// _6064 = Cast(_6063 as i8)
	var326 = var6065 << var6064;
	// ^ Call( _326 = "unchecked_shl"::<i8,>( _6065, _6064, ), bb1518, bb399)
	var327 = 0x2c;	// _327 = Constant(0x2c u8)
	__builtin_add_overflow(0, 57, &var2302);
	// ^ Call( _2302 = "overflowing_add"::<i8,>( +0 i8, +57 i8, ), bb1519, bb399)
	var2303 = -var2302;	// _2303 = UniOp(_2302 NEG)
	var2304 = -var255;	// _2304 = UniOp(_255 NEG)
	var6068 = (int8_t )var2304;	// _6068 = Cast(_2304 as i8)
	var6067 = ZRICb15overflowing_div0g( var6068, 122 );
	// ^ Call( _6067 = <i8 /*- */>::overflowing_div( _6068, +122 i8, ), bb1520, bb399)
	var2305 = -var6067._0;	// _2305 = UniOp(_6067.0 NEG)
	var328 = var2303 * var2305;	// _328 = BinOp(_2303 MUL _2305)
	__builtin_sub_overflow(0x70f725f45a36c464ull, 0x9e4118658aa2e05dull, &var2306);
	// ^ Call( _2306 = "overflowing_sub"::<usize,>( 0x70f725f45a36c464 usize, 0x9e4118658aa2e05d usize, ), bb1521, bb399)
	__builtin_mul_overflow(0xdd9ba93f2f9519d7ull, var271, &var2307);
	// ^ Call( _2307 = "overflowing_mul"::<u64,>( 0xdd9ba93f2f9519d7 u64, _271, ), bb1522, bb399)
	var329 = -31;	// _329 = Constant(+15329 i8)
	var6069 = ZRICd15overflowing_rem0g( var255, var291 );
	// ^ Call( _6069 = <i16 /*- */>::overflowing_rem( _255, _291, ), bb1523, bb399)
	var2308 = (uint32_t )var6069._0;	// _2308 = Cast(_6069.0 as u32)
	var2310 = var143 * var19;	// _2310 = BinOp(_143 MUL _19)
	var2311 = -var182;	// _2311 = UniOp(_182 NEG)
	var2309 = var2310 + var2311;	// _2309 = BinOp(_2310 ADD _2311)
	var2312 = (uint32_t )var2309;	// _2312 = Cast(_2309 as u32)
	var6073 = var2308 / var2312;	// _6073 = BinOp(_2308 DIV _2312)
	var6071 = 0x538b77e1 / var209;	// _6071 = BinOp(0x538b77e1 u32 DIV _209)
	var2313 = (uint32_t )var134;	// _2313 = Cast(_134 as u32)
	var6070 = var2313 | 0x6fd10d76;	// _6070 = BinOp(_2313 BIT_OR 0x6fd10d76 u32)
	__builtin_sub_overflow(var6070, 0x8036cfcb, &var6072);
	// ^ Call( _6072 = "overflowing_sub"::<u32,>( _6070, 0x8036cfcb u32, ), bb1524, bb399)
	var6074 = var6071 % var6072;	// _6074 = BinOp(_6071 MOD _6072)
	__builtin_mul_overflow(var6073, var6074, &var330);
	// ^ Call( _330 = "overflowing_mul"::<u32,>( _6073, _6074, ), bb1525, bb399)
	var6075 = 0xe4e601fc << 0x0;
	// ^ Call( _6075 = "unchecked_shl"::<u32,>( 0xe4e601fc u32, 0x0 u32, ), bb1526, bb399)
	__builtin_sub_overflow(var295, var6075, &var2315);
	// ^ Call( _2315 = "overflowing_sub"::<u32,>( _295, _6075, ), bb1527, bb399)
	var2316 = var285 ^ 0x7193171a;	// _2316 = BinOp(_285 BIT_XOR 0x7193171a u32)
	var2314 = var2315 ^ var2316;	// _2314 = BinOp(_2315 BIT_XOR _2316)
	var331 = (int64_t )var2314;	// _331 = Cast(_2314 as i64)
	__builtin_add_overflow(7706, var142, &var6076);
	// ^ Call( _6076 = "overflowing_add"::<i16,>( +7706 i16, _142, ), bb1528, bb399)
	__builtin_mul_overflow(var6076, 15049, &var2318);
	// ^ Call( _2318 = "overflowing_mul"::<i16,>( _6076, +15049 i16, ), bb1529, bb399)
	var2319 = var296 - -14891;	// _2319 = BinOp(_296 SUB -14891 i16)
	var2320 = -var2319;	// _2320 = UniOp(_2319 NEG)
	var2317 = var2318 ^ var2320;	// _2317 = BinOp(_2318 BIT_XOR _2320)
	var2321 = (uint32_t )var2317;	// _2321 = Cast(_2317 as u32)
	var332 = var2321 * var163;	// _332 = BinOp(_2321 MUL _163)
	var6077 = var63 ^ 0x3;	// _6077 = BinOp(_63 BIT_XOR 0x3 u8)
	__builtin_mul_overflow(var6077, var178, &var2322);
	// ^ Call( _2322 = "overflowing_mul"::<u8,>( _6077, _178, ), bb1530, bb399)
	var2324 = var151 / 0x83;	// _2324 = BinOp(_151 DIV 0x83 u8)
	var2323 = 0x3 * var2324;	// _2323 = BinOp(0x3 u8 MUL _2324)
	var6081 = var223 * var2323;	// _6081 = BinOp(_223 MUL _2323)
	var6078 = var330 & 0x7;	// _6078 = BinOp(_330 BIT_AND 0x7 u32)
	var6079 = (uint8_t )var6078;	// _6079 = Cast(_6078 as u8)
	var2326 = var259 << var6079;
	// ^ Call( _2326 = "unchecked_shl"::<u8,>( _259, _6079, ), bb1531, bb399)
	var2327 = 0xc1 / var327;	// _2327 = BinOp(0xc1 u8 DIV _327)
	var2325 = var2326 ^ var2327;	// _2325 = BinOp(_2326 BIT_XOR _2327)
	var6080 = 0x9b + var81;	// _6080 = BinOp(0x9b u8 ADD _81)
	__builtin_mul_overflow(0x3d, var6080, &var2328);
	// ^ Call( _2328 = "overflowing_mul"::<u8,>( 0x3d u8, _6080, ), bb1532, bb399)
	var6082 = var2325 / var2328;	// _6082 = BinOp(_2325 DIV _2328)
	__builtin_add_overflow(var6081, var6082, &var2329);
	// ^ Call( _2329 = "overflowing_add"::<u8,>( _6081, _6082, ), bb1533, bb399)
	var2331 = (int64_t )var66;	// _2331 = Cast(_66 as i64)
	var2332 = var183 << 15ll;
	// ^ Call( _2332 = "unchecked_shl"::<i64,>( _183, +15 i64, ), bb1534, bb399)
	var2330 = var2331 - var2332;	// _2330 = BinOp(_2331 SUB _2332)
	var2333 = -var2330;	// _2333 = UniOp(_2330 NEG)
	var2334 = -var2333;	// _2334 = UniOp(_2333 NEG)
	var333 = (uint16_t )var2334;	// _333 = Cast(_2334 as u16)
	__builtin_sub_overflow(0x4b, 0x56, &var6084);
	// ^ Call( _6084 = "overflowing_sub"::<u8,>( 0x4b u8, 0x56 u8, ), bb1535, bb399)
	var6083 = var283 + var120;	// _6083 = BinOp(_283 ADD _120)
	__builtin_add_overflow(var6083, 0x1, &var2335);
	// ^ Call( _2335 = "overflowing_add"::<u8,>( _6083, 0x1 u8, ), bb1536, bb399)
	var6085 = var2335 ^ 0xd8;	// _6085 = BinOp(_2335 BIT_XOR 0xd8 u8)
	var2336 = var6084 % var6085;	// _2336 = BinOp(_6084 MOD _6085)
	var334 = var2336 / 0x5e;	// _334 = BinOp(_2336 DIV 0x5e u8)
	var6086 = mul128(make128_raw(17187050995041505555ull, 1546345622904751789ull), var308);	// _6086 = BinOp(0xee84abd1aff911131575b926b137c6ad u128 MUL _308)
	sub128_o(var6086, make128_raw(0ull, 121ull), &var2337);
	// ^ Call( _2337 = "overflowing_sub"::<u128,>( _6086, 0x79 u128, ), bb1537, bb399)
	var335 = 0x1ad7b23b;	// _335 = Constant(0x1ad7b23b u32)
	sub128s_o(make128s_raw(12873208351309950981ull, 16104434042190357591ull), var48, &var2338);
	// ^ Call( _2338 = "overflowing_sub"::<i128,>( -102813587056783317613811216341128518569 i128, _48, ), bb1538, bb399)
	var6087 = and128s(var2338, var313);	// _6087 = BinOp(_2338 BIT_AND _313)
	sub128s_o(var6087, var203, &var2339);
	// ^ Call( _2339 = "overflowing_sub"::<i128,>( _6087, _203, ), bb1539, bb399)
	var6088 = shl128s(make128s_raw(0ull, 7845543550981339816ull), make128s_raw(0ull, 1ull).lo);
	// ^ Call( _6088 = "unchecked_shl"::<i128,>( +7845543550981339816 i128, +1 i128, ), bb1540, bb399)
	var2340 = shr128s(var6088, make128s_raw(0ull, 66ull).lo);
	// ^ Call( _2340 = "unchecked_shr"::<i128,>( _6088, +66 i128, ), bb1541, bb399)
	var336 = 0xd0b1bf9d08f3a4a8ull;	// _336 = Constant(0xd0b1bf9d08f3a4a8 u64)
	__builtin_mul_overflow(var108, var301, &var6090);
	// ^ Call( _6090 = "overflowing_mul"::<u32,>( _108, _301, ), bb1542, bb399)
	var6089 = var6090 & 0x1f;	// _6089 = BinOp(_6090 BIT_AND 0x1f u32)
	var6091 = var49 >> var6089;
	// ^ Call( _6091 = "unchecked_shr"::<u32,>( _49, _6089, ), bb1543, bb399)
	__builtin_mul_overflow(0xf4deacba, var6091, &var2341);
	// ^ Call( _2341 = "overflowing_mul"::<u32,>( 0xf4deacba u32, _6091, ), bb1544, bb399)
	var337 = 0xeb478d61 ^ var2341;	// _337 = BinOp(0xeb478d61 u32 BIT_XOR _2341)
	var2342.lo = var72; var2342.hi = var72 < 0 ? -1 : 0;	// _2342 = Cast(_72 as i128)
	var2343 = neg128s(var2342);	// _2343 = UniOp(_2342 NEG)
	var2344 = neg128s(var2343);	// _2344 = UniOp(_2343 NEG)
	var2345 = var2344.lo;	// _2345 = Cast(_2344 as u8)
	var338 = var2345 ^ 0xd5;	// _338 = BinOp(_2345 BIT_XOR 0xd5 u8)
	var2347 = shl128(var132, make128_raw(0ull, 15ull).lo);
	// ^ Call( _2347 = "unchecked_shl"::<u128,>( _132, 0xf u128, ), bb1545, bb399)
	var2348 = xor128(make128_raw(8070979713119666689ull, 12559503361306931869ull), var3);	// _2348 = BinOp(0x7001e14985e1c201ae4c51c39606329d u128 BIT_XOR _3)
	var6094 = or128(var2347, var2348);	// _6094 = BinOp(_2347 BIT_OR _2348)
	var2349 = 0x860783d2;	// _2349 = Constant(0x860783d2 u32)
	__builtin_sub_overflow(var141, 0x6f544e2e, &var2350);
	// ^ Call( _2350 = "overflowing_sub"::<u32,>( _141, 0x6f544e2e u32, ), bb1546, bb399)
	var6095 = var2349 & var2350;	// _6095 = BinOp(_2349 BIT_AND _2350)
	var6092 = var6095 & 0x7f;	// _6092 = BinOp(_6095 BIT_AND 0x7f u32)
	var6093.lo = var6092; var6093.hi = var6092 < 0 ? -1 : 0;	// _6093 = Cast(_6092 as u128)
	var2351 = shl128(var6094, var6093.lo);
	// ^ Call( _2351 = "unchecked_shl"::<u128,>( _6094, _6093, ), bb1547, bb399)
	var2346 = div128(make128_raw(281553087914828787ull, 6110064309314013867ull), var2351);	// _2346 = BinOp(0x3e8470aae93e3f354cb4f1de7744aab u128 DIV _2351)
	var2352 = mod128(make128_raw(10272455211964773898ull, 3783248744627577884ull), var9);	// _2352 = BinOp(0x8e8f1796e845360a3480ccb05078241c u128 MOD _9)
	var339 = add128(var2346, var2352);	// _339 = BinOp(_2346 ADD _2352)
	var6096 = var63 >> 0x2;
	// ^ Call( _6096 = "unchecked_shr"::<u8,>( _63, 0x2 u8, ), bb1548, bb399)
	__builtin_sub_overflow(0xa, var6096, &var6099);
	// ^ Call( _6099 = "overflowing_sub"::<u8,>( 0xa u8, _6096, ), bb1549, bb399)
	__builtin_add_overflow(var159, 0xd6, &var6097);
	// ^ Call( _6097 = "overflowing_add"::<u8,>( _159, 0xd6 u8, ), bb1550, bb399)
	var6098 = var259 * var103;	// _6098 = BinOp(_259 MUL _103)
	__builtin_sub_overflow(var6097, var6098, &var6100);
	// ^ Call( _6100 = "overflowing_sub"::<u8,>( _6097, _6098, ), bb1551, bb399)
	__builtin_sub_overflow(var6099, var6100, &var6104);
	// ^ Call( _6104 = "overflowing_sub"::<u8,>( _6099, _6100, ), bb1552, bb399)
	__builtin_mul_overflow(var25, var157, &var6103);
	// ^ Call( _6103 = "overflowing_mul"::<u32,>( _25, _157, ), bb1553, bb399)
	var6101 = var6103 & 0x7;	// _6101 = BinOp(_6103 BIT_AND 0x7 u32)
	var6102 = (uint8_t )var6101;	// _6102 = Cast(_6101 as u8)
	var2353 = var200 << var6102;
	// ^ Call( _2353 = "unchecked_shl"::<u8,>( _200, _6102, ), bb1554, bb399)
	var6105 = var2353 / var178;	// _6105 = BinOp(_2353 DIV _178)
	__builtin_add_overflow(var6104, var6105, &var6112);
	// ^ Call( _6112 = "overflowing_add"::<u8,>( _6104, _6105, ), bb1555, bb399)
	var2355 = var67 + var127;	// _2355 = BinOp(_67 ADD _127)
	__builtin_sub_overflow(var261, var177, &var2356);
	// ^ Call( _2356 = "overflowing_sub"::<u32,>( _261, _177, ), bb1556, bb399)
	var2354 = var2355 ^ var2356;	// _2354 = BinOp(_2355 BIT_XOR _2356)
	var6106 = var285 + 0x3841a;	// _6106 = BinOp(_285 ADD 0x3841a u32)
	__builtin_sub_overflow(var25, 0x53c15a73, &var6107);
	// ^ Call( _6107 = "overflowing_sub"::<u32,>( _25, 0x53c15a73 u32, ), bb1557, bb399)
	__builtin_mul_overflow(var6106, var6107, &var2357);
	// ^ Call( _2357 = "overflowing_mul"::<u32,>( _6106, _6107, ), bb1558, bb399)
	var6109 = var2354 / var2357;	// _6109 = BinOp(_2354 DIV _2357)
	var6108 = var6109 & 0x1f;	// _6108 = BinOp(_6109 BIT_AND 0x1f u32)
	var6113 = var71 << var6108;
	// ^ Call( _6113 = "unchecked_shl"::<u32,>( _71, _6108, ), bb1559, bb399)
	var6110 = var6113 & 0x7;	// _6110 = BinOp(_6113 BIT_AND 0x7 u32)
	var6111 = (uint8_t )var6110;	// _6111 = Cast(_6110 as u8)
	var340 = var6112 << var6111;
	// ^ Call( _340 = "unchecked_shl"::<u8,>( _6112, _6111, ), bb1560, bb399)
	var2360 = 0x416e55b3 | var177;	// _2360 = BinOp(0x416e55b3 u32 BIT_OR _177)
	var2359 = var2360 + var260;	// _2359 = BinOp(_2360 ADD _260)
	var2358 = var2359 - 0x2ee84750;	// _2358 = BinOp(_2359 SUB 0x2ee84750 u32)
	__builtin_add_overflow(0xa8d87537, var330, &var2361);
	// ^ Call( _2361 = "overflowing_add"::<u32,>( 0xa8d87537 u32, _330, ), bb1561, bb399)
	var6114 = 0xb0fd8438 ^ var2361;	// _6114 = BinOp(0xb0fd8438 u32 BIT_XOR _2361)
	var2362 = var25 % var6114;	// _2362 = BinOp(_25 MOD _6114)
	var6122 = var2358 ^ var2362;	// _6122 = BinOp(_2358 BIT_XOR _2362)
	var2364 = 0x72ed2521 << 0x1b;
	// ^ Call( _2364 = "unchecked_shl"::<u32,>( 0x72ed2521 u32, 0x1b u32, ), bb1562, bb399)
	var2365 = var265 & 0x28aac2c7;	// _2365 = BinOp(_265 BIT_AND 0x28aac2c7 u32)
	var2363 = var2364 + var2365;	// _2363 = BinOp(_2364 ADD _2365)
	var6115 = var168 & 0x1f;	// _6115 = BinOp(_168 BIT_AND 0x1f u32)
	var6116 = 0x5d02b312 << var6115;
	// ^ Call( _6116 = "unchecked_shl"::<u32,>( 0x5d02b312 u32, _6115, ), bb1563, bb399)
	var6117 = 0x84851e98 | var49;	// _6117 = BinOp(0x84851e98 u32 BIT_OR _49)
	__builtin_sub_overflow(var6116, var6117, &var2366);
	// ^ Call( _2366 = "overflowing_sub"::<u32,>( _6116, _6117, ), bb1564, bb399)
	var6120 = var2363 / var2366;	// _6120 = BinOp(_2363 DIV _2366)
	var2368 = var108 | 0xe92f13d4;	// _2368 = BinOp(_108 BIT_OR 0xe92f13d4 u32)
	var6118 = var266 & 0x1f;	// _6118 = BinOp(_266 BIT_AND 0x1f u32)
	var2369 = 0xb1598f97 >> var6118;
	// ^ Call( _2369 = "unchecked_shr"::<u32,>( 0xb1598f97 u32, _6118, ), bb1565, bb399)
	var2367 = var2368 & var2369;	// _2367 = BinOp(_2368 BIT_AND _2369)
	var6121 = var335 & var2367;	// _6121 = BinOp(_335 BIT_AND _2367)
	var6119 = var6121 & 0x1f;	// _6119 = BinOp(_6121 BIT_AND 0x1f u32)
	var6123 = var6120 >> var6119;
	// ^ Call( _6123 = "unchecked_shr"::<u32,>( _6120, _6119, ), bb1566, bb399)
	__builtin_sub_overflow(var6122, var6123, &var341);
	// ^ Call( _341 = "overflowing_sub"::<u32,>( _6122, _6123, ), bb1567, bb399)
	var2371 = or128s(make128s_raw(14728826931681260274ull, 8856672450614300737ull), var250);	// _2371 = BinOp(-68583466006253536618779319154820607935 i128 BIT_OR _250)
	var2372 = neg128s(var2371);	// _2372 = UniOp(_2371 NEG)
	var2374 = neg128s(var136);	// _2374 = UniOp(_136 NEG)
	var2375 = mul128s(var29, var35);	// _2375 = BinOp(_29 MUL _35)
	var2373 = and128s(var2374, var2375);	// _2373 = BinOp(_2374 BIT_AND _2375)
	var2370 = mul128s(var2372, var2373);	// _2370 = BinOp(_2372 MUL _2373)
	sub128s_o(var136, make128s_raw(12208414621612666995ull, 1206914692713235534ull), &var2376);
	// ^ Call( _2376 = "overflowing_sub"::<i128,>( _136, -115076866850315960546865425711682862002 i128, ), bb1568, bb399)
	var2377 = neg128s(var2376);	// _2377 = UniOp(_2376 NEG)
	var2378 = neg128s(var2377);	// _2378 = UniOp(_2377 NEG)
	var6125 = xor128s(var2370, var2378);	// _6125 = BinOp(_2370 BIT_XOR _2378)
	var6124 = ZRICj15overflowing_rem0g( var29, make128s_raw(13521764891049357450ull, 10406664337159727650ull) );
	// ^ Call( _6124 = <i128 /*- */>::overflowing_rem( _29, -90849830550879848032105913730199344606 i128, ), bb1569, bb399)
	var2380 = neg128s(var6124._0);	// _2380 = UniOp(_6124.0 NEG)
	var2381 = neg128s(var29);	// _2381 = UniOp(_29 NEG)
	var2382 = neg128s(var2381);	// _2382 = UniOp(_2381 NEG)
	var2379 = sub128s(var2380, var2382);	// _2379 = BinOp(_2380 SUB _2382)
	var6126 = neg128s(var2379);	// _6126 = UniOp(_2379 NEG)
	mul128s_o(var6125, var6126, &var2383);
	// ^ Call( _2383 = "overflowing_mul"::<i128,>( _6125, _6126, ), bb1570, bb399)
	__builtin_add_overflow(var205, 0xd6baafce775fdaf0ull, &var2384);
	// ^ Call( _2384 = "overflowing_add"::<usize,>( _205, 0xd6baafce775fdaf0 usize, ), bb1571, bb399)
	var6130 = var2384 - var112;	// _6130 = BinOp(_2384 SUB _112)
	__builtin_mul_overflow(var277, 0x777c7b9f, &var6127);
	// ^ Call( _6127 = "overflowing_mul"::<u32,>( _277, 0x777c7b9f u32, ), bb1572, bb399)
	__builtin_sub_overflow(var247, var6127, &var6131);
	// ^ Call( _6131 = "overflowing_sub"::<u32,>( _247, _6127, ), bb1573, bb399)
	var6128 = var6131 & 0x3f;	// _6128 = BinOp(_6131 BIT_AND 0x3f u32)
	var6129 = (uintptr_t )var6128;	// _6129 = Cast(_6128 as usize)
	var2385 = var6130 >> var6129;
	// ^ Call( _2385 = "unchecked_shr"::<usize,>( _6130, _6129, ), bb1574, bb399)
	var6133 = 0x461b;	// _6133 = Constant(0x461b u16)
	var6132 = 0x5556 >> 0x7;
	// ^ Call( _6132 = "unchecked_shr"::<u16,>( 0x5556 u16, 0x7 u16, ), bb1575, bb399)
	__builtin_sub_overflow(var6132, 0xb7ec, &var6134);
	// ^ Call( _6134 = "overflowing_sub"::<u16,>( _6132, 0xb7ec u16, ), bb1576, bb399)
	var6138 = var6133 % var6134;	// _6138 = BinOp(_6133 MOD _6134)
	var2386 = (uint32_t )var118;	// _2386 = Cast(_118 as u32)
	var6137 = 0x7f66d338 & var2386;	// _6137 = BinOp(0x7f66d338 u32 BIT_AND _2386)
	var6135 = var6137 & 0xf;	// _6135 = BinOp(_6137 BIT_AND 0xf u32)
	var6136 = (uint16_t )var6135;	// _6136 = Cast(_6135 as u16)
	var2387 = var149 >> var6136;
	// ^ Call( _2387 = "unchecked_shr"::<u16,>( _149, _6136, ), bb1577, bb399)
	var2390 = 0xaed2 / var299;	// _2390 = BinOp(0xaed2 u16 DIV _299)
	var2391 = var311 & var288;	// _2391 = BinOp(_311 BIT_AND _288)
	var2389 = var2390 * var2391;	// _2389 = BinOp(_2390 MUL _2391)
	var2388 = 0xf9ac * var2389;	// _2388 = BinOp(0xf9ac u16 MUL _2389)
	var6139 = var2387 + var2388;	// _6139 = BinOp(_2387 ADD _2388)
	__builtin_mul_overflow(var6138, var6139, &var2392);
	// ^ Call( _2392 = "overflowing_mul"::<u16,>( _6138, _6139, ), bb1578, bb399)
	var342 = -var93;	// _342 = UniOp(_93 NEG)
	__builtin_mul_overflow(0xcc2ae48ec188e7b3ull, 0x68ed18a3ed262790ull, &var2393);
	// ^ Call( _2393 = "overflowing_mul"::<usize,>( 0xcc2ae48ec188e7b3 usize, 0x68ed18a3ed262790 usize, ), bb1579, bb399)
	__builtin_mul_overflow(0x2f0664b95b8b4a6full, var114, &var6140);
	// ^ Call( _6140 = "overflowing_mul"::<usize,>( 0x2f0664b95b8b4a6f usize, _114, ), bb1580, bb399)
	__builtin_add_overflow(var112, var6140, &var6141);
	// ^ Call( _6141 = "overflowing_add"::<usize,>( _112, _6140, ), bb1581, bb399)
	var2394 = var6141 >> 0x1ull;
	// ^ Call( _2394 = "unchecked_shr"::<usize,>( _6141, 0x1 usize, ), bb1582, bb399)
	var2395 = -var331;	// _2395 = UniOp(_331 NEG)
	var2396 = -var2395;	// _2396 = UniOp(_2395 NEG)
	var2397 = -var2396;	// _2397 = UniOp(_2396 NEG)
	var6144 = -var2397;	// _6144 = UniOp(_2397 NEG)
	var2398 = -var331;	// _2398 = UniOp(_331 NEG)
	var6143 = var2398 & 7596018830095093849ll;	// _6143 = BinOp(_2398 BIT_AND +7596018830095093849 i64)
	var6142 = ZRICh15overflowing_rem0g( var139, var6143 );
	// ^ Call( _6142 = <i64 /*- */>::overflowing_rem( _139, _6143, ), bb1583, bb399)
	var6145 = var6142._0 * -9185086918882086263ll;	// _6145 = BinOp(_6142.0 MUL -9185086918882086263 i64)
	__builtin_mul_overflow(var6144, var6145, &var343);
	// ^ Call( _343 = "overflowing_mul"::<i64,>( _6144, _6145, ), bb1584, bb399)
	var6146 = 0xd1 / var300;	// _6146 = BinOp(0xd1 u8 DIV _300)
	__builtin_sub_overflow(var6146, 0x65, &var344);
	// ^ Call( _344 = "overflowing_sub"::<u8,>( _6146, 0x65 u8, ), bb1585, bb399)
	var345 = 0x8a432159;	// _345 = Constant(0x8a432159 u32)
	var6149 = var276 ^ var95;	// _6149 = BinOp(_276 BIT_XOR _95)
	var6147 = var6149 & 0x3f;	// _6147 = BinOp(_6149 BIT_AND 0x3f u32)
	var6148 = (uintptr_t )var6147;	// _6148 = Cast(_6147 as usize)
	var2399 = 0xbcbde89c1e0b3291ull << var6148;
	// ^ Call( _2399 = "unchecked_shl"::<usize,>( 0xffffffffffffffffbcbde89c1e0b3291 usize, _6148, ), bb1586, bb399)
	var6156 = var27 + var2399;	// _6156 = BinOp(_27 ADD _2399)
	__builtin_add_overflow(0xc66c46e0214f1e93ull, 0x347b233c9db24086ull, &var2401);
	// ^ Call( _2401 = "overflowing_add"::<usize,>( 0xc66c46e0214f1e93 usize, 0x347b233c9db24086 usize, ), bb1587, bb399)
	var6150 = var49 & 0x3f;	// _6150 = BinOp(_49 BIT_AND 0x3f u32)
	var6151 = (uintptr_t )var6150;	// _6151 = Cast(_6150 as usize)
	var2402 = var76 >> var6151;
	// ^ Call( _2402 = "unchecked_shr"::<usize,>( _76, _6151, ), bb1588, bb399)
	var2400 = var2401 & var2402;	// _2400 = BinOp(_2401 BIT_AND _2402)
	var6152 = var95 & 0x3f;	// _6152 = BinOp(_95 BIT_AND 0x3f u32)
	var6153 = (uintptr_t )var6152;	// _6153 = Cast(_6152 as usize)
	var6154 = 0x5f3aeb88876219cbull >> var6153;
	// ^ Call( _6154 = "unchecked_shr"::<usize,>( 0x5f3aeb88876219cb usize, _6153, ), bb1589, bb399)
	__builtin_add_overflow(var284, var53, &var6155);
	// ^ Call( _6155 = "overflowing_add"::<usize,>( _284, _53, ), bb1590, bb399)
	__builtin_mul_overflow(var6154, var6155, &var2403);
	// ^ Call( _2403 = "overflowing_mul"::<usize,>( _6154, _6155, ), bb1591, bb399)
	var6157 = var2400 ^ var2403;	// _6157 = BinOp(_2400 BIT_XOR _2403)
	__builtin_sub_overflow(var6156, var6157, &var2404);
	// ^ Call( _2404 = "overflowing_sub"::<usize,>( _6156, _6157, ), bb1592, bb399)
	var346 = var2404 & var76;	// _346 = BinOp(_2404 BIT_AND _76)
	var6163 = -77;	// _6163 = Constant(-77 i8)
	var2405 = -var281;	// _2405 = UniOp(_281 NEG)
	var6159 = (uint32_t )var2405;	// _6159 = Cast(_2405 as u32)
	var2406 = (uint32_t )var70;	// _2406 = Cast(_70 as u32)
	var2407 = var41 ^ 0x55bf176c;	// _2407 = BinOp(_41 BIT_XOR 0x55bf176c u32)
	var6160 = var2406 / var2407;	// _6160 = BinOp(_2406 DIV _2407)
	var6158 = var6160 & 0x1f;	// _6158 = BinOp(_6160 BIT_AND 0x1f u32)
	var6164 = var6159 >> var6158;
	// ^ Call( _6164 = "unchecked_shr"::<u32,>( _6159, _6158, ), bb1593, bb399)
	var6161 = var6164 & 0x7;	// _6161 = BinOp(_6164 BIT_AND 0x7 u32)
	var6162 = (int8_t )var6161;	// _6162 = Cast(_6161 as i8)
	var2408 = var6163 >> var6162;
	// ^ Call( _2408 = "unchecked_shr"::<i8,>( _6163, _6162, ), bb1594, bb399)
	var6165 = var295 & 0x1f;	// _6165 = BinOp(_295 BIT_AND 0x1f u32)
	var2409 = var6 >> var6165;
	// ^ Call( _2409 = "unchecked_shr"::<u32,>( _6, _6165, ), bb1595, bb399)
	var6166 = var2409 & 0xd60947a9;	// _6166 = BinOp(_2409 BIT_AND 0xd60947a9 u32)
	__builtin_sub_overflow(var306, 0x3ae8d546, &var2410);
	// ^ Call( _2410 = "overflowing_sub"::<u32,>( _306, 0x3ae8d546 u32, ), bb1596, bb399)
	var6167 = var285 - var2410;	// _6167 = BinOp(_285 SUB _2410)
	__builtin_sub_overflow(var6166, var6167, &var6169);
	// ^ Call( _6169 = "overflowing_sub"::<u32,>( _6166, _6167, ), bb1597, bb399)
	var2411 = -var171;	// _2411 = UniOp(_171 NEG)
	var6168 = (uint32_t )var2411;	// _6168 = Cast(_2411 as u32)
	var6170 = var6168 / 0xf5d6;	// _6170 = BinOp(_6168 DIV 0xf5d6 u32)
	__builtin_add_overflow(var6169, var6170, &var347);
	// ^ Call( _347 = "overflowing_add"::<u32,>( _6169, _6170, ), bb1598, bb399)
	var6171 = var268 / var279;	// _6171 = BinOp(_268 DIV _279)
	__builtin_sub_overflow(var46, 0x8c1c, &var6172);
	// ^ Call( _6172 = "overflowing_sub"::<u16,>( _46, 0x8c1c u16, ), bb1599, bb399)
	var6173 = var6171 / var6172;	// _6173 = BinOp(_6171 DIV _6172)
	__builtin_add_overflow(var6173, 0x6d05, &var6176);
	// ^ Call( _6176 = "overflowing_add"::<u16,>( _6173, 0x6d05 u16, ), bb1600, bb399)
	__builtin_sub_overflow(var6, 0x803d35d0, &var2413);
	// ^ Call( _2413 = "overflowing_sub"::<u32,>( _6, 0x803d35d0 u32, ), bb1601, bb399)
	var2412 = var337 | var2413;	// _2412 = BinOp(_337 BIT_OR _2413)
	var6177 = var2412 ^ 0x95291f4f;	// _6177 = BinOp(_2412 BIT_XOR 0x95291f4f u32)
	var6174 = var6177 & 0xf;	// _6174 = BinOp(_6177 BIT_AND 0xf u32)
	var6175 = (uint16_t )var6174;	// _6175 = Cast(_6174 as u16)
	var6178 = var6176 >> var6175;
	// ^ Call( _6178 = "unchecked_shr"::<u16,>( _6176, _6175, ), bb1602, bb399)
	__builtin_add_overflow(0x2f5d, var6178, &var2414);
	// ^ Call( _2414 = "overflowing_add"::<u16,>( 0x2f5d u16, _6178, ), bb1603, bb399)
	var2415 = var126 << 0x7;
	// ^ Call( _2415 = "unchecked_shl"::<u8,>( _126, 0x7 u8, ), bb1604, bb399)
	var348 = 0xa046;	// _348 = Constant(0xa046 u16)
	__builtin_sub_overflow(var326, 69, &var6180);
	// ^ Call( _6180 = "overflowing_sub"::<i8,>( _326, +69 i8, ), bb1605, bb399)
	var6179 = ZRICb15overflowing_rem0g( var6180, -75 );
	// ^ Call( _6179 = <i8 /*- */>::overflowing_rem( _6180, -75 i8, ), bb1606, bb399)
	var2416 = -var6179._0;	// _2416 = UniOp(_6179.0 NEG)
	var2417 = 16 * var19;	// _2417 = BinOp(+16 i8 MUL _19)
	var2418 = -var2417;	// _2418 = UniOp(_2417 NEG)
	var2419 = -var2418;	// _2419 = UniOp(_2418 NEG)
	var6181 = var2416 * var2419;	// _6181 = BinOp(_2416 MUL _2419)
	__builtin_sub_overflow(var6181, -32, &var349);
	// ^ Call( _349 = "overflowing_sub"::<i8,>( _6181, -32 i8, ), bb1607, bb399)
	var6182 = var166 ^ 0x9a50;	// _6182 = BinOp(_166 BIT_XOR 0x9a50 u16)
	var2421 = var6182 >> 0x0;
	// ^ Call( _2421 = "unchecked_shr"::<u16,>( _6182, 0x0 u16, ), bb1608, bb399)
	var6185 = (uint16_t )var303;	// _6185 = Cast(_303 as u16)
	var6186 = var301 * var306;	// _6186 = BinOp(_301 MUL _306)
	var6183 = var6186 & 0xf;	// _6183 = BinOp(_6186 BIT_AND 0xf u32)
	var6184 = (uint16_t )var6183;	// _6184 = Cast(_6183 as u16)
	var2422 = var6185 >> var6184;
	// ^ Call( _2422 = "unchecked_shr"::<u16,>( _6185, _6184, ), bb1609, bb399)
	var2420 = var2421 - var2422;	// _2420 = BinOp(_2421 SUB _2422)
	__builtin_sub_overflow(var253, var134, &var2425);
	// ^ Call( _2425 = "overflowing_sub"::<u16,>( _253, _134, ), bb1610, bb399)
	var2426 = var263 << 0x1;
	// ^ Call( _2426 = "unchecked_shl"::<u16,>( _263, 0x1 u16, ), bb1611, bb399)
	var2424 = var2425 * var2426;	// _2424 = BinOp(_2425 MUL _2426)
	var2423 = var2424 / var167;	// _2423 = BinOp(_2424 DIV _167)
	var6187 = var2420 & var2423;	// _6187 = BinOp(_2420 BIT_AND _2423)
	var6188 = (uint16_t )var63;	// _6188 = Cast(_63 as u16)
	__builtin_sub_overflow(var6187, var6188, &var350);
	// ^ Call( _350 = "overflowing_sub"::<u16,>( _6187, _6188, ), bb1612, bb399)
	var6189 = var157 << 0x0;
	// ^ Call( _6189 = "unchecked_shl"::<u32,>( _157, 0x0 u32, ), bb1613, bb399)
	var6190 = 0xba089e2c & var285;	// _6190 = BinOp(0xba089e2c u32 BIT_AND _285)
	__builtin_add_overflow(var6189, var6190, &var2428);
	// ^ Call( _2428 = "overflowing_add"::<u32,>( _6189, _6190, ), bb1614, bb399)
	var6191 = var2 / var22;	// _6191 = BinOp(_2 DIV _22)
	var6192 = (uint32_t )var145;	// _6192 = Cast(_145 as u32)
	__builtin_sub_overflow(var6191, var6192, &var2429);
	// ^ Call( _2429 = "overflowing_sub"::<u32,>( _6191, _6192, ), bb1615, bb399)
	var2427 = var2428 / var2429;	// _2427 = BinOp(_2428 DIV _2429)
	var6193 = (uintptr_t )var2427;	// _6193 = Cast(_2427 as usize)
	var6194 = var112 % 0xa378676cc4bb42cfull;	// _6194 = BinOp(_112 MOD 0xa378676cc4bb42cf usize)
	__builtin_sub_overflow(var6193, var6194, &var2430);
	// ^ Call( _2430 = "overflowing_sub"::<usize,>( _6193, _6194, ), bb1616, bb399)
	var2431 = -838 >> 12;
	// ^ Call( _2431 = "unchecked_shr"::<i16,>( -838 i16, +12 i16, ), bb1617, bb399)
	var2432 = -var2431;	// _2432 = UniOp(_2431 NEG)
	var6196 = (uint16_t )var2432;	// _6196 = Cast(_2432 as u16)
	__builtin_mul_overflow(var121, var236, &var2433);
	// ^ Call( _2433 = "overflowing_mul"::<u16,>( _121, _236, ), bb1618, bb399)
	var2434 = 0x30fc ^ var249;	// _2434 = BinOp(0x30fc u16 BIT_XOR _249)
	var6195 = var2433 | var2434;	// _6195 = BinOp(_2433 BIT_OR _2434)
	var6197 = var6195 >> 0xc;
	// ^ Call( _6197 = "unchecked_shr"::<u16,>( _6195, 0xc u16, ), bb1619, bb399)
	__builtin_sub_overflow(var6196, var6197, &var2435);
	// ^ Call( _2435 = "overflowing_sub"::<u16,>( _6196, _6197, ), bb1620, bb399)
	var6198 = (uint16_t )var168;	// _6198 = Cast(_168 as u16)
	__builtin_mul_overflow(var305, 0xb65b, &var2437);
	// ^ Call( _2437 = "overflowing_mul"::<u16,>( _305, 0xb65b u16, ), bb1621, bb399)
	var2436 = var2437 & var268;	// _2436 = BinOp(_2437 BIT_AND _268)
	var6199 = 0x7dc8 * var2436;	// _6199 = BinOp(0x7dc8 u16 MUL _2436)
	__builtin_add_overflow(var6198, var6199, &var2438);
	// ^ Call( _2438 = "overflowing_add"::<u16,>( _6198, _6199, ), bb1622, bb399)
	var351 = var2435 - var2438;	// _351 = BinOp(_2435 SUB _2438)
	var2439 = 0xc5 - var129;	// _2439 = BinOp(0xc5 u8 SUB _129)
	var2440 = (uint16_t )var2439;	// _2440 = Cast(_2439 as u16)
	__builtin_add_overflow(0xf60affae, 0x225747f0, &var6202);
	// ^ Call( _6202 = "overflowing_add"::<u32,>( 0xf60affae u32, 0x225747f0 u32, ), bb1623, bb399)
	var6200 = var6202 & 0xf;	// _6200 = BinOp(_6202 BIT_AND 0xf u32)
	var6201 = (uint16_t )var6200;	// _6201 = Cast(_6200 as u16)
	var2441 = 0x7cc8 << var6201;
	// ^ Call( _2441 = "unchecked_shl"::<u16,>( 0x7cc8 u16, _6201, ), bb1624, bb399)
	var6211 = var2440 & var2441;	// _6211 = BinOp(_2440 BIT_AND _2441)
	__builtin_mul_overflow(0xaac71360, var176, &var6203);
	// ^ Call( _6203 = "overflowing_mul"::<u32,>( 0xaac71360 u32, _176, ), bb1625, bb399)
	var6204 = var285 / var277;	// _6204 = BinOp(_285 DIV _277)
	__builtin_add_overflow(var6203, var6204, &var6207);
	// ^ Call( _6207 = "overflowing_add"::<u32,>( _6203, _6204, ), bb1626, bb399)
	__builtin_sub_overflow(var92, 0xc7b031df, &var2442);
	// ^ Call( _2442 = "overflowing_sub"::<u32,>( _92, 0xc7b031df u32, ), bb1627, bb399)
	var6205 = var209 & 0x1f;	// _6205 = BinOp(_209 BIT_AND 0x1f u32)
	var2443 = var314 >> var6205;
	// ^ Call( _2443 = "unchecked_shr"::<u32,>( _314, _6205, ), bb1628, bb399)
	var6208 = var2442 & var2443;	// _6208 = BinOp(_2442 BIT_AND _2443)
	var6206 = var6208 & 0x1f;	// _6206 = BinOp(_6208 BIT_AND 0x1f u32)
	var6212 = var6207 >> var6206;
	// ^ Call( _6212 = "unchecked_shr"::<u32,>( _6207, _6206, ), bb1629, bb399)
	var6209 = var6212 & 0xf;	// _6209 = BinOp(_6212 BIT_AND 0xf u32)
	var6210 = (uint16_t )var6209;	// _6210 = Cast(_6209 as u16)
	var6213 = var6211 << var6210;
	// ^ Call( _6213 = "unchecked_shl"::<u16,>( _6211, _6210, ), bb1630, bb399)
	__builtin_mul_overflow(var6213, var23, &var352);
	// ^ Call( _352 = "overflowing_mul"::<u16,>( _6213, _23, ), bb1631, bb399)
	var6214 = 0xa5878dd8 & var47;	// _6214 = BinOp(0xa5878dd8 u32 BIT_AND _47)
	__builtin_add_overflow(var177, var41, &var2445);
	// ^ Call( _2445 = "overflowing_add"::<u32,>( _177, _41, ), bb1632, bb399)
	var6215 = var2445 | 0xb98d361e;	// _6215 = BinOp(_2445 BIT_OR 0xb98d361e u32)
	__builtin_sub_overflow(var6214, var6215, &var2446);
	// ^ Call( _2446 = "overflowing_sub"::<u32,>( _6214, _6215, ), bb1633, bb399)
	var2447 = 0x6 * var11;	// _2447 = BinOp(0x6 u16 MUL _11)
	var2448 = (uint32_t )var2447;	// _2448 = Cast(_2447 as u32)
	var2444 = var2446 & var2448;	// _2444 = BinOp(_2446 BIT_AND _2448)
	var353 = var225 - var2444;	// _353 = BinOp(_225 SUB _2444)
	var354 = 0x9e67;	// _354 = Constant(0x9e67 u16)
	var2449 = 8031857309552912740ll * var148;	// _2449 = BinOp(+8031857309552912740 i64 MUL _148)
	var2450 = -var2449;	// _2450 = UniOp(_2449 NEG)
	var355 = -var2450;	// _355 = UniOp(_2450 NEG)
	__builtin_mul_overflow(0x68e1, var278, &var2451);
	// ^ Call( _2451 = "overflowing_mul"::<u16,>( 0x68e1 u16, _278, ), bb1634, bb399)
	var6218 = var2451 + var288;	// _6218 = BinOp(_2451 ADD _288)
	__builtin_mul_overflow(var34, 0x4d406a9a, &var2452);
	// ^ Call( _2452 = "overflowing_mul"::<u32,>( _34, 0x4d406a9a u32, ), bb1635, bb399)
	var6219 = var330 * var2452;	// _6219 = BinOp(_330 MUL _2452)
	var6216 = var6219 & 0xf;	// _6216 = BinOp(_6219 BIT_AND 0xf u32)
	var6217 = (uint16_t )var6216;	// _6217 = Cast(_6216 as u16)
	var2453 = var6218 >> var6217;
	// ^ Call( _2453 = "unchecked_shr"::<u16,>( _6218, _6217, ), bb1636, bb399)
	__builtin_sub_overflow(var131, var236, &var6221);
	// ^ Call( _6221 = "overflowing_sub"::<u16,>( _131, _236, ), bb1637, bb399)
	__builtin_sub_overflow(0x164a, 0x82b6, &var6220);
	// ^ Call( _6220 = "overflowing_sub"::<u16,>( 0x164a u16, 0x82b6 u16, ), bb1638, bb399)
	__builtin_mul_overflow(0x7e2f, var6220, &var6222);
	// ^ Call( _6222 = "overflowing_mul"::<u16,>( 0x7e2f u16, _6220, ), bb1639, bb399)
	var2454 = var253 + 0x6f68;	// _2454 = BinOp(_253 ADD 0x6f68 u16)
	var6223 = 0x3bae / var2454;	// _6223 = BinOp(0x3bae u16 DIV _2454)
	__builtin_mul_overflow(var45, var6223, &var2455);
	// ^ Call( _2455 = "overflowing_mul"::<u16,>( _45, _6223, ), bb1640, bb399)
	var2456 = var329 - -96;	// _2456 = BinOp(_329 SUB -96 i8)
	var6227 = var119 & var2456;	// _6227 = BinOp(_119 BIT_AND _2456)
	var6224 = (uint32_t )var195;	// _6224 = Cast(_195 as u32)
	var6228 = 0x41 / var6224;	// _6228 = BinOp(0x41 u32 DIV _6224)
	var6225 = var6228 & 0x7;	// _6225 = BinOp(_6228 BIT_AND 0x7 u32)
	var6226 = (int8_t )var6225;	// _6226 = Cast(_6225 as i8)
	var2457 = var6227 << var6226;
	// ^ Call( _2457 = "unchecked_shl"::<i8,>( _6227, _6226, ), bb1641, bb399)
	var6232 = -var2457;	// _6232 = UniOp(_2457 NEG)
	var6229 = var141 & 0xf;	// _6229 = BinOp(_141 BIT_AND 0xf u32)
	var6230 = (uint16_t )var6229;	// _6230 = Cast(_6229 as u16)
	var2460 = 0xc048 >> var6230;
	// ^ Call( _2460 = "unchecked_shr"::<u16,>( 0xc048 u16, _6230, ), bb1642, bb399)
	var2461 = var214 + 0x83b7;	// _2461 = BinOp(_214 ADD 0x83b7 u16)
	var2459 = var2460 - var2461;	// _2459 = BinOp(_2460 SUB _2461)
	var2458 = var2459 & 0x671a;	// _2458 = BinOp(_2459 BIT_AND 0x671a u16)
	var6233 = (int8_t )var2458;	// _6233 = Cast(_2458 as i8)
	var6231 = ZRICb15overflowing_div0g( var6232, var6233 );
	// ^ Call( _6231 = <i8 /*- */>::overflowing_div( _6232, _6233, ), bb1643, bb399)
	var6234 = var67 & 0xf;	// _6234 = BinOp(_67 BIT_AND 0xf u32)
	var6235 = (uint16_t )var6234;	// _6235 = Cast(_6234 as u16)
	var6236 = 0xffef << var6235;
	// ^ Call( _6236 = "unchecked_shl"::<u16,>( 0xffef u16, _6235, ), bb1644, bb399)
	var6237 = var6236 / 0xbef0;	// _6237 = BinOp(_6236 DIV 0xbef0 u16)
	var2462 = 0x8aea % var68;	// _2462 = BinOp(0x8aea u16 MOD _68)
	var6238 = var2462 | 0xa6a8;	// _6238 = BinOp(_2462 BIT_OR 0xa6a8 u16)
	__builtin_sub_overflow(var6237, var6238, &var2463);
	// ^ Call( _2463 = "overflowing_sub"::<u16,>( _6237, _6238, ), bb1645, bb399)
	__builtin_add_overflow(-958735765347794710ll, 1497512612410636756ll, &var2464);
	// ^ Call( _2464 = "overflowing_add"::<isize,>( -958735765347794710 isize, +1497512612410636756 isize, ), bb1646, bb399)
	var356 = -var2464;	// _356 = UniOp(_2464 NEG)
	__builtin_mul_overflow(-4774281415815364222ll, var195, &var2465);
	// ^ Call( _2465 = "overflowing_mul"::<i64,>( -4774281415815364222 i64, _195, ), bb1647, bb399)
	var357 = 21133;	// _357 = Constant(-44403 i16)
	var6244 = -24569;	// _6244 = Constant(-24569 i16)
	var6241 = -var60;	// _6241 = UniOp(_60 NEG)
	var6242 = var330 / var285;	// _6242 = BinOp(_330 DIV _285)
	var6239 = var6242 & 0xf;	// _6239 = BinOp(_6242 BIT_AND 0xf u32)
	var6240 = (int16_t )var6239;	// _6240 = Cast(_6239 as i16)
	var6243 = var6241 >> var6240;
	// ^ Call( _6243 = "unchecked_shr"::<i16,>( _6241, _6240, ), bb1648, bb399)
	var6245 = var6243 << 6;
	// ^ Call( _6245 = "unchecked_shl"::<i16,>( _6243, +6 i16, ), bb1649, bb399)
	__builtin_mul_overflow(var6244, var6245, &var6248);
	// ^ Call( _6248 = "overflowing_mul"::<i16,>( _6244, _6245, ), bb1650, bb399)
	var2467 = 25146;	// _2467 = Constant(+10374086724362854970 i16)
	var6246 = var277 & 0xf;	// _6246 = BinOp(_277 BIT_AND 0xf u32)
	var6247 = (int16_t )var6246;	// _6247 = Cast(_6246 as i16)
	var2468 = var254 << var6247;
	// ^ Call( _2468 = "unchecked_shl"::<i16,>( _254, _6247, ), bb1651, bb399)
	var2466 = var2467 / var2468;	// _2466 = BinOp(_2467 DIV _2468)
	var2470 = -var50;	// _2470 = UniOp(_50 NEG)
	__builtin_sub_overflow(-3810, var16, &var2471);
	// ^ Call( _2471 = "overflowing_sub"::<i16,>( -3810 i16, _16, ), bb1652, bb399)
	var2472 = -var2471;	// _2472 = UniOp(_2471 NEG)
	var2469 = var2470 + var2472;	// _2469 = BinOp(_2470 ADD _2472)
	var6249 = var2466 - var2469;	// _6249 = BinOp(_2466 SUB _2469)
	__builtin_add_overflow(var6248, var6249, &var2473);
	// ^ Call( _2473 = "overflowing_add"::<i16,>( _6248, _6249, ), bb1653, bb399)
	add128_o(var82, make128_raw(15349652249298686916ull, 2123634982430611038ull), &var2475);
	// ^ Call( _2475 = "overflowing_add"::<u128,>( _82, 0xd504eb65113953c41d78aac3d85e965e u128, ), bb1654, bb399)
	var2476 = xor128(make128_raw(12223990178948197087ull, 9938967113337714220ull), var144);	// _2476 = BinOp(0xa9a4564d62122adf89ee4dee40c8b62c u128 BIT_XOR _144)
	var2474 = and128(var2475, var2476);	// _2474 = BinOp(_2475 BIT_AND _2476)
	mul128_o(var160, var339, &var2478);
	// ^ Call( _2478 = "overflowing_mul"::<u128,>( _160, _339, ), bb1655, bb399)
	var2479 = sub128(make128_raw(17649575788500825267ull, 7755345387824954686ull), var57);	// _2479 = BinOp(0xf4efe3ab0ded34b36ba0858a67c53d3e u128 SUB _57)
	var2477 = div128(var2478, var2479);	// _2477 = BinOp(_2478 DIV _2479)
	var6252 = sub128(var2474, var2477);	// _6252 = BinOp(_2474 SUB _2477)
	var6250 = var47 & 0x7f;	// _6250 = BinOp(_47 BIT_AND 0x7f u32)
	var6251.lo = var6250; var6251.hi = var6250 < 0 ? -1 : 0;	// _6251 = Cast(_6250 as u128)
	var6253 = shl128(var6252, var6251.lo);
	// ^ Call( _6253 = "unchecked_shl"::<u128,>( _6252, _6251, ), bb1656, bb399)
	var2480 = shl128(var6253, make128_raw(0ull, 29ull).lo);
	// ^ Call( _2480 = "unchecked_shl"::<u128,>( _6253, 0x1d u128, ), bb1657, bb399)
	var2481 = -var44;	// _2481 = UniOp(_44 NEG)
	var6255 = -var2481;	// _6255 = UniOp(_2481 NEG)
	var6254 = ZRICd15overflowing_div0g( var6255, 14204 );
	// ^ Call( _6254 = <i16 /*- */>::overflowing_div( _6255, +14204 i16, ), bb1658, bb399)
	var2482 = 2334;	// _2482 = Constant(+2334 i16)
	var6256 = ZRICd15overflowing_rem0g( var291, -16367 );
	// ^ Call( _6256 = <i16 /*- */>::overflowing_rem( _291, -16367 i16, ), bb1659, bb399)
	var6257 = var2482 & var6256._0;	// _6257 = BinOp(_2482 BIT_AND _6256.0)
	var6258 = -var13;	// _6258 = UniOp(_13 NEG)
	__builtin_mul_overflow(var6257, var6258, &var2483);
	// ^ Call( _2483 = "overflowing_mul"::<i16,>( _6257, _6258, ), bb1660, bb399)
	__builtin_mul_overflow(0xdf, var54, &var6259);
	// ^ Call( _6259 = "overflowing_mul"::<u8,>( 0xdf u8, _54, ), bb1661, bb399)
	var2484 = var34 << 0x14;
	// ^ Call( _2484 = "unchecked_shl"::<u32,>( _34, 0x14 u32, ), bb1662, bb399)
	var6262 = var41 & var2484;	// _6262 = BinOp(_41 BIT_AND _2484)
	var6260 = var6262 & 0xf;	// _6260 = BinOp(_6262 BIT_AND 0xf u32)
	var6261 = (uint16_t )var6260;	// _6261 = Cast(_6260 as u16)
	var2485 = var17 >> var6261;
	// ^ Call( _2485 = "unchecked_shr"::<u16,>( _17, _6261, ), bb1663, bb399)
	var358 = false;	// _358 = Constant(false)
	var6263 = mul128(var308, make128_raw(14296798151860895719ull, 7372156129282361896ull));	// _6263 = BinOp(_308 MUL 0xc6686e2be3213fe7664f28f0b2980a28 u128)
	sub128_o(make128_raw(3027383147394142510ull, 15489336355071524985ull), make128_raw(17441908494475749230ull, 18050502348076924795ull), &var6264);
	// ^ Call( _6264 = "overflowing_sub"::<u128,>( 0x2a036ceecb6e912ed6f52d5952950079 u128, 0xf20e1b5d5218676efa80443ffa7abf7b u128, ), bb1664, bb399)
	var2487 = div128(var6263, var6264);	// _2487 = BinOp(_6263 DIV _6264)
	var6265.lo = var60; var6265.hi = var60 < 0 ? -1 : 0;	// _6265 = Cast(_60 as u128)
	mul128_o(var6265, var132, &var2488);
	// ^ Call( _2488 = "overflowing_mul"::<u128,>( _6265, _132, ), bb1665, bb399)
	var2486 = mul128(var2487, var2488);	// _2486 = BinOp(_2487 MUL _2488)
	var2491.lo = var23; var2491.hi = var23 < 0 ? -1 : 0;	// _2491 = Cast(_23 as u128)
	var2490 = or128(var2491, var339);	// _2490 = BinOp(_2491 BIT_OR _339)
	var2492 = mul128(make128_raw(0ull, 144843343ull), var280);	// _2492 = BinOp(0x8a2224f u128 MUL _280)
	var2489 = mul128(var2490, var2492);	// _2489 = BinOp(_2490 MUL _2492)
	var6268 = sub128(var2486, var2489);	// _6268 = BinOp(_2486 SUB _2489)
	var2495 = var127 & var71;	// _2495 = BinOp(_127 BIT_AND _71)
	var2494 = var208 / var2495;	// _2494 = BinOp(_208 DIV _2495)
	var2496 = 0x1f509b61 << 0x7;
	// ^ Call( _2496 = "unchecked_shl"::<u32,>( 0x1f509b61 u32, 0x7 u32, ), bb1666, bb399)
	var2493 = var2494 & var2496;	// _2493 = BinOp(_2494 BIT_AND _2496)
	var6269 = var193 - var2493;	// _6269 = BinOp(_193 SUB _2493)
	var6266 = var6269 & 0x7f;	// _6266 = BinOp(_6269 BIT_AND 0x7f u32)
	var6267.lo = var6266; var6267.hi = var6266 < 0 ? -1 : 0;	// _6267 = Cast(_6266 as u128)
	var359 = shr128(var6268, var6267.lo);
	// ^ Call( _359 = "unchecked_shr"::<u128,>( _6268, _6267, ), bb1667, bb399)
	var360 = var308;	// _360 = Use(_308)
	var2497 = -12639 + var272;	// _2497 = BinOp(-12639 i16 ADD _272)
	var6270 = (uint32_t )var2497;	// _6270 = Cast(_2497 as u32)
	__builtin_mul_overflow(var41, 0xea0134ed, &var2498);
	// ^ Call( _2498 = "overflowing_mul"::<u32,>( _41, 0xea0134ed u32, ), bb1668, bb399)
	var6271 = var2498 ^ var176;	// _6271 = BinOp(_2498 BIT_XOR _176)
	__builtin_mul_overflow(var6270, var6271, &var6274);
	// ^ Call( _6274 = "overflowing_mul"::<u32,>( _6270, _6271, ), bb1669, bb399)
	var6272 = var6274 & 0x3f;	// _6272 = BinOp(_6274 BIT_AND 0x3f u32)
	var6273 = (intptr_t )var6272;	// _6273 = Cast(_6272 as isize)
	var6275 = var262 << var6273;
	// ^ Call( _6275 = "unchecked_shl"::<isize,>( _262, _6273, ), bb1670, bb399)
	__builtin_mul_overflow(var174, 2282743891546244497ll, &var2500);
	// ^ Call( _2500 = "overflowing_mul"::<isize,>( _174, +2282743891546244497 isize, ), bb1671, bb399)
	var2501 = -var2500;	// _2501 = UniOp(_2500 NEG)
	var2499 = var2501 * var32;	// _2499 = BinOp(_2501 MUL _32)
	var6276 = -var2499;	// _6276 = UniOp(_2499 NEG)
	__builtin_mul_overflow(var6275, var6276, &var2502);
	// ^ Call( _2502 = "overflowing_mul"::<isize,>( _6275, _6276, ), bb1672, bb399)
	var6278 = 0xb339dada / var285;	// _6278 = BinOp(0xb339dada u32 DIV _285)
	var6277 = var6278 & 0x1f;	// _6277 = BinOp(_6278 BIT_AND 0x1f u32)
	var6279 = var61 >> var6277;
	// ^ Call( _6279 = "unchecked_shr"::<u32,>( _61, _6277, ), bb1673, bb399)
	__builtin_add_overflow(var6279, var157, &var6282);
	// ^ Call( _6282 = "overflowing_add"::<u32,>( _6279, _157, ), bb1674, bb399)
	var6280 = var6282 & 0x7f;	// _6280 = BinOp(_6282 BIT_AND 0x7f u32)
	var6281.lo = var6280; var6281.hi = var6280 < 0 ? -1 : 0;	// _6281 = Cast(_6280 as i128)
	var6283 = shl128s(make128s_raw(3349456331016400445ull, 107127631838755560ull), var6281.lo);
	// ^ Call( _6283 = "unchecked_shl"::<i128,>( +61786563724325723127099557975091624680 i128, _6281, ), bb1675, bb399)
	var361 = shr128s(var6283, make128s_raw(0ull, 88ull).lo);
	// ^ Call( _361 = "unchecked_shr"::<i128,>( _6283, +88 i128, ), bb1676, bb399)
	var2503 = var192 / 0x13fffec9d5d6f6cfull;	// _2503 = BinOp(_192 DIV 0x13fffec9d5d6f6cf u64)
	var2504 = var31 / 0x986ac1c71b4e4882ull;	// _2504 = BinOp(_31 DIV 0x986ac1c71b4e4882 u64)
	var6284 = var2503 + var2504;	// _6284 = BinOp(_2503 ADD _2504)
	__builtin_mul_overflow(var271, var6284, &var2505);
	// ^ Call( _2505 = "overflowing_mul"::<u64,>( _271, _6284, ), bb1677, bb399)
	var6285 = 0x152bc98ba06141edull | var2505;	// _6285 = BinOp(0x152bc98ba06141ed u64 BIT_OR _2505)
	__builtin_add_overflow(var6285, var138, &var2506);
	// ^ Call( _2506 = "overflowing_add"::<u64,>( _6285, _138, ), bb1678, bb399)
	var2507 = var65.lo;	// _2507 = Cast(_65 as i32)
	var6288 = var122 + var2507;	// _6288 = BinOp(_122 ADD _2507)
	var6286 = var217 - var158;	// _6286 = BinOp(_217 SUB _158)
	var2509 = var6286 << 0;
	// ^ Call( _2509 = "unchecked_shl"::<i32,>( _6286, +0 i32, ), bb1679, bb399)
	__builtin_add_overflow(1996950973, var125, &var2511);
	// ^ Call( _2511 = "overflowing_add"::<i32,>( +1996950973 i32, _125, ), bb1680, bb399)
	var6287 = ZRICf15overflowing_div0g( 1205115507, 721155823 );
	// ^ Call( _6287 = <i32 /*- */>::overflowing_div( +1205115507 i32, +721155823 i32, ), bb1681, bb399)
	var2510 = var2511 & var6287._0;	// _2510 = BinOp(_2511 BIT_AND _6287.0)
	var2508 = var2509 * var2510;	// _2508 = BinOp(_2509 MUL _2510)
	var6289 = -var2508;	// _6289 = UniOp(_2508 NEG)
	__builtin_mul_overflow(var6288, var6289, &var362);
	// ^ Call( _362 = "overflowing_mul"::<i32,>( _6288, _6289, ), bb1682, bb399)
	var6290 = 0xe1 % var130;	// _6290 = BinOp(0xe1 u8 MOD _130)
	var6291 = var197 * var175;	// _6291 = BinOp(_197 MUL _175)
	__builtin_mul_overflow(var6290, var6291, &var2512);
	// ^ Call( _2512 = "overflowing_mul"::<u8,>( _6290, _6291, ), bb1683, bb399)
	var6294 = var2512 | var120;	// _6294 = BinOp(_2512 BIT_OR _120)
	var6292 = var159 * 0x7;	// _6292 = BinOp(_159 MUL 0x7 u8)
	var6293 = var344 + var117;	// _6293 = BinOp(_344 ADD _117)
	__builtin_sub_overflow(var6292, var6293, &var2513);
	// ^ Call( _2513 = "overflowing_sub"::<u8,>( _6292, _6293, ), bb1684, bb399)
	var6295 = var2513 + 0x3;	// _6295 = BinOp(_2513 ADD 0x3 u8)
	var6297 = var6294 / var6295;	// _6297 = BinOp(_6294 DIV _6295)
	var6296 = ZRICf15overflowing_rem0g( 5, -1406531094 );
	// ^ Call( _6296 = <i32 /*- */>::overflowing_rem( +5 i32, -1406531094 i32, ), bb1685, bb399)
	var6298 = (uint8_t )var6296._0;	// _6298 = Cast(_6296.0 as u8)
	__builtin_mul_overflow(var6297, var6298, &var363);
	// ^ Call( _363 = "overflowing_mul"::<u8,>( _6297, _6298, ), bb1686, bb399)
	var2514 = (uint16_t )var315;	// _2514 = Cast(_315 as u16)
	__builtin_mul_overflow(0xca90, var134, &var2515);
	// ^ Call( _2515 = "overflowing_mul"::<u16,>( 0xca90 u16, _134, ), bb1687, bb399)
	var6299 = var2514 * var2515;	// _6299 = BinOp(_2514 MUL _2515)
	__builtin_mul_overflow(var6299, 0x0, &var6300);
	// ^ Call( _6300 = "overflowing_mul"::<u16,>( _6299, 0x0 u16, ), bb1688, bb399)
	var6301 = (uint16_t )var52;	// _6301 = Cast(_52 as u16)
	__builtin_sub_overflow(var6300, var6301, &var6302);
	// ^ Call( _6302 = "overflowing_sub"::<u16,>( _6300, _6301, ), bb1689, bb399)
	__builtin_mul_overflow(var46, var6302, &var2516);
	// ^ Call( _2516 = "overflowing_mul"::<u16,>( _46, _6302, ), bb1690, bb399)
	var6305 = and128(var324, make128_raw(9894514993944212835ull, 11922745377634221782ull));	// _6305 = BinOp(_324 BIT_AND 0x895060f6aed23563a57619c065517ed6 u128)
	__builtin_sub_overflow(0xbb938177, 0xb78566db, &var6306);
	// ^ Call( _6306 = "overflowing_sub"::<u32,>( 0xbb938177 u32, 0xb78566db u32, ), bb1691, bb399)
	var6303 = var6306 & 0x7f;	// _6303 = BinOp(_6306 BIT_AND 0x7f u32)
	var6304.lo = var6303; var6304.hi = var6303 < 0 ? -1 : 0;	// _6304 = Cast(_6303 as u128)
	var2517 = shr128(var6305, var6304.lo);
	// ^ Call( _2517 = "unchecked_shr"::<u128,>( _6305, _6304, ), bb1692, bb399)
	var2518 = var2517.lo;	// _2518 = Cast(_2517 as i16)
	var6312 = (uint8_t )var2518;	// _6312 = Cast(_2518 as u8)
	var6310 = (uint8_t )var224;	// _6310 = Cast(_224 as u8)
	var6309 = var130 / 0x1b;	// _6309 = BinOp(_130 DIV 0x1b u8)
	var6307 = var345 & 0x7;	// _6307 = BinOp(_345 BIT_AND 0x7 u32)
	var6308 = (uint8_t )var6307;	// _6308 = Cast(_6307 as u8)
	var2519 = var6309 >> var6308;
	// ^ Call( _2519 = "unchecked_shr"::<u8,>( _6309, _6308, ), bb1693, bb399)
	var2521 = var175 / var97;	// _2521 = BinOp(_175 DIV _97)
	var2520 = var2521 ^ 0x0;	// _2520 = BinOp(_2521 BIT_XOR 0x0 u8)
	var6311 = var2519 * var2520;	// _6311 = BinOp(_2519 MUL _2520)
	__builtin_sub_overflow(var6310, var6311, &var6313);
	// ^ Call( _6313 = "overflowing_sub"::<u8,>( _6310, _6311, ), bb1694, bb399)
	__builtin_mul_overflow(var6312, var6313, &var2522);
	// ^ Call( _2522 = "overflowing_mul"::<u8,>( _6312, _6313, ), bb1695, bb399)
	var2525 = (int32_t )var346;	// _2525 = Cast(_346 as i32)
	var2524 = 538960490 / var2525;	// _2524 = BinOp(+538960490 i32 DIV _2525)
	var2523 = var2524 / 787817570;	// _2523 = BinOp(_2524 DIV +787817570 i32)
	var364 = var2523 ^ 0;	// _364 = BinOp(_2523 BIT_XOR +0 i32)
	var6316 = var327 / var178;	// _6316 = BinOp(_327 DIV _178)
	var6317 = var247 % 0xd3a677ec;	// _6317 = BinOp(_247 MOD 0xd3a677ec u32)
	var6314 = var6317 & 0x7;	// _6314 = BinOp(_6317 BIT_AND 0x7 u32)
	var6315 = (uint8_t )var6314;	// _6315 = Cast(_6314 as u8)
	var6318 = var6316 << var6315;
	// ^ Call( _6318 = "unchecked_shl"::<u8,>( _6316, _6315, ), bb1696, bb399)
	var2526 = var340 / 0x80;	// _2526 = BinOp(_340 DIV 0x80 u8)
	var6319 = var2526 & 0x2b;	// _6319 = BinOp(_2526 BIT_AND 0x2b u8)
	__builtin_sub_overflow(var6318, var6319, &var6320);
	// ^ Call( _6320 = "overflowing_sub"::<u8,>( _6318, _6319, ), bb1697, bb399)
	__builtin_mul_overflow(var6320, 0x12, &var6325);
	// ^ Call( _6325 = "overflowing_mul"::<u8,>( _6320, 0x12 u8, ), bb1698, bb399)
	var2527 = 0xe6ce1f42 - var163;	// _2527 = BinOp(0xe6ce1f42 u32 SUB _163)
	var6321 = 0xeec2468c / var2527;	// _6321 = BinOp(0xeec2468c u32 DIV _2527)
	__builtin_add_overflow(var6321, 0x1a, &var6322);
	// ^ Call( _6322 = "overflowing_add"::<u32,>( _6321, 0x1a u32, ), bb1699, bb399)
	var6326 = var6322 >> 0x1;
	// ^ Call( _6326 = "unchecked_shr"::<u32,>( _6322, 0x1 u32, ), bb1700, bb399)
	var6323 = var6326 & 0x7;	// _6323 = BinOp(_6326 BIT_AND 0x7 u32)
	var6324 = (uint8_t )var6323;	// _6324 = Cast(_6323 as u8)
	var365 = var6325 << var6324;
	// ^ Call( _365 = "unchecked_shl"::<u8,>( _6325, _6324, ), bb1701, bb399)
	var6327 = var98 / 0xac2;	// _6327 = BinOp(_98 DIV 0xac2 u16)
	__builtin_sub_overflow(0x145a, var6327, &var2528);
	// ^ Call( _2528 = "overflowing_sub"::<u16,>( 0x145a u16, _6327, ), bb1702, bb399)
	var6331 = var2528 * var134;	// _6331 = BinOp(_2528 MUL _134)
	__builtin_sub_overflow(0x8021, 0x352a, &var2529);
	// ^ Call( _2529 = "overflowing_sub"::<u16,>( 0x8021 u16, 0x352a u16, ), bb1703, bb399)
	var6328 = var2529 + var11;	// _6328 = BinOp(_2529 ADD _11)
	var2530 = (uint32_t )var1;	// _2530 = Cast(_1 as u32)
	var6329 = (uint16_t )var2530;	// _6329 = Cast(_2530 as u16)
	__builtin_sub_overflow(var6328, var6329, &var2531);
	// ^ Call( _2531 = "overflowing_sub"::<u16,>( _6328, _6329, ), bb1704, bb399)
	__builtin_sub_overflow(0xfba8, 0xddbd, &var6330);
	// ^ Call( _6330 = "overflowing_sub"::<u16,>( 0xfba8 u16, 0xddbd u16, ), bb1705, bb399)
	__builtin_mul_overflow(0x7a1f, var6330, &var2533);
	// ^ Call( _2533 = "overflowing_mul"::<u16,>( 0x7a1f u16, _6330, ), bb1706, bb399)
	var2534 = (uint16_t )var47;	// _2534 = Cast(_47 as u16)
	var2532 = var2533 ^ var2534;	// _2532 = BinOp(_2533 BIT_XOR _2534)
	var6332 = var2531 + var2532;	// _6332 = BinOp(_2531 ADD _2532)
	var366 = var6331 / var6332;	// _366 = BinOp(_6331 DIV _6332)
	var6333 = var285 & 0x1f;	// _6333 = BinOp(_285 BIT_AND 0x1f u32)
	var2536 = 0x96f79a32 << var6333;
	// ^ Call( _2536 = "unchecked_shl"::<u32,>( 0x96f79a32 u32, _6333, ), bb1707, bb399)
	var2535 = 0x2663828c ^ var2536;	// _2535 = BinOp(0x2663828c u32 BIT_XOR _2536)
	__builtin_mul_overflow(0xbd7383e5, 0xb95a83d4, &var2537);
	// ^ Call( _2537 = "overflowing_mul"::<u32,>( 0xbd7383e5 u32, 0xb95a83d4 u32, ), bb1708, bb399)
	var6335 = var2535 & var2537;	// _6335 = BinOp(_2535 BIT_AND _2537)
	var6334 = var6335 & 0x1f;	// _6334 = BinOp(_6335 BIT_AND 0x1f u32)
	var2538 = 0x868814f2 << var6334;
	// ^ Call( _2538 = "unchecked_shl"::<u32,>( 0x868814f2 u32, _6334, ), bb1709, bb399)
	var367 = -5288030192881439595ll;	// _367 = Constant(-5288030192881439595 i64)
	var368 = var17 ^ 0x6075;	// _368 = BinOp(_17 BIT_XOR 0x6075 u16)
	var6338 = var232 & 0x3e0eb0bc473ffa63ull;	// _6338 = BinOp(_232 BIT_AND 0x3e0eb0bc473ffa63 usize)
	var6336 = var247 & 0x3f;	// _6336 = BinOp(_247 BIT_AND 0x3f u32)
	var6337 = (uintptr_t )var6336;	// _6337 = Cast(_6336 as usize)
	var6339 = var346 << var6337;
	// ^ Call( _6339 = "unchecked_shl"::<usize,>( _346, _6337, ), bb1710, bb399)
	__builtin_add_overflow(var6338, var6339, &var6344);
	// ^ Call( _6344 = "overflowing_add"::<usize,>( _6338, _6339, ), bb1711, bb399)
	var6340 = var247 + 0x22a03ddb;	// _6340 = BinOp(_247 ADD 0x22a03ddb u32)
	var6341 = var194.lo;	// _6341 = Cast(_194 as u32)
	__builtin_sub_overflow(var6340, var6341, &var6345);
	// ^ Call( _6345 = "overflowing_sub"::<u32,>( _6340, _6341, ), bb1712, bb399)
	var6342 = var6345 & 0x3f;	// _6342 = BinOp(_6345 BIT_AND 0x3f u32)
	var6343 = (uintptr_t )var6342;	// _6343 = Cast(_6342 as usize)
	var2539 = var6344 << var6343;
	// ^ Call( _2539 = "unchecked_shl"::<usize,>( _6344, _6343, ), bb1713, bb399)
	var2540 = (int32_t )var2539;	// _2540 = Cast(_2539 as i32)
	var369 = var2540 + 661452613;	// _369 = BinOp(_2540 ADD +661452613 i32)
	var6351 = 0xf8 * var180;	// _6351 = BinOp(0xf8 u8 MUL _180)
	__builtin_sub_overflow(0xdfede823, var141, &var2541);
	// ^ Call( _2541 = "overflowing_sub"::<u32,>( 0xdfede823 u32, _141, ), bb1714, bb399)
	var6346 = var2541 - 0x845c9816;	// _6346 = BinOp(_2541 SUB 0x845c9816 u32)
	var2542 = var108 ^ 0x40d122d7;	// _2542 = BinOp(_108 BIT_XOR 0x40d122d7 u32)
	var6347 = var345 | var2542;	// _6347 = BinOp(_345 BIT_OR _2542)
	__builtin_sub_overflow(var6346, var6347, &var6348);
	// ^ Call( _6348 = "overflowing_sub"::<u32,>( _6346, _6347, ), bb1715, bb399)
	var6352 = var6348 >> 0xd;
	// ^ Call( _6352 = "unchecked_shr"::<u32,>( _6348, 0xd u32, ), bb1716, bb399)
	var6349 = var6352 & 0x7;	// _6349 = BinOp(_6352 BIT_AND 0x7 u32)
	var6350 = (uint8_t )var6349;	// _6350 = Cast(_6349 as u8)
	var2543 = var6351 >> var6350;
	// ^ Call( _2543 = "unchecked_shr"::<u8,>( _6351, _6350, ), bb1717, bb399)
	var370 = var302;	// _370 = Use(_302)
	__builtin_add_overflow(0x40c6a359, 0x5de86a31, &var2545);
	// ^ Call( _2545 = "overflowing_add"::<u32,>( 0x40c6a359 u32, 0x5de86a31 u32, ), bb1718, bb399)
	var2546 = (uint16_t )var2545;	// _2546 = Cast(_2545 as u16)
	var6353 = var299 * 0x62a8;	// _6353 = BinOp(_299 MUL 0x62a8 u16)
	__builtin_sub_overflow(var6353, 0x9cbf, &var2547);
	// ^ Call( _2547 = "overflowing_sub"::<u16,>( _6353, 0x9cbf u16, ), bb1719, bb399)
	var2544 = var2546 / var2547;	// _2544 = BinOp(_2546 DIV _2547)
	var6354 = var2544 ^ var154;	// _6354 = BinOp(_2544 BIT_XOR _154)
	__builtin_sub_overflow(var166, var6354, &var2548);
	// ^ Call( _2548 = "overflowing_sub"::<u16,>( _166, _6354, ), bb1720, bb399)
	var2549 = (uint8_t )var152;	// _2549 = Cast(_152 as u8)
	var2550 = (int32_t )var2549;	// _2550 = Cast(_2549 as i32)
	var2551 = -var2550;	// _2551 = UniOp(_2550 NEG)
	var6355 = ZRICf15overflowing_rem0g( -594571305, 609594808 );
	// ^ Call( _6355 = <i32 /*- */>::overflowing_rem( -594571305 i32, +609594808 i32, ), bb1721, bb399)
	var2552 = -var240;	// _2552 = UniOp(_240 NEG)
	var2553 = (int32_t )var234;	// _2553 = Cast(_234 as i32)
	var6356 = var2552 ^ var2553;	// _6356 = BinOp(_2552 BIT_XOR _2553)
	__builtin_mul_overflow(var6355._0, var6356, &var6357);
	// ^ Call( _6357 = "overflowing_mul"::<i32,>( _6355.0, _6356, ), bb1722, bb399)
	__builtin_add_overflow(var238, var6357, &var2554);
	// ^ Call( _2554 = "overflowing_add"::<i32,>( _238, _6357, ), bb1723, bb399)
	var371 = var2551 - var2554;	// _371 = BinOp(_2551 SUB _2554)
	var2555 = var275 * var81;	// _2555 = BinOp(_275 MUL _81)
	var6359 = (uint32_t )var2555;	// _6359 = Cast(_2555 as u32)
	var2556 = var250.lo;	// _2556 = Cast(_250 as u32)
	var2557 = 0x751dc10 | var141;	// _2557 = BinOp(0x751dc10 u32 BIT_OR _141)
	var6360 = var2556 ^ var2557;	// _6360 = BinOp(_2556 BIT_XOR _2557)
	var6358 = var6360 & 0x1f;	// _6358 = BinOp(_6360 BIT_AND 0x1f u32)
	var2558 = var6359 << var6358;
	// ^ Call( _2558 = "unchecked_shl"::<u32,>( _6359, _6358, ), bb1724, bb399)
	var6361 = var25 & 0x1f;	// _6361 = BinOp(_25 BIT_AND 0x1f u32)
	var6362 = 0x56156de4 << var6361;
	// ^ Call( _6362 = "unchecked_shl"::<u32,>( 0x56156de4 u32, _6361, ), bb1725, bb399)
	var6364 = (uint32_t )var223;	// _6364 = Cast(_223 as u32)
	var2559 = var61 / var51;	// _2559 = BinOp(_61 DIV _51)
	var2560 = var168 / 0xd4d58f5c;	// _2560 = BinOp(_168 DIV 0xd4d58f5c u32)
	var6365 = var2559 * var2560;	// _6365 = BinOp(_2559 MUL _2560)
	var6363 = var6365 & 0x1f;	// _6363 = BinOp(_6365 BIT_AND 0x1f u32)
	var6368 = var6364 >> var6363;
	// ^ Call( _6368 = "unchecked_shr"::<u32,>( _6364, _6363, ), bb1726, bb399)
	var6366 = var92 / 0xffe7ba2;	// _6366 = BinOp(_92 DIV 0xffe7ba2 u32)
	__builtin_sub_overflow(0x541f875f, var6, &var6367);
	// ^ Call( _6367 = "overflowing_sub"::<u32,>( 0x541f875f u32, _6, ), bb1727, bb399)
	__builtin_sub_overflow(var6366, var6367, &var2561);
	// ^ Call( _2561 = "overflowing_sub"::<u32,>( _6366, _6367, ), bb1728, bb399)
	var6369 = var2561 / var41;	// _6369 = BinOp(_2561 DIV _41)
	__builtin_mul_overflow(var6368, var6369, &var2562);
	// ^ Call( _2562 = "overflowing_mul"::<u32,>( _6368, _6369, ), bb1729, bb399)
	__builtin_mul_overflow(13, -1454236660, &var2563);
	// ^ Call( _2563 = "overflowing_mul"::<i32,>( +13 i32, -1454236660 i32, ), bb1730, bb399)
	var6372 = 0xc3dc;	// _6372 = Constant(0xc3dc u16)
	var2564 = var353 + 0x57d769b6;	// _2564 = BinOp(_353 ADD 0x57d769b6 u32)
	var2565 = 0xa22c2e3a << 0x12;
	// ^ Call( _2565 = "unchecked_shl"::<u32,>( 0xa22c2e3a u32, 0x12 u32, ), bb1731, bb399)
	var6373 = var2564 / var2565;	// _6373 = BinOp(_2564 DIV _2565)
	var6370 = var6373 & 0xf;	// _6370 = BinOp(_6373 BIT_AND 0xf u32)
	var6371 = (uint16_t )var6370;	// _6371 = Cast(_6370 as u16)
	var6376 = var6372 >> var6371;
	// ^ Call( _6376 = "unchecked_shr"::<u16,>( _6372, _6371, ), bb1732, bb399)
	var2567 = var22 >> 0x1f;
	// ^ Call( _2567 = "unchecked_shr"::<u32,>( _22, 0x1f u32, ), bb1733, bb399)
	var2568 = var71 >> 0x18;
	// ^ Call( _2568 = "unchecked_shr"::<u32,>( _71, 0x18 u32, ), bb1734, bb399)
	var2566 = var2567 & var2568;	// _2566 = BinOp(_2567 BIT_AND _2568)
	var6377 = 0x90287acb * var2566;	// _6377 = BinOp(0x90287acb u32 MUL _2566)
	var6374 = var6377 & 0xf;	// _6374 = BinOp(_6377 BIT_AND 0xf u32)
	var6375 = (uint16_t )var6374;	// _6375 = Cast(_6374 as u16)
	var2569 = var6376 << var6375;
	// ^ Call( _2569 = "unchecked_shl"::<u16,>( _6376, _6375, ), bb1735, bb399)
	var6378 = var191 / 0xd200;	// _6378 = BinOp(_191 DIV 0xd200 u16)
	var2571 = -4717399010177809434ll << 59ll;
	// ^ Call( _2571 = "unchecked_shl"::<i64,>( -4717399010177809434 i64, +59 i64, ), bb1736, bb399)
	var2572 = 7032283644259990794ll - var183;	// _2572 = BinOp(+7032283644259990794 i64 SUB _183)
	var2570 = var2571 ^ var2572;	// _2570 = BinOp(_2571 BIT_XOR _2572)
	var6379 = (uint16_t )var2570;	// _6379 = Cast(_2570 as u16)
	__builtin_mul_overflow(var6378, var6379, &var2573);
	// ^ Call( _2573 = "overflowing_mul"::<u16,>( _6378, _6379, ), bb1737, bb399)
	var2574 = var285 << 0x9;
	// ^ Call( _2574 = "unchecked_shl"::<u32,>( _285, 0x9 u32, ), bb1738, bb399)
	__builtin_sub_overflow(0x2b29ab87, 0x8ca4c24b, &var6380);
	// ^ Call( _6380 = "overflowing_sub"::<u32,>( 0x2b29ab87 u32, 0x8ca4c24b u32, ), bb1739, bb399)
	__builtin_mul_overflow(var6380, 0x8aeded1b, &var2575);
	// ^ Call( _2575 = "overflowing_mul"::<u32,>( _6380, 0x8aeded1b u32, ), bb1740, bb399)
	var372 = 0xa4491a79ull;	// _372 = Constant(0xa4491a79 usize)
	var2576.lo = var138; var2576.hi = var138 < 0 ? -1 : 0;	// _2576 = Cast(_138 as u128)
	var6381 = mul128(var82, var2576);	// _6381 = BinOp(_82 MUL _2576)
	mul128_o(var160, var6381, &var2577);
	// ^ Call( _2577 = "overflowing_mul"::<u128,>( _160, _6381, ), bb1741, bb399)
	var6384 = var2577.lo;	// _6384 = Cast(_2577 as i8)
	var6382 = ZRICb15overflowing_div0g( var218, -37 );
	// ^ Call( _6382 = <i8 /*- */>::overflowing_div( _218, -37 i8, ), bb1742, bb399)
	var2579 = -var6382._0;	// _2579 = UniOp(_6382.0 NEG)
	var6383 = -var171;	// _6383 = UniOp(_171 NEG)
	__builtin_mul_overflow(var42, var6383, &var2580);
	// ^ Call( _2580 = "overflowing_mul"::<i8,>( _42, _6383, ), bb1743, bb399)
	var2578 = var2579 + var2580;	// _2578 = BinOp(_2579 ADD _2580)
	var6385 = -var2578;	// _6385 = UniOp(_2578 NEG)
	__builtin_sub_overflow(var6384, var6385, &var373);
	// ^ Call( _373 = "overflowing_sub"::<i8,>( _6384, _6385, ), bb1744, bb399)
	var374 = 0xd516;	// _374 = Constant(0xd516 u16)
	var6386 = -var43;	// _6386 = UniOp(_43 NEG)
	var2582 = var6386 >> 10;
	// ^ Call( _2582 = "unchecked_shr"::<i16,>( _6386, +10 i16, ), bb1745, bb399)
	__builtin_sub_overflow(26502, 9218, &var2583);
	// ^ Call( _2583 = "overflowing_sub"::<i16,>( +26502 i16, +9218 i16, ), bb1746, bb399)
	var2584 = -var2583;	// _2584 = UniOp(_2583 NEG)
	var2581 = var2582 / var2584;	// _2581 = BinOp(_2582 DIV _2584)
	var6393 = -var2581;	// _6393 = UniOp(_2581 NEG)
	var2586 = var38 | var272;	// _2586 = BinOp(_38 BIT_OR _272)
	var2587 = var227 & 32320;	// _2587 = BinOp(_227 BIT_AND +32320 i16)
	var2585 = var2586 - var2587;	// _2585 = BinOp(_2586 SUB _2587)
	var6392 = -var2585;	// _6392 = UniOp(_2585 NEG)
	var6387 = ZRICd15overflowing_rem0g( -30273, -23867 );
	// ^ Call( _6387 = <i16 /*- */>::overflowing_rem( -30273 i16, -23867 i16, ), bb1747, bb399)
	var6390 = var6387._0 >> 2;
	// ^ Call( _6390 = "unchecked_shr"::<i16,>( _6387.0, +2 i16, ), bb1748, bb399)
	var6388 = ZRICd15overflowing_rem0g( var142, 2054 );
	// ^ Call( _6388 = <i16 /*- */>::overflowing_rem( _142, +2054 i16, ), bb1749, bb399)
	__builtin_mul_overflow(28084, var6388._0, &var6391);
	// ^ Call( _6391 = "overflowing_mul"::<i16,>( +28084 i16, _6388.0, ), bb1750, bb399)
	var6389 = ZRICd15overflowing_rem0g( var6390, var6391 );
	// ^ Call( _6389 = <i16 /*- */>::overflowing_rem( _6390, _6391, ), bb1751, bb399)
	__builtin_sub_overflow(var6392, var6389._0, &var6394);
	// ^ Call( _6394 = "overflowing_sub"::<i16,>( _6392, _6389.0, ), bb1752, bb399)
	__builtin_mul_overflow(var6393, var6394, &var2588);
	// ^ Call( _2588 = "overflowing_mul"::<i16,>( _6393, _6394, ), bb1753, bb399)
	var6395 = var141 & 0xf;	// _6395 = BinOp(_141 BIT_AND 0xf u32)
	var6396 = (int16_t )var6395;	// _6396 = Cast(_6395 as i16)
	var2590 = 29309 >> var6396;
	// ^ Call( _2590 = "unchecked_shr"::<i16,>( +29309 i16, _6396, ), bb1754, bb399)
	__builtin_add_overflow(var70, -8840, &var2591);
	// ^ Call( _2591 = "overflowing_add"::<i16,>( _70, -8840 i16, ), bb1755, bb399)
	var6399 = var2590 | var2591;	// _6399 = BinOp(_2590 BIT_OR _2591)
	var6397 = var141 & 0xf;	// _6397 = BinOp(_141 BIT_AND 0xf u32)
	var6398 = (int16_t )var6397;	// _6398 = Cast(_6397 as i16)
	var2592 = var6399 << var6398;
	// ^ Call( _2592 = "unchecked_shl"::<i16,>( _6399, _6398, ), bb1756, bb399)
	var2589 = var2592 | 123;	// _2589 = BinOp(_2592 BIT_OR +123 i16)
	var375 = (uint16_t )var2589;	// _375 = Cast(_2589 as u16)
	add128_o(var57, make128_raw(3440647181766501778ull, 12811719814171895587ull), &var2593);
	// ^ Call( _2593 = "overflowing_add"::<u128,>( _57, 0x2fbfa261eaa42592b1cc5f4aa58ca723 u128, ), bb1757, bb399)
	__builtin_sub_overflow(0x28b96a70, var152, &var2594);
	// ^ Call( _2594 = "overflowing_sub"::<u32,>( 0x28b96a70 u32, _152, ), bb1758, bb399)
	var2595 = var301 >> 0xf;
	// ^ Call( _2595 = "unchecked_shr"::<u32,>( _301, 0xf u32, ), bb1759, bb399)
	var6402 = var2594 * var2595;	// _6402 = BinOp(_2594 MUL _2595)
	var6400 = var6402 & 0x7f;	// _6400 = BinOp(_6402 BIT_AND 0x7f u32)
	var6401.lo = var6400; var6401.hi = var6400 < 0 ? -1 : 0;	// _6401 = Cast(_6400 as u128)
	var2596 = shl128(var359, var6401.lo);
	// ^ Call( _2596 = "unchecked_shl"::<u128,>( _359, _6401, ), bb1760, bb399)
	var6403 = or128(var2593, var2596);	// _6403 = BinOp(_2593 BIT_OR _2596)
	sub128_o(var6403, make128_raw(14134523257532439682ull, 13116295560075033430ull), &var376);
	// ^ Call( _376 = "overflowing_sub"::<u128,>( _6403, 0xc427ea03cab7dc82b60671519b4e3b56 u128, ), bb1761, bb399)
	var6404 = var241 & 0x1f;	// _6404 = BinOp(_241 BIT_AND 0x1f u32)
	var6405 = (int32_t )var6404;	// _6405 = Cast(_6404 as i32)
	var2597 = 834316379 >> var6405;
	// ^ Call( _2597 = "unchecked_shr"::<i32,>( +834316379 i32, _6405, ), bb1762, bb399)
	var2598 = var185 * var255;	// _2598 = BinOp(_185 MUL _255)
	var6406 = var2598 ^ var254;	// _6406 = BinOp(_2598 BIT_XOR _254)
	var2599 = (int16_t )var49;	// _2599 = Cast(_49 as i16)
	var6407 = var2599 | 118;	// _6407 = BinOp(_2599 BIT_OR +118 i16)
	__builtin_add_overflow(var6406, var6407, &var2600);
	// ^ Call( _2600 = "overflowing_add"::<i16,>( _6406, _6407, ), bb1763, bb399)
	var2601 = -var2600;	// _2601 = UniOp(_2600 NEG)
	var377 = var2601 / var291;	// _377 = BinOp(_2601 DIV _291)
	var2604 = var333 - var105;	// _2604 = BinOp(_333 SUB _105)
	var2603 = var66 ^ var2604;	// _2603 = BinOp(_66 BIT_XOR _2604)
	var6410 = var337 | 0x9c2e64c4;	// _6410 = BinOp(_337 BIT_OR 0x9c2e64c4 u32)
	var6408 = var6410 & 0xf;	// _6408 = BinOp(_6410 BIT_AND 0xf u32)
	var6409 = (uint16_t )var6408;	// _6409 = Cast(_6408 as u16)
	var2606 = 0x5020 >> var6409;
	// ^ Call( _2606 = "unchecked_shr"::<u16,>( 0x5020 u16, _6409, ), bb1764, bb399)
	var6411 = var279 % 0xebd0;	// _6411 = BinOp(_279 MOD 0xebd0 u16)
	var2607 = 0xc4a8 / var6411;	// _2607 = BinOp(0xc4a8 u16 DIV _6411)
	var2605 = var2606 - var2607;	// _2605 = BinOp(_2606 SUB _2607)
	var2602 = var2603 / var2605;	// _2602 = BinOp(_2603 DIV _2605)
	__builtin_add_overflow(var162, 0x56a7, &var6412);
	// ^ Call( _6412 = "overflowing_add"::<u16,>( _162, 0x56a7 u16, ), bb1765, bb399)
	__builtin_sub_overflow(0x5e, 0x8, &var2608);
	// ^ Call( _2608 = "overflowing_sub"::<u8,>( 0x5e u8, 0x8 u8, ), bb1766, bb399)
	var6413 = (uint16_t )var2608;	// _6413 = Cast(_2608 as u16)
	__builtin_mul_overflow(var6412, var6413, &var6414);
	// ^ Call( _6414 = "overflowing_mul"::<u16,>( _6412, _6413, ), bb1767, bb399)
	__builtin_add_overflow(var166, var6414, &var2609);
	// ^ Call( _2609 = "overflowing_add"::<u16,>( _166, _6414, ), bb1768, bb399)
	var378 = var2602 / var2609;	// _378 = BinOp(_2602 DIV _2609)
	var2611 = var116 & var368;	// _2611 = BinOp(_116 BIT_AND _368)
	var6419 = (uint8_t )var2611;	// _6419 = Cast(_2611 as u8)
	var6415 = var2 & 0x7;	// _6415 = BinOp(_2 BIT_AND 0x7 u32)
	var6416 = (uint8_t )var6415;	// _6416 = Cast(_6415 as u8)
	var6417 = 0xbd >> var6416;
	// ^ Call( _6417 = "unchecked_shr"::<u8,>( 0xbd u8, _6416, ), bb1769, bb399)
	var6418 = 0x52 | var198;	// _6418 = BinOp(0x52 u8 BIT_OR _198)
	__builtin_add_overflow(var6417, var6418, &var6420);
	// ^ Call( _6420 = "overflowing_add"::<u8,>( _6417, _6418, ), bb1770, bb399)
	var2612 = var6419 / var6420;	// _2612 = BinOp(_6419 DIV _6420)
	var6421 = 0x94 * var159;	// _6421 = BinOp(0x94 u8 MUL _159)
	__builtin_sub_overflow(var6421, var81, &var2614);
	// ^ Call( _2614 = "overflowing_sub"::<u8,>( _6421, _81, ), bb1771, bb399)
	var2613 = var2614 ^ 0x21;	// _2613 = BinOp(_2614 BIT_XOR 0x21 u8)
	var2610 = var2612 / var2613;	// _2610 = BinOp(_2612 DIV _2613)
	var379 = 0x9f + var2610;	// _379 = BinOp(0x9f u8 ADD _2610)
	var380 = 0xd3a94d08bb96c5e7ull;	// _380 = Constant(0xd3a94d08bb96c5e7 usize)
	__builtin_sub_overflow(-30157, 2124, &var2616);
	// ^ Call( _2616 = "overflowing_sub"::<i16,>( -30157 i16, +2124 i16, ), bb1772, bb399)
	var2615 = var104 + var2616;	// _2615 = BinOp(_104 ADD _2616)
	var2617 = -var2615;	// _2617 = UniOp(_2615 NEG)
	var6426 = -var2617;	// _6426 = UniOp(_2617 NEG)
	__builtin_sub_overflow(19631, var377, &var6422);
	// ^ Call( _6422 = "overflowing_sub"::<i16,>( +19631 i16, _377, ), bb1773, bb399)
	__builtin_sub_overflow(var6422, -30667, &var6423);
	// ^ Call( _6423 = "overflowing_sub"::<i16,>( _6422, -30667 i16, ), bb1774, bb399)
	var2618 = -var207;	// _2618 = UniOp(_207 NEG)
	var6424 = var2618 & 4540;	// _6424 = BinOp(_2618 BIT_AND +4540 i16)
	__builtin_add_overflow(var6423, var6424, &var2619);
	// ^ Call( _2619 = "overflowing_add"::<i16,>( _6423, _6424, ), bb1775, bb399)
	var6427 = -var2619;	// _6427 = UniOp(_2619 NEG)
	var6425 = ZRICd15overflowing_rem0g( var6426, var6427 );
	// ^ Call( _6425 = <i16 /*- */>::overflowing_rem( _6426, _6427, ), bb1776, bb399)
	var2621 = 1760880439;	// _2621 = Constant(+1760880439 i32)
	var6429 = var125 | var238;	// _6429 = BinOp(_125 BIT_OR _238)
	var6430 = var5 + var89;	// _6430 = BinOp(_5 ADD _89)
	var6428 = ZRICf15overflowing_div0g( var6429, var6430 );
	// ^ Call( _6428 = <i32 /*- */>::overflowing_div( _6429, _6430, ), bb1777, bb399)
	var2620 = var2621 + var6428._0;	// _2620 = BinOp(_2621 ADD _6428.0)
	var6437 = -var2620;	// _6437 = UniOp(_2620 NEG)
	var6431 = ZRICf15overflowing_rem0g( 223670033, var56 );
	// ^ Call( _6431 = <i32 /*- */>::overflowing_rem( +223670033 i32, _56, ), bb1778, bb399)
	var6432 = -var6431._0;	// _6432 = UniOp(_6431.0 NEG)
	__builtin_sub_overflow(var56, var321, &var2622);
	// ^ Call( _2622 = "overflowing_sub"::<i32,>( _56, _321, ), bb1779, bb399)
	var2623 = (int32_t )var112;	// _2623 = Cast(_112 as i32)
	var6433 = var2622 / var2623;	// _6433 = BinOp(_2622 DIV _2623)
	__builtin_add_overflow(var6432, var6433, &var6435);
	// ^ Call( _6435 = "overflowing_add"::<i32,>( _6432, _6433, ), bb1780, bb399)
	var2624 = -var369;	// _2624 = UniOp(_369 NEG)
	var6434 = 820732030 ^ var2624;	// _6434 = BinOp(+820732030 i32 BIT_XOR _2624)
	var6436 = var6434 << 7;
	// ^ Call( _6436 = "unchecked_shl"::<i32,>( _6434, +7 i32, ), bb1781, bb399)
	__builtin_add_overflow(var6435, var6436, &var6438);
	// ^ Call( _6438 = "overflowing_add"::<i32,>( _6435, _6436, ), bb1782, bb399)
	__builtin_add_overflow(var6437, var6438, &var381);
	// ^ Call( _381 = "overflowing_add"::<i32,>( _6437, _6438, ), bb1783, bb399)
	__builtin_mul_overflow(0xcb9cbbc9, var95, &var2626);
	// ^ Call( _2626 = "overflowing_mul"::<u32,>( 0xcb9cbbc9 u32, _95, ), bb1784, bb399)
	var2627 = (uint32_t )var296;	// _2627 = Cast(_296 as u32)
	var2625 = var2626 / var2627;	// _2625 = BinOp(_2626 DIV _2627)
	var2628 = (uint16_t )var2625;	// _2628 = Cast(_2625 as u16)
	var6439 = 0xb5a7 * var2628;	// _6439 = BinOp(0xb5a7 u16 MUL _2628)
	var2631 = var153 & var213;	// _2631 = BinOp(_153 BIT_AND _213)
	var2630 = var2631 & 0xe92f;	// _2630 = BinOp(_2631 BIT_AND 0xe92f u16)
	var2633 = var350 ^ 0x626c;	// _2633 = BinOp(_350 BIT_XOR 0x626c u16)
	var2632 = 0xcf5d / var2633;	// _2632 = BinOp(0xcf5d u16 DIV _2633)
	var2629 = var2630 / var2632;	// _2629 = BinOp(_2630 DIV _2632)
	var6440 = var2629 & 0x2277;	// _6440 = BinOp(_2629 BIT_AND 0x2277 u16)
	__builtin_add_overflow(var6439, var6440, &var382);
	// ^ Call( _382 = "overflowing_add"::<u16,>( _6439, _6440, ), bb1785, bb399)
	var2634 = -var8;	// _2634 = UniOp(_8 NEG)
	var2635 = -var2634;	// _2635 = UniOp(_2634 NEG)
	var6447 = (int32_t )var2635;	// _6447 = Cast(_2635 as i32)
	__builtin_sub_overflow(var238, -138041996, &var2636);
	// ^ Call( _2636 = "overflowing_sub"::<i32,>( _238, -138041996 i32, ), bb1786, bb399)
	var6444 = -var2636;	// _6444 = UniOp(_2636 NEG)
	var6441 = var157 & 0x1f;	// _6441 = BinOp(_157 BIT_AND 0x1f u32)
	var2637 = var241 >> var6441;
	// ^ Call( _2637 = "unchecked_shr"::<u32,>( _241, _6441, ), bb1787, bb399)
	var2638 = var108 % 0x95772036;	// _2638 = BinOp(_108 MOD 0x95772036 u32)
	var6445 = var2637 * var2638;	// _6445 = BinOp(_2637 MUL _2638)
	var6442 = var6445 & 0x1f;	// _6442 = BinOp(_6445 BIT_AND 0x1f u32)
	var6443 = (int32_t )var6442;	// _6443 = Cast(_6442 as i32)
	var2639 = var6444 >> var6443;
	// ^ Call( _2639 = "unchecked_shr"::<i32,>( _6444, _6443, ), bb1788, bb399)
	var6448 = -var2639;	// _6448 = UniOp(_2639 NEG)
	var6446 = ZRICf15overflowing_rem0g( var6447, var6448 );
	// ^ Call( _6446 = <i32 /*- */>::overflowing_rem( _6447, _6448, ), bb1789, bb399)
	var383 = var6446._0;	// _383 = Use(_6446.0)
	var6451 = var92 | var330;	// _6451 = BinOp(_92 BIT_OR _330)
	var6449 = var6451 & 0x3f;	// _6449 = BinOp(_6451 BIT_AND 0x3f u32)
	var6450 = (intptr_t )var6449;	// _6450 = Cast(_6449 as isize)
	var2640 = -6606476767059479177ll << var6450;
	// ^ Call( _2640 = "unchecked_shl"::<isize,>( -6606476767059479177 isize, _6450, ), bb1790, bb399)
	var6454 = (uint32_t )var298;	// _6454 = Cast(_298 as u32)
	var6452 = var6454 & 0x3f;	// _6452 = BinOp(_6454 BIT_AND 0x3f u32)
	var6453 = (intptr_t )var6452;	// _6453 = Cast(_6452 as isize)
	var2641 = -1439750487106343881ll << var6453;
	// ^ Call( _2641 = "unchecked_shl"::<isize,>( -1439750487106343881 isize, _6453, ), bb1791, bb399)
	var384 = var219;	// _384 = Use(_219)
	var6457 = 0xadca41b6 ^ var6;	// _6457 = BinOp(0xadca41b6 u32 BIT_XOR _6)
	var6455 = var6457 & 0xf;	// _6455 = BinOp(_6457 BIT_AND 0xf u32)
	var6456 = (int16_t )var6455;	// _6456 = Cast(_6455 as i16)
	var6458 = 13230 >> var6456;
	// ^ Call( _6458 = "unchecked_shr"::<i16,>( +13230 i16, _6456, ), bb1792, bb399)
	var2642 = -var319;	// _2642 = UniOp(_319 NEG)
	var6459 = -var2642;	// _6459 = UniOp(_2642 NEG)
	__builtin_sub_overflow(var6458, var6459, &var2643);
	// ^ Call( _2643 = "overflowing_sub"::<i16,>( _6458, _6459, ), bb1793, bb399)
	var6462 = (int32_t )var2643;	// _6462 = Cast(_2643 as i32)
	var6460 = var71 & 0x1f;	// _6460 = BinOp(_71 BIT_AND 0x1f u32)
	var6461 = (int32_t )var6460;	// _6461 = Cast(_6460 as i32)
	var385 = var6462 >> var6461;
	// ^ Call( _385 = "unchecked_shr"::<i32,>( _6462, _6461, ), bb1794, bb399)
	var386 = 0x2e;	// _386 = Constant(0x2e u8)
	var6463 = var218 * -2;	// _6463 = BinOp(_218 MUL -2 i8)
	__builtin_mul_overflow(var170, var6463, &var6468);
	// ^ Call( _6468 = "overflowing_mul"::<i8,>( _170, _6463, ), bb1795, bb399)
	var6464 = 0x35b677b7;	// _6464 = Constant(0x35b677b7 u32)
	__builtin_mul_overflow(0x983f02f2, var241, &var6465);
	// ^ Call( _6465 = "overflowing_mul"::<u32,>( 0x983f02f2 u32, _241, ), bb1796, bb399)
	__builtin_sub_overflow(var6464, var6465, &var6469);
	// ^ Call( _6469 = "overflowing_sub"::<u32,>( _6464, _6465, ), bb1797, bb399)
	var6466 = var6469 & 0x7;	// _6466 = BinOp(_6469 BIT_AND 0x7 u32)
	var6467 = (int8_t )var6466;	// _6467 = Cast(_6466 as i8)
	var2644 = var6468 >> var6467;
	// ^ Call( _2644 = "unchecked_shr"::<i8,>( _6468, _6467, ), bb1798, bb399)
	var6470 = ZRICb15overflowing_div0g( 83, 28 );
	// ^ Call( _6470 = <i8 /*- */>::overflowing_div( +83 i8, +28 i8, ), bb1799, bb399)
	var2646 = (uint64_t )var255;	// _2646 = Cast(_255 as u64)
	var2645 = var2646 / var36;	// _2645 = BinOp(_2646 DIV _36)
	var387.lo = var2645; var387.hi = var2645 < 0 ? -1 : 0;	// _387 = Cast(_2645 as u128)
	__builtin_sub_overflow(var54, 0xad, &var2647);
	// ^ Call( _2647 = "overflowing_sub"::<u8,>( _54, 0xad u8, ), bb1800, bb399)
	var6471 = 0xe9 & var2647;	// _6471 = BinOp(0xe9 u8 BIT_AND _2647)
	__builtin_mul_overflow(var6471, 0x9c, &var2648);
	// ^ Call( _2648 = "overflowing_mul"::<u8,>( _6471, 0x9c u8, ), bb1801, bb399)
	var6472 = var2648 * var180;	// _6472 = BinOp(_2648 MUL _180)
	__builtin_add_overflow(var6472, 0xf0, &var2649);
	// ^ Call( _2649 = "overflowing_add"::<u8,>( _6472, 0xf0 u8, ), bb1802, bb399)
	var6473 = var201 & 0xbc;	// _6473 = BinOp(_201 BIT_AND 0xbc u8)
	__builtin_sub_overflow(0x0, var6473, &var6477);
	// ^ Call( _6477 = "overflowing_sub"::<u8,>( 0x0 u8, _6473, ), bb1803, bb399)
	var6476 = 0x1b4f9650 ^ var79;	// _6476 = BinOp(0x1b4f9650 u32 BIT_XOR _79)
	var6474 = var6476 & 0x7;	// _6474 = BinOp(_6476 BIT_AND 0x7 u32)
	var6475 = (uint8_t )var6474;	// _6475 = Cast(_6474 as u8)
	var6478 = 0x87 << var6475;
	// ^ Call( _6478 = "unchecked_shl"::<u8,>( 0x87 u8, _6475, ), bb1804, bb399)
	__builtin_mul_overflow(var6477, var6478, &var2650);
	// ^ Call( _2650 = "overflowing_mul"::<u8,>( _6477, _6478, ), bb1805, bb399)
	var2651 = var377 >> 12;
	// ^ Call( _2651 = "unchecked_shr"::<i16,>( _377, +12 i16, ), bb1806, bb399)
	var388.lo = var300; var388.hi = var300 < 0 ? -1 : 0;	// _388 = Cast(_300 as u128)
	var6479 = var189 | 0xdeb9;	// _6479 = BinOp(_189 BIT_OR 0xdeb9 u16)
	__builtin_sub_overflow(0x6ab9, var6479, &var2652);
	// ^ Call( _2652 = "overflowing_sub"::<u16,>( 0x6ab9 u16, _6479, ), bb1807, bb399)
	var2653 = -var219;	// _2653 = UniOp(_219 NEG)
	var2654.lo = var2653; var2654.hi = var2653 < 0 ? -1 : 0;	// _2654 = Cast(_2653 as u128)
	var6480 = var92 & 0x7f;	// _6480 = BinOp(_92 BIT_AND 0x7f u32)
	var6481.lo = var6480; var6481.hi = var6480 < 0 ? -1 : 0;	// _6481 = Cast(_6480 as u128)
	var2657 = shl128(make128_raw(4393065983993925737ull, 17173459394113398982ull), var6481.lo);
	// ^ Call( _2657 = "unchecked_shl"::<u128,>( 0x3cf74e3caacf5069ee5462547eb968c6 u128, _6481, ), bb1808, bb399)
	var2656 = xor128(make128_raw(10668322353034677896ull, 14774701504212695540ull), var2657);	// _2656 = BinOp(0x940d7ea829fdce88cd0a48bd0506f9f4 u128 BIT_XOR _2657)
	var6482 = var22 / var276;	// _6482 = BinOp(_22 DIV _276)
	__builtin_add_overflow(var6482, 0xa26ca23c, &var6485);
	// ^ Call( _6485 = "overflowing_add"::<u32,>( _6482, 0xa26ca23c u32, ), bb1809, bb399)
	var6483 = var6485 & 0x7f;	// _6483 = BinOp(_6485 BIT_AND 0x7f u32)
	var6484.lo = var6483; var6484.hi = var6483 < 0 ? -1 : 0;	// _6484 = Cast(_6483 as u128)
	var2658 = shr128(make128_raw(11298203619047964493ull, 4147155915354455462ull), var6484.lo);
	// ^ Call( _2658 = "unchecked_shr"::<u128,>( 0x9ccb4854c162ff4d398da8551adcbda6 u128, _6484, ), bb1810, bb399)
	var2655 = add128(var2656, var2658);	// _2655 = BinOp(_2656 ADD _2658)
	var389 = sub128(var2654, var2655);	// _389 = BinOp(_2654 SUB _2655)
	__builtin_sub_overflow(20656, var207, &var2659);
	// ^ Call( _2659 = "overflowing_sub"::<i16,>( +20656 i16, _207, ), bb1811, bb399)
	var6487 = -var2659;	// _6487 = UniOp(_2659 NEG)
	var6486 = ZRICd15overflowing_div0g( var6487, 21338 );
	// ^ Call( _6486 = <i16 /*- */>::overflowing_div( _6487, +21338 i16, ), bb1812, bb399)
	__builtin_mul_overflow(var6486._0, 28953, &var6492);
	// ^ Call( _6492 = "overflowing_mul"::<i16,>( _6486.0, +28953 i16, ), bb1813, bb399)
	var2660 = -31587 | var52;	// _2660 = BinOp(-31587 i16 BIT_OR _52)
	var6490 = var2660 & var377;	// _6490 = BinOp(_2660 BIT_AND _377)
	var6488 = var227 - 22568;	// _6488 = BinOp(_227 SUB +22568 i16)
	__builtin_mul_overflow(var6488, var291, &var6491);
	// ^ Call( _6491 = "overflowing_mul"::<i16,>( _6488, _291, ), bb1814, bb399)
	var6489 = ZRICd15overflowing_div0g( var6490, var6491 );
	// ^ Call( _6489 = <i16 /*- */>::overflowing_div( _6490, _6491, ), bb1815, bb399)
	__builtin_sub_overflow(var6492, var6489._0, &var390);
	// ^ Call( _390 = "overflowing_sub"::<i16,>( _6492, _6489.0, ), bb1816, bb399)
	__builtin_mul_overflow(var178, var259, &var2661);
	// ^ Call( _2661 = "overflowing_mul"::<u8,>( _178, _259, ), bb1817, bb399)
	var2662 = var142 ^ var38;	// _2662 = BinOp(_142 BIT_XOR _38)
	var2663 = var10 ^ -16315;	// _2663 = BinOp(_10 BIT_XOR -16315 i16)
	var6494 = var2662 | var2663;	// _6494 = BinOp(_2662 BIT_OR _2663)
	var6493 = ZRICd15overflowing_rem0g( var6494, var30 );
	// ^ Call( _6493 = <i16 /*- */>::overflowing_rem( _6494, _30, ), bb1818, bb399)
	var391 = var352;	// _391 = Use(_352)
	var2664 = 1418307821 >> 28;
	// ^ Call( _2664 = "unchecked_shr"::<i32,>( +1418307821 i32, +28 i32, ), bb1819, bb399)
	var2666 = div128(make128_raw(6572239766439017392ull, 4285450294054427694ull), var389);	// _2666 = BinOp(0x5b35493f114b3bb03b78fa564fb51c2e u128 DIV _389)
	var2668.lo = var192; var2668.hi = var192 < 0 ? -1 : 0;	// _2668 = Cast(_192 as u128)
	var2667 = add128(var324, var2668);	// _2667 = BinOp(_324 ADD _2668)
	var2665 = xor128(var2666, var2667);	// _2665 = BinOp(_2666 BIT_XOR _2667)
	var2669 = var2665.lo;	// _2669 = Cast(_2665 as i32)
	var392 = var2664 > var2669;	// _392 = BinOp(_2664 GT _2669)
	var6495 = var51 & 0x3f;	// _6495 = BinOp(_51 BIT_AND 0x3f u32)
	var6496 = (int64_t )var6495;	// _6496 = Cast(_6495 as i64)
	var2672 = var164 << var6496;
	// ^ Call( _2672 = "unchecked_shl"::<i64,>( _164, _6496, ), bb1820, bb399)
	var2673 = -var2672;	// _2673 = UniOp(_2672 NEG)
	var2675 = var183 * var139;	// _2675 = BinOp(_183 MUL _139)
	var2674 = -1777394126164373373ll * var2675;	// _2674 = BinOp(-1777394126164373373 i64 MUL _2675)
	var2671 = var2673 & var2674;	// _2671 = BinOp(_2673 BIT_AND _2674)
	var2670 = var2671 - 35ll;	// _2670 = BinOp(_2671 SUB +35 i64)
	var393 = -var2670;	// _393 = UniOp(_2670 NEG)
	var6497 = 0xea / var87;	// _6497 = BinOp(0xea u8 DIV _87)
	__builtin_add_overflow(var365, var96, &var6498);
	// ^ Call( _6498 = "overflowing_add"::<u8,>( _365, _96, ), bb1821, bb399)
	__builtin_sub_overflow(var6497, var6498, &var6499);
	// ^ Call( _6499 = "overflowing_sub"::<u8,>( _6497, _6498, ), bb1822, bb399)
	__builtin_sub_overflow(var202, var69, &var2676);
	// ^ Call( _2676 = "overflowing_sub"::<u8,>( _202, _69, ), bb1823, bb399)
	var6500 = var2676 & 0x59;	// _6500 = BinOp(_2676 BIT_AND 0x59 u8)
	__builtin_sub_overflow(var6499, var6500, &var6501);
	// ^ Call( _6501 = "overflowing_sub"::<u8,>( _6499, _6500, ), bb1824, bb399)
	var6502 = 0x42 * var275;	// _6502 = BinOp(0x42 u8 MUL _275)
	var2677 = var6502 << 0x4;
	// ^ Call( _2677 = "unchecked_shl"::<u8,>( _6502, 0x4 u8, ), bb1825, bb399)
	__builtin_sub_overflow(var289, 0xf36794dcfaff0b03ull, &var2678);
	// ^ Call( _2678 = "overflowing_sub"::<usize,>( _289, 0xf36794dcfaff0b03 usize, ), bb1826, bb399)
	var2679 = var289 / 0x5cbd646b50e23135ull;	// _2679 = BinOp(_289 DIV 0x5cbd646b50e23135 usize)
	var6505 = var2678 * var2679;	// _6505 = BinOp(_2678 MUL _2679)
	var2680 = 0xc479ebb5 << 0x15;
	// ^ Call( _2680 = "unchecked_shl"::<u32,>( 0xc479ebb5 u32, 0x15 u32, ), bb1827, bb399)
	__builtin_add_overflow(0xd73bedc9, 0xd6d93dba, &var2681);
	// ^ Call( _2681 = "overflowing_add"::<u32,>( 0xd73bedc9 u32, 0xd6d93dba u32, ), bb1828, bb399)
	var6506 = var2680 / var2681;	// _6506 = BinOp(_2680 DIV _2681)
	var6503 = var6506 & 0x3f;	// _6503 = BinOp(_6506 BIT_AND 0x3f u32)
	var6504 = (uintptr_t )var6503;	// _6504 = Cast(_6503 as usize)
	var2682 = var6505 >> var6504;
	// ^ Call( _2682 = "unchecked_shr"::<usize,>( _6505, _6504, ), bb1829, bb399)
	var6517 = var2682 / var112;	// _6517 = BinOp(_2682 DIV _112)
	var6507 = 0x5f7e9491 << 0x15;
	// ^ Call( _6507 = "unchecked_shl"::<u32,>( 0x5f7e9491 u32, 0x15 u32, ), bb1830, bb399)
	__builtin_sub_overflow(0x209b4b5d, var6507, &var6508);
	// ^ Call( _6508 = "overflowing_sub"::<u32,>( 0x209b4b5d u32, _6507, ), bb1831, bb399)
	var6513 = var61 % var6508;	// _6513 = BinOp(_61 MOD _6508)
	var2683 = (uint8_t )var227;	// _2683 = Cast(_227 as u8)
	var6511 = (uint32_t )var2683;	// _6511 = Cast(_2683 as u32)
	var6509 = var41 & 0x1f;	// _6509 = BinOp(_41 BIT_AND 0x1f u32)
	var6512 = var79 >> var6509;
	// ^ Call( _6512 = "unchecked_shr"::<u32,>( _79, _6509, ), bb1832, bb399)
	var6510 = var6512 & 0x1f;	// _6510 = BinOp(_6512 BIT_AND 0x1f u32)
	var6514 = var6511 >> var6510;
	// ^ Call( _6514 = "unchecked_shr"::<u32,>( _6511, _6510, ), bb1833, bb399)
	__builtin_mul_overflow(var6513, var6514, &var6518);
	// ^ Call( _6518 = "overflowing_mul"::<u32,>( _6513, _6514, ), bb1834, bb399)
	var6515 = var6518 & 0x3f;	// _6515 = BinOp(_6518 BIT_AND 0x3f u32)
	var6516 = (uintptr_t )var6515;	// _6516 = Cast(_6515 as usize)
	var394 = var6517 << var6516;
	// ^ Call( _394 = "unchecked_shl"::<usize,>( _6517, _6516, ), bb1835, bb399)
	var2684 = -var38;	// _2684 = UniOp(_38 NEG)
	var395 = -var2684;	// _395 = UniOp(_2684 NEG)
	var6519 = -var83;	// _6519 = UniOp(_83 NEG)
	__builtin_mul_overflow(var188, var6519, &var2685);
	// ^ Call( _2685 = "overflowing_mul"::<i32,>( _188, _6519, ), bb1836, bb399)
	var396 = var2685 * -1530879590;	// _396 = BinOp(_2685 MUL -8221600654947212902 i32)
	var397 = 0x533c5332;	// _397 = Constant(0x533c5332 u32)
	var2688 = var75 - 10248;	// _2688 = BinOp(_75 SUB +10248 i16)
	var2687 = 5519 + var2688;	// _2687 = BinOp(+5519 i16 ADD _2688)
	var2686 = -648 / var2687;	// _2686 = BinOp(-648 i16 DIV _2687)
	var6527 = var2686 / var296;	// _6527 = BinOp(_2686 DIV _296)
	var6523 = 0x2;	// _6523 = Constant(0x2 u32)
	var6520 = var152 & 0x1f;	// _6520 = BinOp(_152 BIT_AND 0x1f u32)
	var6521 = 0x70636bc1 << var6520;
	// ^ Call( _6521 = "unchecked_shl"::<u32,>( 0x70636bc1 u32, _6520, ), bb1837, bb399)
	var6524 = 0x776e02ae / var6521;	// _6524 = BinOp(0x776e02ae u32 DIV _6521)
	var6522 = var6524 & 0x1f;	// _6522 = BinOp(_6524 BIT_AND 0x1f u32)
	var2689 = var6523 >> var6522;
	// ^ Call( _2689 = "unchecked_shr"::<u32,>( _6523, _6522, ), bb1838, bb399)
	var2692 = var332 / var168;	// _2692 = BinOp(_332 DIV _168)
	var2691 = var2692 + var41;	// _2691 = BinOp(_2692 ADD _41)
	var2690 = var2691 | 0xe0c71cad;	// _2690 = BinOp(_2691 BIT_OR 0xe0c71cad u32)
	var6528 = var2689 | var2690;	// _6528 = BinOp(_2689 BIT_OR _2690)
	var6525 = var6528 & 0xf;	// _6525 = BinOp(_6528 BIT_AND 0xf u32)
	var6526 = (int16_t )var6525;	// _6526 = Cast(_6525 as i16)
	var2693 = var6527 << var6526;
	// ^ Call( _2693 = "unchecked_shl"::<i16,>( _6527, _6526, ), bb1839, bb399)
	var6531 = (int16_t )var8;	// _6531 = Cast(_8 as i16)
	var6529 = -var38;	// _6529 = UniOp(_38 NEG)
	var6530 = var190 >> 9;
	// ^ Call( _6530 = "unchecked_shr"::<i16,>( _190, +9 i16, ), bb1840, bb399)
	__builtin_mul_overflow(var6529, var6530, &var6532);
	// ^ Call( _6532 = "overflowing_mul"::<i16,>( _6529, _6530, ), bb1841, bb399)
	__builtin_mul_overflow(var6531, var6532, &var2694);
	// ^ Call( _2694 = "overflowing_mul"::<i16,>( _6531, _6532, ), bb1842, bb399)
	var6533.lo = var2694; var6533.hi = var2694 < 0 ? -1 : 0;	// _6533 = Cast(_2694 as u128)
	sub128_o(var6533, var199, &var2695);
	// ^ Call( _2695 = "overflowing_sub"::<u128,>( _6533, _199, ), bb1843, bb399)
	var398 = 11214;	// _398 = Constant(+11214 i16)
	var2696 = var81 + 0x13;	// _2696 = BinOp(_81 ADD 0x13 u8)
	var2697 = var338 | var175;	// _2697 = BinOp(_338 BIT_OR _175)
	var6534 = var2696 ^ var2697;	// _6534 = BinOp(_2696 BIT_XOR _2697)
	__builtin_sub_overflow(var96, var6534, &var6540);
	// ^ Call( _6540 = "overflowing_sub"::<u8,>( _96, _6534, ), bb1844, bb399)
	var6536 = 0xaf08d287;	// _6536 = Constant(0xaf08d287 u32)
	__builtin_sub_overflow(0x54495521, var285, &var6537);
	// ^ Call( _6537 = "overflowing_sub"::<u32,>( 0x54495521 u32, _285, ), bb1845, bb399)
	var6535 = var6537 & 0x1f;	// _6535 = BinOp(_6537 BIT_AND 0x1f u32)
	var2698 = var6536 << var6535;
	// ^ Call( _2698 = "unchecked_shl"::<u32,>( _6536, _6535, ), bb1846, bb399)
	__builtin_sub_overflow(0xbd3fbc17, var61, &var2700);
	// ^ Call( _2700 = "overflowing_sub"::<u32,>( 0xbd3fbc17 u32, _61, ), bb1847, bb399)
	var2699 = var295 + var2700;	// _2699 = BinOp(_295 ADD _2700)
	var6541 = var2698 / var2699;	// _6541 = BinOp(_2698 DIV _2699)
	var6538 = var6541 & 0x7;	// _6538 = BinOp(_6541 BIT_AND 0x7 u32)
	var6539 = (uint8_t )var6538;	// _6539 = Cast(_6538 as u8)
	var2701 = var6540 << var6539;
	// ^ Call( _2701 = "unchecked_shl"::<u8,>( _6540, _6539, ), bb1848, bb399)
	var399 = var2701 | var7;	// _399 = BinOp(_2701 BIT_OR _7)
	var2704 = 220900655 & var179;	// _2704 = BinOp(+220900655 i32 BIT_AND _179)
	var2705 = (int32_t )var265;	// _2705 = Cast(_265 as i32)
	var2703 = var2704 + var2705;	// _2703 = BinOp(_2704 ADD _2705)
	var2707 = var269 - -1365584911;	// _2707 = BinOp(_269 SUB -1365584911 i32)
	__builtin_mul_overflow(var281, var269, &var2708);
	// ^ Call( _2708 = "overflowing_mul"::<i32,>( _281, _269, ), bb1849, bb399)
	var2706 = var2707 - var2708;	// _2706 = BinOp(_2707 SUB _2708)
	var2702 = var2703 / var2706;	// _2702 = BinOp(_2703 DIV _2706)
	var6543 = var2702 ^ 1080351591;	// _6543 = BinOp(_2702 BIT_XOR +1080351591 i32)
	var2709 = -434388646;	// _2709 = Constant(-434388646 i32)
	var2711 = -1943730058 | var84;	// _2711 = BinOp(-1943730058 i32 BIT_OR _84)
	__builtin_mul_overflow(-349965861, var89, &var2712);
	// ^ Call( _2712 = "overflowing_mul"::<i32,>( -349965861 i32, _89, ), bb1850, bb399)
	var2710 = var2711 & var2712;	// _2710 = BinOp(_2711 BIT_AND _2712)
	var2713 = -var2710;	// _2713 = UniOp(_2710 NEG)
	var6544 = var2709 - var2713;	// _6544 = BinOp(_2709 SUB _2713)
	var6542 = ZRICf15overflowing_div0g( var6543, var6544 );
	// ^ Call( _6542 = <i32 /*- */>::overflowing_div( _6543, _6544, ), bb1851, bb399)
	var2714 = -var184;	// _2714 = UniOp(_184 NEG)
	var6545 = var2714 + -98;	// _6545 = BinOp(_2714 ADD -98 i8)
	__builtin_add_overflow(var384, 15, &var2715);
	// ^ Call( _2715 = "overflowing_add"::<i8,>( _384, +15 i8, ), bb1852, bb399)
	var6546 = -var2715;	// _6546 = UniOp(_2715 NEG)
	__builtin_add_overflow(var6545, var6546, &var2716);
	// ^ Call( _2716 = "overflowing_add"::<i8,>( _6545, _6546, ), bb1853, bb399)
	var400 = (uint32_t )var2716;	// _400 = Cast(_2716 as u32)
	var2717 = xor128(make128_raw(11389055255683949325ull, 9655473680725430036ull), var199);	// _2717 = BinOp(0x9e0e0d69ca56630d85ff2227ddc5cf14 u128 BIT_XOR _199)
	var6550 = or128(make128_raw(0ull, 4ull), var2717);	// _6550 = BinOp(0x4 u128 BIT_OR _2717)
	var6549 = var225 * var301;	// _6549 = BinOp(_225 MUL _301)
	var6547 = var6549 & 0x7f;	// _6547 = BinOp(_6549 BIT_AND 0x7f u32)
	var6548.lo = var6547; var6548.hi = var6547 < 0 ? -1 : 0;	// _6548 = Cast(_6547 as u128)
	var6551 = shl128(make128_raw(0ull, 177803213ull), var6548.lo);
	// ^ Call( _6551 = "unchecked_shl"::<u128,>( 0xa990fcd u128, _6548, ), bb1854, bb399)
	add128_o(var6550, var6551, &var2718);
	// ^ Call( _2718 = "overflowing_add"::<u128,>( _6550, _6551, ), bb1855, bb399)
	var6552 = mod128(var132, var132);	// _6552 = BinOp(_132 MOD _132)
	add128_o(var132, var6552, &var2720);
	// ^ Call( _2720 = "overflowing_add"::<u128,>( _132, _6552, ), bb1856, bb399)
	var2721 = mul128(var132, var14);	// _2721 = BinOp(_132 MUL _14)
	var2719 = div128(var2720, var2721);	// _2719 = BinOp(_2720 DIV _2721)
	var6553 = or128(var2718, var2719);	// _6553 = BinOp(_2718 BIT_OR _2719)
	sub128_o(var3, var6553, &var401);
	// ^ Call( _401 = "overflowing_sub"::<u128,>( _3, _6553, ), bb1857, bb399)
	var402 = 36;	// _402 = Constant(+36 i8)
	var6554 = var221 | var191;	// _6554 = BinOp(_221 BIT_OR _191)
	__builtin_sub_overflow(0x974a, var6554, &var2723);
	// ^ Call( _2723 = "overflowing_sub"::<u16,>( 0x974a u16, _6554, ), bb1858, bb399)
	var6555 = var231 / var17;	// _6555 = BinOp(_231 DIV _17)
	__builtin_add_overflow(0x236b, var323, &var6556);
	// ^ Call( _6556 = "overflowing_add"::<u16,>( 0x236b u16, _323, ), bb1859, bb399)
	var2724 = var6555 % var6556;	// _2724 = BinOp(_6555 MOD _6556)
	var2722 = var2723 * var2724;	// _2722 = BinOp(_2723 MUL _2724)
	var2727 = 0x38c7 & var268;	// _2727 = BinOp(0x38c7 u16 BIT_AND _268)
	var2726 = 0x0 * var2727;	// _2726 = BinOp(0x0 u16 MUL _2727)
	var2729 = 0x2;	// _2729 = Constant(0x2 u16)
	__builtin_mul_overflow(var24, 0x2e02, &var2730);
	// ^ Call( _2730 = "overflowing_mul"::<u16,>( _24, 0x2e02 u16, ), bb1860, bb399)
	var2728 = var2729 / var2730;	// _2728 = BinOp(_2729 DIV _2730)
	var2725 = var2726 | var2728;	// _2725 = BinOp(_2726 BIT_OR _2728)
	var6566 = var2722 * var2725;	// _6566 = BinOp(_2722 MUL _2725)
	var2731 = 74 << 0;
	// ^ Call( _2731 = "unchecked_shl"::<i8,>( +74 i8, +0 i8, ), bb1861, bb399)
	var2732 = -var2731;	// _2732 = UniOp(_2731 NEG)
	var6564 = (uint16_t )var2732;	// _6564 = Cast(_2732 as u16)
	var2733 = var125 ^ 319829916;	// _2733 = BinOp(_125 BIT_XOR +319829916 i32)
	var6560 = (uint32_t )var2733;	// _6560 = Cast(_2733 as u32)
	__builtin_sub_overflow(0x51d19516, var397, &var6558);
	// ^ Call( _6558 = "overflowing_sub"::<u32,>( 0x51d19516 u32, _397, ), bb1862, bb399)
	var6557 = var220 & 0x1f;	// _6557 = BinOp(_220 BIT_AND 0x1f u32)
	var6559 = 0x8ddc3190 >> var6557;
	// ^ Call( _6559 = "unchecked_shr"::<u32,>( 0x8ddc3190 u32, _6557, ), bb1863, bb399)
	var6561 = var6558 / var6559;	// _6561 = BinOp(_6558 DIV _6559)
	__builtin_mul_overflow(var6560, var6561, &var6565);
	// ^ Call( _6565 = "overflowing_mul"::<u32,>( _6560, _6561, ), bb1864, bb399)
	var6562 = var6565 & 0xf;	// _6562 = BinOp(_6565 BIT_AND 0xf u32)
	var6563 = (uint16_t )var6562;	// _6563 = Cast(_6562 as u16)
	var6567 = var6564 >> var6563;
	// ^ Call( _6567 = "unchecked_shr"::<u16,>( _6564, _6563, ), bb1865, bb399)
	__builtin_mul_overflow(var6566, var6567, &var2734);
	// ^ Call( _2734 = "overflowing_mul"::<u16,>( _6566, _6567, ), bb1866, bb399)
	var6568 = var134 % 0xba49;	// _6568 = BinOp(_134 MOD 0xba49 u16)
	__builtin_sub_overflow(var222, var6568, &var6569);
	// ^ Call( _6569 = "overflowing_sub"::<u16,>( _222, _6568, ), bb1867, bb399)
	__builtin_sub_overflow(var6569, 0xd1bb, &var2735);
	// ^ Call( _2735 = "overflowing_sub"::<u16,>( _6569, 0xd1bb u16, ), bb1868, bb399)
	var403 = 0xf23d;	// _403 = Constant(0xf23d u16)
	var404 = var359;	// _404 = Use(_359)
	var405 = -93;	// _405 = Constant(-93 i8)
	var6570 = var127 & 0xf;	// _6570 = BinOp(_127 BIT_AND 0xf u32)
	var6571 = (int16_t )var6570;	// _6571 = Cast(_6570 as i16)
	var2736 = 11396 << var6571;
	// ^ Call( _2736 = "unchecked_shl"::<i16,>( +11396 i16, _6571, ), bb1869, bb399)
	var2737 = -var2736;	// _2737 = UniOp(_2736 NEG)
	var2738 = (uint64_t )var2737;	// _2738 = Cast(_2737 as u64)
	var6572 = var2738 & 0x5614d49ecd1948ddull;	// _6572 = BinOp(_2738 BIT_AND 0x5614d49ecd1948dd u64)
	var2741 = var133 ^ var31;	// _2741 = BinOp(_133 BIT_XOR _31)
	var2740 = var2741 / 0xd7fe9fcfe6b7dfbbull;	// _2740 = BinOp(_2741 DIV 0xd7fe9fcfe6b7dfbb u64)
	var2739 = var192 - var2740;	// _2739 = BinOp(_192 SUB _2740)
	var6573 = 0xd15a9dc4099be262ull | var2739;	// _6573 = BinOp(0xd15a9dc4099be262 u64 BIT_OR _2739)
	__builtin_sub_overflow(var6572, var6573, &var406);
	// ^ Call( _406 = "overflowing_sub"::<u64,>( _6572, _6573, ), bb1870, bb399)
	var2742 = -var371;	// _2742 = UniOp(_371 NEG)
	var2743 = -var2742;	// _2743 = UniOp(_2742 NEG)
	var407 = -var2743;	// _407 = UniOp(_2743 NEG)
	var408 = make128_raw(11707729956137008538ull, 8135473312155736509ull);	// _408 = Constant(0xa27a365d69befd9a70e701dfb2b699bd u128)
	var2745 = -var148;	// _2745 = UniOp(_148 NEG)
	var2744 = 8246645849190014825ll & var2745;	// _2744 = BinOp(+8246645849190014825 i64 BIT_AND _2745)
	var2747 = -var139;	// _2747 = UniOp(_139 NEG)
	var2746 = 3184368373201313814ll | var2747;	// _2746 = BinOp(+3184368373201313814 i64 BIT_OR _2747)
	var6576 = var2744 * var2746;	// _6576 = BinOp(_2744 MUL _2746)
	__builtin_sub_overflow(0x4ee0d840, var400, &var2749);
	// ^ Call( _2749 = "overflowing_sub"::<u32,>( 0x4ee0d840 u32, _400, ), bb1871, bb399)
	var2748 = var2749 / var22;	// _2748 = BinOp(_2749 DIV _22)
	var6577 = var2748 & var2;	// _6577 = BinOp(_2748 BIT_AND _2)
	var6574 = var6577 & 0x3f;	// _6574 = BinOp(_6577 BIT_AND 0x3f u32)
	var6575 = (int64_t )var6574;	// _6575 = Cast(_6574 as i64)
	var2750 = var6576 >> var6575;
	// ^ Call( _2750 = "unchecked_shr"::<i64,>( _6576, _6575, ), bb1872, bb399)
	var6578 = var127 & 0x3f;	// _6578 = BinOp(_127 BIT_AND 0x3f u32)
	var6579 = (uint64_t )var6578;	// _6579 = Cast(_6578 as u64)
	var409 = var406 >> var6579;
	// ^ Call( _409 = "unchecked_shr"::<u64,>( _406, _6579, ), bb1873, bb399)
	var410 = 25005;	// _410 = Constant(+25005 i16)
	var2751 = mul128(make128_raw(7993782359112860074ull, 5263291398568964715ull), var324);	// _2751 = BinOp(0x6eef9eb3e6b4c1aa490af7a41112726b u128 MUL _324)
	mul128_o(make128_raw(7748551810838434693ull, 2581658310644171099ull), make128_raw(12453103359157872976ull, 4532081180336309379ull), &var2752);
	// ^ Call( _2752 = "overflowing_mul"::<u128,>( 0x6b8862d180bc138523d3e48e2961815b u128, 0xacd24f8699d429503ee52fd24f2dc483 u128, ), bb1874, bb399)
	var6580 = add128(var2751, var2752);	// _6580 = BinOp(_2751 ADD _2752)
	sub128_o(var6580, make128_raw(3003630324502406223ull, 18341831465286854497ull), &var6583);
	// ^ Call( _6583 = "overflowing_sub"::<u128,>( _6580, 0x29af09ddc08ea44ffe8b4689da816761 u128, ), bb1875, bb399)
	var6581 = div128(var9, var160);	// _6581 = BinOp(_9 DIV _160)
	sub128_o(var6581, make128_raw(13705536357798243009ull, 5777971742030063008ull), &var6582);
	// ^ Call( _6582 = "overflowing_sub"::<u128,>( _6581, 0xbe33d8b3cec3eac1502f7aafb5f265a0 u128, ), bb1876, bb399)
	sub128_o(make128_raw(17867743496475107894ull, 10743762323994484618ull), var6582, &var6584);
	// ^ Call( _6584 = "overflowing_sub"::<u128,>( 0xf7f6fa0aed31e236951982e928ea9f8a u128, _6582, ), bb1877, bb399)
	sub128_o(var6583, var6584, &var2753);
	// ^ Call( _2753 = "overflowing_sub"::<u128,>( _6583, _6584, ), bb1878, bb399)
	var411 = var2753.lo;	// _411 = Cast(_2753 as u8)
	var412 = -149ll;	// _412 = Constant(-149 isize)
	var413 = 6910484236597420225ll;	// _413 = Constant(+6910484236597420225 i64)
	var6586 = 0x77b1c9e9;	// _6586 = Constant(0x77b1c9e9 u32)
	__builtin_add_overflow(0xa3f6f38b, 0x832a0c3d, &var6587);
	// ^ Call( _6587 = "overflowing_add"::<u32,>( 0xa3f6f38b u32, 0x832a0c3d u32, ), bb1879, bb399)
	var6585 = var6587 & 0x1f;	// _6585 = BinOp(_6587 BIT_AND 0x1f u32)
	var6590 = var6586 << var6585;
	// ^ Call( _6590 = "unchecked_shl"::<u32,>( _6586, _6585, ), bb1880, bb399)
	__builtin_sub_overflow(0x5cad2194, 0x59d9abfc, &var6589);
	// ^ Call( _6589 = "overflowing_sub"::<u32,>( 0x5cad2194 u32, 0x59d9abfc u32, ), bb1881, bb399)
	var6588 = var6589 & 0x1f;	// _6588 = BinOp(_6589 BIT_AND 0x1f u32)
	var6591 = 0x9a2b02ac << var6588;
	// ^ Call( _6591 = "unchecked_shl"::<u32,>( 0x9a2b02ac u32, _6588, ), bb1882, bb399)
	__builtin_add_overflow(0xb672, var311, &var2754);
	// ^ Call( _2754 = "overflowing_add"::<u16,>( 0xb672 u16, _311, ), bb1883, bb399)
	__builtin_mul_overflow(var143, var80, &var2755);
	// ^ Call( _2755 = "overflowing_mul"::<i8,>( _143, _80, ), bb1884, bb399)
	__builtin_sub_overflow(var328, 53, &var2756);
	// ^ Call( _2756 = "overflowing_sub"::<i8,>( _328, +53 i8, ), bb1885, bb399)
	var6592 = (int8_t )var357;	// _6592 = Cast(_357 as i8)
	__builtin_mul_overflow(-119, var6592, &var2757);
	// ^ Call( _2757 = "overflowing_mul"::<i8,>( -119 i8, _6592, ), bb1886, bb399)
	var6593 = (uint32_t )var102;	// _6593 = Cast(_102 as u32)
	__builtin_mul_overflow(0x21242ee7, var6593, &var2758);
	// ^ Call( _2758 = "overflowing_mul"::<u32,>( 0x21242ee7 u32, _6593, ), bb1887, bb399)
	var6594 = 0x97a2d2a6 & var2758;	// _6594 = BinOp(0x97a2d2a6 u32 BIT_AND _2758)
	var2759 = var6594 << 0xe;
	// ^ Call( _2759 = "unchecked_shl"::<u32,>( _6594, 0xe u32, ), bb1888, bb399)
	var414 = 0x708c67f4;	// _414 = Constant(0x708c67f4 u32)
	var2761 = var207 + var142;	// _2761 = BinOp(_207 ADD _142)
	var6595 = -var2761;	// _6595 = UniOp(_2761 NEG)
	__builtin_mul_overflow(var6595, var38, &var2762);
	// ^ Call( _2762 = "overflowing_mul"::<i16,>( _6595, _38, ), bb1889, bb399)
	var2763 = -var255;	// _2763 = UniOp(_255 NEG)
	var2764 = -var2763;	// _2764 = UniOp(_2763 NEG)
	var2760 = var2762 - var2764;	// _2760 = BinOp(_2762 SUB _2764)
	var415 = -var2760;	// _415 = UniOp(_2760 NEG)
	var2766 = div128(var3, make128_raw(4902900866535675423ull, 8039081517716520561ull));	// _2766 = BinOp(_3 DIV 0x440a9a5c86d0561f6f908e0c27e6be71 u128)
	var2767 = mul128(make128_raw(12826695435265205640ull, 3004839812579294585ull), var360);	// _2767 = BinOp(0xb201938a251b658829b355e3a3bd7d79 u128 MUL _360)
	var2765 = sub128(var2766, var2767);	// _2765 = BinOp(_2766 SUB _2767)
	var2769.lo = var81; var2769.hi = var81 < 0 ? -1 : 0;	// _2769 = Cast(_81 as u128)
	var2770 = xor128(var9, make128_raw(16293866705678007752ull, 3679235663244057613ull));	// _2770 = BinOp(_9 BIT_XOR 0xe21f7170b1807dc8330f4557a09c5c0d u128)
	var2768 = and128(var2769, var2770);	// _2768 = BinOp(_2769 BIT_AND _2770)
	var6596 = mul128(var2765, var2768);	// _6596 = BinOp(_2765 MUL _2768)
	var2772 = div128(make128_raw(8721866216954873364ull, 1581515826014979518ull), var160);	// _2772 = BinOp(0x790a4b1d2813461415f2ac43b84805be u128 DIV _160)
	var2771 = mul128(var404, var2772);	// _2771 = BinOp(_404 MUL _2772)
	var2774.lo = var147; var2774.hi = var147 < 0 ? -1 : 0;	// _2774 = Cast(_147 as u128)
	var2773 = sub128(make128_raw(17013306304721925171ull, 17783015168200506387ull), var2774);	// _2773 = BinOp(0xec1b67f19bdd3433f6c9f613b7f97c13 u128 SUB _2774)
	var6597 = xor128(var2771, var2773);	// _6597 = BinOp(_2771 BIT_XOR _2773)
	add128_o(var6596, var6597, &var6598);
	// ^ Call( _6598 = "overflowing_add"::<u128,>( _6596, _6597, ), bb1890, bb399)
	var2777 = div128(var408, var387);	// _2777 = BinOp(_408 DIV _387)
	var2778 = and128(var144, make128_raw(13422376430116413441ull, 13944546551027933032ull));	// _2778 = BinOp(_144 BIT_AND 0xba45dc3f96aa2001c184fb34efeb1f68 u128)
	var2776 = div128(var2777, var2778);	// _2776 = BinOp(_2777 DIV _2778)
	var2775 = and128(make128_raw(7002974388342410732ull, 5434038950245919766ull), var2776);	// _2775 = BinOp(0x612f901a544ecdec4b6995a26d0b6c16 u128 BIT_AND _2776)
	var2779.lo = var270; var2779.hi = var270 < 0 ? -1 : 0;	// _2779 = Cast(_270 as u128)
	var6599 = xor128(var2775, var2779);	// _6599 = BinOp(_2775 BIT_XOR _2779)
	mul128_o(var6598, var6599, &var2780);
	// ^ Call( _2780 = "overflowing_mul"::<u128,>( _6598, _6599, ), bb1891, bb399)
	var6600 = -var60;	// _6600 = UniOp(_60 NEG)
	__builtin_mul_overflow(var6600, var286, &var2783);
	// ^ Call( _2783 = "overflowing_mul"::<i16,>( _6600, _286, ), bb1892, bb399)
	var2782 = var302 - var2783;	// _2782 = BinOp(_302 SUB _2783)
	var2781 = var272 * var2782;	// _2781 = BinOp(_272 MUL _2782)
	var416 = var2781 ^ var60;	// _416 = BinOp(_2781 BIT_XOR _60)
	var2785 = var333 / 0x34aa;	// _2785 = BinOp(_333 DIV 0x34aa u16)
	var2786 = var68 - var391;	// _2786 = BinOp(_68 SUB _391)
	var6601 = 0x37ff | var2786;	// _6601 = BinOp(0x37ff u16 BIT_OR _2786)
	__builtin_add_overflow(var6601, var68, &var2787);
	// ^ Call( _2787 = "overflowing_add"::<u16,>( _6601, _68, ), bb1893, bb399)
	var2784 = var2785 ^ var2787;	// _2784 = BinOp(_2785 BIT_XOR _2787)
	var6602 = var301 & 0xf;	// _6602 = BinOp(_301 BIT_AND 0xf u32)
	var6603 = (uint16_t )var6602;	// _6603 = Cast(_6602 as u16)
	var2789 = 0x1 >> var6603;
	// ^ Call( _2789 = "unchecked_shr"::<u16,>( 0x1 u16, _6603, ), bb1894, bb399)
	var6606 = var368 ^ var189;	// _6606 = BinOp(_368 BIT_XOR _189)
	var6604 = var152 & 0xf;	// _6604 = BinOp(_152 BIT_AND 0xf u32)
	var6605 = (uint16_t )var6604;	// _6605 = Cast(_6604 as u16)
	var2790 = var6606 << var6605;
	// ^ Call( _2790 = "unchecked_shl"::<u16,>( _6606, _6605, ), bb1895, bb399)
	var2788 = var2789 ^ var2790;	// _2788 = BinOp(_2789 BIT_XOR _2790)
	var417 = var2784 / var2788;	// _417 = BinOp(_2784 DIV _2788)
	var418 = var141;	// _418 = Use(_141)
	var6609 = var49 - 0x3645bd48;	// _6609 = BinOp(_49 SUB 0x3645bd48 u32)
	var6607 = var6609 & 0x3f;	// _6607 = BinOp(_6609 BIT_AND 0x3f u32)
	var6608 = (int64_t )var6607;	// _6608 = Cast(_6607 as i64)
	var2792 = 5ll << var6608;
	// ^ Call( _2792 = "unchecked_shl"::<i64,>( +5 i64, _6608, ), bb1896, bb399)
	var2793 = (uint8_t )var2792;	// _2793 = Cast(_2792 as u8)
	var2791 = var2793 * var283;	// _2791 = BinOp(_2793 MUL _283)
	var419 = 0x97 * var2791;	// _419 = BinOp(0x97 u8 MUL _2791)
	__builtin_mul_overflow(var130, 0xfe, &var2794);
	// ^ Call( _2794 = "overflowing_mul"::<u8,>( _130, 0xfe u8, ), bb1897, bb399)
	var6612 = (uint8_t )var88;	// _6612 = Cast(_88 as u8)
	var6610 = var241 & 0x7;	// _6610 = BinOp(_241 BIT_AND 0x7 u32)
	var6611 = (uint8_t )var6610;	// _6611 = Cast(_6610 as u8)
	var2795 = var6612 << var6611;
	// ^ Call( _2795 = "unchecked_shl"::<u8,>( _6612, _6611, ), bb1898, bb399)
	var2796 = var81 >> 0x6;
	// ^ Call( _2796 = "unchecked_shr"::<u8,>( _81, 0x6 u8, ), bb1899, bb399)
	var6613 = var2796 ^ 0x7b;	// _6613 = BinOp(_2796 BIT_XOR 0x7b u8)
	__builtin_sub_overflow(var6613, var151, &var2797);
	// ^ Call( _2797 = "overflowing_sub"::<u8,>( _6613, _151, ), bb1900, bb399)
	var420 = var47 | 0x2d42ed65;	// _420 = BinOp(_47 BIT_OR 0x2d42ed65 u32)
	var6614.lo = var150; var6614.hi = var150 < 0 ? -1 : 0;	// _6614 = Cast(_150 as u128)
	add128_o(var308, make128_raw(12721710491557248160ull, 17900821784186318315ull), &var6615);
	// ^ Call( _6615 = "overflowing_add"::<u128,>( _308, 0xb08c984a20a13ca0f86c7e91f1ffedeb u128, ), bb1901, bb399)
	var6616 = div128(var6614, var6615);	// _6616 = BinOp(_6614 DIV _6615)
	sub128_o(var339, var6616, &var2798);
	// ^ Call( _2798 = "overflowing_sub"::<u128,>( _339, _6616, ), bb1902, bb399)
	var421 = -var396;	// _421 = UniOp(_396 NEG)
	var2799 = var366 ^ var279;	// _2799 = BinOp(_366 BIT_XOR _279)
	var2800 = var253 / var121;	// _2800 = BinOp(_253 DIV _121)
	var6617 = var2799 - var2800;	// _6617 = BinOp(_2799 SUB _2800)
	__builtin_mul_overflow(0xba70, var6617, &var6620);
	// ^ Call( _6620 = "overflowing_mul"::<u16,>( 0xba70 u16, _6617, ), bb1903, bb399)
	__builtin_mul_overflow(0xf952, 0x3a5d, &var6618);
	// ^ Call( _6618 = "overflowing_mul"::<u16,>( 0xf952 u16, 0x3a5d u16, ), bb1904, bb399)
	__builtin_sub_overflow(var45, 0x2844, &var2801);
	// ^ Call( _2801 = "overflowing_sub"::<u16,>( _45, 0x2844 u16, ), bb1905, bb399)
	var2802 = var348 & var278;	// _2802 = BinOp(_348 BIT_AND _278)
	var6619 = var2801 - var2802;	// _6619 = BinOp(_2801 SUB _2802)
	__builtin_mul_overflow(var6618, var6619, &var6621);
	// ^ Call( _6621 = "overflowing_mul"::<u16,>( _6618, _6619, ), bb1906, bb399)
	__builtin_add_overflow(var6620, var6621, &var2803);
	// ^ Call( _2803 = "overflowing_add"::<u16,>( _6620, _6621, ), bb1907, bb399)
	var422 = (int32_t )var2803;	// _422 = Cast(_2803 as i32)
	__builtin_mul_overflow(0x19, 0x9c, &var2804);
	// ^ Call( _2804 = "overflowing_mul"::<u8,>( 0x19 u8, 0x9c u8, ), bb1908, bb399)
	__builtin_sub_overflow(var163, 0xc36a0fe3, &var2805);
	// ^ Call( _2805 = "overflowing_sub"::<u32,>( _163, 0xc36a0fe3 u32, ), bb1909, bb399)
	var6624 = var67 ^ var2805;	// _6624 = BinOp(_67 BIT_XOR _2805)
	var6622 = var6624 & 0x7;	// _6622 = BinOp(_6624 BIT_AND 0x7 u32)
	var6623 = (uint8_t )var6622;	// _6623 = Cast(_6622 as u8)
	var2806 = var399 >> var6623;
	// ^ Call( _2806 = "unchecked_shr"::<u8,>( _399, _6623, ), bb1910, bb399)
	var2807 = !var392;	// _2807 = UniOp(_392 INV)
	if(var2807) goto bb1911; else goto bb1911;
	// ^ If( _2807 : 1911, 1911)
bb1911:
	__builtin_mul_overflow(var130, var198, &var2808);
	// ^ Call( _2808 = "overflowing_mul"::<u8,>( _130, _198, ), bb1912, bb399)
	__builtin_mul_overflow(0x26, var118, &var2809);
	// ^ Call( _2809 = "overflowing_mul"::<u8,>( 0x26 u8, _118, ), bb1913, bb399)
	var6625 = var2808 * var2809;	// _6625 = BinOp(_2808 MUL _2809)
	var6630 = var6625 >> 0x7;
	// ^ Call( _6630 = "unchecked_shr"::<u8,>( _6625, 0x7 u8, ), bb1914, bb399)
	__builtin_mul_overflow(var327, var386, &var2810);
	// ^ Call( _2810 = "overflowing_mul"::<u8,>( _327, _386, ), bb1915, bb399)
	var6628 = 0x6 & var2810;	// _6628 = BinOp(0x6 u8 BIT_AND _2810)
	__builtin_mul_overflow(var54, 0x99, &var6626);
	// ^ Call( _6626 = "overflowing_mul"::<u8,>( _54, 0x99 u8, ), bb1916, bb399)
	__builtin_sub_overflow(0x63, 0x83, &var6627);
	// ^ Call( _6627 = "overflowing_sub"::<u8,>( 0x63 u8, 0x83 u8, ), bb1917, bb399)
	var6629 = var6626 % var6627;	// _6629 = BinOp(_6626 MOD _6627)
	__builtin_mul_overflow(var6628, var6629, &var6631);
	// ^ Call( _6631 = "overflowing_mul"::<u8,>( _6628, _6629, ), bb1918, bb399)
	__builtin_add_overflow(var6630, var6631, &var6632);
	// ^ Call( _6632 = "overflowing_add"::<u8,>( _6630, _6631, ), bb1919, bb399)
	__builtin_mul_overflow(0xa, var6632, &var423);
	// ^ Call( _423 = "overflowing_mul"::<u8,>( 0xa u8, _6632, ), bb1920, bb399)
	var424 = 164;	// _424 = Constant(+164 i32)
	var2812 = var293 + var286;	// _2812 = BinOp(_293 ADD _286)
	var2811 = -10852 / var2812;	// _2811 = BinOp(-10852 i16 DIV _2812)
	var2813 = -var2811;	// _2813 = UniOp(_2811 NEG)
	var6633 = -18916 & var2813;	// _6633 = BinOp(-18916 i16 BIT_AND _2813)
	__builtin_sub_overflow(9465, var6633, &var425);
	// ^ Call( _425 = "overflowing_sub"::<i16,>( +146806400741856192973897929577425937657 i16, _6633, ), bb1921, bb399)
	var6634 = ZRICb15overflowing_rem0g( 23, 94 );
	// ^ Call( _6634 = <i8 /*- */>::overflowing_rem( +23 i8, +94 i8, ), bb1922, bb399)
	__builtin_mul_overflow(var6634._0, 91, &var2814);
	// ^ Call( _2814 = "overflowing_mul"::<i8,>( _6634.0, +91 i8, ), bb1923, bb399)
	var2815 = -var2814;	// _2815 = UniOp(_2814 NEG)
	var6635 = -var2815;	// _6635 = UniOp(_2815 NEG)
	var2817 = (int8_t )var49;	// _2817 = Cast(_49 as i8)
	var2818 = -var2817;	// _2818 = UniOp(_2817 NEG)
	var2819 = div128(var280, make128_raw(17293848842909076045ull, 16608740606120250874ull));	// _2819 = BinOp(_280 DIV 0xf00017e558e54a4de67e19959a674dfa u128)
	var2820 = var2819.lo;	// _2820 = Cast(_2819 as i8)
	var2816 = var2818 ^ var2820;	// _2816 = BinOp(_2818 BIT_XOR _2820)
	var2822 = var12 ^ var242;	// _2822 = BinOp(_12 BIT_XOR _242)
	var2821 = -104 * var2822;	// _2821 = BinOp(-104 i8 MUL _2822)
	var2823 = -var2821;	// _2823 = UniOp(_2821 NEG)
	var6636 = var2816 / var2823;	// _6636 = BinOp(_2816 DIV _2823)
	__builtin_mul_overflow(var6635, var6636, &var426);
	// ^ Call( _426 = "overflowing_mul"::<i8,>( _6635, _6636, ), bb1924, bb399)
	var2824 = -var206;	// _2824 = UniOp(_206 NEG)
	var2825 = -var233;	// _2825 = UniOp(_233 NEG)
	var6638 = var2824 / var2825;	// _6638 = BinOp(_2824 DIV _2825)
	var2826 = 118 | var252;	// _2826 = BinOp(+118 i8 BIT_OR _252)
	var6639 = var2826 | -45;	// _6639 = BinOp(_2826 BIT_OR -45 i8)
	var6637 = ZRICb15overflowing_rem0g( var6638, var6639 );
	// ^ Call( _6637 = <i8 /*- */>::overflowing_rem( _6638, _6639, ), bb1925, bb399)
	var6643 = -var6637._0;	// _6643 = UniOp(_6637.0 NEG)
	__builtin_mul_overflow(var218, -39, &var2828);
	// ^ Call( _2828 = "overflowing_mul"::<i8,>( _218, -39 i8, ), bb1926, bb399)
	var2829 = -var2828;	// _2829 = UniOp(_2828 NEG)
	var6640 = var123 << 7;
	// ^ Call( _6640 = "unchecked_shl"::<i8,>( _123, +7 i8, ), bb1927, bb399)
	var6641 = -var224;	// _6641 = UniOp(_224 NEG)
	__builtin_sub_overflow(var6640, var6641, &var2830);
	// ^ Call( _2830 = "overflowing_sub"::<i8,>( _6640, _6641, ), bb1928, bb399)
	var2827 = var2829 ^ var2830;	// _2827 = BinOp(_2829 BIT_XOR _2830)
	var6644 = -var2827;	// _6644 = UniOp(_2827 NEG)
	var6642 = ZRICb15overflowing_rem0g( var6643, var6644 );
	// ^ Call( _6642 = <i8 /*- */>::overflowing_rem( _6643, _6644, ), bb1929, bb399)
	var6645 = var311 & 0x19c8;	// _6645 = BinOp(_311 BIT_AND 0x19c8 u16)
	var6646 = var46 / var68;	// _6646 = BinOp(_46 DIV _68)
	__builtin_sub_overflow(var6645, var6646, &var2831);
	// ^ Call( _2831 = "overflowing_sub"::<u16,>( _6645, _6646, ), bb1930, bb399)
	var2832.lo = var2831; var2832.hi = var2831 < 0 ? -1 : 0;	// _2832 = Cast(_2831 as u128)
	var6648 = xor128(var359, var2832);	// _6648 = BinOp(_359 BIT_XOR _2832)
	var2834 = -2956;	// _2834 = Constant(-2956 i16)
	var6647 = ZRICb15overflowing_rem0g( var252, var119 );
	// ^ Call( _6647 = <i8 /*- */>::overflowing_rem( _252, _119, ), bb1931, bb399)
	var2835 = (int16_t )var6647._0;	// _2835 = Cast(_6647.0 as i16)
	var2833 = var2834 & var2835;	// _2833 = BinOp(_2834 BIT_AND _2835)
	var6649.lo = var2833; var6649.hi = var2833 < 0 ? -1 : 0;	// _6649 = Cast(_2833 as u128)
	sub128_o(var6648, var6649, &var427);
	// ^ Call( _427 = "overflowing_sub"::<u128,>( _6648, _6649, ), bb1932, bb399)
	__builtin_add_overflow(-16421, 0, &var2836);
	// ^ Call( _2836 = "overflowing_add"::<i32,>( -16421 i32, +0 i32, ), bb1933, bb399)
	var6650 = 0xa3596ea2;	// _6650 = Constant(0xa3596ea2 u32)
	__builtin_sub_overflow(var79, var92, &var2837);
	// ^ Call( _2837 = "overflowing_sub"::<u32,>( _79, _92, ), bb1934, bb399)
	__builtin_sub_overflow(0x2e45dc67, var337, &var2838);
	// ^ Call( _2838 = "overflowing_sub"::<u32,>( 0x2e45dc67 u32, _337, ), bb1935, bb399)
	var6651 = var2837 / var2838;	// _6651 = BinOp(_2837 DIV _2838)
	__builtin_mul_overflow(var6650, var6651, &var2839);
	// ^ Call( _2839 = "overflowing_mul"::<u32,>( _6650, _6651, ), bb1936, bb399)
	var6652 = var241 + 0x9515647e;	// _6652 = BinOp(_241 ADD 0x9515647e u32)
	__builtin_sub_overflow(var6652, var157, &var2840);
	// ^ Call( _2840 = "overflowing_sub"::<u32,>( _6652, _157, ), bb1937, bb399)
	var428 = 0x2f;	// _428 = Constant(0x2f u8)
	var429 = 228326303;	// _429 = Constant(+228326303 i32)
	var6654 = var183 & var413;	// _6654 = BinOp(_183 BIT_AND _413)
	var6653 = ZRICh15overflowing_div0g( 5146739519523489142ll, var6654 );
	// ^ Call( _6653 = <i64 /*- */>::overflowing_div( +5146739519523489142 i64, _6654, ), bb1938, bb399)
	var2842 = -var6653._0;	// _2842 = UniOp(_6653.0 NEG)
	var2844 = var331 / 9045468900705411069ll;	// _2844 = BinOp(_331 DIV +9045468900705411069 i64)
	var2845 = -var2844;	// _2845 = UniOp(_2844 NEG)
	var6655 = var247 & 0x3f;	// _6655 = BinOp(_247 BIT_AND 0x3f u32)
	var6656 = (int64_t )var6655;	// _6656 = Cast(_6655 as i64)
	var2846 = 8303042127244709222ll >> var6656;
	// ^ Call( _2846 = "unchecked_shr"::<i64,>( +8303042127244709222 i64, _6656, ), bb1939, bb399)
	var2843 = var2845 * var2846;	// _2843 = BinOp(_2845 MUL _2846)
	var2841 = var2842 * var2843;	// _2841 = BinOp(_2842 MUL _2843)
	var430 = -var2841;	// _430 = UniOp(_2841 NEG)
	var6659 = 313291965 << 7;
	// ^ Call( _6659 = "unchecked_shl"::<i32,>( +313291965 i32, +7 i32, ), bb1940, bb399)
	var6657 = var347 & 0x1f;	// _6657 = BinOp(_347 BIT_AND 0x1f u32)
	var6658 = (int32_t )var6657;	// _6658 = Cast(_6657 as i32)
	var6661 = var6659 >> var6658;
	// ^ Call( _6661 = "unchecked_shr"::<i32,>( _6659, _6658, ), bb1941, bb399)
	var6660 = -var145;	// _6660 = UniOp(_145 NEG)
	__builtin_sub_overflow(var6660, -1083380314, &var2847);
	// ^ Call( _2847 = "overflowing_sub"::<i32,>( _6660, -1083380314 i32, ), bb1942, bb399)
	var2848 = var26 / 1130283836;	// _2848 = BinOp(_26 DIV +1130283836 i32)
	var2849 = -var2848;	// _2849 = UniOp(_2848 NEG)
	var6662 = var2847 * var2849;	// _6662 = BinOp(_2847 MUL _2849)
	__builtin_mul_overflow(var6661, var6662, &var2850);
	// ^ Call( _2850 = "overflowing_mul"::<i32,>( _6661, _6662, ), bb1943, bb399)
	var431 = var364 * var2850;	// _431 = BinOp(_364 MUL _2850)
	var432 = var403;	// _432 = Use(_403)
	var6663 = ZRICd15overflowing_div0g( var398, -22386 );
	// ^ Call( _6663 = <i16 /*- */>::overflowing_div( _398, -22386 i16, ), bb1944, bb399)
	var2851 = neg128s(var307);	// _2851 = UniOp(_307 NEG)
	var2852 = var2851.lo;	// _2852 = Cast(_2851 as u16)
	var6664 = (uint16_t )var126;	// _6664 = Cast(_126 as u16)
	__builtin_sub_overflow(0x808d, var6664, &var2853);
	// ^ Call( _2853 = "overflowing_sub"::<u16,>( 0x808d u16, _6664, ), bb1945, bb399)
	var6665 = var2852 / var2853;	// _6665 = BinOp(_2852 DIV _2853)
	var2854 = var6665 >> 0x4;
	// ^ Call( _2854 = "unchecked_shr"::<u16,>( _6665, 0x4 u16, ), bb1946, bb399)
	var6670 = 0x25ull;	// _6670 = Constant(0x25 u64)
	var6668 = 0x87fd79776f9f669full;	// _6668 = Constant(0x87fd79776f9f669f u64)
	var6666 = var168 & 0x3f;	// _6666 = BinOp(_168 BIT_AND 0x3f u32)
	var6667 = (uint64_t )var6666;	// _6667 = Cast(_6666 as u64)
	var6669 = var133 << var6667;
	// ^ Call( _6669 = "unchecked_shl"::<u64,>( _133, _6667, ), bb1947, bb399)
	__builtin_mul_overflow(var6668, var6669, &var6671);
	// ^ Call( _6671 = "overflowing_mul"::<u64,>( _6668, _6669, ), bb1948, bb399)
	var2855 = var6670 % var6671;	// _2855 = BinOp(_6670 MOD _6671)
	var6672 = var2855 * var74;	// _6672 = BinOp(_2855 MUL _74)
	__builtin_add_overflow(var271, var6672, &var433);
	// ^ Call( _433 = "overflowing_add"::<u64,>( _271, _6672, ), bb1949, bb399)
	var6673 = var47 & 0x3f;	// _6673 = BinOp(_47 BIT_AND 0x3f u32)
	var6674 = (uintptr_t )var6673;	// _6674 = Cast(_6673 as usize)
	var2856 = var380 << var6674;
	// ^ Call( _2856 = "unchecked_shl"::<usize,>( _380, _6674, ), bb1950, bb399)
	var6677 = var34 * 0x553a8e00;	// _6677 = BinOp(_34 MUL 0x553a8e00 u32)
	var6675 = var414 >> 0x13;
	// ^ Call( _6675 = "unchecked_shr"::<u32,>( _414, 0x13 u32, ), bb1951, bb399)
	__builtin_add_overflow(0x3152e21b, var6675, &var6678);
	// ^ Call( _6678 = "overflowing_add"::<u32,>( 0x3152e21b u32, _6675, ), bb1952, bb399)
	var6676 = var6678 & 0x1f;	// _6676 = BinOp(_6678 BIT_AND 0x1f u32)
	var2857 = var6677 << var6676;
	// ^ Call( _2857 = "unchecked_shl"::<u32,>( _6677, _6676, ), bb1953, bb399)
	var2858 = 2998425291129725375ll / var64;	// _2858 = BinOp(+2998425291129725375 isize DIV _64)
	var6680 = -var2858;	// _6680 = UniOp(_2858 NEG)
	var6679 = ZRICv15overflowing_rem0g( -6562995113852513910ll, var6680 );
	// ^ Call( _6679 = <isize /*- */>::overflowing_rem( -6562995113852513910 isize, _6680, ), bb1954, bb399)
	var434 = 0 | var8;	// _434 = BinOp(+0 i8 BIT_OR _8)
	var6681 = var51 / 0xf744737b;	// _6681 = BinOp(_51 DIV 0xf744737b u32)
	__builtin_sub_overflow(var6681, var397, &var2859);
	// ^ Call( _2859 = "overflowing_sub"::<u32,>( _6681, _397, ), bb1955, bb399)
	var6684 = var2859 | var261;	// _6684 = BinOp(_2859 BIT_OR _261)
	var6682 = var6684 & 0x7;	// _6682 = BinOp(_6684 BIT_AND 0x7 u32)
	var6683 = (int8_t )var6682;	// _6683 = Cast(_6682 as i8)
	var2860 = var37 >> var6683;
	// ^ Call( _2860 = "unchecked_shr"::<i8,>( _37, _6683, ), bb1956, bb399)
	__builtin_add_overflow(var342, var264, &var6686);
	// ^ Call( _6686 = "overflowing_add"::<i8,>( _342, _264, ), bb1957, bb399)
	var6687 = var184 ^ var402;	// _6687 = BinOp(_184 BIT_XOR _402)
	var6685 = ZRICb15overflowing_div0g( var6686, var6687 );
	// ^ Call( _6685 = <i8 /*- */>::overflowing_div( _6686, _6687, ), bb1958, bb399)
	var6689 = 91 << 3;
	// ^ Call( _6689 = "unchecked_shl"::<i8,>( +91 i8, +3 i8, ), bb1959, bb399)
	var6688 = ZRICb15overflowing_rem0g( var6689, 84 );
	// ^ Call( _6688 = <i8 /*- */>::overflowing_rem( _6689, +84 i8, ), bb1960, bb399)
	var6690 = ZRICb15overflowing_div0g( var6685._0, var6688._0 );
	// ^ Call( _6690 = <i8 /*- */>::overflowing_div( _6685.0, _6688.0, ), bb1961, bb399)
	var2861 = -var291;	// _2861 = UniOp(_291 NEG)
	var435 = -var2861;	// _435 = UniOp(_2861 NEG)
	var436 = (uint32_t )var327;	// _436 = Cast(_327 as u32)
	var2862 = (int8_t )var10;	// _2862 = Cast(_10 as i8)
	var2863 = -var2862;	// _2863 = UniOp(_2862 NEG)
	var2864 = -var2863;	// _2864 = UniOp(_2863 NEG)
	var437 = var2864 & 81;	// _437 = BinOp(_2864 BIT_AND +81 i8)
	var438 = -119 + var119;	// _438 = BinOp(-119 i8 ADD _119)
	var439 = 0xbc0fa6e5;	// _439 = Constant(0xbc0fa6e5 u32)
	__builtin_add_overflow(var270, -82, &var6692);
	// ^ Call( _6692 = "overflowing_add"::<i8,>( _270, -82 i8, ), bb1962, bb399)
	var6691 = ZRICb15overflowing_div0g( var6692, 34 );
	// ^ Call( _6691 = <i8 /*- */>::overflowing_div( _6692, +34 i8, ), bb1963, bb399)
	var2866 = (uint32_t )var6691._0;	// _2866 = Cast(_6691.0 as u32)
	var2865 = 0x5e81a4dd & var2866;	// _2865 = BinOp(0x5e81a4dd u32 BIT_AND _2866)
	var440 = var2865 ^ var314;	// _440 = BinOp(_2865 BIT_XOR _314)
	var2870 = var170 / 16;	// _2870 = BinOp(_170 DIV +16 i8)
	__builtin_sub_overflow(-101, 125, &var2871);
	// ^ Call( _2871 = "overflowing_sub"::<i8,>( -101 i8, +125 i8, ), bb1964, bb399)
	var2869 = var2870 & var2871;	// _2869 = BinOp(_2870 BIT_AND _2871)
	var2873 = -var172;	// _2873 = UniOp(_172 NEG)
	var6693 = var266 & 0x7;	// _6693 = BinOp(_266 BIT_AND 0x7 u32)
	var6694 = (int8_t )var6693;	// _6694 = Cast(_6693 as i8)
	var2874 = -32 >> var6694;
	// ^ Call( _2874 = "unchecked_shr"::<i8,>( -32 i8, _6694, ), bb1965, bb399)
	var2872 = var2873 * var2874;	// _2872 = BinOp(_2873 MUL _2874)
	var2868 = var2869 + var2872;	// _2868 = BinOp(_2869 ADD _2872)
	var2867 = var170 * var2868;	// _2867 = BinOp(_170 MUL _2868)
	var441 = -var2867;	// _441 = UniOp(_2867 NEG)
	var442 = var320;	// _442 = Use(_320)
	var2875 = var365 | var423;	// _2875 = BinOp(_365 BIT_OR _423)
	var6697 = var2875 & var300;	// _6697 = BinOp(_2875 BIT_AND _300)
	var6695 = var49 & 0x7;	// _6695 = BinOp(_49 BIT_AND 0x7 u32)
	var6696 = (uint8_t )var6695;	// _6696 = Cast(_6695 as u8)
	var6698 = var6697 >> var6696;
	// ^ Call( _6698 = "unchecked_shr"::<u8,>( _6697, _6696, ), bb1966, bb399)
	var2876 = var6698 / 0xb0;	// _2876 = BinOp(_6698 DIV 0xb0 u8)
	__builtin_add_overflow(0xbd, 0x41, &var6699);
	// ^ Call( _6699 = "overflowing_add"::<u8,>( 0xbd u8, 0x41 u8, ), bb1967, bb399)
	var6700 = var428 | 0xac;	// _6700 = BinOp(_428 BIT_OR 0xac u8)
	__builtin_sub_overflow(var6699, var6700, &var6701);
	// ^ Call( _6701 = "overflowing_sub"::<u8,>( _6699, _6700, ), bb1968, bb399)
	__builtin_add_overflow(0xf9aa, 0xd5dc, &var2877);
	// ^ Call( _2877 = "overflowing_add"::<u16,>( 0xf9aa u16, 0xd5dc u16, ), bb1969, bb399)
	var6702 = (uint8_t )var2877;	// _6702 = Cast(_2877 as u8)
	__builtin_sub_overflow(var6701, var6702, &var6703);
	// ^ Call( _6703 = "overflowing_sub"::<u8,>( _6701, _6702, ), bb1970, bb399)
	__builtin_mul_overflow(var6703, 0x50, &var2878);
	// ^ Call( _2878 = "overflowing_mul"::<u8,>( _6703, 0x50 u8, ), bb1971, bb399)
	var443 = var2876 * var2878;	// _443 = BinOp(_2876 MUL _2878)
	var2880 = -var355;	// _2880 = UniOp(_355 NEG)
	var2879 = 485995034071504527ll * var2880;	// _2879 = BinOp(+485995034071504527 i64 MUL _2880)
	var2881 = -var2879;	// _2881 = UniOp(_2879 NEG)
	var2884 = var148 * var430;	// _2884 = BinOp(_148 MUL _430)
	__builtin_sub_overflow(var413, 1925095341614709377ll, &var2885);
	// ^ Call( _2885 = "overflowing_sub"::<i64,>( _413, +1925095341614709377 i64, ), bb1972, bb399)
	var2883 = var2884 & var2885;	// _2883 = BinOp(_2884 BIT_AND _2885)
	var2882 = var2883 & -6972823443127698219ll;	// _2882 = BinOp(_2883 BIT_AND -6972823443127698219 i64)
	var6710 = var2881 ^ var2882;	// _6710 = BinOp(_2881 BIT_XOR _2882)
	var2886 = var92 / var247;	// _2886 = BinOp(_92 DIV _247)
	var6705 = 0x744cbd62 | var2886;	// _6705 = BinOp(0x744cbd62 u32 BIT_OR _2886)
	var2887 = var285 | var285;	// _2887 = BinOp(_285 BIT_OR _285)
	var6704 = var2 & 0x1f;	// _6704 = BinOp(_2 BIT_AND 0x1f u32)
	var2888 = var67 >> var6704;
	// ^ Call( _2888 = "unchecked_shr"::<u32,>( _67, _6704, ), bb1973, bb399)
	var6706 = var2887 * var2888;	// _6706 = BinOp(_2887 MUL _2888)
	var2889 = var6705 / var6706;	// _2889 = BinOp(_6705 DIV _6706)
	var2890 = var47 / var420;	// _2890 = BinOp(_47 DIV _420)
	var6707 = 0xd1627ad4 * var2890;	// _6707 = BinOp(0xd1627ad4 u32 MUL _2890)
	__builtin_mul_overflow(var6707, var95, &var2891);
	// ^ Call( _2891 = "overflowing_mul"::<u32,>( _6707, _95, ), bb1974, bb399)
	var6711 = var2889 * var2891;	// _6711 = BinOp(_2889 MUL _2891)
	var6708 = var6711 & 0x3f;	// _6708 = BinOp(_6711 BIT_AND 0x3f u32)
	var6709 = (int64_t )var6708;	// _6709 = Cast(_6708 as i64)
	var2892 = var6710 >> var6709;
	// ^ Call( _2892 = "unchecked_shr"::<i64,>( _6710, _6709, ), bb1975, bb399)
	var6712 = ZRICv15overflowing_div0g( 2367238091616790345ll, -5020181658620819431ll );
	// ^ Call( _6712 = <isize /*- */>::overflowing_div( +2367238091616790345 isize, -5020181658620819431 isize, ), bb1976, bb399)
	var444 = -var6712._0;	// _444 = UniOp(_6712.0 NEG)
	var445 = var19;	// _445 = Use(_19)
	var6713 = (uintptr_t )var254;	// _6713 = Cast(_254 as usize)
	__builtin_sub_overflow(var6713, var289, &var2895);
	// ^ Call( _2895 = "overflowing_sub"::<usize,>( _6713, _289, ), bb1977, bb399)
	__builtin_sub_overflow(0x85064efe069ed271ull, var53, &var6714);
	// ^ Call( _6714 = "overflowing_sub"::<usize,>( 0x85064efe069ed271 usize, _53, ), bb1978, bb399)
	var2896 = var273 % var6714;	// _2896 = BinOp(_273 MOD _6714)
	var2894 = var2895 - var2896;	// _2894 = BinOp(_2895 SUB _2896)
	var2893 = var234 / var2894;	// _2893 = BinOp(_234 DIV _2894)
	var446 = var234 + var2893;	// _446 = BinOp(_234 ADD _2893)
	var2898 = make128s_raw(18446744073709551615ull, 18446744073709551581ull);	// _2898 = Constant(-35 i128)
	var6715 = ZRICj15overflowing_div0g( var136, var65 );
	// ^ Call( _6715 = <i128 /*- */>::overflowing_div( _136, _65, ), bb1979, bb399)
	var2901 = or128s(var307, make128s_raw(15953918454152541413ull, 879796934108799622ull));	// _2901 = BinOp(_307 BIT_OR -45984516224354619293673857678558338426 i128)
	var2900 = div128s(var6715._0, var2901);	// _2900 = BinOp(_6715.0 DIV _2901)
	var2899 = mul128s(var136, var2900);	// _2899 = BinOp(_136 MUL _2900)
	var2897 = xor128s(var2898, var2899);	// _2897 = BinOp(_2898 BIT_XOR _2899)
	var6716 = ZRICj15overflowing_div0g( make128s_raw(2771661215686642998ull, 15198526913994235290ull), var48 );
	// ^ Call( _6716 = <i128 /*- */>::overflowing_div( +51128125104798193058416959856840220058 i128, _48, ), bb1980, bb399)
	var2904 = neg128s(var107);	// _2904 = UniOp(_107 NEG)
	var2903 = div128s(var6716._0, var2904);	// _2903 = BinOp(_6716.0 DIV _2904)
	var2902 = add128s(var2903, make128s_raw(5336976952403867640ull, 13939547285860280023ull));	// _2902 = BinOp(_2903 ADD +98449847968280509125518964374472386263 i128)
	var447 = and128s(var2897, var2902);	// _447 = BinOp(_2897 BIT_AND _2902)
	var448 = var238;	// _448 = Use(_238)
	var6717 = var25 & 0x1f;	// _6717 = BinOp(_25 BIT_AND 0x1f u32)
	var6718 = (int32_t )var6717;	// _6718 = Cast(_6717 as i32)
	var2905 = 138423429 << var6718;
	// ^ Call( _2905 = "unchecked_shl"::<i32,>( +138423429 i32, _6718, ), bb1981, bb399)
	var449 = 0x24;	// _449 = Constant(0x24 u8)
	var2907 = 0x23d7 / var382;	// _2907 = BinOp(0x23d7 u16 DIV _382)
	var2908.lo = var2907; var2908.hi = var2907 < 0 ? -1 : 0;	// _2908 = Cast(_2907 as i128)
	var6719 = ZRICj15overflowing_div0g( make128s_raw(13411298284772074069ull, 6551414311249682140ull), make128s_raw(8206467732674054012ull, 7081772833385942196ull) );
	// ^ Call( _6719 = <i128 /*- */>::overflowing_div( -92887579765568131597962396736187883812 i128, +151382610013793766735195374734871825588 i128, ), bb1982, bb399)
	var2906 = 0 <= cmp128s(var6719._0, var2908);	// _2906 = BinOp(_2908 LE _6719.0)
	var2909 = !var2906;	// _2909 = UniOp(_2906 INV)
	var450 = !var2909;	// _450 = UniOp(_2909 INV)
	var451 = 0x69;	// _451 = Constant(0x69 u8)
	var6720 = var2 & 0x7f;	// _6720 = BinOp(_2 BIT_AND 0x7f u32)
	var6721.lo = var6720; var6721.hi = var6720 < 0 ? -1 : 0;	// _6721 = Cast(_6720 as u128)
	var6722 = shr128(make128_raw(0ull, 168ull), var6721.lo);
	// ^ Call( _6722 = "unchecked_shr"::<u128,>( 0xa8 u128, _6721, ), bb1983, bb399)
	var2911 = shl128(var6722, make128_raw(0ull, 126ull).lo);
	// ^ Call( _2911 = "unchecked_shl"::<u128,>( _6722, 0x7e u128, ), bb1984, bb399)
	var2914 = div128(var376, make128_raw(13348544873680690763ull, 8686411391899212886ull));	// _2914 = BinOp(_376 DIV 0xb93f8ed6c8195e4b788c55236b0f1c56 u128)
	var2915 = mod128(make128_raw(17334511173468597430ull, 1193409527191174662ull), var57);	// _2915 = BinOp(0xf0908e11f1a2acb6108fd7a45bcbfe06 u128 MOD _57)
	var2913 = or128(var2914, var2915);	// _2913 = BinOp(_2914 BIT_OR _2915)
	var2912 = div128(var2913, var3);	// _2912 = BinOp(_2913 DIV _3)
	var2910 = mul128(var2911, var2912);	// _2910 = BinOp(_2911 MUL _2912)
	var2917 = var270 + -50;	// _2917 = BinOp(_270 ADD -50 i8)
	__builtin_mul_overflow(-89, var4, &var2918);
	// ^ Call( _2918 = "overflowing_mul"::<i8,>( -89 i8, _4, ), bb1985, bb399)
	var2916 = var2917 | var2918;	// _2916 = BinOp(_2917 BIT_OR _2918)
	var2919 = -var2916;	// _2919 = UniOp(_2916 NEG)
	var2920.lo = var2919; var2920.hi = var2919 < 0 ? -1 : 0;	// _2920 = Cast(_2919 as u128)
	var452 = add128(var2910, var2920);	// _452 = BinOp(_2910 ADD _2920)
	var6723 = var299 - var11;	// _6723 = BinOp(_299 SUB _11)
	__builtin_sub_overflow(var6723, var221, &var6725);
	// ^ Call( _6725 = "overflowing_sub"::<u16,>( _6723, _221, ), bb1986, bb399)
	var6724 = 0x4a72 >> 0x2;
	// ^ Call( _6724 = "unchecked_shr"::<u16,>( 0x4a72 u16, 0x2 u16, ), bb1987, bb399)
	__builtin_mul_overflow(var6724, 0x1, &var6726);
	// ^ Call( _6726 = "overflowing_mul"::<u16,>( _6724, 0x1 u16, ), bb1988, bb399)
	var453 = 0x91;	// _453 = Constant(0x91 u16)
	var6727 = 0;	// _6727 = Constant(+0 i8)
	var6728 = -32 << 5;
	// ^ Call( _6728 = "unchecked_shl"::<i8,>( -32 i8, +5 i8, ), bb1989, bb399)
	__builtin_sub_overflow(var6727, var6728, &var2922);
	// ^ Call( _2922 = "overflowing_sub"::<i8,>( _6727, _6728, ), bb1990, bb399)
	var2921 = 123 - var2922;	// _2921 = BinOp(+123 i8 SUB _2922)
	var2925 = -var434;	// _2925 = UniOp(_434 NEG)
	var2924 = -10 ^ var2925;	// _2924 = BinOp(+246 i8 BIT_XOR _2925)
	var2926 = -var2924;	// _2926 = UniOp(_2924 NEG)
	var6730 = -112 | var304;	// _6730 = BinOp(-112 i8 BIT_OR _304)
	var6729 = ZRICb15overflowing_div0g( -37, var6730 );
	// ^ Call( _6729 = <i8 /*- */>::overflowing_div( -37 i8, _6730, ), bb1991, bb399)
	var2927 = var6729._0 - 93;	// _2927 = BinOp(_6729.0 SUB +93 i8)
	var2923 = var2926 + var2927;	// _2923 = BinOp(_2926 ADD _2927)
	var454 = var2921 / var2923;	// _454 = BinOp(_2921 DIV _2923)
	var455 = var364;	// _455 = Use(_364)
	var456 = 0xdcc360ff;	// _456 = Constant(0xdcc360ff u32)
	var457 = 0xff;	// _457 = Constant(0xff u8)
	var6731 = var102 / 0xa9070b844dd2d506ull;	// _6731 = BinOp(_102 DIV 0xa9070b844dd2d506 u64)
	__builtin_mul_overflow(0x20c6ec5e87ac97d7ull, var186, &var6732);
	// ^ Call( _6732 = "overflowing_mul"::<u64,>( 0x20c6ec5e87ac97d7 u64, _186, ), bb1992, bb399)
	__builtin_sub_overflow(var6731, var6732, &var2928);
	// ^ Call( _2928 = "overflowing_sub"::<u64,>( _6731, _6732, ), bb1993, bb399)
	var6733 = var22 & 0x3f;	// _6733 = BinOp(_22 BIT_AND 0x3f u32)
	var6734 = (uint64_t )var6733;	// _6734 = Cast(_6733 as u64)
	var6735 = 0x4ull >> var6734;
	// ^ Call( _6735 = "unchecked_shr"::<u64,>( 0x4 u64, _6734, ), bb1994, bb399)
	__builtin_add_overflow(var6735, var74, &var2929);
	// ^ Call( _2929 = "overflowing_add"::<u64,>( _6735, _74, ), bb1995, bb399)
	var6736 = add128(var427, var82);	// _6736 = BinOp(_427 ADD _82)
	var6737 = sub128(make128_raw(1211563310409863103ull, 16416648381958847984ull), var388);	// _6737 = BinOp(0x10d0566963e04fbfe3d3a6b96925fdf0 u128 SUB _388)
	sub128_o(var6736, var6737, &var2930);
	// ^ Call( _2930 = "overflowing_sub"::<u128,>( _6736, _6737, ), bb1996, bb399)
	var2931 = var2930.lo;	// _2931 = Cast(_2930 as u16)
	var6739 = (uint16_t )var49;	// _6739 = Cast(_49 as u16)
	var6738 = (uint16_t )var125;	// _6738 = Cast(_125 as u16)
	__builtin_sub_overflow(0x5e19, var6738, &var6740);
	// ^ Call( _6740 = "overflowing_sub"::<u16,>( 0x5e19 u16, _6738, ), bb1997, bb399)
	var2932 = var6739 / var6740;	// _2932 = BinOp(_6739 DIV _6740)
	var6749 = var2931 | var2932;	// _6749 = BinOp(_2931 BIT_OR _2932)
	var2933 = add128(var404, make128_raw(15072767680563860021ull, 3045615199051796415ull));	// _2933 = BinOp(_404 ADD 0xd12d3a58b5ff52352a4432e31e034fbf u128)
	var6741 = var2933.lo;	// _6741 = Cast(_2933 as u16)
	var2934 = 0x13ca + var311;	// _2934 = BinOp(0x13ca u16 ADD _311)
	var6742 = var2934 | 0x0;	// _6742 = BinOp(_2934 BIT_OR 0x0 u16)
	var2935 = var6741 / var6742;	// _2935 = BinOp(_6741 DIV _6742)
	var6743 = var314 & 0x1f;	// _6743 = BinOp(_314 BIT_AND 0x1f u32)
	var6745 = 0x9891b46a >> var6743;
	// ^ Call( _6745 = "unchecked_shr"::<u32,>( 0x9891b46a u32, _6743, ), bb1998, bb399)
	var6744 = var95 & 0x1f;	// _6744 = BinOp(_95 BIT_AND 0x1f u32)
	var6748 = var6745 << var6744;
	// ^ Call( _6748 = "unchecked_shl"::<u32,>( _6745, _6744, ), bb1999, bb399)
	var6746 = var6748 & 0xf;	// _6746 = BinOp(_6748 BIT_AND 0xf u32)
	var6747 = (uint16_t )var6746;	// _6747 = Cast(_6746 as u16)
	var2936 = var351 << var6747;
	// ^ Call( _2936 = "unchecked_shl"::<u16,>( _351, _6747, ), bb2000, bb399)
	var6750 = var2935 ^ var2936;	// _6750 = BinOp(_2935 BIT_XOR _2936)
	__builtin_add_overflow(var6749, var6750, &var2937);
	// ^ Call( _2937 = "overflowing_add"::<u16,>( _6749, _6750, ), bb2001, bb399)
	var458 = var237;	// _458 = Use(_237)
	var2940 = 5591098540681132392ll | var343;	// _2940 = BinOp(+5591098540681132392 i64 BIT_OR _343)
	var2941 = var139 - 372671700722800399ll;	// _2941 = BinOp(_139 SUB +372671700722800399 i64)
	var2939 = var2940 - var2941;	// _2939 = BinOp(_2940 SUB _2941)
	var2943 = var183 | -6210254405253949468ll;	// _2943 = BinOp(_183 BIT_OR -6210254405253949468 i64)
	var2944 = -var367;	// _2944 = UniOp(_367 NEG)
	var2942 = var2943 / var2944;	// _2942 = BinOp(_2943 DIV _2944)
	var2938 = var2939 * var2942;	// _2938 = BinOp(_2939 MUL _2942)
	var6753 = -7868552541243168327ll * var2938;	// _6753 = BinOp(-7868552541243168327 i64 MUL _2938)
	var6751 = ZRICh15overflowing_div0g( -5156624646885306086ll, 2895753359737670124ll );
	// ^ Call( _6751 = <i64 /*- */>::overflowing_div( -5156624646885306086 i64, +2895753359737670124 i64, ), bb2002, bb399)
	var6754 = -var6751._0;	// _6754 = UniOp(_6751.0 NEG)
	var6752 = ZRICh15overflowing_rem0g( var6753, var6754 );
	// ^ Call( _6752 = <i64 /*- */>::overflowing_rem( _6753, _6754, ), bb2003, bb399)
	var459 = var6752._0;	// _459 = Use(_6752.0)
	if(var215) goto bb2004; else goto bb2004;
	// ^ If( _215 : 2004, 2004)
bb2004:
	var6755 = -20666 << 14;
	// ^ Call( _6755 = "unchecked_shl"::<i16,>( -20666 i16, +14 i16, ), bb2005, bb399)
	var6756 = var255 / var425;	// _6756 = BinOp(_255 DIV _425)
	__builtin_mul_overflow(var6755, var6756, &var2946);
	// ^ Call( _2946 = "overflowing_mul"::<i16,>( _6755, _6756, ), bb2006, bb399)
	var2945 = 5686 - var2946;	// _2945 = BinOp(+5686 i16 SUB _2946)
	var6762 = -var2945;	// _6762 = UniOp(_2945 NEG)
	var6757 = var72 - var72;	// _6757 = BinOp(_72 SUB _72)
	var6758 = -27019 ^ var286;	// _6758 = BinOp(-27019 i16 BIT_XOR _286)
	__builtin_mul_overflow(var6757, var6758, &var6760);
	// ^ Call( _6760 = "overflowing_mul"::<i16,>( _6757, _6758, ), bb2007, bb399)
	var2947 = var416 ^ var357;	// _2947 = BinOp(_416 BIT_XOR _357)
	var6761 = 12684 | var2947;	// _6761 = BinOp(+12684 i16 BIT_OR _2947)
	var6759 = ZRICd15overflowing_div0g( var6760, var6761 );
	// ^ Call( _6759 = <i16 /*- */>::overflowing_div( _6760, _6761, ), bb2008, bb399)
	var6763 = -var6759._0;	// _6763 = UniOp(_6759.0 NEG)
	__builtin_mul_overflow(var6762, var6763, &var2948);
	// ^ Call( _2948 = "overflowing_mul"::<i16,>( _6762, _6763, ), bb2009, bb399)
	var2950 = var356 ^ -8049413776207952374ll;	// _2950 = BinOp(_356 BIT_XOR -8049413776207952374 isize)
	var2949 = var2950 / 4995322872466443053ll;	// _2949 = BinOp(_2950 DIV +4995322872466443053 isize)
	var2951 = -var2949;	// _2951 = UniOp(_2949 NEG)
	var2952 = -var2951;	// _2952 = UniOp(_2951 NEG)
	var2954 = -4017529844642811570ll | var245;	// _2954 = BinOp(-4017529844642811570 isize BIT_OR _245)
	var6764 = -var2954;	// _6764 = UniOp(_2954 NEG)
	var2955 = -1525648750103443002ll;	// _2955 = Constant(-1525648750103443002 isize)
	__builtin_mul_overflow(var109, var55, &var2956);
	// ^ Call( _2956 = "overflowing_mul"::<isize,>( _109, _55, ), bb2010, bb399)
	var6765 = var2955 * var2956;	// _6765 = BinOp(_2955 MUL _2956)
	__builtin_mul_overflow(var6764, var6765, &var2957);
	// ^ Call( _2957 = "overflowing_mul"::<isize,>( _6764, _6765, ), bb2011, bb399)
	var2958 = var412 + var298;	// _2958 = BinOp(_412 ADD _298)
	var2959 = -var2958;	// _2959 = UniOp(_2958 NEG)
	var2960 = -var2959;	// _2960 = UniOp(_2959 NEG)
	var2953 = var2957 + var2960;	// _2953 = BinOp(_2957 ADD _2960)
	var460 = var2952 < var2953;	// _460 = BinOp(_2952 LT _2953)
	var2961 = -var255;	// _2961 = UniOp(_255 NEG)
	var2962 = -var2961;	// _2962 = UniOp(_2961 NEG)
	var2963 = -var2962;	// _2963 = UniOp(_2962 NEG)
	var6768 = var2963 - -13178;	// _6768 = BinOp(_2963 SUB -13178 i16)
	var6766 = var456 & 0xf;	// _6766 = BinOp(_456 BIT_AND 0xf u32)
	var6767 = (int16_t )var6766;	// _6767 = Cast(_6766 as i16)
	var461 = var6768 >> var6767;
	// ^ Call( _461 = "unchecked_shr"::<i16,>( _6768, _6767, ), bb2012, bb399)
	var2965 = -var431;	// _2965 = UniOp(_431 NEG)
	var2964 = 0 | var2965;	// _2964 = BinOp(+0 i32 BIT_OR _2965)
	var6770 = var33 | -1955755010;	// _6770 = BinOp(_33 BIT_OR -1955755010 i32)
	var6769 = ZRICf15overflowing_div0g( var424, var6770 );
	// ^ Call( _6769 = <i32 /*- */>::overflowing_div( _424, _6770, ), bb2013, bb399)
	var2966 = -var6769._0;	// _2966 = UniOp(_6769.0 NEG)
	var2967 = -var2966;	// _2967 = UniOp(_2966 NEG)
	var462 = var2964 ^ var2967;	// _462 = BinOp(_2964 BIT_XOR _2967)
	__builtin_add_overflow(var317, -6808, &var2970);
	// ^ Call( _2970 = "overflowing_add"::<i16,>( _317, -6808 i16, ), bb2014, bb399)
	var2969 = var2970 | -8621;	// _2969 = BinOp(_2970 BIT_OR -8621 i16)
	var2968 = var2969 ^ 1;	// _2968 = BinOp(_2969 BIT_XOR +1 i16)
	var2971 = (int32_t )var2968;	// _2971 = Cast(_2968 as i32)
	var463 = -var2971;	// _463 = UniOp(_2971 NEG)
	var464 = -989884456;	// _464 = Constant(-989884456 i32)
	var2972 = var459 - var393;	// _2972 = BinOp(_459 SUB _393)
	var6775 = -var2972;	// _6775 = UniOp(_2972 NEG)
	var2973 = 0x4a03e9d2 & var177;	// _2973 = BinOp(0x4a03e9d2 u32 BIT_AND _177)
	var2974 = var176 % 0xd95d304f;	// _2974 = BinOp(_176 MOD 0xd95d304f u32)
	var6771 = var2973 ^ var2974;	// _6771 = BinOp(_2973 BIT_XOR _2974)
	var2975 = 0x667a6563 | var220;	// _2975 = BinOp(0x667a6563 u32 BIT_OR _220)
	var2976 = var41 / 0x7f7624fd;	// _2976 = BinOp(_41 DIV 0x7f7624fd u32)
	var6772 = var2975 ^ var2976;	// _6772 = BinOp(_2975 BIT_XOR _2976)
	__builtin_sub_overflow(var6771, var6772, &var6776);
	// ^ Call( _6776 = "overflowing_sub"::<u32,>( _6771, _6772, ), bb2015, bb399)
	var6773 = var6776 & 0x3f;	// _6773 = BinOp(_6776 BIT_AND 0x3f u32)
	var6774 = (int64_t )var6773;	// _6774 = Cast(_6773 as i64)
	var2977 = var6775 << var6774;
	// ^ Call( _2977 = "unchecked_shl"::<i64,>( _6775, _6774, ), bb2016, bb399)
	var2978 = -var50;	// _2978 = UniOp(_50 NEG)
	var6777 = -var2978;	// _6777 = UniOp(_2978 NEG)
	__builtin_sub_overflow(26118, var6777, &var6779);
	// ^ Call( _6779 = "overflowing_sub"::<i16,>( +26118 i16, _6777, ), bb2017, bb399)
	var6778 = ZRICd15overflowing_rem0g( var6779, var296 );
	// ^ Call( _6778 = <i16 /*- */>::overflowing_rem( _6779, _296, ), bb2018, bb399)
	var2979 = var6778._0;	// _2979 = Use(_6778.0)
	var6782 = (uint32_t )var130;	// _6782 = Cast(_130 as u32)
	var6780 = var6782 & 0xf;	// _6780 = BinOp(_6782 BIT_AND 0xf u32)
	var6781 = (int16_t )var6780;	// _6781 = Cast(_6780 as i16)
	var2980 = var319 << var6781;
	// ^ Call( _2980 = "unchecked_shl"::<i16,>( _319, _6781, ), bb2019, bb399)
	var2981 = -var2980;	// _2981 = UniOp(_2980 NEG)
	var465 = var2979 | var2981;	// _465 = BinOp(_2979 BIT_OR _2981)
	var466 = var179;	// _466 = Use(_179)
	var467 = 1577476862;	// _467 = Constant(+1577476862 i32)
	var6785 = var298 / -4952756087141541308ll;	// _6785 = BinOp(_298 DIV -4952756087141541308 isize)
	var6783 = var71 & 0x3f;	// _6783 = BinOp(_71 BIT_AND 0x3f u32)
	var6784 = (intptr_t )var6783;	// _6784 = Cast(_6783 as isize)
	var2982 = var6785 >> var6784;
	// ^ Call( _2982 = "unchecked_shr"::<isize,>( _6785, _6784, ), bb2020, bb399)
	var6786 = (intptr_t )var284;	// _6786 = Cast(_284 as isize)
	__builtin_add_overflow(-8236252836157025851ll, var6786, &var2983);
	// ^ Call( _2983 = "overflowing_add"::<isize,>( -8236252836157025851 isize, _6786, ), bb2021, bb399)
	var2985 = 32085 ^ var377;	// _2985 = BinOp(+32085 i16 BIT_XOR _377)
	var2984 = var2985 ^ 1357;	// _2984 = BinOp(_2985 BIT_XOR +1357 i16)
	var2986 = (int64_t )var2984;	// _2986 = Cast(_2984 as i64)
	var6787 = -var2986;	// _6787 = UniOp(_2986 NEG)
	__builtin_sub_overflow(-3190350603796541389ll, var6787, &var468);
	// ^ Call( _468 = "overflowing_sub"::<i64,>( -28030315386750448510044409958636646349 i64, _6787, ), bb2022, bb399)
	var2988 = var377 / 10357;	// _2988 = BinOp(_377 DIV +10357 i16)
	var2987 = 10522 & var2988;	// _2987 = BinOp(+10522 i16 BIT_AND _2988)
	var6789 = -var2987;	// _6789 = UniOp(_2987 NEG)
	var6790 = -var30;	// _6790 = UniOp(_30 NEG)
	var6788 = ZRICd15overflowing_rem0g( var6789, var6790 );
	// ^ Call( _6788 = <i16 /*- */>::overflowing_rem( _6789, _6790, ), bb2023, bb399)
	var469 = (uint32_t )var6788._0;	// _469 = Cast(_6788.0 as u32)
	var470 = var162;	// _470 = Use(_162)
	var6791 = var257 / 0x10;	// _6791 = BinOp(_257 DIV 0x10 u8)
	__builtin_add_overflow(0xb1, var6791, &var2990);
	// ^ Call( _2990 = "overflowing_add"::<u8,>( 0xb1 u8, _6791, ), bb2024, bb399)
	var2992 = 0x48 / var300;	// _2992 = BinOp(0x48 u8 DIV _300)
	var2991 = var2992 + 0x5d;	// _2991 = BinOp(_2992 ADD 0x5d u8)
	var2989 = var2990 | var2991;	// _2989 = BinOp(_2990 BIT_OR _2991)
	var6794 = (int64_t )var2989;	// _6794 = Cast(_2989 as i64)
	var6792 = var332 & 0x3f;	// _6792 = BinOp(_332 BIT_AND 0x3f u32)
	var6793 = (int64_t )var6792;	// _6793 = Cast(_6792 as i64)
	var2993 = var6794 << var6793;
	// ^ Call( _2993 = "unchecked_shl"::<i64,>( _6794, _6793, ), bb2025, bb399)
	var6797 = var437 / 98;	// _6797 = BinOp(_437 DIV +98 i8)
	var6798 = (uint32_t )var158;	// _6798 = Cast(_158 as u32)
	var6795 = var6798 & 0x7;	// _6795 = BinOp(_6798 BIT_AND 0x7 u32)
	var6796 = (int8_t )var6795;	// _6796 = Cast(_6795 as i8)
	var6799 = var6797 >> var6796;
	// ^ Call( _6799 = "unchecked_shr"::<i8,>( _6797, _6796, ), bb2026, bb399)
	__builtin_add_overflow(99, var6799, &var2994);
	// ^ Call( _2994 = "overflowing_add"::<i8,>( +99 i8, _6799, ), bb2027, bb399)
	var6801 = var282 & var2994;	// _6801 = BinOp(_282 BIT_AND _2994)
	var6800 = var445 ^ -24;	// _6800 = BinOp(_445 BIT_XOR -24 i8)
	__builtin_add_overflow(113, var6800, &var2996);
	// ^ Call( _2996 = "overflowing_add"::<i8,>( +113 i8, _6800, ), bb2028, bb399)
	var2998 = var123 ^ var80;	// _2998 = BinOp(_123 BIT_XOR _80)
	var2997 = var441 ^ var2998;	// _2997 = BinOp(_441 BIT_XOR _2998)
	var2995 = var2996 * var2997;	// _2995 = BinOp(_2996 MUL _2997)
	var6802 = var2995 + var170;	// _6802 = BinOp(_2995 ADD _170)
	__builtin_sub_overflow(var6801, var6802, &var471);
	// ^ Call( _471 = "overflowing_sub"::<i8,>( _6801, _6802, ), bb2029, bb399)
	var472 = 0x54;	// _472 = Constant(0x54 u8)
	var6803 = var260 & 0x3f;	// _6803 = BinOp(_260 BIT_AND 0x3f u32)
	var6804 = (uintptr_t )var6803;	// _6804 = Cast(_6803 as usize)
	var2999 = 0x4e35e61f6c9ca4e3ull >> var6804;
	// ^ Call( _2999 = "unchecked_shr"::<usize,>( 0x4e35e61f6c9ca4e3 usize, _6804, ), bb2030, bb399)
	__builtin_mul_overflow(0x5bc4e6d0a1c5d90cull, var446, &var3000);
	// ^ Call( _3000 = "overflowing_mul"::<usize,>( 0x5bc4e6d0a1c5d90c usize, _446, ), bb2031, bb399)
	__builtin_add_overflow(0x99dbee2dd56e65f1ull, 0x0ull, &var6805);
	// ^ Call( _6805 = "overflowing_add"::<usize,>( 0x99dbee2dd56e65f1 usize, 0x0 usize, ), bb2032, bb399)
	__builtin_add_overflow(var6805, var112, &var6806);
	// ^ Call( _6806 = "overflowing_add"::<usize,>( _6805, _112, ), bb2033, bb399)
	var473 = make128s_raw(2566619946068921242ull, 8093280952318180869ull);	// _473 = Constant(+47345781279611601908851615532956007941 i128)
	var6807 = ZRICj15overflowing_rem0g( var65, make128s_raw(18446744073709551615ull, 380519154087027304ull) );
	// ^ Call( _6807 = <i128 /*- */>::overflowing_rem( _65, -18066224919622524312 i128, ), bb2034, bb399)
	var3001 = neg128s(var6807._0);	// _3001 = UniOp(_6807.0 NEG)
	sub128s_o(make128s_raw(14688096392729078841ull, 5549207165741567899ull), var20, &var3002);
	// ^ Call( _3002 = "overflowing_sub"::<i128,>( -69334811834288685521434252331203686501 i128, _20, ), bb2035, bb399)
	var3003 = neg128s(var3002);	// _3003 = UniOp(_3002 NEG)
	var6815 = neg128s(var3003);	// _6815 = UniOp(_3003 NEG)
	var3005.lo = var356; var3005.hi = var356 < 0 ? -1 : 0;	// _3005 = Cast(_356 as i128)
	var6808 = ZRICj15overflowing_div0g( var48, make128s_raw(17646339981096563893ull, 8106692115511523025ull) );
	// ^ Call( _6808 = <i128 /*- */>::overflowing_div( _48, -14764849451981502371331882764931287343 i128, ), bb2036, bb399)
	var3004 = mul128s(var3005, var6808._0);	// _3004 = BinOp(_3005 MUL _6808.0)
	var6809 = var306 & 0x7f;	// _6809 = BinOp(_306 BIT_AND 0x7f u32)
	var6810.lo = var6809; var6810.hi = var6809 < 0 ? -1 : 0;	// _6810 = Cast(_6809 as i128)
	var6812 = shl128s(var235, var6810.lo);
	// ^ Call( _6812 = "unchecked_shl"::<i128,>( _235, _6810, ), bb2037, bb399)
	var6813 = neg128s(var447);	// _6813 = UniOp(_447 NEG)
	var6811 = ZRICj15overflowing_rem0g( var6812, var6813 );
	// ^ Call( _6811 = <i128 /*- */>::overflowing_rem( _6812, _6813, ), bb2038, bb399)
	var6816 = xor128s(var3004, var6811._0);	// _6816 = BinOp(_3004 BIT_XOR _6811.0)
	var6814 = ZRICj15overflowing_rem0g( var6815, var6816 );
	// ^ Call( _6814 = <i128 /*- */>::overflowing_rem( _6815, _6816, ), bb2039, bb399)
	var474 = add128s(var3001, var6814._0);	// _474 = BinOp(_3001 ADD _6814.0)
	var6817 = var6 & 0x1f;	// _6817 = BinOp(_6 BIT_AND 0x1f u32)
	var3007 = var400 << var6817;
	// ^ Call( _3007 = "unchecked_shl"::<u32,>( _400, _6817, ), bb2040, bb399)
	var3008 = var208 >> 0x4;
	// ^ Call( _3008 = "unchecked_shr"::<u32,>( _208, 0x4 u32, ), bb2041, bb399)
	var3006 = var3007 / var3008;	// _3006 = BinOp(_3007 DIV _3008)
	var6818 = var332 & 0x1f;	// _6818 = BinOp(_332 BIT_AND 0x1f u32)
	var6819 = 0x348a30c6 >> var6818;
	// ^ Call( _6819 = "unchecked_shr"::<u32,>( 0x348a30c6 u32, _6818, ), bb2042, bb399)
	var3009 = var6819 / 0x96a78f0c;	// _3009 = BinOp(_6819 DIV 0x96a78f0c u32)
	var6821 = var3006 ^ var3009;	// _6821 = BinOp(_3006 BIT_XOR _3009)
	var3010 = var201 / var472;	// _3010 = BinOp(_201 DIV _472)
	var3011 = (uint32_t )var3010;	// _3011 = Cast(_3010 as u32)
	var6822 = 0xe3ff7211 | var3011;	// _6822 = BinOp(0xe3ff7211 u32 BIT_OR _3011)
	var6820 = var6822 & 0x1f;	// _6820 = BinOp(_6822 BIT_AND 0x1f u32)
	var6823 = var6821 << var6820;
	// ^ Call( _6823 = "unchecked_shl"::<u32,>( _6821, _6820, ), bb2043, bb399)
	__builtin_add_overflow(-1900850393, var421, &var3012);
	// ^ Call( _3012 = "overflowing_add"::<i32,>( -1900850393 i32, _421, ), bb2044, bb399)
	var6828 = -var3012;	// _6828 = UniOp(_3012 NEG)
	var6824 = 0x92bc836 ^ var243;	// _6824 = BinOp(0x92bc836 u32 BIT_XOR _243)
	var6825 = var163 + var335;	// _6825 = BinOp(_163 ADD _335)
	var6829 = var6824 / var6825;	// _6829 = BinOp(_6824 DIV _6825)
	var6826 = var6829 & 0x1f;	// _6826 = BinOp(_6829 BIT_AND 0x1f u32)
	var6827 = (int32_t )var6826;	// _6827 = Cast(_6826 as i32)
	var3013 = var6828 << var6827;
	// ^ Call( _3013 = "unchecked_shl"::<i32,>( _6828, _6827, ), bb2045, bb399)
	var475 = 0x84ff;	// _475 = Constant(0x84ff u32)
	var3014 = 0x30a5 >> 0x7;
	// ^ Call( _3014 = "unchecked_shr"::<u16,>( 0x30a5 u16, 0x7 u16, ), bb2046, bb399)
	var6832 = (uint32_t )var3014;	// _6832 = Cast(_3014 as u32)
	var6830 = var6832 & 0xf;	// _6830 = BinOp(_6832 BIT_AND 0xf u32)
	var6831 = (uint16_t )var6830;	// _6831 = Cast(_6830 as u16)
	var3015 = var305 >> var6831;
	// ^ Call( _3015 = "unchecked_shr"::<u16,>( _305, _6831, ), bb2047, bb399)
	var476.lo = var3015; var476.hi = var3015 < 0 ? -1 : 0;	// _476 = Cast(_3015 as u128)
	var3016 = -13412 / var398;	// _3016 = BinOp(-13412 i16 DIV _398)
	var6834 = -var3016;	// _6834 = UniOp(_3016 NEG)
	var3017 = var72 ^ 9921;	// _3017 = BinOp(_72 BIT_XOR +9921 i16)
	var6835 = -var3017;	// _6835 = UniOp(_3017 NEG)
	var6833 = ZRICd15overflowing_div0g( var6834, var6835 );
	// ^ Call( _6833 = <i16 /*- */>::overflowing_div( _6834, _6835, ), bb2048, bb399)
	var3018 = -var6833._0;	// _3018 = UniOp(_6833.0 NEG)
	var477 = (int8_t )var3018;	// _477 = Cast(_3018 as i8)
	if(var358) goto bb2049; else goto bb2052;
	// ^ If( _358 : 2049, 2052)
bb2049:
	var6836 = 3714218225515108990ll / var458;	// _6836 = BinOp(+3714218225515108990 isize DIV _458)
	__builtin_sub_overflow(8837645655260884522ll, var6836, &var3020);
	// ^ Call( _3020 = "overflowing_sub"::<isize,>( +8837645655260884522 isize, _6836, ), bb2050, bb399)
	__builtin_mul_overflow(7933688496054984560ll, var298, &var3021);
	// ^ Call( _3021 = "overflowing_mul"::<isize,>( +7933688496054984560 isize, _298, ), bb2051, bb399)
	var3019 = var3020 <= var3021;	// _3019 = BinOp(_3020 LE _3021)
	goto bb2053;
	// ^ Goto(2053)
bb2052:
	var3019 = false;	// _3019 = Constant(false)
	// ^ Goto(2053)
bb2053:
	if(var3019) goto bb2058; else goto bb2054;
	// ^ If( _3019 : 2058, 2054)
bb2054:
	var3023 = !var450;	// _3023 = UniOp(_450 INV)
	if(var3023) goto bb2055; else goto bb2056;
	// ^ If( _3023 : 2055, 2056)
bb2055:
	var3022 = true;	// _3022 = Constant(true)
	goto bb2057;
	// ^ Goto(2057)
bb2056:
	var3022 = false;	// _3022 = Constant(false)
	// ^ Goto(2057)
bb2057:
	if(var3022) goto bb2058; else goto bb2058;
	// ^ If( _3022 : 2058, 2058)
bb2058:
	__builtin_add_overflow(var311, 0xcddd, &var6837);
	// ^ Call( _6837 = "overflowing_add"::<u16,>( _311, 0xcddd u16, ), bb2059, bb399)
	var6838 = 0x9e68 % var6837;	// _6838 = BinOp(0x9e68 u16 MOD _6837)
	__builtin_mul_overflow(var403, 0x613a, &var3024);
	// ^ Call( _3024 = "overflowing_mul"::<u16,>( _403, 0x613a u16, ), bb2060, bb399)
	var6839 = var3024 / var374;	// _6839 = BinOp(_3024 DIV _374)
	__builtin_mul_overflow(var6838, var6839, &var6842);
	// ^ Call( _6842 = "overflowing_mul"::<u16,>( _6838, _6839, ), bb2061, bb399)
	var3025 = var255 / 7121;	// _3025 = BinOp(_255 DIV +7121 i16)
	var3026 = (uint32_t )var3025;	// _3026 = Cast(_3025 as u32)
	var6843 = 0x0 + var3026;	// _6843 = BinOp(0x0 u32 ADD _3026)
	var6840 = var6843 & 0xf;	// _6840 = BinOp(_6843 BIT_AND 0xf u32)
	var6841 = (uint16_t )var6840;	// _6841 = Cast(_6840 as u16)
	var6848 = var6842 >> var6841;
	// ^ Call( _6848 = "unchecked_shr"::<u16,>( _6842, _6841, ), bb2062, bb399)
	__builtin_sub_overflow(0x6a23, var162, &var6844);
	// ^ Call( _6844 = "overflowing_sub"::<u16,>( 0x6a23 u16, _162, ), bb2063, bb399)
	var3027 = var6844 % 0xa1ea;	// _3027 = BinOp(_6844 MOD 0xa1ea u16)
	var6845 = ZRICb15overflowing_div0g( -97, 31 );
	// ^ Call( _6845 = <i8 /*- */>::overflowing_div( -97 i8, +31 i8, ), bb2064, bb399)
	var3028 = (uint16_t )var6845._0;	// _3028 = Cast(_6845.0 as u16)
	var6846 = var3027 / var3028;	// _6846 = BinOp(_3027 DIV _3028)
	var3029 = var153 % 0xfe33;	// _3029 = BinOp(_153 MOD 0xfe33 u16)
	var6847 = 0xd55a ^ var3029;	// _6847 = BinOp(0xd55a u16 BIT_XOR _3029)
	__builtin_sub_overflow(var6846, var6847, &var6849);
	// ^ Call( _6849 = "overflowing_sub"::<u16,>( _6846, _6847, ), bb2065, bb399)
	__builtin_sub_overflow(var6848, var6849, &var478);
	// ^ Call( _478 = "overflowing_sub"::<u16,>( _6848, _6849, ), bb2066, bb399)
	var6850 = var332 & 0x1f;	// _6850 = BinOp(_332 BIT_AND 0x1f u32)
	var3030 = var301 >> var6850;
	// ^ Call( _3030 = "unchecked_shr"::<u32,>( _301, _6850, ), bb2067, bb399)
	var6852 = (int16_t )var3030;	// _6852 = Cast(_3030 as i16)
	var6851 = ZRICd15overflowing_div0g( var6852, var50 );
	// ^ Call( _6851 = <i16 /*- */>::overflowing_div( _6852, _50, ), bb2068, bb399)
	var3031 = (int8_t )var409;	// _3031 = Cast(_409 as i8)
	var479 = var477 - var3031;	// _479 = BinOp(_477 SUB _3031)
	var480 = -516973092;	// _480 = Constant(-516973092 i32)
	var3032 = (int16_t )var24;	// _3032 = Cast(_24 as i16)
	var6857 = var3032 | -26283;	// _6857 = BinOp(_3032 BIT_OR -26283 i16)
	var6855 = -var142;	// _6855 = UniOp(_142 NEG)
	var6856 = var397 % var67;	// _6856 = BinOp(_397 MOD _67)
	var6853 = var6856 & 0xf;	// _6853 = BinOp(_6856 BIT_AND 0xf u32)
	var6854 = (int16_t )var6853;	// _6854 = Cast(_6853 as i16)
	var6858 = var6855 >> var6854;
	// ^ Call( _6858 = "unchecked_shr"::<i16,>( _6855, _6854, ), bb2069, bb399)
	__builtin_sub_overflow(var6857, var6858, &var3033);
	// ^ Call( _3033 = "overflowing_sub"::<i16,>( _6857, _6858, ), bb2070, bb399)
	var6864 = -var3033;	// _6864 = UniOp(_3033 NEG)
	var6860 = -26240;	// _6860 = Constant(+50473695037277382090029092802636716416 i16)
	__builtin_add_overflow(2660, 15402, &var3034);
	// ^ Call( _3034 = "overflowing_add"::<i16,>( +2660 i16, +15402 i16, ), bb2071, bb399)
	var3035 = (int16_t )var329;	// _3035 = Cast(_329 as i16)
	var6861 = var3034 ^ var3035;	// _6861 = BinOp(_3034 BIT_XOR _3035)
	var6859 = ZRICd15overflowing_rem0g( var6860, var6861 );
	// ^ Call( _6859 = <i16 /*- */>::overflowing_rem( _6860, _6861, ), bb2072, bb399)
	var6862 = var34 & 0xf;	// _6862 = BinOp(_34 BIT_AND 0xf u32)
	var6863 = (int16_t )var6862;	// _6863 = Cast(_6862 as i16)
	var6865 = var6859._0 >> var6863;
	// ^ Call( _6865 = "unchecked_shr"::<i16,>( _6859.0, _6863, ), bb2073, bb399)
	__builtin_mul_overflow(var6864, var6865, &var481);
	// ^ Call( _481 = "overflowing_mul"::<i16,>( _6864, _6865, ), bb2074, bb399)
	var3037 = 0;	// _3037 = Constant(+0 i8)
	var6866 = ZRICb15overflowing_rem0g( 104, 122 );
	// ^ Call( _6866 = <i8 /*- */>::overflowing_rem( +104 i8, +122 i8, ), bb2075, bb399)
	var3036 = var3037 ^ var6866._0;	// _3036 = BinOp(_3037 BIT_XOR _6866.0)
	var3038 = -var3036;	// _3038 = UniOp(_3036 NEG)
	var6867 = (uint16_t )var3038;	// _6867 = Cast(_3038 as u16)
	__builtin_sub_overflow(0x157a, var6867, &var3039);
	// ^ Call( _3039 = "overflowing_sub"::<u16,>( 0x157a u16, _6867, ), bb2076, bb399)
	var3042 = var296 ^ -3893;	// _3042 = BinOp(_296 BIT_XOR -3893 i16)
	var3041 = var293 & var3042;	// _3041 = BinOp(_293 BIT_AND _3042)
	var3043 = 0x78f3 & var66;	// _3043 = BinOp(0x78f3 u16 BIT_AND _66)
	var3044 = (int16_t )var3043;	// _3044 = Cast(_3043 as i16)
	var3040 = var3041 & var3044;	// _3040 = BinOp(_3041 BIT_AND _3044)
	var6881 = -547 * var3040;	// _6881 = BinOp(-547 i16 MUL _3040)
	var6868 = var141 & 0x1f;	// _6868 = BinOp(_141 BIT_AND 0x1f u32)
	var6870 = 0x8796321c >> var6868;
	// ^ Call( _6870 = "unchecked_shr"::<u32,>( 0x8796321c u32, _6868, ), bb2077, bb399)
	var6869 = var6870 & 0x1f;	// _6869 = BinOp(_6870 BIT_AND 0x1f u32)
	var6872 = 0x625ec39d >> var6869;
	// ^ Call( _6872 = "unchecked_shr"::<u32,>( 0x625ec39d u32, _6869, ), bb2078, bb399)
	var6871 = var51 | 0x783042ad;	// _6871 = BinOp(_51 BIT_OR 0x783042ad u32)
	__builtin_mul_overflow(0x92e29e2d, var6871, &var6873);
	// ^ Call( _6873 = "overflowing_mul"::<u32,>( 0x92e29e2d u32, _6871, ), bb2079, bb399)
	var6877 = var6872 / var6873;	// _6877 = BinOp(_6872 DIV _6873)
	__builtin_add_overflow(var352, var189, &var3045);
	// ^ Call( _3045 = "overflowing_add"::<u16,>( _352, _189, ), bb2080, bb399)
	var3046 = (uint32_t )var3045;	// _3046 = Cast(_3045 as u32)
	var6875 = var341 - 0xad223379;	// _6875 = BinOp(_341 SUB 0xad223379 u32)
	var6876 = var400 - 0xfd0d81cd;	// _6876 = BinOp(_400 SUB 0xfd0d81cd u32)
	var6874 = var6876 & 0x1f;	// _6874 = BinOp(_6876 BIT_AND 0x1f u32)
	var3047 = var6875 >> var6874;
	// ^ Call( _3047 = "unchecked_shr"::<u32,>( _6875, _6874, ), bb2081, bb399)
	var6878 = var3046 + var3047;	// _6878 = BinOp(_3046 ADD _3047)
	__builtin_sub_overflow(var6877, var6878, &var6882);
	// ^ Call( _6882 = "overflowing_sub"::<u32,>( _6877, _6878, ), bb2082, bb399)
	var6879 = var6882 & 0xf;	// _6879 = BinOp(_6882 BIT_AND 0xf u32)
	var6880 = (int16_t )var6879;	// _6880 = Cast(_6879 as i16)
	var482 = var6881 >> var6880;
	// ^ Call( _482 = "unchecked_shr"::<i16,>( _6881, _6880, ), bb2083, bb399)
	var3049 = 0x550f;	// _3049 = Constant(0x550f u16)
	var3050 = 0xa77b >> 0x9;
	// ^ Call( _3050 = "unchecked_shr"::<u16,>( 0xa77b u16, 0x9 u16, ), bb2084, bb399)
	var3048 = var3049 | var3050;	// _3048 = BinOp(_3049 BIT_OR _3050)
	var3052 = 0xebe3 & var299;	// _3052 = BinOp(0xebe3 u16 BIT_AND _299)
	var3051 = var3052 | var374;	// _3051 = BinOp(_3052 BIT_OR _374)
	var6883 = var3048 / var3051;	// _6883 = BinOp(_3048 DIV _3051)
	__builtin_sub_overflow(var440, var22, &var3054);
	// ^ Call( _3054 = "overflowing_sub"::<u32,>( _440, _22, ), bb2085, bb399)
	var3053 = var3054 / var418;	// _3053 = BinOp(_3054 DIV _418)
	var6884 = (uint16_t )var3053;	// _6884 = Cast(_3053 as u16)
	__builtin_add_overflow(var6883, var6884, &var3055);
	// ^ Call( _3055 = "overflowing_add"::<u16,>( _6883, _6884, ), bb2086, bb399)
	var6887 = -4824812323738485023ll;	// _6887 = Constant(-4824812323738485023 isize)
	__builtin_sub_overflow(0xa48f686f, var335, &var3056);
	// ^ Call( _3056 = "overflowing_sub"::<u32,>( 0xa48f686f u32, _335, ), bb2087, bb399)
	var6888 = var3056 / 0xc3e97b63;	// _6888 = BinOp(_3056 DIV 0xc3e97b63 u32)
	var6885 = var6888 & 0x3f;	// _6885 = BinOp(_6888 BIT_AND 0x3f u32)
	var6886 = (intptr_t )var6885;	// _6886 = Cast(_6885 as isize)
	var3057 = var6887 << var6886;
	// ^ Call( _3057 = "unchecked_shl"::<isize,>( _6887, _6886, ), bb2088, bb399)
	var6892 = 0x90;	// _6892 = Constant(0x90 u8)
	var6891 = var226 - 0xd;	// _6891 = BinOp(_226 SUB 0xd u8)
	var6889 = var47 & 0x7;	// _6889 = BinOp(_47 BIT_AND 0x7 u32)
	var6890 = (uint8_t )var6889;	// _6890 = Cast(_6889 as u8)
	var6893 = var6891 << var6890;
	// ^ Call( _6893 = "unchecked_shl"::<u8,>( _6891, _6890, ), bb2089, bb399)
	__builtin_mul_overflow(var6892, var6893, &var6896);
	// ^ Call( _6896 = "overflowing_mul"::<u8,>( _6892, _6893, ), bb2090, bb399)
	var3059 = 0x1a817c9f / var341;	// _3059 = BinOp(0x1a817c9f u32 DIV _341)
	var3060 = var277 | 0x73e8fd75;	// _3060 = BinOp(_277 BIT_OR 0x73e8fd75 u32)
	var3058 = var3059 ^ var3060;	// _3058 = BinOp(_3059 BIT_XOR _3060)
	__builtin_add_overflow(0x504c09e2, var414, &var3062);
	// ^ Call( _3062 = "overflowing_add"::<u32,>( 0x504c09e2 u32, _414, ), bb2091, bb399)
	var3061 = var3062 ^ 0xc33eb0c1;	// _3061 = BinOp(_3062 BIT_XOR 0xc33eb0c1 u32)
	var6897 = var3058 / var3061;	// _6897 = BinOp(_3058 DIV _3061)
	var6894 = var6897 & 0x7;	// _6894 = BinOp(_6897 BIT_AND 0x7 u32)
	var6895 = (uint8_t )var6894;	// _6895 = Cast(_6894 as u8)
	var6898 = var6896 << var6895;
	// ^ Call( _6898 = "unchecked_shl"::<u8,>( _6896, _6895, ), bb2092, bb399)
	__builtin_mul_overflow(0x8a, var6898, &var483);
	// ^ Call( _483 = "overflowing_mul"::<u8,>( 0x8a u8, _6898, ), bb2093, bb399)
	var6899 = ZRICb15overflowing_div0g( 86, 8 );
	// ^ Call( _6899 = <i8 /*- */>::overflowing_div( +86 i8, +8 i8, ), bb2094, bb399)
	var484 = var6899._0;	// _484 = Use(_6899.0)
	var3064 = (uint8_t )var79;	// _3064 = Cast(_79 as u8)
	var3063 = 0xdd & var3064;	// _3063 = BinOp(0xdd u8 BIT_AND _3064)
	var3066 = var257 / 0x7d;	// _3066 = BinOp(_257 DIV 0x7d u8)
	var3065 = var3066 / 0xd8;	// _3065 = BinOp(_3066 DIV 0xd8 u8)
	var6905 = var3063 + var3065;	// _6905 = BinOp(_3063 ADD _3065)
	var6900 = var22 & 0x7;	// _6900 = BinOp(_22 BIT_AND 0x7 u32)
	var6901 = (uint8_t )var6900;	// _6901 = Cast(_6900 as u8)
	var6902 = 0x56 << var6901;
	// ^ Call( _6902 = "unchecked_shl"::<u8,>( 0x56 u8, _6901, ), bb2095, bb399)
	var6903 = var63 / var63;	// _6903 = BinOp(_63 DIV _63)
	__builtin_sub_overflow(var6902, var6903, &var6904);
	// ^ Call( _6904 = "overflowing_sub"::<u8,>( _6902, _6903, ), bb2096, bb399)
	__builtin_sub_overflow(0x3c, var6904, &var6906);
	// ^ Call( _6906 = "overflowing_sub"::<u8,>( 0x3c u8, _6904, ), bb2097, bb399)
	__builtin_mul_overflow(var6905, var6906, &var6912);
	// ^ Call( _6912 = "overflowing_mul"::<u8,>( _6905, _6906, ), bb2098, bb399)
	var6907 = var475 & 0x7;	// _6907 = BinOp(_475 BIT_AND 0x7 u32)
	var6908 = (uint8_t )var6907;	// _6908 = Cast(_6907 as u8)
	var6911 = 0x0 << var6908;
	// ^ Call( _6911 = "unchecked_shl"::<u8,>( 0x0 u8, _6908, ), bb2099, bb399)
	var6909 = var456 & 0x7;	// _6909 = BinOp(_456 BIT_AND 0x7 u32)
	var6910 = (uint8_t )var6909;	// _6910 = Cast(_6909 as u8)
	var3067 = var6911 << var6910;
	// ^ Call( _3067 = "unchecked_shl"::<u8,>( _6911, _6910, ), bb2100, bb399)
	var6913 = 0xce & var3067;	// _6913 = BinOp(0xce u8 BIT_AND _3067)
	__builtin_sub_overflow(var6912, var6913, &var485);
	// ^ Call( _485 = "overflowing_sub"::<u8,>( _6912, _6913, ), bb2101, bb399)
	var6917 = var351 / var221;	// _6917 = BinOp(_351 DIV _221)
	var6914 = var209 & 0x7f;	// _6914 = BinOp(_209 BIT_AND 0x7f u32)
	var6915.lo = var6914; var6915.hi = var6914 < 0 ? -1 : 0;	// _6915 = Cast(_6914 as i128)
	var3068 = shr128s(make128s_raw(11693105060697535679ull, 1684808784275735890ull), var6915.lo);
	// ^ Call( _3068 = "unchecked_shr"::<i128,>( -124582650439253030337514803552240368302 i128, _6915, ), bb2102, bb399)
	var6916 = var3068.lo;	// _6916 = Cast(_3068 as u16)
	__builtin_sub_overflow(0xbb5, var6916, &var6918);
	// ^ Call( _6918 = "overflowing_sub"::<u16,>( 0xbb5 u16, _6916, ), bb2103, bb399)
	__builtin_mul_overflow(var6917, var6918, &var6919);
	// ^ Call( _6919 = "overflowing_mul"::<u16,>( _6917, _6918, ), bb2104, bb399)
	__builtin_sub_overflow(var6919, 0x83d8, &var3069);
	// ^ Call( _3069 = "overflowing_sub"::<u16,>( _6919, 0x83d8 u16, ), bb2105, bb399)
	__builtin_add_overflow(var86, var455, &var3070);
	// ^ Call( _3070 = "overflowing_add"::<i32,>( _86, _455, ), bb2106, bb399)
	var6921 = -var3070;	// _6921 = UniOp(_3070 NEG)
	var6920 = ZRICf15overflowing_div0g( var6921, 1574016063 );
	// ^ Call( _6920 = <i32 /*- */>::overflowing_div( _6921, +1574016063 i32, ), bb2107, bb399)
	var6922 = ZRICf15overflowing_div0g( 1317552889, 1812480931 );
	// ^ Call( _6922 = <i32 /*- */>::overflowing_div( +1317552889 i32, +1812480931 i32, ), bb2108, bb399)
	var6923 = neg128s(var447);	// _6923 = UniOp(_447 NEG)
	add128s_o(var6923, make128s_raw(7084921995945347666ull, 15858404593391579550ull), &var6927);
	// ^ Call( _6927 = "overflowing_add"::<i128,>( _6923, +130693742841399289957025255095483707806 i128, ), bb2109, bb399)
	var6924 = var41 & 0x1f;	// _6924 = BinOp(_41 BIT_AND 0x1f u32)
	var6928 = 0x2381 << var6924;
	// ^ Call( _6928 = "unchecked_shl"::<u32,>( 0x2381 u32, _6924, ), bb2110, bb399)
	var6925 = var6928 & 0x7f;	// _6925 = BinOp(_6928 BIT_AND 0x7f u32)
	var6926.lo = var6925; var6926.hi = var6925 < 0 ? -1 : 0;	// _6926 = Cast(_6925 as i128)
	var3071 = shr128s(var6927, var6926.lo);
	// ^ Call( _3071 = "unchecked_shr"::<i128,>( _6927, _6926, ), bb2111, bb399)
	var3072 = neg128s(var3071);	// _3072 = UniOp(_3071 NEG)
	var486 = neg128s(var3072);	// _486 = UniOp(_3072 NEG)
	var6929 = var13 & var185;	// _6929 = BinOp(_13 BIT_AND _185)
	__builtin_sub_overflow(var6929, -4210, &var3073);
	// ^ Call( _3073 = "overflowing_sub"::<i16,>( _6929, -4210 i16, ), bb2112, bb399)
	var6931 = 27450 - var410;	// _6931 = BinOp(+27450 i16 SUB _410)
	var6932 = var72 / -17174;	// _6932 = BinOp(_72 DIV -17174 i16)
	var6930 = ZRICd15overflowing_rem0g( var6931, var6932 );
	// ^ Call( _6930 = <i16 /*- */>::overflowing_rem( _6931, _6932, ), bb2113, bb399)
	var487 = 9088;	// _487 = Constant(+9088 i16)
	var3074 = and128s(var307, make128s_raw(15438923946480840937ull, 15395445944315053633ull));	// _3074 = BinOp(_307 BIT_AND -55484488106740528249792066886565853631 i128)
	var3075 = neg128s(var3074);	// _3075 = UniOp(_3074 NEG)
	var6933 = neg128s(var3075);	// _6933 = UniOp(_3075 NEG)
	mul128s_o(make128s_raw(15300011366251418532ull, 3083218019204894683ull), var6933, &var3076);
	// ^ Call( _3076 = "overflowing_mul"::<i128,>( -58046972922851328637535966694890369061 i128, _6933, ), bb2114, bb399)
	var488 = neg128s(var3076);	// _488 = UniOp(_3076 NEG)
	__builtin_mul_overflow(-3279277226086606033ll, var237, &var6934);
	// ^ Call( _6934 = "overflowing_mul"::<isize,>( -3279277226086606033 isize, _237, ), bb2115, bb399)
	__builtin_sub_overflow(var6934, 86ll, &var3077);
	// ^ Call( _3077 = "overflowing_sub"::<isize,>( _6934, +86 isize, ), bb2116, bb399)
	var489 = -var83;	// _489 = UniOp(_83 NEG)
	var6935 = var108 & 0x7f;	// _6935 = BinOp(_108 BIT_AND 0x7f u32)
	var6936.lo = var6935; var6936.hi = var6935 < 0 ? -1 : 0;	// _6936 = Cast(_6935 as u128)
	var6937 = shl128(var3, var6936.lo);
	// ^ Call( _6937 = "unchecked_shl"::<u128,>( _3, _6936, ), bb2117, bb399)
	var6938.lo = var269; var6938.hi = var269 < 0 ? -1 : 0;	// _6938 = Cast(_269 as u128)
	sub128_o(var6937, var6938, &var6940);
	// ^ Call( _6940 = "overflowing_sub"::<u128,>( _6937, _6938, ), bb2118, bb399)
	var6939 = shl128(var408, make128_raw(0ull, 24ull).lo);
	// ^ Call( _6939 = "unchecked_shl"::<u128,>( _408, 0x18 u128, ), bb2119, bb399)
	var6941 = div128(var82, var6939);	// _6941 = BinOp(_82 DIV _6939)
	mul128_o(var6940, var6941, &var3078);
	// ^ Call( _3078 = "overflowing_mul"::<u128,>( _6940, _6941, ), bb2120, bb399)
	var3079 = var3078.lo;	// _3079 = Cast(_3078 as u8)
	var3081 = -var43;	// _3081 = UniOp(_43 NEG)
	var3082 = (uint8_t )var3081;	// _3082 = Cast(_3081 as u8)
	var3083 = 0x1e ^ var338;	// _3083 = BinOp(0x1e u8 BIT_XOR _338)
	var3080 = var3082 * var3083;	// _3080 = BinOp(_3082 MUL _3083)
	var490 = var3079 - var3080;	// _490 = BinOp(_3079 SUB _3080)
	var491 = 198;	// _491 = Constant(+198 i16)
	var6942 = ZRICd15overflowing_div0g( var291, -30008 );
	// ^ Call( _6942 = <i16 /*- */>::overflowing_div( _291, -30008 i16, ), bb2121, bb399)
	var6943 = ZRICd15overflowing_div0g( var6942._0, 170 );
	// ^ Call( _6943 = <i16 /*- */>::overflowing_div( _6942.0, +170 i16, ), bb2122, bb399)
	var3085 = -var6943._0;	// _3085 = UniOp(_6943.0 NEG)
	var3084 = var3085 ^ 16261;	// _3084 = BinOp(_3085 BIT_XOR +2587705221 i16)
	var492 = -var3084;	// _492 = UniOp(_3084 NEG)
	var6944 = var440 & 0xf;	// _6944 = BinOp(_440 BIT_AND 0xf u32)
	var6945 = (uint16_t )var6944;	// _6945 = Cast(_6944 as u16)
	var6946 = var382 >> var6945;
	// ^ Call( _6946 = "unchecked_shr"::<u16,>( _382, _6945, ), bb2123, bb399)
	var6947 = 0x1f8f << 0x6;
	// ^ Call( _6947 = "unchecked_shl"::<u16,>( 0x1f8f u16, 0x6 u16, ), bb2124, bb399)
	__builtin_sub_overflow(var6946, var6947, &var3086);
	// ^ Call( _3086 = "overflowing_sub"::<u16,>( _6946, _6947, ), bb2125, bb399)
	var6949 = var348 + var3086;	// _6949 = BinOp(_348 ADD _3086)
	var6948 = var249 | 0x28b7;	// _6948 = BinOp(_249 BIT_OR 0x28b7 u16)
	var3087 = var6948 << 0xd;
	// ^ Call( _3087 = "unchecked_shl"::<u16,>( _6948, 0xd u16, ), bb2126, bb399)
	var6950 = var3087 / 0x827;	// _6950 = BinOp(_3087 DIV 0x827 u16)
	__builtin_sub_overflow(var6949, var6950, &var6951);
	// ^ Call( _6951 = "overflowing_sub"::<u16,>( _6949, _6950, ), bb2127, bb399)
	var6955 = var49 >> 0x9;
	// ^ Call( _6955 = "unchecked_shr"::<u32,>( _49, 0x9 u32, ), bb2128, bb399)
	var3088 = var350 ^ var18;	// _3088 = BinOp(_350 BIT_XOR _18)
	var3089 = (uint32_t )var3088;	// _3089 = Cast(_3088 as u32)
	__builtin_sub_overflow(var220, var353, &var6953);
	// ^ Call( _6953 = "overflowing_sub"::<u32,>( _220, _353, ), bb2129, bb399)
	var6952 = var177 & 0x1f;	// _6952 = BinOp(_177 BIT_AND 0x1f u32)
	var6954 = var295 << var6952;
	// ^ Call( _6954 = "unchecked_shl"::<u32,>( _295, _6952, ), bb2130, bb399)
	var3090 = var6953 % var6954;	// _3090 = BinOp(_6953 MOD _6954)
	var6956 = var3089 + var3090;	// _6956 = BinOp(_3089 ADD _3090)
	__builtin_sub_overflow(var6955, var6956, &var3091);
	// ^ Call( _3091 = "overflowing_sub"::<u32,>( _6955, _6956, ), bb2131, bb399)
	var3094 = -var140;	// _3094 = UniOp(_140 NEG)
	var3093 = -110 & var3094;	// _3093 = BinOp(-110 i8 BIT_AND _3094)
	var3092 = var91 * var3093;	// _3092 = BinOp(_91 MUL _3093)
	var6960 = -37;	// _6960 = Constant(-37 i8)
	__builtin_sub_overflow(var176, var475, &var6959);
	// ^ Call( _6959 = "overflowing_sub"::<u32,>( _176, _475, ), bb2132, bb399)
	var6957 = var6959 & 0x7;	// _6957 = BinOp(_6959 BIT_AND 0x7 u32)
	var6958 = (int8_t )var6957;	// _6958 = Cast(_6957 as i8)
	var6961 = var8 >> var6958;
	// ^ Call( _6961 = "unchecked_shr"::<i8,>( _8, _6958, ), bb2133, bb399)
	__builtin_mul_overflow(var6960, var6961, &var3095);
	// ^ Call( _3095 = "overflowing_mul"::<i8,>( _6960, _6961, ), bb2134, bb399)
	var6967 = var3092 + var3095;	// _6967 = BinOp(_3092 ADD _3095)
	var3096 = -var80;	// _3096 = UniOp(_80 NEG)
	var6962 = ZRICb15overflowing_rem0g( 111, 82 );
	// ^ Call( _6962 = <i8 /*- */>::overflowing_rem( +111 i8, +82 i8, ), bb2135, bb399)
	var6963 = ZRICb15overflowing_rem0g( var6962._0, -69 );
	// ^ Call( _6963 = <i8 /*- */>::overflowing_rem( _6962.0, -69 i8, ), bb2136, bb399)
	var6965 = var3096 + var6963._0;	// _6965 = BinOp(_3096 ADD _6963.0)
	var3098 = 86;	// _3098 = Constant(+7290539739691357782 i8)
	var6964 = ZRICb15overflowing_rem0g( var471, -85 );
	// ^ Call( _6964 = <i8 /*- */>::overflowing_rem( _471, -85 i8, ), bb2137, bb399)
	var3097 = var3098 + var6964._0;	// _3097 = BinOp(_3098 ADD _6964.0)
	var6966 = var3097 - var143;	// _6966 = BinOp(_3097 SUB _143)
	__builtin_mul_overflow(var6965, var6966, &var6968);
	// ^ Call( _6968 = "overflowing_mul"::<i8,>( _6965, _6966, ), bb2138, bb399)
	__builtin_sub_overflow(var6967, var6968, &var493);
	// ^ Call( _493 = "overflowing_sub"::<i8,>( _6967, _6968, ), bb2139, bb399)
	var494 = 2;	// _494 = Constant(+2 i8)
	var6971 = var449 / 0x2;	// _6971 = BinOp(_449 DIV 0x2 u8)
	var6969 = var347 & 0x7;	// _6969 = BinOp(_347 BIT_AND 0x7 u32)
	var6970 = (uint8_t )var6969;	// _6970 = Cast(_6969 as u8)
	var3099 = var6971 >> var6970;
	// ^ Call( _3099 = "unchecked_shr"::<u8,>( _6971, _6970, ), bb2140, bb399)
	var3101 = var477 * -82;	// _3101 = BinOp(_477 MUL -82 i8)
	var3102 = -var4;	// _3102 = UniOp(_4 NEG)
	var6972 = var3101 | var3102;	// _6972 = BinOp(_3101 BIT_OR _3102)
	__builtin_add_overflow(10, var93, &var3103);
	// ^ Call( _3103 = "overflowing_add"::<i8,>( +10 i8, _93, ), bb2141, bb399)
	var6973 = var3103 / var182;	// _6973 = BinOp(_3103 DIV _182)
	__builtin_add_overflow(var6972, var6973, &var3104);
	// ^ Call( _3104 = "overflowing_add"::<i8,>( _6972, _6973, ), bb2142, bb399)
	var3100 = var3104 + var294;	// _3100 = BinOp(_3104 ADD _294)
	var3106 = 0x6420b6ec / var277;	// _3106 = BinOp(0x6420b6ec u32 DIV _277)
	var6976 = 0x641ee2b1 * var3106;	// _6976 = BinOp(0x641ee2b1 u32 MUL _3106)
	var6974 = var6976 & 0x7;	// _6974 = BinOp(_6976 BIT_AND 0x7 u32)
	var6975 = (int8_t )var6974;	// _6975 = Cast(_6974 as i8)
	var3107 = 116 << var6975;
	// ^ Call( _3107 = "unchecked_shl"::<i8,>( +116 i8, _6975, ), bb2143, bb399)
	var6979 = -var62;	// _6979 = UniOp(_62 NEG)
	var6980 = var220 / 0xf4a0b3d2;	// _6980 = BinOp(_220 DIV 0xf4a0b3d2 u32)
	var6977 = var6980 & 0x7;	// _6977 = BinOp(_6980 BIT_AND 0x7 u32)
	var6978 = (int8_t )var6977;	// _6978 = Cast(_6977 as i8)
	var3108 = var6979 >> var6978;
	// ^ Call( _3108 = "unchecked_shr"::<i8,>( _6979, _6978, ), bb2144, bb399)
	var3109 = -var3108;	// _3109 = UniOp(_3108 NEG)
	var3105 = var3107 * var3109;	// _3105 = BinOp(_3107 MUL _3109)
	var495 = var3100 + var3105;	// _495 = BinOp(_3100 ADD _3105)
	var6981 = ZRICv15overflowing_rem0g( var245, 7419816936642304554ll );
	// ^ Call( _6981 = <isize /*- */>::overflowing_rem( _245, +7419816936642304554 isize, ), bb2145, bb399)
	var6982 = ZRICv15overflowing_rem0g( var6981._0, 1849745358150551319ll );
	// ^ Call( _6982 = <isize /*- */>::overflowing_rem( _6981.0, +1849745358150551319 isize, ), bb2146, bb399)
	__builtin_add_overflow(0xa55390f4, var439, &var6983);
	// ^ Call( _6983 = "overflowing_add"::<u32,>( 0xa55390f4 u32, _439, ), bb2147, bb399)
	__builtin_add_overflow(var2, var6983, &var6986);
	// ^ Call( _6986 = "overflowing_add"::<u32,>( _2, _6983, ), bb2148, bb399)
	var6984 = var6986 & 0x3f;	// _6984 = BinOp(_6986 BIT_AND 0x3f u32)
	var6985 = (intptr_t )var6984;	// _6985 = Cast(_6984 as isize)
	var3110 = var6982._0 << var6985;
	// ^ Call( _3110 = "unchecked_shl"::<isize,>( _6982.0, _6985, ), bb2149, bb399)
	__builtin_mul_overflow(0x9fdc, 0x6f49, &var6987);
	// ^ Call( _6987 = "overflowing_mul"::<u16,>( 0x9fdc u16, 0x6f49 u16, ), bb2150, bb399)
	__builtin_sub_overflow(var305, 0xa7c, &var6988);
	// ^ Call( _6988 = "overflowing_sub"::<u16,>( _305, 0xa7c u16, ), bb2151, bb399)
	__builtin_add_overflow(var6987, var6988, &var3113);
	// ^ Call( _3113 = "overflowing_add"::<u16,>( _6987, _6988, ), bb2152, bb399)
	var3114 = 0xdec425acc021ec00ull * var205;	// _3114 = BinOp(0xdec425acc021ec00 usize MUL _205)
	var3115 = (uint16_t )var3114;	// _3115 = Cast(_3114 as u16)
	var3112 = var3113 * var3115;	// _3112 = BinOp(_3113 MUL _3115)
	__builtin_mul_overflow(0x221c, var374, &var3117);
	// ^ Call( _3117 = "overflowing_mul"::<u16,>( 0x221c u16, _374, ), bb2153, bb399)
	var3116 = 0x22a8 & var3117;	// _3116 = BinOp(0x22a8 u16 BIT_AND _3117)
	var3111 = var3112 + var3116;	// _3111 = BinOp(_3112 ADD _3116)
	__builtin_mul_overflow(0x2807, var470, &var6989);
	// ^ Call( _6989 = "overflowing_mul"::<u16,>( 0x2807 u16, _470, ), bb2154, bb399)
	var3120 = var46 % var6989;	// _3120 = BinOp(_46 MOD _6989)
	var3119 = var3120 & 0x716d;	// _3119 = BinOp(_3120 BIT_AND 0x716d u16)
	var3118 = var3119 ^ var221;	// _3118 = BinOp(_3119 BIT_XOR _221)
	var496 = var3111 + var3118;	// _496 = BinOp(_3111 ADD _3118)
	var497 = var467;	// _497 = Use(_467)
	var498 = var34 / 0xf082d550;	// _498 = BinOp(_34 DIV 0xf082d550 u32)
	var6990 = -var90;	// _6990 = UniOp(_90 NEG)
	__builtin_add_overflow(-1844283924, var6990, &var3121);
	// ^ Call( _3121 = "overflowing_add"::<i32,>( -1844283924 i32, _6990, ), bb2155, bb399)
	__builtin_mul_overflow(5662749926341019615ll, 9046357952837523175ll, &var3122);
	// ^ Call( _3122 = "overflowing_mul"::<i64,>( +5662749926341019615 i64, +9046357952837523175 i64, ), bb2156, bb399)
	__builtin_mul_overflow(0x4e, var379, &var3125);
	// ^ Call( _3125 = "overflowing_mul"::<u8,>( 0x4e u8, _379, ), bb2157, bb399)
	var3124 = var3125 ^ 0xde;	// _3124 = BinOp(_3125 BIT_XOR 0xde u8)
	var3127 = (uint8_t )var171;	// _3127 = Cast(_171 as u8)
	var3126 = var275 & var3127;	// _3126 = BinOp(_275 BIT_AND _3127)
	var3123 = var3124 * var3126;	// _3123 = BinOp(_3124 MUL _3126)
	var6991 = and128s(var107, var28);	// _6991 = BinOp(_107 BIT_AND _28)
	var3128 = shl128s(var6991, make128s_raw(0ull, 127ull).lo);
	// ^ Call( _3128 = "unchecked_shl"::<i128,>( _6991, +127 i128, ), bb2158, bb399)
	var3129 = var3128.lo;	// _3129 = Cast(_3128 as u8)
	var6998 = var3123 & var3129;	// _6998 = BinOp(_3123 BIT_AND _3129)
	__builtin_sub_overflow(0xbbffe0fd, 0xc856b216, &var6992);
	// ^ Call( _6992 = "overflowing_sub"::<u32,>( 0xbbffe0fd u32, 0xc856b216 u32, ), bb2159, bb399)
	__builtin_add_overflow(0x115c680c, 0xaff3937e, &var6993);
	// ^ Call( _6993 = "overflowing_add"::<u32,>( 0x115c680c u32, 0xaff3937e u32, ), bb2160, bb399)
	var6994 = var6992 / var6993;	// _6994 = BinOp(_6992 DIV _6993)
	var3130 = 0xd7e8b18e & var176;	// _3130 = BinOp(0xd7e8b18e u32 BIT_AND _176)
	var6995 = 0x7fdaeb75 & var3130;	// _6995 = BinOp(0x7fdaeb75 u32 BIT_AND _3130)
	var3131 = var6994 % var6995;	// _3131 = BinOp(_6994 MOD _6995)
	var6999 = var469 / var3131;	// _6999 = BinOp(_469 DIV _3131)
	var6996 = var6999 & 0x7;	// _6996 = BinOp(_6999 BIT_AND 0x7 u32)
	var6997 = (uint8_t )var6996;	// _6997 = Cast(_6996 as u8)
	var499 = var6998 << var6997;
	// ^ Call( _499 = "unchecked_shl"::<u8,>( _6998, _6997, ), bb2161, bb399)
	__builtin_sub_overflow(var97, 0x72, &var500);
	// ^ Call( _500 = "overflowing_sub"::<u8,>( _97, 0x72 u8, ), bb2162, bb399)
	__builtin_add_overflow(8543961117271372417ll, var32, &var7000);
	// ^ Call( _7000 = "overflowing_add"::<isize,>( +8543961117271372417 isize, _32, ), bb2163, bb399)
	__builtin_mul_overflow(5650407608970279409ll, var7000, &var3133);
	// ^ Call( _3133 = "overflowing_mul"::<isize,>( +5650407608970279409 isize, _7000, ), bb2164, bb399)
	var3135 = -6557809228674451062ll / var322;	// _3135 = BinOp(-6557809228674451062 isize DIV _322)
	var3134 = var3135 * var113;	// _3134 = BinOp(_3135 MUL _113)
	var3132 = var3133 ^ var3134;	// _3132 = BinOp(_3133 BIT_XOR _3134)
	var7001 = ZRICf15overflowing_div0g( -176152539, -489812261 );
	// ^ Call( _7001 = <i32 /*- */>::overflowing_div( -176152539 i32, -489812261 i32, ), bb2165, bb399)
	var3136 = (intptr_t )var7001._0;	// _3136 = Cast(_7001.0 as isize)
	var7005 = var3132 & var3136;	// _7005 = BinOp(_3132 BIT_AND _3136)
	var7003 = -var412;	// _7003 = UniOp(_412 NEG)
	var7002 = ZRICv15overflowing_div0g( var7003, 3392496743112051870ll );
	// ^ Call( _7002 = <isize /*- */>::overflowing_div( _7003, +3392496743112051870 isize, ), bb2166, bb399)
	var3137 = var7002._0;	// _3137 = Use(_7002.0)
	__builtin_sub_overflow(-7802586172148115996ll, var458, &var3138);
	// ^ Call( _3138 = "overflowing_sub"::<isize,>( -7802586172148115996 isize, _458, ), bb2167, bb399)
	var3139 = -var3138;	// _3139 = UniOp(_3138 NEG)
	var7004 = var3137 + var3139;	// _7004 = BinOp(_3137 ADD _3139)
	__builtin_sub_overflow(var444, var7004, &var7006);
	// ^ Call( _7006 = "overflowing_sub"::<isize,>( _444, _7004, ), bb2168, bb399)
	__builtin_add_overflow(var7005, var7006, &var501);
	// ^ Call( _501 = "overflowing_add"::<isize,>( _7005, _7006, ), bb2169, bb399)
	var7009 = var439 - var209;	// _7009 = BinOp(_439 SUB _209)
	var7007 = var7009 & 0x7;	// _7007 = BinOp(_7009 BIT_AND 0x7 u32)
	var7008 = (int8_t )var7007;	// _7008 = Cast(_7007 as i8)
	var7011 = -43 << var7008;
	// ^ Call( _7011 = "unchecked_shl"::<i8,>( -43 i8, _7008, ), bb2170, bb399)
	__builtin_mul_overflow(110, -2, &var3140);
	// ^ Call( _3140 = "overflowing_mul"::<i8,>( +110 i8, -2 i8, ), bb2171, bb399)
	var7012 = var3140 - 26;	// _7012 = BinOp(_3140 SUB +26 i8)
	var7010 = ZRICb15overflowing_rem0g( var7011, var7012 );
	// ^ Call( _7010 = <i8 /*- */>::overflowing_rem( _7011, _7012, ), bb2172, bb399)
	var7013 = -var7010._0;	// _7013 = UniOp(_7010.0 NEG)
	var7014 = var182 >> 5;
	// ^ Call( _7014 = "unchecked_shr"::<i8,>( _182, +5 i8, ), bb2173, bb399)
	__builtin_sub_overflow(var7013, var7014, &var502);
	// ^ Call( _502 = "overflowing_sub"::<i8,>( _7013, _7014, ), bb2174, bb399)
	var3141 = 99;	// _3141 = Constant(+99 i8)
	__builtin_sub_overflow(116, var19, &var3142);
	// ^ Call( _3142 = "overflowing_sub"::<i8,>( +116 i8, _19, ), bb2175, bb399)
	var7016 = -var3142;	// _7016 = UniOp(_3142 NEG)
	var3144 = 125 / var438;	// _3144 = BinOp(+125 i8 DIV _438)
	var7015 = ZRICb15overflowing_div0g( -126, var206 );
	// ^ Call( _7015 = <i8 /*- */>::overflowing_div( -126 i8, _206, ), bb2176, bb399)
	var3143 = var3144 * var7015._0;	// _3143 = BinOp(_3144 MUL _7015.0)
	var7017 = -var3143;	// _7017 = UniOp(_3143 NEG)
	__builtin_add_overflow(var7016, var7017, &var3145);
	// ^ Call( _3145 = "overflowing_add"::<i8,>( _7016, _7017, ), bb2177, bb399)
	var503 = var3141 + var3145;	// _503 = BinOp(_3141 ADD _3145)
	var3148 = var150 >> 0x3bull;
	// ^ Call( _3148 = "unchecked_shr"::<u64,>( _150, 0x3b u64, ), bb2178, bb399)
	var3147 = var3148 / 0x695dff3affff3e7dull;	// _3147 = BinOp(_3148 DIV 0x695dff3affff3e7d u64)
	__builtin_add_overflow(0xad49b9eeed166715ull, 0xbb1865dc6490e6c7ull, &var7018);
	// ^ Call( _7018 = "overflowing_add"::<u64,>( 0xad49b9eeed166715 u64, 0xbb1865dc6490e6c7 u64, ), bb2179, bb399)
	var7019 = var433 & 0x7e77ac8c55fb9e5ull;	// _7019 = BinOp(_433 BIT_AND 0x7e77ac8c55fb9e5 u64)
	__builtin_mul_overflow(var7018, var7019, &var3149);
	// ^ Call( _3149 = "overflowing_mul"::<u64,>( _7018, _7019, ), bb2180, bb399)
	var3146 = var3147 | var3149;	// _3146 = BinOp(_3147 BIT_OR _3149)
	__builtin_sub_overflow(var271, var336, &var7020);
	// ^ Call( _7020 = "overflowing_sub"::<u64,>( _271, _336, ), bb2181, bb399)
	var3151 = var7020 / 0x6b6bb4b2646f7543ull;	// _3151 = BinOp(_7020 DIV 0x6b6bb4b2646f7543 u64)
	var3150 = var3151 | 0x0ull;	// _3150 = BinOp(_3151 BIT_OR 0x0 u64)
	var7021 = var3146 - var3150;	// _7021 = BinOp(_3146 SUB _3150)
	__builtin_add_overflow(0x3dc7660e2bc720eeull, var114, &var3154);
	// ^ Call( _3154 = "overflowing_add"::<usize,>( 0x3dc7660e2bc720ee usize, _114, ), bb2182, bb399)
	var3153 = var3154 & 0x30c022502c1c826aull;	// _3153 = BinOp(_3154 BIT_AND 0x30c022502c1c826a usize)
	var3156 = var267 - 0xbb8640914f7783dbull;	// _3156 = BinOp(_267 SUB 0xbb8640914f7783db usize)
	var3157 = (uintptr_t )var270;	// _3157 = Cast(_270 as usize)
	var3155 = var3156 ^ var3157;	// _3155 = BinOp(_3156 BIT_XOR _3157)
	var3152 = var3153 | var3155;	// _3152 = BinOp(_3153 BIT_OR _3155)
	var7022 = (uint64_t )var3152;	// _7022 = Cast(_3152 as u64)
	__builtin_add_overflow(var7021, var7022, &var504);
	// ^ Call( _504 = "overflowing_add"::<u64,>( _7021, _7022, ), bb2183, bb399)
	var7023 = var234 << 0x33ull;
	// ^ Call( _7023 = "unchecked_shl"::<usize,>( _234, 0x33 usize, ), bb2184, bb399)
	__builtin_sub_overflow(var289, 0x3d824d94db3e669cull, &var7024);
	// ^ Call( _7024 = "overflowing_sub"::<usize,>( _289, 0x3d824d94db3e669c usize, ), bb2185, bb399)
	__builtin_add_overflow(var7023, var7024, &var3160);
	// ^ Call( _3160 = "overflowing_add"::<usize,>( _7023, _7024, ), bb2186, bb399)
	var3162 = (uintptr_t )var12;	// _3162 = Cast(_12 as usize)
	var3161 = var3162 / 0x7bd9ull;	// _3161 = BinOp(_3162 DIV 0x7bd9 usize)
	var3159 = var3160 * var3161;	// _3159 = BinOp(_3160 MUL _3161)
	var3158 = 0xc13d1e40e4829425ull * var3159;	// _3158 = BinOp(0xc13d1e40e4829425 usize MUL _3159)
	var3164 = -var377;	// _3164 = UniOp(_377 NEG)
	var3163 = var3164 * -22844;	// _3163 = BinOp(_3164 MUL -22844 i16)
	var3165 = -var3163;	// _3165 = UniOp(_3163 NEG)
	var3166 = (uintptr_t )var3165;	// _3166 = Cast(_3165 as usize)
	var505 = var3158 | var3166;	// _505 = BinOp(_3158 BIT_OR _3166)
	var3167 = (intptr_t )var281;	// _3167 = Cast(_281 as isize)
	var7025 = (uint16_t )var3167;	// _7025 = Cast(_3167 as u16)
	var3168 = var7025 >> 0x6;
	// ^ Call( _3168 = "unchecked_shr"::<u16,>( _7025, 0x6 u16, ), bb2187, bb399)
	var506 = 0x5eb6;	// _506 = Constant(0x5eb6 u16)
	var3169 = -24573;	// _3169 = Constant(-24573 i32)
	var7030 = 1182650176;	// _7030 = Constant(+1182650176 i32)
	var3170 = 0x4500b000;	// _3170 = Constant(0x4500b000 u32)
	var7026 = 0x3e0a221d % var353;	// _7026 = BinOp(0x3e0a221d u32 MOD _353)
	__builtin_add_overflow(0xf0b5a19d, var225, &var7027);
	// ^ Call( _7027 = "overflowing_add"::<u32,>( 0xf0b5a19d u32, _225, ), bb2188, bb399)
	__builtin_sub_overflow(var7026, var7027, &var3171);
	// ^ Call( _3171 = "overflowing_sub"::<u32,>( _7026, _7027, ), bb2189, bb399)
	var7031 = var3170 / var3171;	// _7031 = BinOp(_3170 DIV _3171)
	var7028 = var7031 & 0x1f;	// _7028 = BinOp(_7031 BIT_AND 0x1f u32)
	var7029 = (int32_t )var7028;	// _7029 = Cast(_7028 as i32)
	var3172 = var7030 << var7029;
	// ^ Call( _3172 = "unchecked_shl"::<i32,>( _7030, _7029, ), bb2190, bb399)
	var507 = var3169 ^ var3172;	// _507 = BinOp(_3169 BIT_XOR _3172)
	var508 = 0xc416ce4f;	// _508 = Constant(0xc416ce4f u32)
	var509 = make128s_raw(1174691425955843862ull, 8868244695594247470ull);	// _509 = Constant(+21669232100188385329518487978520028462 i128)
	var7037 = var502;	// _7037 = Use(_502)
	var7032 = -118;	// _7032 = Constant(-118 i8)
	__builtin_mul_overflow(-88, var171, &var7033);
	// ^ Call( _7033 = "overflowing_mul"::<i8,>( -88 i8, _171, ), bb2191, bb399)
	__builtin_mul_overflow(var7032, var7033, &var7034);
	// ^ Call( _7034 = "overflowing_mul"::<i8,>( _7032, _7033, ), bb2192, bb399)
	var3173 = -var184;	// _3173 = UniOp(_184 NEG)
	var7035 = var3173 | 122;	// _7035 = BinOp(_3173 BIT_OR +122 i8)
	__builtin_add_overflow(var7034, var7035, &var3174);
	// ^ Call( _3174 = "overflowing_add"::<i8,>( _7034, _7035, ), bb2193, bb399)
	var3175 = -var304;	// _3175 = UniOp(_304 NEG)
	var7036 = var3175 | 95;	// _7036 = BinOp(_3175 BIT_OR +95 i8)
	__builtin_mul_overflow(var502, var7036, &var3176);
	// ^ Call( _3176 = "overflowing_mul"::<i8,>( _502, _7036, ), bb2194, bb399)
	var7038 = var3174 & var3176;	// _7038 = BinOp(_3174 BIT_AND _3176)
	__builtin_mul_overflow(var7037, var7038, &var3177);
	// ^ Call( _3177 = "overflowing_mul"::<i8,>( _7037, _7038, ), bb2195, bb399)
	var7039 = -var435;	// _7039 = UniOp(_435 NEG)
	var7040 = -var296;	// _7040 = UniOp(_296 NEG)
	__builtin_mul_overflow(var7039, var7040, &var3178);
	// ^ Call( _3178 = "overflowing_mul"::<i16,>( _7039, _7040, ), bb2196, bb399)
	var3179 = (uint16_t )var3178;	// _3179 = Cast(_3178 as u16)
	var7041 = var3179 * var39;	// _7041 = BinOp(_3179 MUL _39)
	__builtin_mul_overflow(var7041, 0x9bb5, &var510);
	// ^ Call( _510 = "overflowing_mul"::<u16,>( _7041, 0x9bb5 u16, ), bb2197, bb399)
	var3182 = var47 ^ var347;	// _3182 = BinOp(_47 BIT_XOR _347)
	__builtin_sub_overflow(var335, var337, &var3183);
	// ^ Call( _3183 = "overflowing_sub"::<u32,>( _335, _337, ), bb2198, bb399)
	var3181 = var3182 / var3183;	// _3181 = BinOp(_3182 DIV _3183)
	var3180 = var225 - var3181;	// _3180 = BinOp(_225 SUB _3181)
	var7044 = 0x4e88f905 ^ var3180;	// _7044 = BinOp(0x4e88f905 u32 BIT_XOR _3180)
	var7043 = -var367;	// _7043 = UniOp(_367 NEG)
	var7042 = ZRICh15overflowing_div0g( 1469055017203792691ll, var7043 );
	// ^ Call( _7042 = <i64 /*- */>::overflowing_div( +1469055017203792691 i64, _7043, ), bb2199, bb399)
	var3184 = -var7042._0;	// _3184 = UniOp(_7042.0 NEG)
	var7045 = (uint32_t )var3184;	// _7045 = Cast(_3184 as u32)
	__builtin_mul_overflow(var7044, var7045, &var511);
	// ^ Call( _511 = "overflowing_mul"::<u32,>( _7044, _7045, ), bb2200, bb399)
	var7046 = var345 & 0xf;	// _7046 = BinOp(_345 BIT_AND 0xf u32)
	var7047 = (int16_t )var7046;	// _7047 = Cast(_7046 as i16)
	var7048 = var38 << var7047;
	// ^ Call( _7048 = "unchecked_shl"::<i16,>( _38, _7047, ), bb2201, bb399)
	var3185 = (int16_t )var253;	// _3185 = Cast(_253 as i16)
	var3186 = -var3185;	// _3186 = UniOp(_3185 NEG)
	var7049 = -19626 ^ var3186;	// _7049 = BinOp(-19626 i16 BIT_XOR _3186)
	__builtin_add_overflow(var7048, var7049, &var3187);
	// ^ Call( _3187 = "overflowing_add"::<i16,>( _7048, _7049, ), bb2202, bb399)
	var512 = -var3187;	// _512 = UniOp(_3187 NEG)
	var513 = -var55;	// _513 = UniOp(_55 NEG)
	var7051 = -103 ^ var8;	// _7051 = BinOp(-103 i8 BIT_XOR _8)
	var7050 = ZRICb15overflowing_rem0g( 35, var7051 );
	// ^ Call( _7050 = <i8 /*- */>::overflowing_rem( +35 i8, _7051, ), bb2203, bb399)
	var7053 = -var184;	// _7053 = UniOp(_184 NEG)
	var7052 = ZRICb15overflowing_div0g( 85, var7053 );
	// ^ Call( _7052 = <i8 /*- */>::overflowing_div( +85 i8, _7053, ), bb2204, bb399)
	var7054 = var511 & 0x7;	// _7054 = BinOp(_511 BIT_AND 0x7 u32)
	var7055 = (int8_t )var7054;	// _7055 = Cast(_7054 as i8)
	var3188 = var206 << var7055;
	// ^ Call( _3188 = "unchecked_shl"::<i8,>( _206, _7055, ), bb2205, bb399)
	var7056 = ZRICf15overflowing_div0g( -1069913892, -1656344608 );
	// ^ Call( _7056 = <i32 /*- */>::overflowing_div( -153781992082247964981260309609067157284 i32, +2054894502313078752 i32, ), bb2206, bb399)
	var514 = var7056._0;	// _514 = Use(_7056.0)
	var7057 = var295 / 0x66f2e7d4;	// _7057 = BinOp(_295 DIV 0x66f2e7d4 u32)
	__builtin_sub_overflow(var7057, 0x8c55fac9, &var7060);
	// ^ Call( _7060 = "overflowing_sub"::<u32,>( _7057, 0x8c55fac9 u32, ), bb2207, bb399)
	var7058 = var7060 & 0x7f;	// _7058 = BinOp(_7060 BIT_AND 0x7f u32)
	var7059.lo = var7058; var7059.hi = var7058 < 0 ? -1 : 0;	// _7059 = Cast(_7058 as i128)
	var3189 = shr128s(var509, var7059.lo);
	// ^ Call( _3189 = "unchecked_shr"::<i128,>( _509, _7059, ), bb2208, bb399)
	var515 = var512;	// _515 = Use(_512)
	var516 = 1901653803;	// _516 = Constant(+1901653803 i32)
	var3190 = -var444;	// _3190 = UniOp(_444 NEG)
	var517 = -var3190;	// _517 = UniOp(_3190 NEG)
	var3191.lo = var442; var3191.hi = var442 < 0 ? -1 : 0;	// _3191 = Cast(_442 as u128)
	var7063 = var3191.lo;	// _7063 = Cast(_3191 as u8)
	var7064 = 0xa93c44f4 | var314;	// _7064 = BinOp(0xa93c44f4 u32 BIT_OR _314)
	var7061 = var7064 & 0x7;	// _7061 = BinOp(_7064 BIT_AND 0x7 u32)
	var7062 = (uint8_t )var7061;	// _7062 = Cast(_7061 as u8)
	var3192 = var7063 >> var7062;
	// ^ Call( _3192 = "unchecked_shr"::<u8,>( _7063, _7062, ), bb2209, bb399)
	var7065 = var257 + var3192;	// _7065 = BinOp(_257 ADD _3192)
	var3195 = var472 * var81;	// _3195 = BinOp(_472 MUL _81)
	var3194 = 0xb8 + var3195;	// _3194 = BinOp(0xb8 u8 ADD _3195)
	var3196 = var43 * var395;	// _3196 = BinOp(_43 MUL _395)
	var3197 = (uint8_t )var3196;	// _3197 = Cast(_3196 as u8)
	var3193 = var3194 ^ var3197;	// _3193 = BinOp(_3194 BIT_XOR _3197)
	var7066 = var3193 / 0x5d;	// _7066 = BinOp(_3193 DIV 0x5d u8)
	__builtin_mul_overflow(var7065, var7066, &var518);
	// ^ Call( _518 = "overflowing_mul"::<u8,>( _7065, _7066, ), bb2210, bb399)
	var519 = var347 - 0x403f6f08;	// _519 = BinOp(_347 SUB 0x403f6f08 u32)
	var520 = var203;	// _520 = Use(_203)
	var3198 = 0x0ull;	// _3198 = Constant(0x0 usize)
	__builtin_mul_overflow(var446, var372, &var3200);
	// ^ Call( _3200 = "overflowing_mul"::<usize,>( _446, _372, ), bb2211, bb399)
	var3201 = var372 / 0xb61fe01209f4405full;	// _3201 = BinOp(_372 DIV 0xb61fe01209f4405f usize)
	var3199 = var3200 * var3201;	// _3199 = BinOp(_3200 MUL _3201)
	var7067 = var3198 * var3199;	// _7067 = BinOp(_3198 MUL _3199)
	var3203 = 0x9dffb6ff96155261ull | var273;	// _3203 = BinOp(0x9dffb6ff96155261 usize BIT_OR _273)
	__builtin_sub_overflow(var161, 0xf7611fc62e502818ull, &var3204);
	// ^ Call( _3204 = "overflowing_sub"::<usize,>( _161, 0xf7611fc62e502818 usize, ), bb2212, bb399)
	var3202 = var3203 / var3204;	// _3202 = BinOp(_3203 DIV _3204)
	var3206 = var205 * 0xd409bfa92d2a4c07ull;	// _3206 = BinOp(_205 MUL 0xd409bfa92d2a4c07 usize)
	var3205 = var3206 & 0x16c8ae0065d780faull;	// _3205 = BinOp(_3206 BIT_AND 0x16c8ae0065d780fa usize)
	var7068 = var3202 + var3205;	// _7068 = BinOp(_3202 ADD _3205)
	__builtin_add_overflow(var7067, var7068, &var3207);
	// ^ Call( _3207 = "overflowing_add"::<usize,>( _7067, _7068, ), bb2213, bb399)
	var3208 = neg128s(var250);	// _3208 = UniOp(_250 NEG)
	var3212 = div128s(var165, var307);	// _3212 = BinOp(_165 DIV _307)
	var3213 = neg128s(var361);	// _3213 = UniOp(_361 NEG)
	var3211 = mul128s(var3212, var3213);	// _3211 = BinOp(_3212 MUL _3213)
	var3210 = div128s(var3211, make128s_raw(8487657493156002136ull, 4422148806667072328ull));	// _3210 = BinOp(_3211 DIV +156569645561551951561378838990365324104 i128)
	sub128s_o(make128s_raw(1155364084490325523ull, 9325217782249013870ull), make128s_raw(1210360226127758994ull, 9293791760184167931ull), &var3215);
	// ^ Call( _3215 = "overflowing_sub"::<i128,>( +21312705578548774029784563972459709038 i128, +22327205328375991027026811138835402235 i128, ), bb2214, bb399)
	var7069 = ZRICj15overflowing_div0g( var29, make128s_raw(13531349547806122767ull, 1722234859471952580ull) );
	// ^ Call( _7069 = <i128 /*- */>::overflowing_div( _29, -90673024840653447218078058917277017404 i128, ), bb2215, bb399)
	var3216 = neg128s(var7069._0);	// _3216 = UniOp(_7069.0 NEG)
	var3214 = mul128s(var3215, var3216);	// _3214 = BinOp(_3215 MUL _3216)
	var3209 = mul128s(var3210, var3214);	// _3209 = BinOp(_3210 MUL _3214)
	var521 = and128s(var3208, var3209);	// _521 = BinOp(_3208 BIT_AND _3209)
	var7070 = var350 & 0x64df;	// _7070 = BinOp(_350 BIT_AND 0x64df u16)
	__builtin_mul_overflow(var7070, 0x734d, &var3217);
	// ^ Call( _3217 = "overflowing_mul"::<u16,>( _7070, 0x734d u16, ), bb2216, bb399)
	var522 = 0x57d9604;	// _522 = Constant(0x57d9604 u32)
	var7071 = var49 & 0xf;	// _7071 = BinOp(_49 BIT_AND 0xf u32)
	var7072 = (uint16_t )var7071;	// _7072 = Cast(_7071 as u16)
	var3218 = 0xc105 >> var7072;
	// ^ Call( _3218 = "unchecked_shr"::<u16,>( 0xc105 u16, _7072, ), bb2217, bb399)
	var3219 = 0x388a << 0x4;
	// ^ Call( _3219 = "unchecked_shl"::<u16,>( 0x388a u16, 0x4 u16, ), bb2218, bb399)
	var7073 = var3218 - var3219;	// _7073 = BinOp(_3218 SUB _3219)
	var3220 = var444 + -2827171133944705360ll;	// _3220 = BinOp(_444 ADD -2827171133944705360 isize)
	var7074 = (uint16_t )var3220;	// _7074 = Cast(_3220 as u16)
	var7077 = var7073 % var7074;	// _7077 = BinOp(_7073 MOD _7074)
	var7075 = var46 & var378;	// _7075 = BinOp(_46 BIT_AND _378)
	var3221 = 0x1;	// _3221 = Constant(0x1 u16)
	__builtin_sub_overflow(0xcd9c, var417, &var3222);
	// ^ Call( _3222 = "overflowing_sub"::<u16,>( 0xcd9c u16, _417, ), bb2219, bb399)
	var7076 = var3221 * var3222;	// _7076 = BinOp(_3221 MUL _3222)
	var7078 = var7075 / var7076;	// _7078 = BinOp(_7075 DIV _7076)
	__builtin_add_overflow(var7077, var7078, &var3223);
	// ^ Call( _3223 = "overflowing_add"::<u16,>( _7077, _7078, ), bb2220, bb399)
	__builtin_add_overflow(0x21b14f58, 0xf03f757f, &var3224);
	// ^ Call( _3224 = "overflowing_add"::<u32,>( 0x21b14f58 u32, 0xf03f757f u32, ), bb2221, bb399)
	var7081 = 0x44cd6aa4 / var3224;	// _7081 = BinOp(0x44cd6aa4 u32 DIV _3224)
	var7079 = var7081 & 0xf;	// _7079 = BinOp(_7081 BIT_AND 0xf u32)
	var7080 = (uint16_t )var7079;	// _7080 = Cast(_7079 as u16)
	var7084 = var352 << var7080;
	// ^ Call( _7084 = "unchecked_shl"::<u16,>( _352, _7080, ), bb2222, bb399)
	var7082 = var417 * var510;	// _7082 = BinOp(_417 MUL _510)
	var7083 = 0xf07e % var121;	// _7083 = BinOp(0xf07e u16 MOD _121)
	__builtin_sub_overflow(var7082, var7083, &var3225);
	// ^ Call( _3225 = "overflowing_sub"::<u16,>( _7082, _7083, ), bb2223, bb399)
	var3226 = var159 | 0xb6;	// _3226 = BinOp(_159 BIT_OR 0xb6 u8)
	var3227 = (uint16_t )var3226;	// _3227 = Cast(_3226 as u16)
	var7085 = var3225 ^ var3227;	// _7085 = BinOp(_3225 BIT_XOR _3227)
	__builtin_mul_overflow(var7084, var7085, &var3228);
	// ^ Call( _3228 = "overflowing_mul"::<u16,>( _7084, _7085, ), bb2224, bb399)
	var523 = var3223 * var3228;	// _523 = BinOp(_3223 MUL _3228)
	var7086 = var337 & 0x7;	// _7086 = BinOp(_337 BIT_AND 0x7 u32)
	var7087 = (uint8_t )var7086;	// _7087 = Cast(_7086 as u8)
	var524 = 0xd5 >> var7087;
	// ^ Call( _524 = "unchecked_shr"::<u8,>( 0xd5 u8, _7087, ), bb2225, bb399)
	var7089 = 8338ll;	// _7089 = Constant(+8338 isize)
	var3229 = var298 & -5088128423998146078ll;	// _3229 = BinOp(_298 BIT_AND -5088128423998146078 isize)
	var7088 = var237 + var3229;	// _7088 = BinOp(_237 ADD _3229)
	__builtin_add_overflow(var7088, 8473715680406863737ll, &var7090);
	// ^ Call( _7090 = "overflowing_add"::<isize,>( _7088, +8473715680406863737 isize, ), bb2226, bb399)
	__builtin_add_overflow(var7089, var7090, &var3230);
	// ^ Call( _3230 = "overflowing_add"::<isize,>( _7089, _7090, ), bb2227, bb399)
	var525 = -var3230;	// _525 = UniOp(_3230 NEG)
	__builtin_sub_overflow(0xaf2ead87a228355dull, var74, &var3232);
	// ^ Call( _3232 = "overflowing_sub"::<u64,>( 0xaf2ead87a228355d u64, _74, ), bb2228, bb399)
	var3231 = var3232 / 0x4fc0cdfc99aa9498ull;	// _3231 = BinOp(_3232 DIV 0x4fc0cdfc99aa9498 u64)
	var3233 = (uint8_t )var3231;	// _3233 = Cast(_3231 as u8)
	var7091 = 0x49 * var3233;	// _7091 = BinOp(0x49 u8 MUL _3233)
	var526 = var129 % var7091;	// _526 = BinOp(_129 MOD _7091)
	var7092 = var152 & 0x1f;	// _7092 = BinOp(_152 BIT_AND 0x1f u32)
	var3235 = var41 << var7092;
	// ^ Call( _3235 = "unchecked_shl"::<u32,>( _41, _7092, ), bb2229, bb399)
	var3234 = var3235 / 0x8bf125d9;	// _3234 = BinOp(_3235 DIV 0x8bf125d9 u32)
	var7095 = var3234 * var95;	// _7095 = BinOp(_3234 MUL _95)
	var7093 = var260 & 0x1f;	// _7093 = BinOp(_260 BIT_AND 0x1f u32)
	var7094 = 0xc0b00597 >> var7093;
	// ^ Call( _7094 = "unchecked_shr"::<u32,>( 0xc0b00597 u32, _7093, ), bb2230, bb399)
	__builtin_add_overflow(var498, var7094, &var3236);
	// ^ Call( _3236 = "overflowing_add"::<u32,>( _498, _7094, ), bb2231, bb399)
	var7096 = 0xffddceb + var3236;	// _7096 = BinOp(0xffddceb u32 ADD _3236)
	__builtin_sub_overflow(var7095, var7096, &var7099);
	// ^ Call( _7099 = "overflowing_sub"::<u32,>( _7095, _7096, ), bb2232, bb399)
	var7097 = var7099 & 0x7;	// _7097 = BinOp(_7099 BIT_AND 0x7 u32)
	var7098 = (uint8_t )var7097;	// _7098 = Cast(_7097 as u8)
	var3237 = 0xc8 << var7098;
	// ^ Call( _3237 = "unchecked_shl"::<u8,>( 0xc8 u8, _7098, ), bb2233, bb399)
	var7100 = var375 - var167;	// _7100 = BinOp(_375 SUB _167)
	var7101 = var166 & 0x6224;	// _7101 = BinOp(_166 BIT_AND 0x6224 u16)
	__builtin_mul_overflow(var7100, var7101, &var3238);
	// ^ Call( _3238 = "overflowing_mul"::<u16,>( _7100, _7101, ), bb2234, bb399)
	var3239 = 0xee << 0x1d;
	// ^ Call( _3239 = "unchecked_shl"::<u32,>( 0xee u32, 0x1d u32, ), bb2235, bb399)
	var3241 = var41 ^ var337;	// _3241 = BinOp(_41 BIT_XOR _337)
	var7102 = 0x7e + var3241;	// _7102 = BinOp(0x7e u32 ADD _3241)
	__builtin_mul_overflow(var7102, 0x7987612b, &var3242);
	// ^ Call( _3242 = "overflowing_mul"::<u32,>( _7102, 0x7987612b u32, ), bb2236, bb399)
	var3240 = var3242 + 0xd493c93;	// _3240 = BinOp(_3242 ADD 0xd493c93 u32)
	var527 = var3239 ^ var3240;	// _527 = BinOp(_3239 BIT_XOR _3240)
	var3243 = (int64_t )var323;	// _3243 = Cast(_323 as i64)
	var7105 = var367 + var3243;	// _7105 = BinOp(_367 ADD _3243)
	var7103 = var468 & 8457842089789507764ll;	// _7103 = BinOp(_468 BIT_AND +8457842089789507764 i64)
	__builtin_mul_overflow(var7103, -1312930659579643593ll, &var7106);
	// ^ Call( _7106 = "overflowing_mul"::<i64,>( _7103, -1312930659579643593 i64, ), bb2237, bb399)
	var7104 = ZRICh15overflowing_rem0g( var7105, var7106 );
	// ^ Call( _7104 = <i64 /*- */>::overflowing_rem( _7105, _7106, ), bb2238, bb399)
	var7107 = ZRICh15overflowing_rem0g( 1359037967961567946ll, var468 );
	// ^ Call( _7107 = <i64 /*- */>::overflowing_rem( +1359037967961567946 i64, _468, ), bb2239, bb399)
	var7108 = 5719709897744481201ll ^ var183;	// _7108 = BinOp(+5719709897744481201 i64 BIT_XOR _183)
	__builtin_mul_overflow(var7108, 786941588213742932ll, &var7111);
	// ^ Call( _7111 = "overflowing_mul"::<i64,>( _7108, +786941588213742932 i64, ), bb2240, bb399)
	var7109 = -var367;	// _7109 = UniOp(_367 NEG)
	__builtin_add_overflow(2820490951720443570ll, var7109, &var7112);
	// ^ Call( _7112 = "overflowing_add"::<i64,>( +2820490951720443570 i64, _7109, ), bb2241, bb399)
	var7110 = ZRICh15overflowing_div0g( var7111, var7112 );
	// ^ Call( _7110 = <i64 /*- */>::overflowing_div( _7111, _7112, ), bb2242, bb399)
	var7115 = 0x76c8;	// _7115 = Constant(0x76c8 u32)
	__builtin_sub_overflow(var241, var420, &var7113);
	// ^ Call( _7113 = "overflowing_sub"::<u32,>( _241, _420, ), bb2243, bb399)
	__builtin_sub_overflow(0x399ca26f, var79, &var7114);
	// ^ Call( _7114 = "overflowing_sub"::<u32,>( 0x399ca26f u32, _79, ), bb2244, bb399)
	var7116 = var7113 % var7114;	// _7116 = BinOp(_7113 MOD _7114)
	__builtin_add_overflow(var7115, var7116, &var3244);
	// ^ Call( _3244 = "overflowing_add"::<u32,>( _7115, _7116, ), bb2245, bb399)
	var7118 = 0x4a786c0 / var314;	// _7118 = BinOp(0x4a786c0 u32 DIV _314)
	var7117 = var7118 & 0x1f;	// _7117 = BinOp(_7118 BIT_AND 0x1f u32)
	var7119 = 0x9c30b3bb >> var7117;
	// ^ Call( _7119 = "unchecked_shr"::<u32,>( 0x9c30b3bb u32, _7117, ), bb2246, bb399)
	__builtin_sub_overflow(var243, var7119, &var3245);
	// ^ Call( _3245 = "overflowing_sub"::<u32,>( _243, _7119, ), bb2247, bb399)
	var3247 = -var466;	// _3247 = UniOp(_466 NEG)
	__builtin_mul_overflow(var88, var407, &var3248);
	// ^ Call( _3248 = "overflowing_mul"::<i32,>( _88, _407, ), bb2248, bb399)
	var3246 = var3247 / var3248;	// _3246 = BinOp(_3247 DIV _3248)
	var7120 = -var3246;	// _7120 = UniOp(_3246 NEG)
	__builtin_mul_overflow(var466, var7120, &var528);
	// ^ Call( _528 = "overflowing_mul"::<i32,>( _466, _7120, ), bb2249, bb399)
	var7121.lo = var406; var7121.hi = var406 < 0 ? -1 : 0;	// _7121 = Cast(_406 as i128)
	sub128s_o(make128s_raw(17745096199192674461ull, 5093414379806457327ull), var7121, &var3249);
	// ^ Call( _3249 = "overflowing_sub"::<i128,>( -12943118771075106775598353339797275153 i128, _7121, ), bb2250, bb399)
	var7126 = neg128s(var3249);	// _7126 = UniOp(_3249 NEG)
	var7124 = var47 ^ var71;	// _7124 = BinOp(_47 BIT_XOR _71)
	var7122 = var7124 & 0x7f;	// _7122 = BinOp(_7124 BIT_AND 0x7f u32)
	var7123.lo = var7122; var7123.hi = var7122 < 0 ? -1 : 0;	// _7123 = Cast(_7122 as i128)
	var3251 = shr128s(make128s_raw(1794525788413140606ull, 15377463723671046261ull), var7123.lo);
	// ^ Call( _3251 = "unchecked_shr"::<i128,>( +33103157952529062237545809954293565557 i128, _7123, ), bb2251, bb399)
	var3250 = or128s(var3251, make128s_raw(0ull, 0ull));	// _3250 = BinOp(_3251 BIT_OR +0 i128)
	var7127 = sub128s(var3250, make128s_raw(14853959494025447126ull, 2022766029215347676ull));	// _7127 = BinOp(_3250 SUB -66275177653402816815652158851177008164 i128)
	var7125 = ZRICj15overflowing_div0g( var7126, var7127 );
	// ^ Call( _7125 = <i128 /*- */>::overflowing_div( _7126, _7127, ), bb2252, bb399)
	var529 = var7125._0;	// _529 = Use(_7125.0)
	if(var460) goto bb2253; else goto bb2253;
	// ^ If( _460 : 2253, 2253)
bb2253:
	var3252 = 0x4846 >> 0x4;
	// ^ Call( _3252 = "unchecked_shr"::<u16,>( 0x4846 u16, 0x4 u16, ), bb2254, bb399)
	var3253 = var323 / 0xd59;	// _3253 = BinOp(_323 DIV 0xd59 u16)
	var7128 = var3252 | var3253;	// _7128 = BinOp(_3252 BIT_OR _3253)
	__builtin_sub_overflow(var167, 0xe6c3, &var7129);
	// ^ Call( _7129 = "overflowing_sub"::<u16,>( _167, 0xe6c3 u16, ), bb2255, bb399)
	__builtin_mul_overflow(var7128, var7129, &var3254);
	// ^ Call( _3254 = "overflowing_mul"::<u16,>( _7128, _7129, ), bb2256, bb399)
	var7130 = 37 << 4;
	// ^ Call( _7130 = "unchecked_shl"::<i8,>( +37 i8, +4 i8, ), bb2257, bb399)
	var7131 = -var12;	// _7131 = UniOp(_12 NEG)
	__builtin_mul_overflow(var7130, var7131, &var3255);
	// ^ Call( _3255 = "overflowing_mul"::<i8,>( _7130, _7131, ), bb2258, bb399)
	__builtin_sub_overflow(105, var384, &var3256);
	// ^ Call( _3256 = "overflowing_sub"::<i8,>( +105 i8, _384, ), bb2259, bb399)
	var7133 = var3255 + var3256;	// _7133 = BinOp(_3255 ADD _3256)
	var7132 = ZRICb15overflowing_rem0g( var7133, -51 );
	// ^ Call( _7132 = <i8 /*- */>::overflowing_rem( _7133, -2967350311050935859 i8, ), bb2260, bb399)
	__builtin_add_overflow(var153, 0xffaa, &var3257);
	// ^ Call( _3257 = "overflowing_add"::<u16,>( _153, 0xffaa u16, ), bb2261, bb399)
	var530 = var3257 / 0x3639;	// _530 = BinOp(_3257 DIV 0x3639 u16)
	var7136 = 0xe722f7b4 >> 0x0;
	// ^ Call( _7136 = "unchecked_shr"::<u32,>( 0xe722f7b4 u32, 0x0 u32, ), bb2262, bb399)
	__builtin_sub_overflow(0x71a59d46, 0xbd82d9e1, &var3259);
	// ^ Call( _3259 = "overflowing_sub"::<u32,>( 0x71a59d46 u32, 0xbd82d9e1 u32, ), bb2263, bb399)
	var3258 = var152 & var3259;	// _3258 = BinOp(_152 BIT_AND _3259)
	var7134 = var400 - 0xff616bfd;	// _7134 = BinOp(_400 SUB 0xff616bfd u32)
	__builtin_sub_overflow(0xa620401a, var400, &var7135);
	// ^ Call( _7135 = "overflowing_sub"::<u32,>( 0xa620401a u32, _400, ), bb2264, bb399)
	__builtin_sub_overflow(var7134, var7135, &var3260);
	// ^ Call( _3260 = "overflowing_sub"::<u32,>( _7134, _7135, ), bb2265, bb399)
	var7137 = var3258 - var3260;	// _7137 = BinOp(_3258 SUB _3260)
	var7138 = var7136 % var7137;	// _7138 = BinOp(_7136 MOD _7137)
	var3261 = -var113;	// _3261 = UniOp(_113 NEG)
	var3262 = (uint32_t )var3261;	// _3262 = Cast(_3261 as u32)
	add128_o(var387, make128_raw(18442717280774137199ull, 8421359569861593160ull), &var3263);
	// ^ Call( _3263 = "overflowing_add"::<u128,>( _387, 0xfff1b1a73580256f74deade9176fc848 u128, ), bb2266, bb399)
	var3264 = var3263.lo;	// _3264 = Cast(_3263 as u32)
	var7139 = var3262 | var3264;	// _7139 = BinOp(_3262 BIT_OR _3264)
	__builtin_sub_overflow(var7138, var7139, &var3265);
	// ^ Call( _3265 = "overflowing_sub"::<u32,>( _7138, _7139, ), bb2267, bb399)
	var7140 = var25 & 0x7;	// _7140 = BinOp(_25 BIT_AND 0x7 u32)
	var7141 = (uint8_t )var7140;	// _7141 = Cast(_7140 as u8)
	var3266 = 0xdd << var7141;
	// ^ Call( _3266 = "unchecked_shl"::<u8,>( 0xdd u8, _7141, ), bb2268, bb399)
	var7142 = var386 / var3266;	// _7142 = BinOp(_386 DIV _3266)
	var7143 = 0x9 * var363;	// _7143 = BinOp(0x9 u8 MUL _363)
	__builtin_add_overflow(var7142, var7143, &var3267);
	// ^ Call( _3267 = "overflowing_add"::<u8,>( _7142, _7143, ), bb2269, bb399)
	var7148 = 84;	// _7148 = Constant(+84 i16)
	var3268 = -25555;	// _3268 = Constant(-25555 i16)
	__builtin_sub_overflow(var291, 22857, &var7146);
	// ^ Call( _7146 = "overflowing_sub"::<i16,>( _291, +22857 i16, ), bb2270, bb399)
	var7147 = var71 << 0xc;
	// ^ Call( _7147 = "unchecked_shl"::<u32,>( _71, 0xc u32, ), bb2271, bb399)
	var7144 = var7147 & 0xf;	// _7144 = BinOp(_7147 BIT_AND 0xf u32)
	var7145 = (int16_t )var7144;	// _7145 = Cast(_7144 as i16)
	var3269 = var7146 >> var7145;
	// ^ Call( _3269 = "unchecked_shr"::<i16,>( _7146, _7145, ), bb2272, bb399)
	var7149 = var3268 & var3269;	// _7149 = BinOp(_3268 BIT_AND _3269)
	__builtin_sub_overflow(var7148, var7149, &var3270);
	// ^ Call( _3270 = "overflowing_sub"::<i16,>( _7148, _7149, ), bb2273, bb399)
	var3271 = 0xf4f7 << 0x9;
	// ^ Call( _3271 = "unchecked_shl"::<u16,>( 0xf4f7 u16, 0x9 u16, ), bb2274, bb399)
	var3272.lo = var3271; var3272.hi = var3271 < 0 ? -1 : 0;	// _3272 = Cast(_3271 as u128)
	var7152 = var3272.lo;	// _7152 = Cast(_3272 as u32)
	var7150 = var7152 & 0xf;	// _7150 = BinOp(_7152 BIT_AND 0xf u32)
	var7151 = (uint16_t )var7150;	// _7151 = Cast(_7150 as u16)
	var3273 = var153 << var7151;
	// ^ Call( _3273 = "unchecked_shl"::<u16,>( _153, _7151, ), bb2275, bb399)
	__builtin_sub_overflow(var478, var134, &var3274);
	// ^ Call( _3274 = "overflowing_sub"::<u16,>( _478, _134, ), bb2276, bb399)
	var3276 = 0xd0 > var97;	// _3276 = BinOp(0xd0 u8 GT _97)
	var3277 = !var3276;	// _3277 = UniOp(_3276 INV)
	if(var3277) goto bb2277; else goto bb2278;
	// ^ If( _3277 : 2277, 2278)
bb2277:
	var3278 = !var204;	// _3278 = UniOp(_204 INV)
	var3275 = !var3278;	// _3275 = UniOp(_3278 INV)
	goto bb2279;
	// ^ Goto(2279)
bb2278:
	var3275 = false;	// _3275 = Constant(false)
	// ^ Goto(2279)
bb2279:
	var3279 = !var3275;	// _3279 = UniOp(_3275 INV)
	if(var3279) goto bb2280; else goto bb2280;
	// ^ If( _3279 : 2280, 2280)
bb2280:
	mul128_o(var389, make128_raw(10242419770598134105ull, 16739752608884633865ull), &var7156);
	// ^ Call( _7156 = "overflowing_mul"::<u128,>( _389, 0x8e246283c2f09159e84f8c4e887cb109 u128, ), bb2281, bb399)
	var7153 = var247 & 0x1f;	// _7153 = BinOp(_247 BIT_AND 0x1f u32)
	var7157 = var225 >> var7153;
	// ^ Call( _7157 = "unchecked_shr"::<u32,>( _225, _7153, ), bb2282, bb399)
	var7154 = var7157 & 0x7f;	// _7154 = BinOp(_7157 BIT_AND 0x7f u32)
	var7155.lo = var7154; var7155.hi = var7154 < 0 ? -1 : 0;	// _7155 = Cast(_7154 as u128)
	var3280 = shr128(var7156, var7155.lo);
	// ^ Call( _3280 = "unchecked_shr"::<u128,>( _7156, _7155, ), bb2283, bb399)
	var7158 = sub128(var401, var3280);	// _7158 = BinOp(_401 SUB _3280)
	mul128_o(var292, var7158, &var7162);
	// ^ Call( _7162 = "overflowing_mul"::<u128,>( _292, _7158, ), bb2284, bb399)
	var3281 = -var369;	// _3281 = UniOp(_369 NEG)
	var7161 = (uint32_t )var3281;	// _7161 = Cast(_3281 as u32)
	var7159 = var7161 & 0x7f;	// _7159 = BinOp(_7161 BIT_AND 0x7f u32)
	var7160.lo = var7159; var7160.hi = var7159 < 0 ? -1 : 0;	// _7160 = Cast(_7159 as u128)
	var3282 = shl128(make128_raw(4513903609658208124ull, 17813308656954871534ull), var7160.lo);
	// ^ Call( _3282 = "unchecked_shl"::<u128,>( 0x3ea49b6ad407ef7cf73595d8342f8eee u128, _7160, ), bb2285, bb399)
	var7163 = mul128(var3282, var82);	// _7163 = BinOp(_3282 MUL _82)
	sub128_o(var7162, var7163, &var531);
	// ^ Call( _531 = "overflowing_sub"::<u128,>( _7162, _7163, ), bb2286, bb399)
	var7167 = 1;	// _7167 = Constant(+1 i32)
	__builtin_sub_overflow(var163, 0x55ae38d6, &var7164);
	// ^ Call( _7164 = "overflowing_sub"::<u32,>( _163, 0x55ae38d6 u32, ), bb2287, bb399)
	__builtin_sub_overflow(var7164, var475, &var7168);
	// ^ Call( _7168 = "overflowing_sub"::<u32,>( _7164, _475, ), bb2288, bb399)
	var7165 = var7168 & 0x1f;	// _7165 = BinOp(_7168 BIT_AND 0x1f u32)
	var7166 = (int32_t )var7165;	// _7166 = Cast(_7165 as i32)
	var3283 = var7167 >> var7166;
	// ^ Call( _3283 = "unchecked_shr"::<i32,>( _7167, _7166, ), bb2289, bb399)
	__builtin_sub_overflow(1586323492, var5, &var3284);
	// ^ Call( _3284 = "overflowing_sub"::<i32,>( +1586323492 i32, _5, ), bb2290, bb399)
	var532 = -1577097674142846152ll;	// _532 = Constant(-1577097674142846152 i64)
	__builtin_add_overflow(0x52be1b6f, var127, &var3285);
	// ^ Call( _3285 = "overflowing_add"::<u32,>( 0x52be1b6f u32, _127, ), bb2291, bb399)
	var7169 = var168 & 0x1f;	// _7169 = BinOp(_168 BIT_AND 0x1f u32)
	var3286 = 0xea1ca38e >> var7169;
	// ^ Call( _3286 = "unchecked_shr"::<u32,>( 0xea1ca38e u32, _7169, ), bb2292, bb399)
	var7170 = var3285 / var3286;	// _7170 = BinOp(_3285 DIV _3286)
	__builtin_sub_overflow(var243, var295, &var3287);
	// ^ Call( _3287 = "overflowing_sub"::<u32,>( _243, _295, ), bb2293, bb399)
	var7171 = var3287 | 0x75529c58;	// _7171 = BinOp(_3287 BIT_OR 0x75529c58 u32)
	__builtin_sub_overflow(var7170, var7171, &var7172);
	// ^ Call( _7172 = "overflowing_sub"::<u32,>( _7170, _7171, ), bb2294, bb399)
	__builtin_sub_overflow(var414, var7172, &var7175);
	// ^ Call( _7175 = "overflowing_sub"::<u32,>( _414, _7172, ), bb2295, bb399)
	var7173 = var7175 & 0x3f;	// _7173 = BinOp(_7175 BIT_AND 0x3f u32)
	var7174 = (uintptr_t )var7173;	// _7174 = Cast(_7173 as usize)
	var3288 = var284 << var7174;
	// ^ Call( _3288 = "unchecked_shl"::<usize,>( _284, _7174, ), bb2296, bb399)
	__builtin_sub_overflow(0xe3a5854b, var337, &var3289);
	// ^ Call( _3289 = "overflowing_sub"::<u32,>( 0xe3a5854b u32, _337, ), bb2297, bb399)
	var7176 = var25 ^ var3289;	// _7176 = BinOp(_25 BIT_XOR _3289)
	__builtin_mul_overflow(0x4d600bfb, var7176, &var3290);
	// ^ Call( _3290 = "overflowing_mul"::<u32,>( 0x4d600bfb u32, _7176, ), bb2298, bb399)
	__builtin_sub_overflow(0x4136db64, var456, &var7177);
	// ^ Call( _7177 = "overflowing_sub"::<u32,>( 0x4136db64 u32, _456, ), bb2299, bb399)
	__builtin_sub_overflow(var353, var7177, &var7179);
	// ^ Call( _7179 = "overflowing_sub"::<u32,>( _353, _7177, ), bb2300, bb399)
	var7180 = var397 / 0x5ebdb4c9;	// _7180 = BinOp(_397 DIV 0x5ebdb4c9 u32)
	var7178 = var7180 & 0x1f;	// _7178 = BinOp(_7180 BIT_AND 0x1f u32)
	var3291 = var7179 << var7178;
	// ^ Call( _3291 = "unchecked_shl"::<u32,>( _7179, _7178, ), bb2301, bb399)
	var7184 = var3290 | var3291;	// _7184 = BinOp(_3290 BIT_OR _3291)
	var3292 = var472 / 0xd1;	// _3292 = BinOp(_472 DIV 0xd1 u8)
	var7181 = (uint32_t )var3292;	// _7181 = Cast(_3292 as u32)
	var3293 = 0xcb9b40be;	// _3293 = Constant(0xcb9b40be u32)
	__builtin_mul_overflow(var440, var163, &var3294);
	// ^ Call( _3294 = "overflowing_mul"::<u32,>( _440, _163, ), bb2302, bb399)
	var7182 = var3293 - var3294;	// _7182 = BinOp(_3293 SUB _3294)
	var7183 = var7181 % var7182;	// _7183 = BinOp(_7181 MOD _7182)
	__builtin_add_overflow(0x68d3238b, var7183, &var7185);
	// ^ Call( _7185 = "overflowing_add"::<u32,>( 0x68d3238b u32, _7183, ), bb2303, bb399)
	var533 = var7184 / var7185;	// _533 = BinOp(_7184 DIV _7185)
	var3295 = div128(var199, make128_raw(12417683409253795777ull, 106415138678106263ull));	// _3295 = BinOp(_199 DIV 0xac547944ddd587c1017a10013ba1e897 u128)
	var7186 = mul128(make128_raw(3779218272376830092ull, 2642778359386406086ull), var3295);	// _7186 = BinOp(0x34727afeddafb88c24ad08ea7350fcc6 u128 MUL _3295)
	add128_o(make128_raw(11767924790608590204ull, 15286800893100504441ull), var7186, &var7194);
	// ^ Call( _7194 = "overflowing_add"::<u128,>( 0xa350113f77bcf57cd425a06b59613579 u128, _7186, ), bb2304, bb399)
	var7187 = var276 & 0x1f;	// _7187 = BinOp(_276 BIT_AND 0x1f u32)
	var3296 = var314 << var7187;
	// ^ Call( _3296 = "unchecked_shl"::<u32,>( _314, _7187, ), bb2305, bb399)
	__builtin_mul_overflow(0x9b93e273, 0x4b02426f, &var3297);
	// ^ Call( _3297 = "overflowing_mul"::<u32,>( 0x9b93e273 u32, 0x4b02426f u32, ), bb2306, bb399)
	var7190 = var3296 ^ var3297;	// _7190 = BinOp(_3296 BIT_XOR _3297)
	var7189 = var418 / 0x3df3390;	// _7189 = BinOp(_418 DIV 0x3df3390 u32)
	var7188 = var6 & 0x1f;	// _7188 = BinOp(_6 BIT_AND 0x1f u32)
	var7191 = var7189 >> var7188;
	// ^ Call( _7191 = "unchecked_shr"::<u32,>( _7189, _7188, ), bb2307, bb399)
	__builtin_add_overflow(var7190, var7191, &var7195);
	// ^ Call( _7195 = "overflowing_add"::<u32,>( _7190, _7191, ), bb2308, bb399)
	var7192 = var7195 & 0x7f;	// _7192 = BinOp(_7195 BIT_AND 0x7f u32)
	var7193.lo = var7192; var7193.hi = var7192 < 0 ? -1 : 0;	// _7193 = Cast(_7192 as u128)
	var7199 = shr128(var7194, var7193.lo);
	// ^ Call( _7199 = "unchecked_shr"::<u128,>( _7194, _7193, ), bb2309, bb399)
	var3298 = var241 | var168;	// _3298 = BinOp(_241 BIT_OR _168)
	var3299 = (uint32_t )var175;	// _3299 = Cast(_175 as u32)
	var7198 = var3298 * var3299;	// _7198 = BinOp(_3298 MUL _3299)
	var7196 = var7198 & 0x7f;	// _7196 = BinOp(_7198 BIT_AND 0x7f u32)
	var7197.lo = var7196; var7197.hi = var7196 < 0 ? -1 : 0;	// _7197 = Cast(_7196 as u128)
	var3300 = shl128(make128_raw(14065987019595685142ull, 3808545390792847448ull), var7197.lo);
	// ^ Call( _3300 = "unchecked_shl"::<u128,>( 0xc3346cab66419d1634daabdab928b058 u128, _7197, ), bb2310, bb399)
	var7200 = or128(make128_raw(6941819943816704538ull, 4701036500913777545ull), var3300);	// _7200 = BinOp(0x60564c75a5eab21a413d6fca591c6b89 u128 BIT_OR _3300)
	add128_o(var7199, var7200, &var7374);
	// ^ Call( _7374 = "overflowing_add"::<u128,>( _7199, _7200, ), bb2311, bb399)
	var3301 = var1 + 159206787;	// _3301 = BinOp(_1 ADD +159206787 i32)
	var3302 = -var3301;	// _3302 = UniOp(_3301 NEG)
	var7205 = var3302 + -1052817408;	// _7205 = BinOp(_3302 ADD -1052817408 i32)
	var7201 = var347 / var527;	// _7201 = BinOp(_347 DIV _527)
	var7202 = var7201 / var418;	// _7202 = BinOp(_7201 DIV _418)
	var7206 = var7202 << 0x0;
	// ^ Call( _7206 = "unchecked_shl"::<u32,>( _7202, 0x0 u32, ), bb2312, bb399)
	var7203 = var7206 & 0x1f;	// _7203 = BinOp(_7206 BIT_AND 0x1f u32)
	var7204 = (int32_t )var7203;	// _7204 = Cast(_7203 as i32)
	var3303 = var7205 >> var7204;
	// ^ Call( _3303 = "unchecked_shr"::<i32,>( _7205, _7204, ), bb2313, bb399)
	var7207 = 0xf1a17721 / var420;	// _7207 = BinOp(0xf1a17721 u32 DIV _420)
	var3305 = var7207 / 0xdedfcafe;	// _3305 = BinOp(_7207 DIV 0xdedfcafe u32)
	var3306 = (uint8_t )var3305;	// _3306 = Cast(_3305 as u8)
	var7208 = var363 + var200;	// _7208 = BinOp(_363 ADD _200)
	var7209 = var97 / 0xdf;	// _7209 = BinOp(_97 DIV 0xdf u8)
	__builtin_mul_overflow(var7208, var7209, &var7210);
	// ^ Call( _7210 = "overflowing_mul"::<u8,>( _7208, _7209, ), bb2314, bb399)
	var3307 = var327 / 0x85;	// _3307 = BinOp(_327 DIV 0x85 u8)
	var7211 = 0x84 ^ var3307;	// _7211 = BinOp(0x84 u8 BIT_XOR _3307)
	var3308 = var7210 / var7211;	// _3308 = BinOp(_7210 DIV _7211)
	var3304 = var3306 * var3308;	// _3304 = BinOp(_3306 MUL _3308)
	var3309 = (uint8_t )var380;	// _3309 = Cast(_380 as u8)
	var7212 = var81 | var3309;	// _7212 = BinOp(_81 BIT_OR _3309)
	__builtin_sub_overflow(0xb0, var7212, &var7213);
	// ^ Call( _7213 = "overflowing_sub"::<u8,>( 0xb0 u8, _7212, ), bb2315, bb399)
	__builtin_mul_overflow(0x91, var99, &var3310);
	// ^ Call( _3310 = "overflowing_mul"::<u8,>( 0x91 u8, _99, ), bb2316, bb399)
	__builtin_sub_overflow(var120, 0x1a, &var3312);
	// ^ Call( _3312 = "overflowing_sub"::<u8,>( _120, 0x1a u8, ), bb2317, bb399)
	var3313 = var99 << 0x0;
	// ^ Call( _3313 = "unchecked_shl"::<u8,>( _99, 0x0 u8, ), bb2318, bb399)
	var3311 = var3312 / var3313;	// _3311 = BinOp(_3312 DIV _3313)
	var7214 = var3310 ^ var3311;	// _7214 = BinOp(_3310 BIT_XOR _3311)
	var3314 = var7213 % var7214;	// _3314 = BinOp(_7213 MOD _7214)
	var534 = var3304 * var3314;	// _534 = BinOp(_3304 MUL _3314)
	var535 = var214;	// _535 = Use(_214)
	var3317 = -var494;	// _3317 = UniOp(_494 NEG)
	var3316 = var3317 * var342;	// _3316 = BinOp(_3317 MUL _342)
	__builtin_add_overflow(-104, -54, &var3318);
	// ^ Call( _3318 = "overflowing_add"::<i8,>( -104 i8, -54 i8, ), bb2319, bb399)
	var3319 = -var3318;	// _3319 = UniOp(_3318 NEG)
	var3315 = var3316 & var3319;	// _3315 = BinOp(_3316 BIT_AND _3319)
	var7217 = -var3315;	// _7217 = UniOp(_3315 NEG)
	var3320 = var51 & 0x0;	// _3320 = BinOp(_51 BIT_AND 0x0 u32)
	var3321 = var108 / 0xd374;	// _3321 = BinOp(_108 DIV 0xd374 u32)
	var7218 = var3320 * var3321;	// _7218 = BinOp(_3320 MUL _3321)
	var7215 = var7218 & 0x7;	// _7215 = BinOp(_7218 BIT_AND 0x7 u32)
	var7216 = (int8_t )var7215;	// _7216 = Cast(_7215 as i8)
	var536 = var7217 << var7216;
	// ^ Call( _536 = "unchecked_shl"::<i8,>( _7217, _7216, ), bb2320, bb399)
	var7219 = var267 / var273;	// _7219 = BinOp(_267 DIV _273)
	var7220 = 0xa22771fd22c04b9cull & var372;	// _7220 = BinOp(0xa22771fd22c04b9c usize BIT_AND _372)
	__builtin_add_overflow(var7219, var7220, &var3322);
	// ^ Call( _3322 = "overflowing_add"::<usize,>( _7219, _7220, ), bb2321, bb399)
	var7224 = var27 ^ var3322;	// _7224 = BinOp(_27 BIT_XOR _3322)
	__builtin_sub_overflow(0xc3aefd08, 0xeab671e3, &var3323);
	// ^ Call( _3323 = "overflowing_sub"::<u32,>( 0xc3aefd08 u32, 0xeab671e3 u32, ), bb2322, bb399)
	var7221 = var3323 | 0xee2432a2;	// _7221 = BinOp(_3323 BIT_OR 0xee2432a2 u32)
	__builtin_add_overflow(var7221, 0x2dbdf81d, &var7225);
	// ^ Call( _7225 = "overflowing_add"::<u32,>( _7221, 0x2dbdf81d u32, ), bb2323, bb399)
	var7222 = var7225 & 0x3f;	// _7222 = BinOp(_7225 BIT_AND 0x3f u32)
	var7223 = (uintptr_t )var7222;	// _7223 = Cast(_7222 as usize)
	var7229 = var7224 >> var7223;
	// ^ Call( _7229 = "unchecked_shr"::<usize,>( _7224, _7223, ), bb2324, bb399)
	var7226 = var209 & 0x3f;	// _7226 = BinOp(_209 BIT_AND 0x3f u32)
	var7227 = (uintptr_t )var7226;	// _7227 = Cast(_7226 as usize)
	var3324 = var53 >> var7227;
	// ^ Call( _3324 = "unchecked_shr"::<usize,>( _53, _7227, ), bb2325, bb399)
	var7228 = 0xb974387b108f3be5ull ^ var3324;	// _7228 = BinOp(0xb974387b108f3be5 usize BIT_XOR _3324)
	var3325 = var7228 % 0xa1ull;	// _3325 = BinOp(_7228 MOD 0xa1 usize)
	__builtin_sub_overflow(0x43eca80a, var209, &var3327);
	// ^ Call( _3327 = "overflowing_sub"::<u32,>( 0x43eca80a u32, _209, ), bb2326, bb399)
	var3328 = var34 % var397;	// _3328 = BinOp(_34 MOD _397)
	var3326 = var3327 * var3328;	// _3326 = BinOp(_3327 MUL _3328)
	var3329 = (uintptr_t )var3326;	// _3329 = Cast(_3326 as usize)
	var7230 = var3325 & var3329;	// _7230 = BinOp(_3325 BIT_AND _3329)
	__builtin_mul_overflow(var7229, var7230, &var3330);
	// ^ Call( _3330 = "overflowing_mul"::<usize,>( _7229, _7230, ), bb2327, bb399)
	__builtin_sub_overflow(var245, var517, &var3332);
	// ^ Call( _3332 = "overflowing_sub"::<isize,>( _245, _517, ), bb2328, bb399)
	var3333 = var237 - 1956411908347166170ll;	// _3333 = BinOp(_237 SUB +1956411908347166170 isize)
	var3331 = var3332 + var3333;	// _3331 = BinOp(_3332 ADD _3333)
	var7232 = (intptr_t )var219;	// _7232 = Cast(_219 as isize)
	__builtin_mul_overflow(var174, var55, &var7233);
	// ^ Call( _7233 = "overflowing_mul"::<isize,>( _174, _55, ), bb2329, bb399)
	var7231 = ZRICv15overflowing_rem0g( var7232, var7233 );
	// ^ Call( _7231 = <isize /*- */>::overflowing_rem( _7232, _7233, ), bb2330, bb399)
	var7234 = var3331 + var7231._0;	// _7234 = BinOp(_3331 ADD _7231.0)
	__builtin_mul_overflow(var7234, -7280473841671706595ll, &var7237);
	// ^ Call( _7237 = "overflowing_mul"::<isize,>( _7234, -7280473841671706595 isize, ), bb2331, bb399)
	var3334 = var309 / 1688843688;	// _3334 = BinOp(_309 DIV +1688843688 i32)
	var3335 = -var3334;	// _3335 = UniOp(_3334 NEG)
	var3336 = (uint32_t )var3335;	// _3336 = Cast(_3335 as u32)
	var3339 = 0xe1216005 & var522;	// _3339 = BinOp(0xe1216005 u32 BIT_AND _522)
	var3338 = var3339 * var533;	// _3338 = BinOp(_3339 MUL _533)
	__builtin_sub_overflow(0xaef501b2, 0x3ea4be53, &var3340);
	// ^ Call( _3340 = "overflowing_sub"::<u32,>( 0xaef501b2 u32, 0x3ea4be53 u32, ), bb2332, bb399)
	var3337 = var3338 / var3340;	// _3337 = BinOp(_3338 DIV _3340)
	var7238 = var3336 & var3337;	// _7238 = BinOp(_3336 BIT_AND _3337)
	var7235 = var7238 & 0x3f;	// _7235 = BinOp(_7238 BIT_AND 0x3f u32)
	var7236 = (intptr_t )var7235;	// _7236 = Cast(_7235 as isize)
	var537 = var7237 >> var7236;
	// ^ Call( _537 = "unchecked_shr"::<isize,>( _7237, _7236, ), bb2333, bb399)
	var7240 = 4143;	// _7240 = Constant(+4143 i16)
	var3342 = -7049 << 3;
	// ^ Call( _3342 = "unchecked_shl"::<i16,>( -7049 i16, +3 i16, ), bb2334, bb399)
	var3343 = var52 & var481;	// _3343 = BinOp(_52 BIT_AND _481)
	var7241 = var3342 / var3343;	// _7241 = BinOp(_3342 DIV _3343)
	var7239 = ZRICd15overflowing_rem0g( var7240, var7241 );
	// ^ Call( _7239 = <i16 /*- */>::overflowing_rem( _7240, _7241, ), bb2335, bb399)
	var3344 = var7239._0;	// _3344 = Use(_7239.0)
	var7243 = -var104;	// _7243 = UniOp(_104 NEG)
	var7242 = ZRICd15overflowing_rem0g( var104, -5743 );
	// ^ Call( _7242 = <i16 /*- */>::overflowing_rem( _104, -5743 i16, ), bb2336, bb399)
	var7244 = -var7242._0;	// _7244 = UniOp(_7242.0 NEG)
	__builtin_mul_overflow(var7243, var7244, &var3345);
	// ^ Call( _3345 = "overflowing_mul"::<i16,>( _7243, _7244, ), bb2337, bb399)
	var3341 = var3344 * var3345;	// _3341 = BinOp(_3344 MUL _3345)
	var538 = -var3341;	// _538 = UniOp(_3341 NEG)
	var539 = -7907;	// _539 = Constant(-7907 i16)
	var7245 = (uint64_t )var480;	// _7245 = Cast(_480 as u64)
	var7246 = var31 + 0x75c6c8dc03c4206ull;	// _7246 = BinOp(_31 ADD 0x75c6c8dc03c4206 u64)
	__builtin_sub_overflow(var7245, var7246, &var7247);
	// ^ Call( _7247 = "overflowing_sub"::<u64,>( _7245, _7246, ), bb2338, bb399)
	var3346 = var155 / var433;	// _3346 = BinOp(_155 DIV _433)
	var3347 = (uint64_t )var248;	// _3347 = Cast(_248 as u64)
	var7248 = var3346 & var3347;	// _7248 = BinOp(_3346 BIT_AND _3347)
	__builtin_sub_overflow(var7247, var7248, &var7249);
	// ^ Call( _7249 = "overflowing_sub"::<u64,>( _7247, _7248, ), bb2339, bb399)
	__builtin_sub_overflow(var196, var7249, &var3348);
	// ^ Call( _3348 = "overflowing_sub"::<u64,>( _196, _7249, ), bb2340, bb399)
	var7250 = var475 & 0xf;	// _7250 = BinOp(_475 BIT_AND 0xf u32)
	var7251 = (uint16_t )var7250;	// _7251 = Cast(_7250 as u16)
	var3350 = var98 << var7251;
	// ^ Call( _3350 = "unchecked_shl"::<u16,>( _98, _7251, ), bb2341, bb399)
	var3351 = var470 / var222;	// _3351 = BinOp(_470 DIV _222)
	var3349 = var3350 & var3351;	// _3349 = BinOp(_3350 BIT_AND _3351)
	var3352 = (uintptr_t )var3349;	// _3352 = Cast(_3349 as usize)
	var7254 = var3352 & 0x91ad1c91ba19708eull;	// _7254 = BinOp(_3352 BIT_AND 0x91ad1c91ba19708e usize)
	var3354 = 0x0ull;	// _3354 = Constant(0x0 usize)
	__builtin_sub_overflow(0x4477ce49e8560cd6ull, var267, &var7252);
	// ^ Call( _7252 = "overflowing_sub"::<usize,>( 0x4477ce49e8560cd6 usize, _267, ), bb2342, bb399)
	var7253 = 0x6a9c890962cfa117ull - var27;	// _7253 = BinOp(0x6a9c890962cfa117 usize SUB _27)
	var3355 = var7252 % var7253;	// _3355 = BinOp(_7252 MOD _7253)
	var3353 = var3354 | var3355;	// _3353 = BinOp(_3354 BIT_OR _3355)
	var7255 = var3353 + var53;	// _7255 = BinOp(_3353 ADD _53)
	__builtin_add_overflow(var7254, var7255, &var540);
	// ^ Call( _540 = "overflowing_add"::<usize,>( _7254, _7255, ), bb2343, bb399)
	var541 = 0xec3bffe9;	// _541 = Constant(0xec3bffe9 u32)
	var3357 = 0xfac8ab610666fc0eull & var112;	// _3357 = BinOp(0xfac8ab610666fc0e usize BIT_AND _112)
	var7258 = var3357 / 0x1f2e2615af1a984eull;	// _7258 = BinOp(_3357 DIV 0x1f2e2615af1a984e usize)
	var3358 = 0xbf56d24d - var25;	// _3358 = BinOp(0xbf56d24d u32 SUB _25)
	var7259 = 0x85f9329d / var3358;	// _7259 = BinOp(0x85f9329d u32 DIV _3358)
	var7256 = var7259 & 0x3f;	// _7256 = BinOp(_7259 BIT_AND 0x3f u32)
	var7257 = (uintptr_t )var7256;	// _7257 = Cast(_7256 as usize)
	var3359 = var7258 << var7257;
	// ^ Call( _3359 = "unchecked_shl"::<usize,>( _7258, _7257, ), bb2344, bb399)
	var3356 = 0x89696ae4e76ebb7ull / var3359;	// _3356 = BinOp(0x89696ae4e76ebb7 usize DIV _3359)
	var542 = (uint32_t )var3356;	// _542 = Cast(_3356 as u32)
	var7260 = var418 & 0x7;	// _7260 = BinOp(_418 BIT_AND 0x7 u32)
	var7261 = (uint8_t )var7260;	// _7261 = Cast(_7260 as u8)
	var7268 = 0xb6 >> var7261;
	// ^ Call( _7268 = "unchecked_shr"::<u8,>( 0xb6 u8, _7261, ), bb2345, bb399)
	var7262 = var147 & var78;	// _7262 = BinOp(_147 BIT_AND _78)
	var7266 = var7262 >> 0x3;
	// ^ Call( _7266 = "unchecked_shr"::<u8,>( _7262, 0x3 u8, ), bb2346, bb399)
	__builtin_sub_overflow(var277, 0x9234d5d8, &var7263);
	// ^ Call( _7263 = "overflowing_sub"::<u32,>( _277, 0x9234d5d8 u32, ), bb2347, bb399)
	__builtin_add_overflow(var7263, 0x563b518b, &var7267);
	// ^ Call( _7267 = "overflowing_add"::<u32,>( _7263, 0x563b518b u32, ), bb2348, bb399)
	var7264 = var7267 & 0x7;	// _7264 = BinOp(_7267 BIT_AND 0x7 u32)
	var7265 = (uint8_t )var7264;	// _7265 = Cast(_7264 as u8)
	var7269 = var7266 >> var7265;
	// ^ Call( _7269 = "unchecked_shr"::<u8,>( _7266, _7265, ), bb2349, bb399)
	__builtin_mul_overflow(var7268, var7269, &var7270);
	// ^ Call( _7270 = "overflowing_mul"::<u8,>( _7268, _7269, ), bb2350, bb399)
	__builtin_mul_overflow(0x8a, var7270, &var3360);
	// ^ Call( _3360 = "overflowing_mul"::<u8,>( 0x8a u8, _7270, ), bb2351, bb399)
	var7271 = 0xec3f230e % var108;	// _7271 = BinOp(0xec3f230e u32 MOD _108)
	var7272 = var7271 % var418;	// _7272 = BinOp(_7271 MOD _418)
	__builtin_sub_overflow(0x7cb822f0, var7272, &var7275);
	// ^ Call( _7275 = "overflowing_sub"::<u32,>( 0x7cb822f0 u32, _7272, ), bb2352, bb399)
	var7273 = var7275 & 0x7;	// _7273 = BinOp(_7275 BIT_AND 0x7 u32)
	var7274 = (int8_t )var7273;	// _7274 = Cast(_7273 as i8)
	var3361 = var434 << var7274;
	// ^ Call( _3361 = "unchecked_shl"::<i8,>( _434, _7274, ), bb2353, bb399)
	var3362 = 1831219042 & var281;	// _3362 = BinOp(+2714593266193805154 i32 BIT_AND _281)
	var543 = var3362 - var422;	// _543 = BinOp(_3362 SUB _422)
	var7276 = -1770755298 / var497;	// _7276 = BinOp(-1770755298 i32 DIV _497)
	__builtin_sub_overflow(var7276, 481464136, &var3365);
	// ^ Call( _3365 = "overflowing_sub"::<i32,>( _7276, +481464136 i32, ), bb2354, bb399)
	var3366 = -var281;	// _3366 = UniOp(_281 NEG)
	var3364 = var3365 | var3366;	// _3364 = BinOp(_3365 BIT_OR _3366)
	var3363 = var3364 * var256;	// _3363 = BinOp(_3364 MUL _256)
	var544 = -var3363;	// _544 = UniOp(_3363 NEG)
	var3369 = var96 | var399;	// _3369 = BinOp(_96 BIT_OR _399)
	var3370 = var178 ^ 0x31;	// _3370 = BinOp(_178 BIT_XOR 0x31 u8)
	var3368 = var3369 / var3370;	// _3368 = BinOp(_3369 DIV _3370)
	var3367 = 0x80 & var3368;	// _3367 = BinOp(0x80 u8 BIT_AND _3368)
	var7277 = var3367 * 0x94;	// _7277 = BinOp(_3367 MUL 0x94 u8)
	mul128s_o(make128s_raw(18012302930022734033ull, 4475523822806357650ull), make128s_raw(13694832996907419387ull, 1143903745861518920ull), &var3373);
	// ^ Call( _3373 = "overflowing_mul"::<i128,>( -8014024592680402028521781350108506478 i128, -87657287494794506671557378006471113144 i128, ), bb2355, bb399)
	var3372 = div128s(var3373, make128s_raw(6252554204731912492ull, 22057370799979559ull));	// _3372 = BinOp(_3373 DIV +115339267221686145255872840642269166631 i128)
	add128s_o(var307, make128s_raw(10285233197289300845ull, 14822377130256674406ull), &var3374);
	// ^ Call( _3374 = "overflowing_add"::<i128,>( _307, -150553302392121309583661118382431621530 i128, ), bb2356, bb399)
	var3375 = neg128s(var3374);	// _3375 = UniOp(_3374 NEG)
	var3371 = xor128s(var3372, var3375);	// _3371 = BinOp(_3372 BIT_XOR _3375)
	var7278 = var3371.lo;	// _7278 = Cast(_3371 as u8)
	__builtin_sub_overflow(var7277, var7278, &var545);
	// ^ Call( _545 = "overflowing_sub"::<u8,>( _7277, _7278, ), bb2357, bb399)
	var546 = var88;	// _546 = Use(_88)
	var7280 = -var188;	// _7280 = UniOp(_188 NEG)
	var7279 = ZRICf15overflowing_div0g( var7280, 345029141 );
	// ^ Call( _7279 = <i32 /*- */>::overflowing_div( _7280, +345029141 i32, ), bb2358, bb399)
	var7282 = -var422;	// _7282 = UniOp(_422 NEG)
	var7281 = ZRICf15overflowing_div0g( var7279._0, var7282 );
	// ^ Call( _7281 = <i32 /*- */>::overflowing_div( _7279.0, _7282, ), bb2359, bb399)
	var7285 = var163 & var6;	// _7285 = BinOp(_163 BIT_AND _6)
	var7283 = var7285 & 0x1f;	// _7283 = BinOp(_7285 BIT_AND 0x1f u32)
	var7284 = (int32_t )var7283;	// _7284 = Cast(_7283 as i32)
	var3376 = var7281._0 << var7284;
	// ^ Call( _3376 = "unchecked_shl"::<i32,>( _7281.0, _7284, ), bb2360, bb399)
	__builtin_sub_overflow(var244, -486579572, &var3377);
	// ^ Call( _3377 = "overflowing_sub"::<i32,>( _244, -486579572 i32, ), bb2361, bb399)
	var3378 = -var464;	// _3378 = UniOp(_464 NEG)
	var7286 = var3378 / -122815469;	// _7286 = BinOp(_3378 DIV -122815469 i32)
	var3379 = (int32_t )var343;	// _3379 = Cast(_343 as i32)
	var7287 = -var3379;	// _7287 = UniOp(_3379 NEG)
	__builtin_mul_overflow(var7286, var7287, &var3380);
	// ^ Call( _3380 = "overflowing_mul"::<i32,>( _7286, _7287, ), bb2362, bb399)
	var7289 = (int32_t )var442;	// _7289 = Cast(_442 as i32)
	var7288 = ZRICf15overflowing_rem0g( var7289, var466 );
	// ^ Call( _7288 = <i32 /*- */>::overflowing_rem( _7289, _466, ), bb2363, bb399)
	var7290 = var141 & 0x1f;	// _7290 = BinOp(_141 BIT_AND 0x1f u32)
	var7291 = (int32_t )var7290;	// _7291 = Cast(_7290 as i32)
	var7292 = -1349597672 >> var7291;
	// ^ Call( _7292 = "unchecked_shr"::<i32,>( -1349597672 i32, _7291, ), bb2364, bb399)
	__builtin_mul_overflow(var7292, 388148987, &var3381);
	// ^ Call( _3381 = "overflowing_mul"::<i32,>( _7292, +388148987 i32, ), bb2365, bb399)
	var7295 = 1228027042 << 16;
	// ^ Call( _7295 = "unchecked_shl"::<i32,>( +1228027042 i32, +16 i32, ), bb2366, bb399)
	var7296 = var92 % 0x9658c1c9;	// _7296 = BinOp(_92 MOD 0x9658c1c9 u32)
	var7293 = var7296 & 0x1f;	// _7293 = BinOp(_7296 BIT_AND 0x1f u32)
	var7294 = (int32_t )var7293;	// _7294 = Cast(_7293 as i32)
	var3382 = var7295 >> var7294;
	// ^ Call( _3382 = "unchecked_shr"::<i32,>( _7295, _7294, ), bb2367, bb399)
	var7298 = var3381 | var3382;	// _7298 = BinOp(_3381 BIT_OR _3382)
	var7297 = ZRICf15overflowing_div0g( var7288._0, var7298 );
	// ^ Call( _7297 = <i32 /*- */>::overflowing_div( _7288.0, _7298, ), bb2368, bb399)
	var7300 = -var15;	// _7300 = UniOp(_15 NEG)
	var7301 = -1879877862 << 19;
	// ^ Call( _7301 = "unchecked_shl"::<i32,>( -1879877862 i32, +19 i32, ), bb2369, bb399)
	var7299 = ZRICf15overflowing_div0g( var7300, var7301 );
	// ^ Call( _7299 = <i32 /*- */>::overflowing_div( _7300, _7301, ), bb2370, bb399)
	var7302 = var420 & 0xf;	// _7302 = BinOp(_420 BIT_AND 0xf u32)
	var7303 = (int16_t )var7302;	// _7303 = Cast(_7302 as i16)
	var3383 = -22614 >> var7303;
	// ^ Call( _3383 = "unchecked_shr"::<i16,>( -22614 i16, _7303, ), bb2371, bb399)
	var7306 = (uint32_t )var3383;	// _7306 = Cast(_3383 as u32)
	var7304 = var7306 & 0x1f;	// _7304 = BinOp(_7306 BIT_AND 0x1f u32)
	var7305 = (int32_t )var7304;	// _7305 = Cast(_7304 as i32)
	var3384 = var7299._0 << var7305;
	// ^ Call( _3384 = "unchecked_shl"::<i32,>( _7299.0, _7305, ), bb2372, bb399)
	var7307 = -var3384;	// _7307 = UniOp(_3384 NEG)
	__builtin_mul_overflow(var7297._0, var7307, &var3385);
	// ^ Call( _3385 = "overflowing_mul"::<i32,>( _7297.0, _7307, ), bb2373, bb399)
	var3388 = var350 & var299;	// _3388 = BinOp(_350 BIT_AND _299)
	var3387 = var3388 * 0xbdd7;	// _3387 = BinOp(_3388 MUL 0xbdd7 u16)
	__builtin_sub_overflow(var236, var68, &var3390);
	// ^ Call( _3390 = "overflowing_sub"::<u16,>( _236, _68, ), bb2374, bb399)
	__builtin_add_overflow(0xb8ce, 0xb65a, &var3391);
	// ^ Call( _3391 = "overflowing_add"::<u16,>( 0xb8ce u16, 0xb65a u16, ), bb2375, bb399)
	var3389 = var3390 / var3391;	// _3389 = BinOp(_3390 DIV _3391)
	var3386 = var3387 * var3389;	// _3386 = BinOp(_3387 MUL _3389)
	var7308 = var3386 & 0xcefe;	// _7308 = BinOp(_3386 BIT_AND 0xcefe u16)
	__builtin_sub_overflow(0x69a6, var7308, &var3392);
	// ^ Call( _3392 = "overflowing_sub"::<u16,>( 0x69a6 u16, _7308, ), bb2376, bb399)
	var3393.lo = var1; var3393.hi = var1 < 0 ? -1 : 0;	// _3393 = Cast(_1 as u128)
	var0 = add128(var0, var3393);	// _0 = BinOp(_0 ADD _3393)
	var3394.lo = var7; var3394.hi = var7 < 0 ? -1 : 0;	// _3394 = Cast(_7 as u128)
	var0 = add128(var0, var3394);	// _0 = BinOp(_0 ADD _3394)
	var3395.lo = var85; var3395.hi = var85 < 0 ? -1 : 0;	// _3395 = Cast(_85 as u128)
	var0 = add128(var0, var3395);	// _0 = BinOp(_0 ADD _3395)
	var3396.lo = var86; var3396.hi = var86 < 0 ? -1 : 0;	// _3396 = Cast(_86 as u128)
	var0 = add128(var0, var3396);	// _0 = BinOp(_0 ADD _3396)
	var3397.lo = var87; var3397.hi = var87 < 0 ? -1 : 0;	// _3397 = Cast(_87 as u128)
	var0 = add128(var0, var3397);	// _0 = BinOp(_0 ADD _3397)
	var3398.lo = var88; var3398.hi = var88 < 0 ? -1 : 0;	// _3398 = Cast(_88 as u128)
	var0 = sub128(var0, var3398);	// _0 = BinOp(_0 SUB _3398)
	var3399.lo = var89; var3399.hi = var89 < 0 ? -1 : 0;	// _3399 = Cast(_89 as u128)
	var0 = add128(var0, var3399);	// _0 = BinOp(_0 ADD _3399)
	var3400.lo = var90; var3400.hi = var90 < 0 ? -1 : 0;	// _3400 = Cast(_90 as u128)
	var0 = add128(var0, var3400);	// _0 = BinOp(_0 ADD _3400)
	var7309.lo = var91; var7309.hi = var91 < 0 ? -1 : 0;	// _7309 = Cast(_91 as u128)
	sub128_o(var0, var7309, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7309, ), bb2377, bb399)
	var3401.lo = var92; var3401.hi = var92 < 0 ? -1 : 0;	// _3401 = Cast(_92 as u128)
	var0 = add128(var0, var3401);	// _0 = BinOp(_0 ADD _3401)
	var3402.lo = var8; var3402.hi = var8 < 0 ? -1 : 0;	// _3402 = Cast(_8 as u128)
	var0 = add128(var0, var3402);	// _0 = BinOp(_0 ADD _3402)
	var7310.lo = var93; var7310.hi = var93 < 0 ? -1 : 0;	// _7310 = Cast(_93 as u128)
	sub128_o(var0, var7310, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7310, ), bb2378, bb399)
	var3403.lo = var94; var3403.hi = var94 < 0 ? -1 : 0;	// _3403 = Cast(_94 as u128)
	var0 = add128(var0, var3403);	// _0 = BinOp(_0 ADD _3403)
	var3404.lo = var95; var3404.hi = var95 < 0 ? -1 : 0;	// _3404 = Cast(_95 as u128)
	var0 = add128(var0, var3404);	// _0 = BinOp(_0 ADD _3404)
	var3405.lo = var96; var3405.hi = var96 < 0 ? -1 : 0;	// _3405 = Cast(_96 as u128)
	var0 = add128(var0, var3405);	// _0 = BinOp(_0 ADD _3405)
	var3406.lo = var97; var3406.hi = var97 < 0 ? -1 : 0;	// _3406 = Cast(_97 as u128)
	var0 = add128(var0, var3406);	// _0 = BinOp(_0 ADD _3406)
	var3407.lo = var98; var3407.hi = var98 < 0 ? -1 : 0;	// _3407 = Cast(_98 as u128)
	var0 = add128(var0, var3407);	// _0 = BinOp(_0 ADD _3407)
	var3408.lo = var99; var3408.hi = var99 < 0 ? -1 : 0;	// _3408 = Cast(_99 as u128)
	var0 = add128(var0, var3408);	// _0 = BinOp(_0 ADD _3408)
	var3409.lo = var100; var3409.hi = var100 < 0 ? -1 : 0;	// _3409 = Cast(_100 as u128)
	var0 = add128(var0, var3409);	// _0 = BinOp(_0 ADD _3409)
	var3410.lo = var101; var3410.hi = var101 < 0 ? -1 : 0;	// _3410 = Cast(_101 as u128)
	var0 = add128(var0, var3410);	// _0 = BinOp(_0 ADD _3410)
	var0 = add128(var0, var9);	// _0 = BinOp(_0 ADD _9)
	var3411.lo = var102; var3411.hi = var102 < 0 ? -1 : 0;	// _3411 = Cast(_102 as u128)
	var0 = add128(var0, var3411);	// _0 = BinOp(_0 ADD _3411)
	var3412.lo = var103; var3412.hi = var103 < 0 ? -1 : 0;	// _3412 = Cast(_103 as u128)
	var0 = add128(var0, var3412);	// _0 = BinOp(_0 ADD _3412)
	var3413.lo = var104; var3413.hi = var104 < 0 ? -1 : 0;	// _3413 = Cast(_104 as u128)
	var0 = add128(var0, var3413);	// _0 = BinOp(_0 ADD _3413)
	var3414.lo = var105; var3414.hi = var105 < 0 ? -1 : 0;	// _3414 = Cast(_105 as u128)
	var0 = add128(var0, var3414);	// _0 = BinOp(_0 ADD _3414)
	var3415.lo = var106; var3415.hi = var106 < 0 ? -1 : 0;	// _3415 = Cast(_106 as u128)
	var0 = add128(var0, var3415);	// _0 = BinOp(_0 ADD _3415)
	var3416.lo = var107.lo; var3416.hi = var107.hi;	// _3416 = Cast(_107 as u128)
	var0 = add128(var0, var3416);	// _0 = BinOp(_0 ADD _3416)
	var3417.lo = var108; var3417.hi = var108 < 0 ? -1 : 0;	// _3417 = Cast(_108 as u128)
	var0 = add128(var0, var3417);	// _0 = BinOp(_0 ADD _3417)
	var3418.lo = var109; var3418.hi = var109 < 0 ? -1 : 0;	// _3418 = Cast(_109 as u128)
	var0 = add128(var0, var3418);	// _0 = BinOp(_0 ADD _3418)
	var3419.lo = var110; var3419.hi = var110 < 0 ? -1 : 0;	// _3419 = Cast(_110 as u128)
	var0 = add128(var0, var3419);	// _0 = BinOp(_0 ADD _3419)
	var3420.lo = var10; var3420.hi = var10 < 0 ? -1 : 0;	// _3420 = Cast(_10 as u128)
	var0 = add128(var0, var3420);	// _0 = BinOp(_0 ADD _3420)
	var7311.lo = var111; var7311.hi = var111 < 0 ? -1 : 0;	// _7311 = Cast(_111 as u128)
	sub128_o(var0, var7311, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7311, ), bb2379, bb399)
	var3421.lo = var112; var3421.hi = var112 < 0 ? -1 : 0;	// _3421 = Cast(_112 as u128)
	var0 = add128(var0, var3421);	// _0 = BinOp(_0 ADD _3421)
	var3422.lo = var113; var3422.hi = var113 < 0 ? -1 : 0;	// _3422 = Cast(_113 as u128)
	var0 = add128(var0, var3422);	// _0 = BinOp(_0 ADD _3422)
	var3423.lo = var114; var3423.hi = var114 < 0 ? -1 : 0;	// _3423 = Cast(_114 as u128)
	var0 = add128(var0, var3423);	// _0 = BinOp(_0 ADD _3423)
	var3424.lo = var115.lo; var3424.hi = var115.hi;	// _3424 = Cast(_115 as u128)
	var0 = add128(var0, var3424);	// _0 = BinOp(_0 ADD _3424)
	var3425.lo = var116; var3425.hi = var116 < 0 ? -1 : 0;	// _3425 = Cast(_116 as u128)
	var0 = add128(var0, var3425);	// _0 = BinOp(_0 ADD _3425)
	var3426.lo = var117; var3426.hi = var117 < 0 ? -1 : 0;	// _3426 = Cast(_117 as u128)
	var0 = add128(var0, var3426);	// _0 = BinOp(_0 ADD _3426)
	var3427.lo = var118; var3427.hi = var118 < 0 ? -1 : 0;	// _3427 = Cast(_118 as u128)
	var0 = add128(var0, var3427);	// _0 = BinOp(_0 ADD _3427)
	var3428.lo = var119; var3428.hi = var119 < 0 ? -1 : 0;	// _3428 = Cast(_119 as u128)
	var0 = add128(var0, var3428);	// _0 = BinOp(_0 ADD _3428)
	var3429.lo = var120; var3429.hi = var120 < 0 ? -1 : 0;	// _3429 = Cast(_120 as u128)
	var0 = add128(var0, var3429);	// _0 = BinOp(_0 ADD _3429)
	var3430.lo = var11; var3430.hi = var11 < 0 ? -1 : 0;	// _3430 = Cast(_11 as u128)
	var0 = add128(var0, var3430);	// _0 = BinOp(_0 ADD _3430)
	var3431.lo = var121; var3431.hi = var121 < 0 ? -1 : 0;	// _3431 = Cast(_121 as u128)
	var0 = add128(var0, var3431);	// _0 = BinOp(_0 ADD _3431)
	var3432.lo = var122; var3432.hi = var122 < 0 ? -1 : 0;	// _3432 = Cast(_122 as u128)
	var0 = add128(var0, var3432);	// _0 = BinOp(_0 ADD _3432)
	var3433.lo = var123; var3433.hi = var123 < 0 ? -1 : 0;	// _3433 = Cast(_123 as u128)
	var0 = add128(var0, var3433);	// _0 = BinOp(_0 ADD _3433)
	var3434.lo = var124; var3434.hi = var124 < 0 ? -1 : 0;	// _3434 = Cast(_124 as u128)
	var0 = add128(var0, var3434);	// _0 = BinOp(_0 ADD _3434)
	var3435.lo = var125; var3435.hi = var125 < 0 ? -1 : 0;	// _3435 = Cast(_125 as u128)
	var0 = add128(var0, var3435);	// _0 = BinOp(_0 ADD _3435)
	var3436.lo = var126; var3436.hi = var126 < 0 ? -1 : 0;	// _3436 = Cast(_126 as u128)
	var0 = add128(var0, var3436);	// _0 = BinOp(_0 ADD _3436)
	var3437.lo = var127; var3437.hi = var127 < 0 ? -1 : 0;	// _3437 = Cast(_127 as u128)
	var0 = add128(var0, var3437);	// _0 = BinOp(_0 ADD _3437)
	var7312.lo = var128; var7312.hi = var128 < 0 ? -1 : 0;	// _7312 = Cast(_128 as u128)
	sub128_o(var0, var7312, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7312, ), bb2380, bb399)
	var3438.lo = var129; var3438.hi = var129 < 0 ? -1 : 0;	// _3438 = Cast(_129 as u128)
	var0 = add128(var0, var3438);	// _0 = BinOp(_0 ADD _3438)
	var3439.lo = var130; var3439.hi = var130 < 0 ? -1 : 0;	// _3439 = Cast(_130 as u128)
	var0 = add128(var0, var3439);	// _0 = BinOp(_0 ADD _3439)
	var3440.lo = var12; var3440.hi = var12 < 0 ? -1 : 0;	// _3440 = Cast(_12 as u128)
	var0 = add128(var0, var3440);	// _0 = BinOp(_0 ADD _3440)
	var3441.lo = var131; var3441.hi = var131 < 0 ? -1 : 0;	// _3441 = Cast(_131 as u128)
	var0 = add128(var0, var3441);	// _0 = BinOp(_0 ADD _3441)
	var0 = add128(var0, var132);	// _0 = BinOp(_0 ADD _132)
	var3442.lo = var133; var3442.hi = var133 < 0 ? -1 : 0;	// _3442 = Cast(_133 as u128)
	var0 = add128(var0, var3442);	// _0 = BinOp(_0 ADD _3442)
	var3443.lo = var134; var3443.hi = var134 < 0 ? -1 : 0;	// _3443 = Cast(_134 as u128)
	var0 = add128(var0, var3443);	// _0 = BinOp(_0 ADD _3443)
	var3444.lo = var135; var3444.hi = var135 < 0 ? -1 : 0;	// _3444 = Cast(_135 as u128)
	var0 = add128(var0, var3444);	// _0 = BinOp(_0 ADD _3444)
	var3445.lo = var136.lo; var3445.hi = var136.hi;	// _3445 = Cast(_136 as u128)
	var0 = add128(var0, var3445);	// _0 = BinOp(_0 ADD _3445)
	var3446.lo = var137; var3446.hi = var137 < 0 ? -1 : 0;	// _3446 = Cast(_137 as u128)
	var0 = add128(var0, var3446);	// _0 = BinOp(_0 ADD _3446)
	var3447.lo = var138; var3447.hi = var138 < 0 ? -1 : 0;	// _3447 = Cast(_138 as u128)
	var0 = add128(var0, var3447);	// _0 = BinOp(_0 ADD _3447)
	var3448.lo = var139; var3448.hi = var139 < 0 ? -1 : 0;	// _3448 = Cast(_139 as u128)
	var0 = add128(var0, var3448);	// _0 = BinOp(_0 ADD _3448)
	var3449.lo = var13; var3449.hi = var13 < 0 ? -1 : 0;	// _3449 = Cast(_13 as u128)
	var0 = add128(var0, var3449);	// _0 = BinOp(_0 ADD _3449)
	var3450.lo = var140; var3450.hi = var140 < 0 ? -1 : 0;	// _3450 = Cast(_140 as u128)
	var0 = add128(var0, var3450);	// _0 = BinOp(_0 ADD _3450)
	var3451.lo = var141; var3451.hi = var141 < 0 ? -1 : 0;	// _3451 = Cast(_141 as u128)
	var0 = add128(var0, var3451);	// _0 = BinOp(_0 ADD _3451)
	var3452.lo = var142; var3452.hi = var142 < 0 ? -1 : 0;	// _3452 = Cast(_142 as u128)
	var0 = add128(var0, var3452);	// _0 = BinOp(_0 ADD _3452)
	var3453.lo = var143; var3453.hi = var143 < 0 ? -1 : 0;	// _3453 = Cast(_143 as u128)
	var0 = add128(var0, var3453);	// _0 = BinOp(_0 ADD _3453)
	var0 = sub128(var0, var144);	// _0 = BinOp(_0 SUB _144)
	var7313.lo = var145; var7313.hi = var145 < 0 ? -1 : 0;	// _7313 = Cast(_145 as u128)
	sub128_o(var0, var7313, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7313, ), bb2381, bb399)
	var3454.lo = var146; var3454.hi = var146 < 0 ? -1 : 0;	// _3454 = Cast(_146 as u128)
	var0 = add128(var0, var3454);	// _0 = BinOp(_0 ADD _3454)
	var3455.lo = var147; var3455.hi = var147 < 0 ? -1 : 0;	// _3455 = Cast(_147 as u128)
	var0 = add128(var0, var3455);	// _0 = BinOp(_0 ADD _3455)
	var0 = add128(var0, var14);	// _0 = BinOp(_0 ADD _14)
	var3456.lo = var148; var3456.hi = var148 < 0 ? -1 : 0;	// _3456 = Cast(_148 as u128)
	var0 = add128(var0, var3456);	// _0 = BinOp(_0 ADD _3456)
	var3457.lo = var149; var3457.hi = var149 < 0 ? -1 : 0;	// _3457 = Cast(_149 as u128)
	var0 = add128(var0, var3457);	// _0 = BinOp(_0 ADD _3457)
	var3458.lo = var150; var3458.hi = var150 < 0 ? -1 : 0;	// _3458 = Cast(_150 as u128)
	var0 = add128(var0, var3458);	// _0 = BinOp(_0 ADD _3458)
	var3459.lo = var151; var3459.hi = var151 < 0 ? -1 : 0;	// _3459 = Cast(_151 as u128)
	var0 = add128(var0, var3459);	// _0 = BinOp(_0 ADD _3459)
	var3460.lo = var152; var3460.hi = var152 < 0 ? -1 : 0;	// _3460 = Cast(_152 as u128)
	var0 = add128(var0, var3460);	// _0 = BinOp(_0 ADD _3460)
	var3461.lo = var153; var3461.hi = var153 < 0 ? -1 : 0;	// _3461 = Cast(_153 as u128)
	var0 = add128(var0, var3461);	// _0 = BinOp(_0 ADD _3461)
	var3462.lo = var154; var3462.hi = var154 < 0 ? -1 : 0;	// _3462 = Cast(_154 as u128)
	var0 = add128(var0, var3462);	// _0 = BinOp(_0 ADD _3462)
	var3463.lo = var155; var3463.hi = var155 < 0 ? -1 : 0;	// _3463 = Cast(_155 as u128)
	var0 = add128(var0, var3463);	// _0 = BinOp(_0 ADD _3463)
	var3464.lo = var156; var3464.hi = var156 < 0 ? -1 : 0;	// _3464 = Cast(_156 as u128)
	var0 = add128(var0, var3464);	// _0 = BinOp(_0 ADD _3464)
	var3465.lo = var157; var3465.hi = var157 < 0 ? -1 : 0;	// _3465 = Cast(_157 as u128)
	var0 = add128(var0, var3465);	// _0 = BinOp(_0 ADD _3465)
	var7314.lo = var15; var7314.hi = var15 < 0 ? -1 : 0;	// _7314 = Cast(_15 as u128)
	sub128_o(var0, var7314, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7314, ), bb2382, bb399)
	var3466.lo = var158; var3466.hi = var158 < 0 ? -1 : 0;	// _3466 = Cast(_158 as u128)
	var0 = add128(var0, var3466);	// _0 = BinOp(_0 ADD _3466)
	var3467.lo = var159; var3467.hi = var159 < 0 ? -1 : 0;	// _3467 = Cast(_159 as u128)
	var0 = add128(var0, var3467);	// _0 = BinOp(_0 ADD _3467)
	var0 = add128(var0, var160);	// _0 = BinOp(_0 ADD _160)
	var3468.lo = var161; var3468.hi = var161 < 0 ? -1 : 0;	// _3468 = Cast(_161 as u128)
	var0 = add128(var0, var3468);	// _0 = BinOp(_0 ADD _3468)
	var3469.lo = var162; var3469.hi = var162 < 0 ? -1 : 0;	// _3469 = Cast(_162 as u128)
	var0 = add128(var0, var3469);	// _0 = BinOp(_0 ADD _3469)
	var3470.lo = var163; var3470.hi = var163 < 0 ? -1 : 0;	// _3470 = Cast(_163 as u128)
	var0 = add128(var0, var3470);	// _0 = BinOp(_0 ADD _3470)
	var3471.lo = var164; var3471.hi = var164 < 0 ? -1 : 0;	// _3471 = Cast(_164 as u128)
	var0 = add128(var0, var3471);	// _0 = BinOp(_0 ADD _3471)
	var7315.lo = var165.lo; var7315.hi = var165.hi;	// _7315 = Cast(_165 as u128)
	sub128_o(var0, var7315, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7315, ), bb2383, bb399)
	var3472.lo = var16; var3472.hi = var16 < 0 ? -1 : 0;	// _3472 = Cast(_16 as u128)
	var0 = add128(var0, var3472);	// _0 = BinOp(_0 ADD _3472)
	var3473.lo = var166; var3473.hi = var166 < 0 ? -1 : 0;	// _3473 = Cast(_166 as u128)
	var0 = add128(var0, var3473);	// _0 = BinOp(_0 ADD _3473)
	var3474.lo = var167; var3474.hi = var167 < 0 ? -1 : 0;	// _3474 = Cast(_167 as u128)
	var0 = add128(var0, var3474);	// _0 = BinOp(_0 ADD _3474)
	var3475.lo = var168; var3475.hi = var168 < 0 ? -1 : 0;	// _3475 = Cast(_168 as u128)
	var0 = add128(var0, var3475);	// _0 = BinOp(_0 ADD _3475)
	var3476.lo = var169; var3476.hi = var169 < 0 ? -1 : 0;	// _3476 = Cast(_169 as u128)
	var0 = add128(var0, var3476);	// _0 = BinOp(_0 ADD _3476)
	var7316.lo = var170; var7316.hi = var170 < 0 ? -1 : 0;	// _7316 = Cast(_170 as u128)
	sub128_o(var0, var7316, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7316, ), bb2384, bb399)
	var7317.lo = var171; var7317.hi = var171 < 0 ? -1 : 0;	// _7317 = Cast(_171 as u128)
	sub128_o(var0, var7317, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7317, ), bb2385, bb399)
	var3477.lo = var172; var3477.hi = var172 < 0 ? -1 : 0;	// _3477 = Cast(_172 as u128)
	var0 = add128(var0, var3477);	// _0 = BinOp(_0 ADD _3477)
	var3478.lo = var173; var3478.hi = var173 < 0 ? -1 : 0;	// _3478 = Cast(_173 as u128)
	var0 = add128(var0, var3478);	// _0 = BinOp(_0 ADD _3478)
	var3479.lo = var174; var3479.hi = var174 < 0 ? -1 : 0;	// _3479 = Cast(_174 as u128)
	var0 = add128(var0, var3479);	// _0 = BinOp(_0 ADD _3479)
	var3480.lo = var175; var3480.hi = var175 < 0 ? -1 : 0;	// _3480 = Cast(_175 as u128)
	var0 = add128(var0, var3480);	// _0 = BinOp(_0 ADD _3480)
	var3481.lo = var17; var3481.hi = var17 < 0 ? -1 : 0;	// _3481 = Cast(_17 as u128)
	var0 = add128(var0, var3481);	// _0 = BinOp(_0 ADD _3481)
	var3482.lo = var176; var3482.hi = var176 < 0 ? -1 : 0;	// _3482 = Cast(_176 as u128)
	var0 = add128(var0, var3482);	// _0 = BinOp(_0 ADD _3482)
	var3483.lo = var177; var3483.hi = var177 < 0 ? -1 : 0;	// _3483 = Cast(_177 as u128)
	var0 = add128(var0, var3483);	// _0 = BinOp(_0 ADD _3483)
	var3484.lo = var178; var3484.hi = var178 < 0 ? -1 : 0;	// _3484 = Cast(_178 as u128)
	var0 = add128(var0, var3484);	// _0 = BinOp(_0 ADD _3484)
	var3485.lo = var179; var3485.hi = var179 < 0 ? -1 : 0;	// _3485 = Cast(_179 as u128)
	var0 = add128(var0, var3485);	// _0 = BinOp(_0 ADD _3485)
	var3486.lo = var180; var3486.hi = var180 < 0 ? -1 : 0;	// _3486 = Cast(_180 as u128)
	var0 = add128(var0, var3486);	// _0 = BinOp(_0 ADD _3486)
	var3487.lo = var181; var3487.hi = var181 < 0 ? -1 : 0;	// _3487 = Cast(_181 as u128)
	var0 = add128(var0, var3487);	// _0 = BinOp(_0 ADD _3487)
	var3488.lo = var182; var3488.hi = var182 < 0 ? -1 : 0;	// _3488 = Cast(_182 as u128)
	var0 = add128(var0, var3488);	// _0 = BinOp(_0 ADD _3488)
	var3489.lo = var183; var3489.hi = var183 < 0 ? -1 : 0;	// _3489 = Cast(_183 as u128)
	var0 = add128(var0, var3489);	// _0 = BinOp(_0 ADD _3489)
	var7318.lo = var184; var7318.hi = var184 < 0 ? -1 : 0;	// _7318 = Cast(_184 as u128)
	sub128_o(var0, var7318, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7318, ), bb2386, bb399)
	var3490.lo = var185; var3490.hi = var185 < 0 ? -1 : 0;	// _3490 = Cast(_185 as u128)
	var0 = add128(var0, var3490);	// _0 = BinOp(_0 ADD _3490)
	var3491.lo = var186; var3491.hi = var186 < 0 ? -1 : 0;	// _3491 = Cast(_186 as u128)
	var0 = add128(var0, var3491);	// _0 = BinOp(_0 ADD _3491)
	var3492.lo = var187; var3492.hi = var187 < 0 ? -1 : 0;	// _3492 = Cast(_187 as u128)
	var0 = add128(var0, var3492);	// _0 = BinOp(_0 ADD _3492)
	var7319.lo = var188; var7319.hi = var188 < 0 ? -1 : 0;	// _7319 = Cast(_188 as u128)
	sub128_o(var0, var7319, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7319, ), bb2387, bb399)
	var3493.lo = var189; var3493.hi = var189 < 0 ? -1 : 0;	// _3493 = Cast(_189 as u128)
	var0 = add128(var0, var3493);	// _0 = BinOp(_0 ADD _3493)
	var7320.lo = var190; var7320.hi = var190 < 0 ? -1 : 0;	// _7320 = Cast(_190 as u128)
	sub128_o(var0, var7320, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7320, ), bb2388, bb399)
	var3494.lo = var191; var3494.hi = var191 < 0 ? -1 : 0;	// _3494 = Cast(_191 as u128)
	var0 = add128(var0, var3494);	// _0 = BinOp(_0 ADD _3494)
	var3495.lo = var192; var3495.hi = var192 < 0 ? -1 : 0;	// _3495 = Cast(_192 as u128)
	var0 = add128(var0, var3495);	// _0 = BinOp(_0 ADD _3495)
	var3496.lo = var193; var3496.hi = var193 < 0 ? -1 : 0;	// _3496 = Cast(_193 as u128)
	var0 = add128(var0, var3496);	// _0 = BinOp(_0 ADD _3496)
	var3497.lo = var194.lo; var3497.hi = var194.hi;	// _3497 = Cast(_194 as u128)
	var0 = add128(var0, var3497);	// _0 = BinOp(_0 ADD _3497)
	var3498.lo = var18; var3498.hi = var18 < 0 ? -1 : 0;	// _3498 = Cast(_18 as u128)
	var0 = add128(var0, var3498);	// _0 = BinOp(_0 ADD _3498)
	var3499.lo = var195; var3499.hi = var195 < 0 ? -1 : 0;	// _3499 = Cast(_195 as u128)
	var0 = add128(var0, var3499);	// _0 = BinOp(_0 ADD _3499)
	var3500.lo = var196; var3500.hi = var196 < 0 ? -1 : 0;	// _3500 = Cast(_196 as u128)
	var0 = add128(var0, var3500);	// _0 = BinOp(_0 ADD _3500)
	var3501.lo = var197; var3501.hi = var197 < 0 ? -1 : 0;	// _3501 = Cast(_197 as u128)
	var0 = add128(var0, var3501);	// _0 = BinOp(_0 ADD _3501)
	var3502.lo = var198; var3502.hi = var198 < 0 ? -1 : 0;	// _3502 = Cast(_198 as u128)
	var0 = add128(var0, var3502);	// _0 = BinOp(_0 ADD _3502)
	var0 = add128(var0, var199);	// _0 = BinOp(_0 ADD _199)
	var3503.lo = var200; var3503.hi = var200 < 0 ? -1 : 0;	// _3503 = Cast(_200 as u128)
	var0 = add128(var0, var3503);	// _0 = BinOp(_0 ADD _3503)
	var3504.lo = var201; var3504.hi = var201 < 0 ? -1 : 0;	// _3504 = Cast(_201 as u128)
	var0 = add128(var0, var3504);	// _0 = BinOp(_0 ADD _3504)
	var3505.lo = var19; var3505.hi = var19 < 0 ? -1 : 0;	// _3505 = Cast(_19 as u128)
	var0 = add128(var0, var3505);	// _0 = BinOp(_0 ADD _3505)
	var3506.lo = var202; var3506.hi = var202 < 0 ? -1 : 0;	// _3506 = Cast(_202 as u128)
	var0 = add128(var0, var3506);	// _0 = BinOp(_0 ADD _3506)
	var7321.lo = var203.lo; var7321.hi = var203.hi;	// _7321 = Cast(_203 as u128)
	sub128_o(var0, var7321, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7321, ), bb2389, bb399)
	var3507.lo = var205; var3507.hi = var205 < 0 ? -1 : 0;	// _3507 = Cast(_205 as u128)
	var0 = add128(var0, var3507);	// _0 = BinOp(_0 ADD _3507)
	var7322.lo = var206; var7322.hi = var206 < 0 ? -1 : 0;	// _7322 = Cast(_206 as u128)
	sub128_o(var0, var7322, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7322, ), bb2390, bb399)
	var3508.lo = var207; var3508.hi = var207 < 0 ? -1 : 0;	// _3508 = Cast(_207 as u128)
	var0 = add128(var0, var3508);	// _0 = BinOp(_0 ADD _3508)
	var3509.lo = var208; var3509.hi = var208 < 0 ? -1 : 0;	// _3509 = Cast(_208 as u128)
	var0 = add128(var0, var3509);	// _0 = BinOp(_0 ADD _3509)
	var3510.lo = var209; var3510.hi = var209 < 0 ? -1 : 0;	// _3510 = Cast(_209 as u128)
	var0 = add128(var0, var3510);	// _0 = BinOp(_0 ADD _3510)
	var3511.lo = var20.lo; var3511.hi = var20.hi;	// _3511 = Cast(_20 as u128)
	var0 = add128(var0, var3511);	// _0 = BinOp(_0 ADD _3511)
	var3512.lo = var210; var3512.hi = var210 < 0 ? -1 : 0;	// _3512 = Cast(_210 as u128)
	var0 = add128(var0, var3512);	// _0 = BinOp(_0 ADD _3512)
	var3513.lo = var211; var3513.hi = var211 < 0 ? -1 : 0;	// _3513 = Cast(_211 as u128)
	var0 = add128(var0, var3513);	// _0 = BinOp(_0 ADD _3513)
	var3514.lo = var212; var3514.hi = var212 < 0 ? -1 : 0;	// _3514 = Cast(_212 as u128)
	var0 = add128(var0, var3514);	// _0 = BinOp(_0 ADD _3514)
	var3515.lo = var213; var3515.hi = var213 < 0 ? -1 : 0;	// _3515 = Cast(_213 as u128)
	var0 = add128(var0, var3515);	// _0 = BinOp(_0 ADD _3515)
	var3516.lo = var214; var3516.hi = var214 < 0 ? -1 : 0;	// _3516 = Cast(_214 as u128)
	var0 = add128(var0, var3516);	// _0 = BinOp(_0 ADD _3516)
	var3517.lo = var216; var3517.hi = var216 < 0 ? -1 : 0;	// _3517 = Cast(_216 as u128)
	var0 = add128(var0, var3517);	// _0 = BinOp(_0 ADD _3517)
	var3518.lo = var21; var3518.hi = var21 < 0 ? -1 : 0;	// _3518 = Cast(_21 as u128)
	var0 = add128(var0, var3518);	// _0 = BinOp(_0 ADD _3518)
	var3519.lo = var217; var3519.hi = var217 < 0 ? -1 : 0;	// _3519 = Cast(_217 as u128)
	var0 = add128(var0, var3519);	// _0 = BinOp(_0 ADD _3519)
	var7323.lo = var218; var7323.hi = var218 < 0 ? -1 : 0;	// _7323 = Cast(_218 as u128)
	sub128_o(var0, var7323, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7323, ), bb2391, bb399)
	var3520.lo = var219; var3520.hi = var219 < 0 ? -1 : 0;	// _3520 = Cast(_219 as u128)
	var0 = add128(var0, var3520);	// _0 = BinOp(_0 ADD _3520)
	var3521.lo = var220; var3521.hi = var220 < 0 ? -1 : 0;	// _3521 = Cast(_220 as u128)
	var0 = add128(var0, var3521);	// _0 = BinOp(_0 ADD _3521)
	var3522.lo = var221; var3522.hi = var221 < 0 ? -1 : 0;	// _3522 = Cast(_221 as u128)
	var0 = add128(var0, var3522);	// _0 = BinOp(_0 ADD _3522)
	var3523.lo = var222; var3523.hi = var222 < 0 ? -1 : 0;	// _3523 = Cast(_222 as u128)
	var0 = add128(var0, var3523);	// _0 = BinOp(_0 ADD _3523)
	var3524.lo = var223; var3524.hi = var223 < 0 ? -1 : 0;	// _3524 = Cast(_223 as u128)
	var0 = add128(var0, var3524);	// _0 = BinOp(_0 ADD _3524)
	var7324.lo = var224; var7324.hi = var224 < 0 ? -1 : 0;	// _7324 = Cast(_224 as u128)
	sub128_o(var0, var7324, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7324, ), bb2392, bb399)
	var3525.lo = var225; var3525.hi = var225 < 0 ? -1 : 0;	// _3525 = Cast(_225 as u128)
	var0 = add128(var0, var3525);	// _0 = BinOp(_0 ADD _3525)
	var3526.lo = var22; var3526.hi = var22 < 0 ? -1 : 0;	// _3526 = Cast(_22 as u128)
	var0 = add128(var0, var3526);	// _0 = BinOp(_0 ADD _3526)
	var3527.lo = var226; var3527.hi = var226 < 0 ? -1 : 0;	// _3527 = Cast(_226 as u128)
	var0 = add128(var0, var3527);	// _0 = BinOp(_0 ADD _3527)
	var7325.lo = var227; var7325.hi = var227 < 0 ? -1 : 0;	// _7325 = Cast(_227 as u128)
	sub128_o(var0, var7325, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7325, ), bb2393, bb399)
	var3528.lo = var228; var3528.hi = var228 < 0 ? -1 : 0;	// _3528 = Cast(_228 as u128)
	var0 = add128(var0, var3528);	// _0 = BinOp(_0 ADD _3528)
	var3529.lo = var229; var3529.hi = var229 < 0 ? -1 : 0;	// _3529 = Cast(_229 as u128)
	var0 = add128(var0, var3529);	// _0 = BinOp(_0 ADD _3529)
	var7326.lo = var230; var7326.hi = var230 < 0 ? -1 : 0;	// _7326 = Cast(_230 as u128)
	sub128_o(var0, var7326, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7326, ), bb2394, bb399)
	var3530.lo = var231; var3530.hi = var231 < 0 ? -1 : 0;	// _3530 = Cast(_231 as u128)
	var0 = add128(var0, var3530);	// _0 = BinOp(_0 ADD _3530)
	var3531.lo = var232; var3531.hi = var232 < 0 ? -1 : 0;	// _3531 = Cast(_232 as u128)
	var0 = add128(var0, var3531);	// _0 = BinOp(_0 ADD _3531)
	var7327.lo = var233; var7327.hi = var233 < 0 ? -1 : 0;	// _7327 = Cast(_233 as u128)
	sub128_o(var0, var7327, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7327, ), bb2395, bb399)
	var3532.lo = var234; var3532.hi = var234 < 0 ? -1 : 0;	// _3532 = Cast(_234 as u128)
	var0 = add128(var0, var3532);	// _0 = BinOp(_0 ADD _3532)
	var3533.lo = var23; var3533.hi = var23 < 0 ? -1 : 0;	// _3533 = Cast(_23 as u128)
	var0 = add128(var0, var3533);	// _0 = BinOp(_0 ADD _3533)
	var7328.lo = var235.lo; var7328.hi = var235.hi;	// _7328 = Cast(_235 as u128)
	sub128_o(var0, var7328, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7328, ), bb2396, bb399)
	var3534.lo = var236; var3534.hi = var236 < 0 ? -1 : 0;	// _3534 = Cast(_236 as u128)
	var0 = add128(var0, var3534);	// _0 = BinOp(_0 ADD _3534)
	var3535.lo = var237; var3535.hi = var237 < 0 ? -1 : 0;	// _3535 = Cast(_237 as u128)
	var0 = add128(var0, var3535);	// _0 = BinOp(_0 ADD _3535)
	var3536.lo = var238; var3536.hi = var238 < 0 ? -1 : 0;	// _3536 = Cast(_238 as u128)
	var0 = add128(var0, var3536);	// _0 = BinOp(_0 ADD _3536)
	var3537.lo = var239; var3537.hi = var239 < 0 ? -1 : 0;	// _3537 = Cast(_239 as u128)
	var0 = add128(var0, var3537);	// _0 = BinOp(_0 ADD _3537)
	var3538.lo = var240; var3538.hi = var240 < 0 ? -1 : 0;	// _3538 = Cast(_240 as u128)
	var0 = add128(var0, var3538);	// _0 = BinOp(_0 ADD _3538)
	var3539.lo = var241; var3539.hi = var241 < 0 ? -1 : 0;	// _3539 = Cast(_241 as u128)
	var0 = add128(var0, var3539);	// _0 = BinOp(_0 ADD _3539)
	var3540.lo = var242; var3540.hi = var242 < 0 ? -1 : 0;	// _3540 = Cast(_242 as u128)
	var0 = add128(var0, var3540);	// _0 = BinOp(_0 ADD _3540)
	var3541.lo = var243; var3541.hi = var243 < 0 ? -1 : 0;	// _3541 = Cast(_243 as u128)
	var0 = add128(var0, var3541);	// _0 = BinOp(_0 ADD _3541)
	var7329.lo = var244; var7329.hi = var244 < 0 ? -1 : 0;	// _7329 = Cast(_244 as u128)
	sub128_o(var0, var7329, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7329, ), bb2397, bb399)
	var3542.lo = var24; var3542.hi = var24 < 0 ? -1 : 0;	// _3542 = Cast(_24 as u128)
	var0 = add128(var0, var3542);	// _0 = BinOp(_0 ADD _3542)
	var3543.lo = var245; var3543.hi = var245 < 0 ? -1 : 0;	// _3543 = Cast(_245 as u128)
	var0 = add128(var0, var3543);	// _0 = BinOp(_0 ADD _3543)
	var7330.lo = var246; var7330.hi = var246 < 0 ? -1 : 0;	// _7330 = Cast(_246 as u128)
	sub128_o(var0, var7330, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7330, ), bb2398, bb399)
	var3544.lo = var247; var3544.hi = var247 < 0 ? -1 : 0;	// _3544 = Cast(_247 as u128)
	var0 = add128(var0, var3544);	// _0 = BinOp(_0 ADD _3544)
	var3545.lo = var248; var3545.hi = var248 < 0 ? -1 : 0;	// _3545 = Cast(_248 as u128)
	var0 = add128(var0, var3545);	// _0 = BinOp(_0 ADD _3545)
	var3546.lo = var249; var3546.hi = var249 < 0 ? -1 : 0;	// _3546 = Cast(_249 as u128)
	var0 = add128(var0, var3546);	// _0 = BinOp(_0 ADD _3546)
	var3547.lo = var250.lo; var3547.hi = var250.hi;	// _3547 = Cast(_250 as u128)
	var0 = add128(var0, var3547);	// _0 = BinOp(_0 ADD _3547)
	var3548.lo = var251; var3548.hi = var251 < 0 ? -1 : 0;	// _3548 = Cast(_251 as u128)
	var0 = add128(var0, var3548);	// _0 = BinOp(_0 ADD _3548)
	var3549.lo = var252; var3549.hi = var252 < 0 ? -1 : 0;	// _3549 = Cast(_252 as u128)
	var0 = add128(var0, var3549);	// _0 = BinOp(_0 ADD _3549)
	var3550.lo = var253; var3550.hi = var253 < 0 ? -1 : 0;	// _3550 = Cast(_253 as u128)
	var0 = add128(var0, var3550);	// _0 = BinOp(_0 ADD _3550)
	var3551.lo = var25; var3551.hi = var25 < 0 ? -1 : 0;	// _3551 = Cast(_25 as u128)
	var0 = add128(var0, var3551);	// _0 = BinOp(_0 ADD _3551)
	var3552.lo = var254; var3552.hi = var254 < 0 ? -1 : 0;	// _3552 = Cast(_254 as u128)
	var0 = add128(var0, var3552);	// _0 = BinOp(_0 ADD _3552)
	var3553.lo = var255; var3553.hi = var255 < 0 ? -1 : 0;	// _3553 = Cast(_255 as u128)
	var0 = add128(var0, var3553);	// _0 = BinOp(_0 ADD _3553)
	var3554.lo = var256; var3554.hi = var256 < 0 ? -1 : 0;	// _3554 = Cast(_256 as u128)
	var0 = add128(var0, var3554);	// _0 = BinOp(_0 ADD _3554)
	var3555.lo = var257; var3555.hi = var257 < 0 ? -1 : 0;	// _3555 = Cast(_257 as u128)
	var0 = add128(var0, var3555);	// _0 = BinOp(_0 ADD _3555)
	var3556.lo = var258; var3556.hi = var258 < 0 ? -1 : 0;	// _3556 = Cast(_258 as u128)
	var0 = add128(var0, var3556);	// _0 = BinOp(_0 ADD _3556)
	var3557.lo = var259; var3557.hi = var259 < 0 ? -1 : 0;	// _3557 = Cast(_259 as u128)
	var0 = add128(var0, var3557);	// _0 = BinOp(_0 ADD _3557)
	var3558.lo = var260; var3558.hi = var260 < 0 ? -1 : 0;	// _3558 = Cast(_260 as u128)
	var0 = add128(var0, var3558);	// _0 = BinOp(_0 ADD _3558)
	var3559.lo = var2; var3559.hi = var2 < 0 ? -1 : 0;	// _3559 = Cast(_2 as u128)
	var0 = add128(var0, var3559);	// _0 = BinOp(_0 ADD _3559)
	var3560.lo = var26; var3560.hi = var26 < 0 ? -1 : 0;	// _3560 = Cast(_26 as u128)
	var0 = add128(var0, var3560);	// _0 = BinOp(_0 ADD _3560)
	var3561.lo = var261; var3561.hi = var261 < 0 ? -1 : 0;	// _3561 = Cast(_261 as u128)
	var0 = add128(var0, var3561);	// _0 = BinOp(_0 ADD _3561)
	var3562.lo = var262; var3562.hi = var262 < 0 ? -1 : 0;	// _3562 = Cast(_262 as u128)
	var0 = add128(var0, var3562);	// _0 = BinOp(_0 ADD _3562)
	var3563.lo = var263; var3563.hi = var263 < 0 ? -1 : 0;	// _3563 = Cast(_263 as u128)
	var0 = add128(var0, var3563);	// _0 = BinOp(_0 ADD _3563)
	var3564.lo = var264; var3564.hi = var264 < 0 ? -1 : 0;	// _3564 = Cast(_264 as u128)
	var0 = add128(var0, var3564);	// _0 = BinOp(_0 ADD _3564)
	var3565.lo = var265; var3565.hi = var265 < 0 ? -1 : 0;	// _3565 = Cast(_265 as u128)
	var0 = add128(var0, var3565);	// _0 = BinOp(_0 ADD _3565)
	var3566.lo = var266; var3566.hi = var266 < 0 ? -1 : 0;	// _3566 = Cast(_266 as u128)
	var0 = add128(var0, var3566);	// _0 = BinOp(_0 ADD _3566)
	var3567.lo = var267; var3567.hi = var267 < 0 ? -1 : 0;	// _3567 = Cast(_267 as u128)
	var0 = add128(var0, var3567);	// _0 = BinOp(_0 ADD _3567)
	var3568.lo = var27; var3568.hi = var27 < 0 ? -1 : 0;	// _3568 = Cast(_27 as u128)
	var0 = add128(var0, var3568);	// _0 = BinOp(_0 ADD _3568)
	var3569.lo = var268; var3569.hi = var268 < 0 ? -1 : 0;	// _3569 = Cast(_268 as u128)
	var0 = add128(var0, var3569);	// _0 = BinOp(_0 ADD _3569)
	var7331.lo = var269; var7331.hi = var269 < 0 ? -1 : 0;	// _7331 = Cast(_269 as u128)
	sub128_o(var0, var7331, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7331, ), bb2399, bb399)
	var3570.lo = var270; var3570.hi = var270 < 0 ? -1 : 0;	// _3570 = Cast(_270 as u128)
	var0 = add128(var0, var3570);	// _0 = BinOp(_0 ADD _3570)
	var3571.lo = var271; var3571.hi = var271 < 0 ? -1 : 0;	// _3571 = Cast(_271 as u128)
	var0 = add128(var0, var3571);	// _0 = BinOp(_0 ADD _3571)
	var7332.lo = var272; var7332.hi = var272 < 0 ? -1 : 0;	// _7332 = Cast(_272 as u128)
	sub128_o(var0, var7332, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7332, ), bb2400, bb399)
	var3572.lo = var273; var3572.hi = var273 < 0 ? -1 : 0;	// _3572 = Cast(_273 as u128)
	var0 = add128(var0, var3572);	// _0 = BinOp(_0 ADD _3572)
	var3573.lo = var274; var3573.hi = var274 < 0 ? -1 : 0;	// _3573 = Cast(_274 as u128)
	var0 = add128(var0, var3573);	// _0 = BinOp(_0 ADD _3573)
	var3574.lo = var275; var3574.hi = var275 < 0 ? -1 : 0;	// _3574 = Cast(_275 as u128)
	var0 = add128(var0, var3574);	// _0 = BinOp(_0 ADD _3574)
	var3575.lo = var276; var3575.hi = var276 < 0 ? -1 : 0;	// _3575 = Cast(_276 as u128)
	var0 = add128(var0, var3575);	// _0 = BinOp(_0 ADD _3575)
	var3576.lo = var277; var3576.hi = var277 < 0 ? -1 : 0;	// _3576 = Cast(_277 as u128)
	var0 = add128(var0, var3576);	// _0 = BinOp(_0 ADD _3576)
	var7333.lo = var28.lo; var7333.hi = var28.hi;	// _7333 = Cast(_28 as u128)
	sub128_o(var0, var7333, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7333, ), bb2401, bb399)
	var3577.lo = var278; var3577.hi = var278 < 0 ? -1 : 0;	// _3577 = Cast(_278 as u128)
	var0 = add128(var0, var3577);	// _0 = BinOp(_0 ADD _3577)
	var3578.lo = var279; var3578.hi = var279 < 0 ? -1 : 0;	// _3578 = Cast(_279 as u128)
	var0 = add128(var0, var3578);	// _0 = BinOp(_0 ADD _3578)
	var0 = add128(var0, var280);	// _0 = BinOp(_0 ADD _280)
	var3579.lo = var281; var3579.hi = var281 < 0 ? -1 : 0;	// _3579 = Cast(_281 as u128)
	var0 = add128(var0, var3579);	// _0 = BinOp(_0 ADD _3579)
	var3580.lo = var282; var3580.hi = var282 < 0 ? -1 : 0;	// _3580 = Cast(_282 as u128)
	var0 = add128(var0, var3580);	// _0 = BinOp(_0 ADD _3580)
	var3581.lo = var283; var3581.hi = var283 < 0 ? -1 : 0;	// _3581 = Cast(_283 as u128)
	var0 = add128(var0, var3581);	// _0 = BinOp(_0 ADD _3581)
	var3582.lo = var284; var3582.hi = var284 < 0 ? -1 : 0;	// _3582 = Cast(_284 as u128)
	var0 = add128(var0, var3582);	// _0 = BinOp(_0 ADD _3582)
	var3583.lo = var285; var3583.hi = var285 < 0 ? -1 : 0;	// _3583 = Cast(_285 as u128)
	var0 = add128(var0, var3583);	// _0 = BinOp(_0 ADD _3583)
	var3584.lo = var286; var3584.hi = var286 < 0 ? -1 : 0;	// _3584 = Cast(_286 as u128)
	var0 = add128(var0, var3584);	// _0 = BinOp(_0 ADD _3584)
	var7334.lo = var287; var7334.hi = var287 < 0 ? -1 : 0;	// _7334 = Cast(_287 as u128)
	sub128_o(var0, var7334, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7334, ), bb2402, bb399)
	var3585.lo = var288; var3585.hi = var288 < 0 ? -1 : 0;	// _3585 = Cast(_288 as u128)
	var0 = add128(var0, var3585);	// _0 = BinOp(_0 ADD _3585)
	var3586.lo = var289; var3586.hi = var289 < 0 ? -1 : 0;	// _3586 = Cast(_289 as u128)
	var0 = add128(var0, var3586);	// _0 = BinOp(_0 ADD _3586)
	var3587.lo = var290; var3587.hi = var290 < 0 ? -1 : 0;	// _3587 = Cast(_290 as u128)
	var0 = add128(var0, var3587);	// _0 = BinOp(_0 ADD _3587)
	var7335.lo = var291; var7335.hi = var291 < 0 ? -1 : 0;	// _7335 = Cast(_291 as u128)
	sub128_o(var0, var7335, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7335, ), bb2403, bb399)
	var0 = sub128(var0, var292);	// _0 = BinOp(_0 SUB _292)
	var3588.lo = var293; var3588.hi = var293 < 0 ? -1 : 0;	// _3588 = Cast(_293 as u128)
	var0 = add128(var0, var3588);	// _0 = BinOp(_0 ADD _3588)
	var3589.lo = var294; var3589.hi = var294 < 0 ? -1 : 0;	// _3589 = Cast(_294 as u128)
	var0 = add128(var0, var3589);	// _0 = BinOp(_0 ADD _3589)
	var3590.lo = var295; var3590.hi = var295 < 0 ? -1 : 0;	// _3590 = Cast(_295 as u128)
	var0 = add128(var0, var3590);	// _0 = BinOp(_0 ADD _3590)
	var3591.lo = var29.lo; var3591.hi = var29.hi;	// _3591 = Cast(_29 as u128)
	var0 = add128(var0, var3591);	// _0 = BinOp(_0 ADD _3591)
	var7336.lo = var296; var7336.hi = var296 < 0 ? -1 : 0;	// _7336 = Cast(_296 as u128)
	sub128_o(var0, var7336, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7336, ), bb2404, bb399)
	var3592.lo = var297; var3592.hi = var297 < 0 ? -1 : 0;	// _3592 = Cast(_297 as u128)
	var0 = add128(var0, var3592);	// _0 = BinOp(_0 ADD _3592)
	var3593.lo = var298; var3593.hi = var298 < 0 ? -1 : 0;	// _3593 = Cast(_298 as u128)
	var0 = add128(var0, var3593);	// _0 = BinOp(_0 ADD _3593)
	var3594.lo = var299; var3594.hi = var299 < 0 ? -1 : 0;	// _3594 = Cast(_299 as u128)
	var0 = add128(var0, var3594);	// _0 = BinOp(_0 ADD _3594)
	var3595.lo = var300; var3595.hi = var300 < 0 ? -1 : 0;	// _3595 = Cast(_300 as u128)
	var0 = add128(var0, var3595);	// _0 = BinOp(_0 ADD _3595)
	var3596.lo = var301; var3596.hi = var301 < 0 ? -1 : 0;	// _3596 = Cast(_301 as u128)
	var0 = add128(var0, var3596);	// _0 = BinOp(_0 ADD _3596)
	var3597.lo = var302; var3597.hi = var302 < 0 ? -1 : 0;	// _3597 = Cast(_302 as u128)
	var0 = add128(var0, var3597);	// _0 = BinOp(_0 ADD _3597)
	var3598.lo = var303; var3598.hi = var303 < 0 ? -1 : 0;	// _3598 = Cast(_303 as u128)
	var0 = add128(var0, var3598);	// _0 = BinOp(_0 ADD _3598)
	var3599.lo = var304; var3599.hi = var304 < 0 ? -1 : 0;	// _3599 = Cast(_304 as u128)
	var0 = add128(var0, var3599);	// _0 = BinOp(_0 ADD _3599)
	var3600.lo = var305; var3600.hi = var305 < 0 ? -1 : 0;	// _3600 = Cast(_305 as u128)
	var0 = add128(var0, var3600);	// _0 = BinOp(_0 ADD _3600)
	var7337.lo = var30; var7337.hi = var30 < 0 ? -1 : 0;	// _7337 = Cast(_30 as u128)
	sub128_o(var0, var7337, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7337, ), bb2405, bb399)
	var3601.lo = var306; var3601.hi = var306 < 0 ? -1 : 0;	// _3601 = Cast(_306 as u128)
	var0 = add128(var0, var3601);	// _0 = BinOp(_0 ADD _3601)
	var3602.lo = var307.lo; var3602.hi = var307.hi;	// _3602 = Cast(_307 as u128)
	var0 = sub128(var0, var3602);	// _0 = BinOp(_0 SUB _3602)
	var0 = add128(var0, var308);	// _0 = BinOp(_0 ADD _308)
	var3603.lo = var309; var3603.hi = var309 < 0 ? -1 : 0;	// _3603 = Cast(_309 as u128)
	var0 = add128(var0, var3603);	// _0 = BinOp(_0 ADD _3603)
	var3604.lo = var310; var3604.hi = var310 < 0 ? -1 : 0;	// _3604 = Cast(_310 as u128)
	var0 = add128(var0, var3604);	// _0 = BinOp(_0 ADD _3604)
	var3605.lo = var311; var3605.hi = var311 < 0 ? -1 : 0;	// _3605 = Cast(_311 as u128)
	var0 = add128(var0, var3605);	// _0 = BinOp(_0 ADD _3605)
	var7338.lo = var312; var7338.hi = var312 < 0 ? -1 : 0;	// _7338 = Cast(_312 as u128)
	sub128_o(var0, var7338, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7338, ), bb2406, bb399)
	var3606.lo = var313.lo; var3606.hi = var313.hi;	// _3606 = Cast(_313 as u128)
	var0 = add128(var0, var3606);	// _0 = BinOp(_0 ADD _3606)
	var3607.lo = var314; var3607.hi = var314 < 0 ? -1 : 0;	// _3607 = Cast(_314 as u128)
	var0 = add128(var0, var3607);	// _0 = BinOp(_0 ADD _3607)
	var7339.lo = var315; var7339.hi = var315 < 0 ? -1 : 0;	// _7339 = Cast(_315 as u128)
	sub128_o(var0, var7339, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7339, ), bb2407, bb399)
	var3608.lo = var316; var3608.hi = var316 < 0 ? -1 : 0;	// _3608 = Cast(_316 as u128)
	var0 = add128(var0, var3608);	// _0 = BinOp(_0 ADD _3608)
	var3609.lo = var317; var3609.hi = var317 < 0 ? -1 : 0;	// _3609 = Cast(_317 as u128)
	var0 = add128(var0, var3609);	// _0 = BinOp(_0 ADD _3609)
	var7340.lo = var318; var7340.hi = var318 < 0 ? -1 : 0;	// _7340 = Cast(_318 as u128)
	sub128_o(var0, var7340, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7340, ), bb2408, bb399)
	var7341.lo = var319; var7341.hi = var319 < 0 ? -1 : 0;	// _7341 = Cast(_319 as u128)
	sub128_o(var0, var7341, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7341, ), bb2409, bb399)
	var7342.lo = var320; var7342.hi = var320 < 0 ? -1 : 0;	// _7342 = Cast(_320 as u128)
	sub128_o(var0, var7342, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7342, ), bb2410, bb399)
	var3610.lo = var321; var3610.hi = var321 < 0 ? -1 : 0;	// _3610 = Cast(_321 as u128)
	var0 = add128(var0, var3610);	// _0 = BinOp(_0 ADD _3610)
	var3611.lo = var322; var3611.hi = var322 < 0 ? -1 : 0;	// _3611 = Cast(_322 as u128)
	var0 = add128(var0, var3611);	// _0 = BinOp(_0 ADD _3611)
	var3612.lo = var323; var3612.hi = var323 < 0 ? -1 : 0;	// _3612 = Cast(_323 as u128)
	var0 = add128(var0, var3612);	// _0 = BinOp(_0 ADD _3612)
	var3613.lo = var31; var3613.hi = var31 < 0 ? -1 : 0;	// _3613 = Cast(_31 as u128)
	var0 = add128(var0, var3613);	// _0 = BinOp(_0 ADD _3613)
	var0 = add128(var0, var324);	// _0 = BinOp(_0 ADD _324)
	var3614.lo = var325; var3614.hi = var325 < 0 ? -1 : 0;	// _3614 = Cast(_325 as u128)
	var0 = add128(var0, var3614);	// _0 = BinOp(_0 ADD _3614)
	var7343.lo = var326; var7343.hi = var326 < 0 ? -1 : 0;	// _7343 = Cast(_326 as u128)
	sub128_o(var0, var7343, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7343, ), bb2411, bb399)
	var3615.lo = var327; var3615.hi = var327 < 0 ? -1 : 0;	// _3615 = Cast(_327 as u128)
	var0 = add128(var0, var3615);	// _0 = BinOp(_0 ADD _3615)
	var3616.lo = var328; var3616.hi = var328 < 0 ? -1 : 0;	// _3616 = Cast(_328 as u128)
	var0 = add128(var0, var3616);	// _0 = BinOp(_0 ADD _3616)
	var7344.lo = var329; var7344.hi = var329 < 0 ? -1 : 0;	// _7344 = Cast(_329 as u128)
	sub128_o(var0, var7344, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7344, ), bb2412, bb399)
	var3617.lo = var330; var3617.hi = var330 < 0 ? -1 : 0;	// _3617 = Cast(_330 as u128)
	var0 = add128(var0, var3617);	// _0 = BinOp(_0 ADD _3617)
	var3618.lo = var331; var3618.hi = var331 < 0 ? -1 : 0;	// _3618 = Cast(_331 as u128)
	var0 = add128(var0, var3618);	// _0 = BinOp(_0 ADD _3618)
	var3619.lo = var332; var3619.hi = var332 < 0 ? -1 : 0;	// _3619 = Cast(_332 as u128)
	var0 = add128(var0, var3619);	// _0 = BinOp(_0 ADD _3619)
	var3620.lo = var32; var3620.hi = var32 < 0 ? -1 : 0;	// _3620 = Cast(_32 as u128)
	var0 = add128(var0, var3620);	// _0 = BinOp(_0 ADD _3620)
	var3621.lo = var333; var3621.hi = var333 < 0 ? -1 : 0;	// _3621 = Cast(_333 as u128)
	var0 = add128(var0, var3621);	// _0 = BinOp(_0 ADD _3621)
	var3622.lo = var334; var3622.hi = var334 < 0 ? -1 : 0;	// _3622 = Cast(_334 as u128)
	var0 = add128(var0, var3622);	// _0 = BinOp(_0 ADD _3622)
	var3623.lo = var335; var3623.hi = var335 < 0 ? -1 : 0;	// _3623 = Cast(_335 as u128)
	var0 = add128(var0, var3623);	// _0 = BinOp(_0 ADD _3623)
	var3624.lo = var336; var3624.hi = var336 < 0 ? -1 : 0;	// _3624 = Cast(_336 as u128)
	var0 = add128(var0, var3624);	// _0 = BinOp(_0 ADD _3624)
	var3625.lo = var337; var3625.hi = var337 < 0 ? -1 : 0;	// _3625 = Cast(_337 as u128)
	var0 = add128(var0, var3625);	// _0 = BinOp(_0 ADD _3625)
	var3626.lo = var338; var3626.hi = var338 < 0 ? -1 : 0;	// _3626 = Cast(_338 as u128)
	var0 = add128(var0, var3626);	// _0 = BinOp(_0 ADD _3626)
	var0 = add128(var0, var339);	// _0 = BinOp(_0 ADD _339)
	var3627.lo = var340; var3627.hi = var340 < 0 ? -1 : 0;	// _3627 = Cast(_340 as u128)
	var0 = add128(var0, var3627);	// _0 = BinOp(_0 ADD _3627)
	var3628.lo = var341; var3628.hi = var341 < 0 ? -1 : 0;	// _3628 = Cast(_341 as u128)
	var0 = add128(var0, var3628);	// _0 = BinOp(_0 ADD _3628)
	var3629.lo = var342; var3629.hi = var342 < 0 ? -1 : 0;	// _3629 = Cast(_342 as u128)
	var0 = add128(var0, var3629);	// _0 = BinOp(_0 ADD _3629)
	var3630.lo = var33; var3630.hi = var33 < 0 ? -1 : 0;	// _3630 = Cast(_33 as u128)
	var0 = add128(var0, var3630);	// _0 = BinOp(_0 ADD _3630)
	var3631.lo = var343; var3631.hi = var343 < 0 ? -1 : 0;	// _3631 = Cast(_343 as u128)
	var0 = add128(var0, var3631);	// _0 = BinOp(_0 ADD _3631)
	var3632.lo = var344; var3632.hi = var344 < 0 ? -1 : 0;	// _3632 = Cast(_344 as u128)
	var0 = add128(var0, var3632);	// _0 = BinOp(_0 ADD _3632)
	var3633.lo = var345; var3633.hi = var345 < 0 ? -1 : 0;	// _3633 = Cast(_345 as u128)
	var0 = add128(var0, var3633);	// _0 = BinOp(_0 ADD _3633)
	var3634.lo = var346; var3634.hi = var346 < 0 ? -1 : 0;	// _3634 = Cast(_346 as u128)
	var0 = add128(var0, var3634);	// _0 = BinOp(_0 ADD _3634)
	var3635.lo = var347; var3635.hi = var347 < 0 ? -1 : 0;	// _3635 = Cast(_347 as u128)
	var0 = add128(var0, var3635);	// _0 = BinOp(_0 ADD _3635)
	var3636.lo = var348; var3636.hi = var348 < 0 ? -1 : 0;	// _3636 = Cast(_348 as u128)
	var0 = add128(var0, var3636);	// _0 = BinOp(_0 ADD _3636)
	var3637.lo = var349; var3637.hi = var349 < 0 ? -1 : 0;	// _3637 = Cast(_349 as u128)
	var0 = add128(var0, var3637);	// _0 = BinOp(_0 ADD _3637)
	var3638.lo = var350; var3638.hi = var350 < 0 ? -1 : 0;	// _3638 = Cast(_350 as u128)
	var0 = add128(var0, var3638);	// _0 = BinOp(_0 ADD _3638)
	var3639.lo = var351; var3639.hi = var351 < 0 ? -1 : 0;	// _3639 = Cast(_351 as u128)
	var0 = add128(var0, var3639);	// _0 = BinOp(_0 ADD _3639)
	var3640.lo = var34; var3640.hi = var34 < 0 ? -1 : 0;	// _3640 = Cast(_34 as u128)
	var0 = add128(var0, var3640);	// _0 = BinOp(_0 ADD _3640)
	var3641.lo = var352; var3641.hi = var352 < 0 ? -1 : 0;	// _3641 = Cast(_352 as u128)
	var0 = add128(var0, var3641);	// _0 = BinOp(_0 ADD _3641)
	var3642.lo = var353; var3642.hi = var353 < 0 ? -1 : 0;	// _3642 = Cast(_353 as u128)
	var0 = add128(var0, var3642);	// _0 = BinOp(_0 ADD _3642)
	var3643.lo = var354; var3643.hi = var354 < 0 ? -1 : 0;	// _3643 = Cast(_354 as u128)
	var0 = add128(var0, var3643);	// _0 = BinOp(_0 ADD _3643)
	var3644.lo = var355; var3644.hi = var355 < 0 ? -1 : 0;	// _3644 = Cast(_355 as u128)
	var0 = add128(var0, var3644);	// _0 = BinOp(_0 ADD _3644)
	var7345.lo = var356; var7345.hi = var356 < 0 ? -1 : 0;	// _7345 = Cast(_356 as u128)
	sub128_o(var0, var7345, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7345, ), bb2413, bb399)
	var3645.lo = var357; var3645.hi = var357 < 0 ? -1 : 0;	// _3645 = Cast(_357 as u128)
	var0 = add128(var0, var3645);	// _0 = BinOp(_0 ADD _3645)
	var0 = add128(var0, var359);	// _0 = BinOp(_0 ADD _359)
	var0 = add128(var0, var360);	// _0 = BinOp(_0 ADD _360)
	var3646.lo = var35.lo; var3646.hi = var35.hi;	// _3646 = Cast(_35 as u128)
	var0 = add128(var0, var3646);	// _0 = BinOp(_0 ADD _3646)
	var7346.lo = var361.lo; var7346.hi = var361.hi;	// _7346 = Cast(_361 as u128)
	sub128_o(var0, var7346, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7346, ), bb2414, bb399)
	var3647.lo = var362; var3647.hi = var362 < 0 ? -1 : 0;	// _3647 = Cast(_362 as u128)
	var0 = add128(var0, var3647);	// _0 = BinOp(_0 ADD _3647)
	var3648.lo = var363; var3648.hi = var363 < 0 ? -1 : 0;	// _3648 = Cast(_363 as u128)
	var0 = add128(var0, var3648);	// _0 = BinOp(_0 ADD _3648)
	var3649.lo = var364; var3649.hi = var364 < 0 ? -1 : 0;	// _3649 = Cast(_364 as u128)
	var0 = add128(var0, var3649);	// _0 = BinOp(_0 ADD _3649)
	var3650.lo = var365; var3650.hi = var365 < 0 ? -1 : 0;	// _3650 = Cast(_365 as u128)
	var0 = add128(var0, var3650);	// _0 = BinOp(_0 ADD _3650)
	var3651.lo = var366; var3651.hi = var366 < 0 ? -1 : 0;	// _3651 = Cast(_366 as u128)
	var0 = add128(var0, var3651);	// _0 = BinOp(_0 ADD _3651)
	var7347.lo = var367; var7347.hi = var367 < 0 ? -1 : 0;	// _7347 = Cast(_367 as u128)
	sub128_o(var0, var7347, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7347, ), bb2415, bb399)
	var3652.lo = var368; var3652.hi = var368 < 0 ? -1 : 0;	// _3652 = Cast(_368 as u128)
	var0 = add128(var0, var3652);	// _0 = BinOp(_0 ADD _3652)
	var3653.lo = var369; var3653.hi = var369 < 0 ? -1 : 0;	// _3653 = Cast(_369 as u128)
	var0 = add128(var0, var3653);	// _0 = BinOp(_0 ADD _3653)
	var3654.lo = var370; var3654.hi = var370 < 0 ? -1 : 0;	// _3654 = Cast(_370 as u128)
	var0 = add128(var0, var3654);	// _0 = BinOp(_0 ADD _3654)
	var3655.lo = var36; var3655.hi = var36 < 0 ? -1 : 0;	// _3655 = Cast(_36 as u128)
	var0 = add128(var0, var3655);	// _0 = BinOp(_0 ADD _3655)
	var3656.lo = var371; var3656.hi = var371 < 0 ? -1 : 0;	// _3656 = Cast(_371 as u128)
	var0 = add128(var0, var3656);	// _0 = BinOp(_0 ADD _3656)
	var3657.lo = var372; var3657.hi = var372 < 0 ? -1 : 0;	// _3657 = Cast(_372 as u128)
	var0 = add128(var0, var3657);	// _0 = BinOp(_0 ADD _3657)
	var7348.lo = var373; var7348.hi = var373 < 0 ? -1 : 0;	// _7348 = Cast(_373 as u128)
	sub128_o(var0, var7348, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7348, ), bb2416, bb399)
	var3658.lo = var374; var3658.hi = var374 < 0 ? -1 : 0;	// _3658 = Cast(_374 as u128)
	var0 = add128(var0, var3658);	// _0 = BinOp(_0 ADD _3658)
	var3659.lo = var375; var3659.hi = var375 < 0 ? -1 : 0;	// _3659 = Cast(_375 as u128)
	var0 = add128(var0, var3659);	// _0 = BinOp(_0 ADD _3659)
	var0 = add128(var0, var376);	// _0 = BinOp(_0 ADD _376)
	var3660.lo = var377; var3660.hi = var377 < 0 ? -1 : 0;	// _3660 = Cast(_377 as u128)
	var0 = add128(var0, var3660);	// _0 = BinOp(_0 ADD _3660)
	var3661.lo = var378; var3661.hi = var378 < 0 ? -1 : 0;	// _3661 = Cast(_378 as u128)
	var0 = add128(var0, var3661);	// _0 = BinOp(_0 ADD _3661)
	var3662.lo = var379; var3662.hi = var379 < 0 ? -1 : 0;	// _3662 = Cast(_379 as u128)
	var0 = add128(var0, var3662);	// _0 = BinOp(_0 ADD _3662)
	var3663.lo = var380; var3663.hi = var380 < 0 ? -1 : 0;	// _3663 = Cast(_380 as u128)
	var0 = add128(var0, var3663);	// _0 = BinOp(_0 ADD _3663)
	var7349.lo = var381; var7349.hi = var381 < 0 ? -1 : 0;	// _7349 = Cast(_381 as u128)
	sub128_o(var0, var7349, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7349, ), bb2417, bb399)
	var3664.lo = var382; var3664.hi = var382 < 0 ? -1 : 0;	// _3664 = Cast(_382 as u128)
	var0 = add128(var0, var3664);	// _0 = BinOp(_0 ADD _3664)
	var3665.lo = var383; var3665.hi = var383 < 0 ? -1 : 0;	// _3665 = Cast(_383 as u128)
	var0 = add128(var0, var3665);	// _0 = BinOp(_0 ADD _3665)
	var3666.lo = var384; var3666.hi = var384 < 0 ? -1 : 0;	// _3666 = Cast(_384 as u128)
	var0 = add128(var0, var3666);	// _0 = BinOp(_0 ADD _3666)
	var3667.lo = var385; var3667.hi = var385 < 0 ? -1 : 0;	// _3667 = Cast(_385 as u128)
	var0 = add128(var0, var3667);	// _0 = BinOp(_0 ADD _3667)
	var3668.lo = var386; var3668.hi = var386 < 0 ? -1 : 0;	// _3668 = Cast(_386 as u128)
	var0 = add128(var0, var3668);	// _0 = BinOp(_0 ADD _3668)
	var0 = add128(var0, var387);	// _0 = BinOp(_0 ADD _387)
	var0 = add128(var0, var388);	// _0 = BinOp(_0 ADD _388)
	var0 = sub128(var0, var389);	// _0 = BinOp(_0 SUB _389)
	var3669.lo = var390; var3669.hi = var390 < 0 ? -1 : 0;	// _3669 = Cast(_390 as u128)
	var0 = add128(var0, var3669);	// _0 = BinOp(_0 ADD _3669)
	var3670.lo = var37; var3670.hi = var37 < 0 ? -1 : 0;	// _3670 = Cast(_37 as u128)
	var0 = add128(var0, var3670);	// _0 = BinOp(_0 ADD _3670)
	var3671.lo = var391; var3671.hi = var391 < 0 ? -1 : 0;	// _3671 = Cast(_391 as u128)
	var0 = add128(var0, var3671);	// _0 = BinOp(_0 ADD _3671)
	var3672.lo = var393; var3672.hi = var393 < 0 ? -1 : 0;	// _3672 = Cast(_393 as u128)
	var0 = add128(var0, var3672);	// _0 = BinOp(_0 ADD _3672)
	var3673.lo = var394; var3673.hi = var394 < 0 ? -1 : 0;	// _3673 = Cast(_394 as u128)
	var0 = add128(var0, var3673);	// _0 = BinOp(_0 ADD _3673)
	var3674.lo = var395; var3674.hi = var395 < 0 ? -1 : 0;	// _3674 = Cast(_395 as u128)
	var0 = add128(var0, var3674);	// _0 = BinOp(_0 ADD _3674)
	var3675.lo = var396; var3675.hi = var396 < 0 ? -1 : 0;	// _3675 = Cast(_396 as u128)
	var0 = add128(var0, var3675);	// _0 = BinOp(_0 ADD _3675)
	var3676.lo = var397; var3676.hi = var397 < 0 ? -1 : 0;	// _3676 = Cast(_397 as u128)
	var0 = add128(var0, var3676);	// _0 = BinOp(_0 ADD _3676)
	var3677.lo = var398; var3677.hi = var398 < 0 ? -1 : 0;	// _3677 = Cast(_398 as u128)
	var0 = add128(var0, var3677);	// _0 = BinOp(_0 ADD _3677)
	var3678.lo = var399; var3678.hi = var399 < 0 ? -1 : 0;	// _3678 = Cast(_399 as u128)
	var0 = add128(var0, var3678);	// _0 = BinOp(_0 ADD _3678)
	var3679.lo = var400; var3679.hi = var400 < 0 ? -1 : 0;	// _3679 = Cast(_400 as u128)
	var0 = add128(var0, var3679);	// _0 = BinOp(_0 ADD _3679)
	var3680.lo = var38; var3680.hi = var38 < 0 ? -1 : 0;	// _3680 = Cast(_38 as u128)
	var0 = add128(var0, var3680);	// _0 = BinOp(_0 ADD _3680)
	sub128_o(var0, var401, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _401, ), bb2418, bb399)
	var3681.lo = var402; var3681.hi = var402 < 0 ? -1 : 0;	// _3681 = Cast(_402 as u128)
	var0 = add128(var0, var3681);	// _0 = BinOp(_0 ADD _3681)
	var3682.lo = var403; var3682.hi = var403 < 0 ? -1 : 0;	// _3682 = Cast(_403 as u128)
	var0 = add128(var0, var3682);	// _0 = BinOp(_0 ADD _3682)
	var0 = add128(var0, var404);	// _0 = BinOp(_0 ADD _404)
	var7350.lo = var405; var7350.hi = var405 < 0 ? -1 : 0;	// _7350 = Cast(_405 as u128)
	sub128_o(var0, var7350, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7350, ), bb2419, bb399)
	var3683.lo = var406; var3683.hi = var406 < 0 ? -1 : 0;	// _3683 = Cast(_406 as u128)
	var0 = add128(var0, var3683);	// _0 = BinOp(_0 ADD _3683)
	var7351.lo = var407; var7351.hi = var407 < 0 ? -1 : 0;	// _7351 = Cast(_407 as u128)
	sub128_o(var0, var7351, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7351, ), bb2420, bb399)
	var0 = sub128(var0, var408);	// _0 = BinOp(_0 SUB _408)
	var3684.lo = var409; var3684.hi = var409 < 0 ? -1 : 0;	// _3684 = Cast(_409 as u128)
	var0 = add128(var0, var3684);	// _0 = BinOp(_0 ADD _3684)
	var3685.lo = var39; var3685.hi = var39 < 0 ? -1 : 0;	// _3685 = Cast(_39 as u128)
	var0 = add128(var0, var3685);	// _0 = BinOp(_0 ADD _3685)
	var3686.lo = var410; var3686.hi = var410 < 0 ? -1 : 0;	// _3686 = Cast(_410 as u128)
	var0 = add128(var0, var3686);	// _0 = BinOp(_0 ADD _3686)
	var3687.lo = var411; var3687.hi = var411 < 0 ? -1 : 0;	// _3687 = Cast(_411 as u128)
	var0 = add128(var0, var3687);	// _0 = BinOp(_0 ADD _3687)
	var7352.lo = var412; var7352.hi = var412 < 0 ? -1 : 0;	// _7352 = Cast(_412 as u128)
	sub128_o(var0, var7352, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7352, ), bb2421, bb399)
	var3688.lo = var413; var3688.hi = var413 < 0 ? -1 : 0;	// _3688 = Cast(_413 as u128)
	var0 = add128(var0, var3688);	// _0 = BinOp(_0 ADD _3688)
	var3689.lo = var414; var3689.hi = var414 < 0 ? -1 : 0;	// _3689 = Cast(_414 as u128)
	var0 = add128(var0, var3689);	// _0 = BinOp(_0 ADD _3689)
	var3690.lo = var415; var3690.hi = var415 < 0 ? -1 : 0;	// _3690 = Cast(_415 as u128)
	var0 = add128(var0, var3690);	// _0 = BinOp(_0 ADD _3690)
	var7353.lo = var416; var7353.hi = var416 < 0 ? -1 : 0;	// _7353 = Cast(_416 as u128)
	sub128_o(var0, var7353, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7353, ), bb2422, bb399)
	var3691.lo = var417; var3691.hi = var417 < 0 ? -1 : 0;	// _3691 = Cast(_417 as u128)
	var0 = add128(var0, var3691);	// _0 = BinOp(_0 ADD _3691)
	var3692.lo = var418; var3692.hi = var418 < 0 ? -1 : 0;	// _3692 = Cast(_418 as u128)
	var0 = add128(var0, var3692);	// _0 = BinOp(_0 ADD _3692)
	var3693.lo = var419; var3693.hi = var419 < 0 ? -1 : 0;	// _3693 = Cast(_419 as u128)
	var0 = add128(var0, var3693);	// _0 = BinOp(_0 ADD _3693)
	var3694.lo = var420; var3694.hi = var420 < 0 ? -1 : 0;	// _3694 = Cast(_420 as u128)
	var0 = add128(var0, var3694);	// _0 = BinOp(_0 ADD _3694)
	var3695.lo = var421; var3695.hi = var421 < 0 ? -1 : 0;	// _3695 = Cast(_421 as u128)
	var0 = add128(var0, var3695);	// _0 = BinOp(_0 ADD _3695)
	var3696.lo = var422; var3696.hi = var422 < 0 ? -1 : 0;	// _3696 = Cast(_422 as u128)
	var0 = add128(var0, var3696);	// _0 = BinOp(_0 ADD _3696)
	var3697.lo = var423; var3697.hi = var423 < 0 ? -1 : 0;	// _3697 = Cast(_423 as u128)
	var0 = add128(var0, var3697);	// _0 = BinOp(_0 ADD _3697)
	var3698.lo = var424; var3698.hi = var424 < 0 ? -1 : 0;	// _3698 = Cast(_424 as u128)
	var0 = add128(var0, var3698);	// _0 = BinOp(_0 ADD _3698)
	var3699.lo = var425; var3699.hi = var425 < 0 ? -1 : 0;	// _3699 = Cast(_425 as u128)
	var0 = add128(var0, var3699);	// _0 = BinOp(_0 ADD _3699)
	var7354.lo = var426; var7354.hi = var426 < 0 ? -1 : 0;	// _7354 = Cast(_426 as u128)
	sub128_o(var0, var7354, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7354, ), bb2423, bb399)
	var3700.lo = var40; var3700.hi = var40 < 0 ? -1 : 0;	// _3700 = Cast(_40 as u128)
	var0 = add128(var0, var3700);	// _0 = BinOp(_0 ADD _3700)
	var0 = add128(var0, var427);	// _0 = BinOp(_0 ADD _427)
	var3701.lo = var428; var3701.hi = var428 < 0 ? -1 : 0;	// _3701 = Cast(_428 as u128)
	var0 = add128(var0, var3701);	// _0 = BinOp(_0 ADD _3701)
	var3702.lo = var429; var3702.hi = var429 < 0 ? -1 : 0;	// _3702 = Cast(_429 as u128)
	var0 = add128(var0, var3702);	// _0 = BinOp(_0 ADD _3702)
	var3703.lo = var430; var3703.hi = var430 < 0 ? -1 : 0;	// _3703 = Cast(_430 as u128)
	var0 = add128(var0, var3703);	// _0 = BinOp(_0 ADD _3703)
	var3704.lo = var431; var3704.hi = var431 < 0 ? -1 : 0;	// _3704 = Cast(_431 as u128)
	var0 = add128(var0, var3704);	// _0 = BinOp(_0 ADD _3704)
	var3705.lo = var432; var3705.hi = var432 < 0 ? -1 : 0;	// _3705 = Cast(_432 as u128)
	var0 = add128(var0, var3705);	// _0 = BinOp(_0 ADD _3705)
	var3706.lo = var433; var3706.hi = var433 < 0 ? -1 : 0;	// _3706 = Cast(_433 as u128)
	var0 = add128(var0, var3706);	// _0 = BinOp(_0 ADD _3706)
	var3707.lo = var434; var3707.hi = var434 < 0 ? -1 : 0;	// _3707 = Cast(_434 as u128)
	var0 = add128(var0, var3707);	// _0 = BinOp(_0 ADD _3707)
	var7355.lo = var435; var7355.hi = var435 < 0 ? -1 : 0;	// _7355 = Cast(_435 as u128)
	sub128_o(var0, var7355, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7355, ), bb2424, bb399)
	var3708.lo = var41; var3708.hi = var41 < 0 ? -1 : 0;	// _3708 = Cast(_41 as u128)
	var0 = add128(var0, var3708);	// _0 = BinOp(_0 ADD _3708)
	var3709.lo = var436; var3709.hi = var436 < 0 ? -1 : 0;	// _3709 = Cast(_436 as u128)
	var0 = add128(var0, var3709);	// _0 = BinOp(_0 ADD _3709)
	var3710.lo = var437; var3710.hi = var437 < 0 ? -1 : 0;	// _3710 = Cast(_437 as u128)
	var0 = add128(var0, var3710);	// _0 = BinOp(_0 ADD _3710)
	var7356.lo = var438; var7356.hi = var438 < 0 ? -1 : 0;	// _7356 = Cast(_438 as u128)
	sub128_o(var0, var7356, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7356, ), bb2425, bb399)
	var3711.lo = var439; var3711.hi = var439 < 0 ? -1 : 0;	// _3711 = Cast(_439 as u128)
	var0 = add128(var0, var3711);	// _0 = BinOp(_0 ADD _3711)
	var3712.lo = var440; var3712.hi = var440 < 0 ? -1 : 0;	// _3712 = Cast(_440 as u128)
	var0 = add128(var0, var3712);	// _0 = BinOp(_0 ADD _3712)
	var3713.lo = var441; var3713.hi = var441 < 0 ? -1 : 0;	// _3713 = Cast(_441 as u128)
	var0 = add128(var0, var3713);	// _0 = BinOp(_0 ADD _3713)
	var7357.lo = var442; var7357.hi = var442 < 0 ? -1 : 0;	// _7357 = Cast(_442 as u128)
	sub128_o(var0, var7357, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7357, ), bb2426, bb399)
	var3714.lo = var443; var3714.hi = var443 < 0 ? -1 : 0;	// _3714 = Cast(_443 as u128)
	var0 = add128(var0, var3714);	// _0 = BinOp(_0 ADD _3714)
	var3715.lo = var444; var3715.hi = var444 < 0 ? -1 : 0;	// _3715 = Cast(_444 as u128)
	var0 = add128(var0, var3715);	// _0 = BinOp(_0 ADD _3715)
	var3716.lo = var445; var3716.hi = var445 < 0 ? -1 : 0;	// _3716 = Cast(_445 as u128)
	var0 = add128(var0, var3716);	// _0 = BinOp(_0 ADD _3716)
	var0 = add128(var0, var3);	// _0 = BinOp(_0 ADD _3)
	var3717.lo = var42; var3717.hi = var42 < 0 ? -1 : 0;	// _3717 = Cast(_42 as u128)
	var0 = add128(var0, var3717);	// _0 = BinOp(_0 ADD _3717)
	var3718.lo = var446; var3718.hi = var446 < 0 ? -1 : 0;	// _3718 = Cast(_446 as u128)
	var0 = add128(var0, var3718);	// _0 = BinOp(_0 ADD _3718)
	var3719.lo = var447.lo; var3719.hi = var447.hi;	// _3719 = Cast(_447 as u128)
	var0 = add128(var0, var3719);	// _0 = BinOp(_0 ADD _3719)
	var3720.lo = var448; var3720.hi = var448 < 0 ? -1 : 0;	// _3720 = Cast(_448 as u128)
	var0 = add128(var0, var3720);	// _0 = BinOp(_0 ADD _3720)
	var3721.lo = var449; var3721.hi = var449 < 0 ? -1 : 0;	// _3721 = Cast(_449 as u128)
	var0 = add128(var0, var3721);	// _0 = BinOp(_0 ADD _3721)
	var3722.lo = var451; var3722.hi = var451 < 0 ? -1 : 0;	// _3722 = Cast(_451 as u128)
	var0 = add128(var0, var3722);	// _0 = BinOp(_0 ADD _3722)
	var0 = add128(var0, var452);	// _0 = BinOp(_0 ADD _452)
	var3723.lo = var453; var3723.hi = var453 < 0 ? -1 : 0;	// _3723 = Cast(_453 as u128)
	var0 = add128(var0, var3723);	// _0 = BinOp(_0 ADD _3723)
	var7358.lo = var454; var7358.hi = var454 < 0 ? -1 : 0;	// _7358 = Cast(_454 as u128)
	sub128_o(var0, var7358, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7358, ), bb2427, bb399)
	var3724.lo = var455; var3724.hi = var455 < 0 ? -1 : 0;	// _3724 = Cast(_455 as u128)
	var0 = add128(var0, var3724);	// _0 = BinOp(_0 ADD _3724)
	var3725.lo = var43; var3725.hi = var43 < 0 ? -1 : 0;	// _3725 = Cast(_43 as u128)
	var0 = add128(var0, var3725);	// _0 = BinOp(_0 ADD _3725)
	var3726.lo = var456; var3726.hi = var456 < 0 ? -1 : 0;	// _3726 = Cast(_456 as u128)
	var0 = add128(var0, var3726);	// _0 = BinOp(_0 ADD _3726)
	var3727.lo = var457; var3727.hi = var457 < 0 ? -1 : 0;	// _3727 = Cast(_457 as u128)
	var0 = add128(var0, var3727);	// _0 = BinOp(_0 ADD _3727)
	var3728.lo = var458; var3728.hi = var458 < 0 ? -1 : 0;	// _3728 = Cast(_458 as u128)
	var0 = add128(var0, var3728);	// _0 = BinOp(_0 ADD _3728)
	var3729.lo = var459; var3729.hi = var459 < 0 ? -1 : 0;	// _3729 = Cast(_459 as u128)
	var0 = add128(var0, var3729);	// _0 = BinOp(_0 ADD _3729)
	var3730.lo = var461; var3730.hi = var461 < 0 ? -1 : 0;	// _3730 = Cast(_461 as u128)
	var0 = add128(var0, var3730);	// _0 = BinOp(_0 ADD _3730)
	var3731.lo = var462; var3731.hi = var462 < 0 ? -1 : 0;	// _3731 = Cast(_462 as u128)
	var0 = add128(var0, var3731);	// _0 = BinOp(_0 ADD _3731)
	var3732.lo = var463; var3732.hi = var463 < 0 ? -1 : 0;	// _3732 = Cast(_463 as u128)
	var0 = add128(var0, var3732);	// _0 = BinOp(_0 ADD _3732)
	var7359.lo = var464; var7359.hi = var464 < 0 ? -1 : 0;	// _7359 = Cast(_464 as u128)
	sub128_o(var0, var7359, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7359, ), bb2428, bb399)
	var3733.lo = var44; var3733.hi = var44 < 0 ? -1 : 0;	// _3733 = Cast(_44 as u128)
	var0 = add128(var0, var3733);	// _0 = BinOp(_0 ADD _3733)
	var3734.lo = var465; var3734.hi = var465 < 0 ? -1 : 0;	// _3734 = Cast(_465 as u128)
	var0 = add128(var0, var3734);	// _0 = BinOp(_0 ADD _3734)
	var3735.lo = var466; var3735.hi = var466 < 0 ? -1 : 0;	// _3735 = Cast(_466 as u128)
	var0 = add128(var0, var3735);	// _0 = BinOp(_0 ADD _3735)
	var3736.lo = var467; var3736.hi = var467 < 0 ? -1 : 0;	// _3736 = Cast(_467 as u128)
	var0 = add128(var0, var3736);	// _0 = BinOp(_0 ADD _3736)
	var7360.lo = var468; var7360.hi = var468 < 0 ? -1 : 0;	// _7360 = Cast(_468 as u128)
	sub128_o(var0, var7360, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7360, ), bb2429, bb399)
	var3737.lo = var469; var3737.hi = var469 < 0 ? -1 : 0;	// _3737 = Cast(_469 as u128)
	var0 = add128(var0, var3737);	// _0 = BinOp(_0 ADD _3737)
	var3738.lo = var470; var3738.hi = var470 < 0 ? -1 : 0;	// _3738 = Cast(_470 as u128)
	var0 = add128(var0, var3738);	// _0 = BinOp(_0 ADD _3738)
	var3739.lo = var471; var3739.hi = var471 < 0 ? -1 : 0;	// _3739 = Cast(_471 as u128)
	var0 = add128(var0, var3739);	// _0 = BinOp(_0 ADD _3739)
	var3740.lo = var472; var3740.hi = var472 < 0 ? -1 : 0;	// _3740 = Cast(_472 as u128)
	var0 = add128(var0, var3740);	// _0 = BinOp(_0 ADD _3740)
	var3741.lo = var473.lo; var3741.hi = var473.hi;	// _3741 = Cast(_473 as u128)
	var0 = add128(var0, var3741);	// _0 = BinOp(_0 ADD _3741)
	var7361.lo = var474.lo; var7361.hi = var474.hi;	// _7361 = Cast(_474 as u128)
	sub128_o(var0, var7361, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7361, ), bb2430, bb399)
	var3742.lo = var45; var3742.hi = var45 < 0 ? -1 : 0;	// _3742 = Cast(_45 as u128)
	var0 = add128(var0, var3742);	// _0 = BinOp(_0 ADD _3742)
	var3743.lo = var475; var3743.hi = var475 < 0 ? -1 : 0;	// _3743 = Cast(_475 as u128)
	var0 = add128(var0, var3743);	// _0 = BinOp(_0 ADD _3743)
	var0 = add128(var0, var476);	// _0 = BinOp(_0 ADD _476)
	var3744.lo = var477; var3744.hi = var477 < 0 ? -1 : 0;	// _3744 = Cast(_477 as u128)
	var0 = add128(var0, var3744);	// _0 = BinOp(_0 ADD _3744)
	var3745.lo = var478; var3745.hi = var478 < 0 ? -1 : 0;	// _3745 = Cast(_478 as u128)
	var0 = add128(var0, var3745);	// _0 = BinOp(_0 ADD _3745)
	var7362.lo = var479; var7362.hi = var479 < 0 ? -1 : 0;	// _7362 = Cast(_479 as u128)
	sub128_o(var0, var7362, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7362, ), bb2431, bb399)
	var7363.lo = var480; var7363.hi = var480 < 0 ? -1 : 0;	// _7363 = Cast(_480 as u128)
	sub128_o(var0, var7363, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7363, ), bb2432, bb399)
	var3746.lo = var481; var3746.hi = var481 < 0 ? -1 : 0;	// _3746 = Cast(_481 as u128)
	var0 = add128(var0, var3746);	// _0 = BinOp(_0 ADD _3746)
	var3747.lo = var482; var3747.hi = var482 < 0 ? -1 : 0;	// _3747 = Cast(_482 as u128)
	var0 = add128(var0, var3747);	// _0 = BinOp(_0 ADD _3747)
	var3748.lo = var483; var3748.hi = var483 < 0 ? -1 : 0;	// _3748 = Cast(_483 as u128)
	var0 = add128(var0, var3748);	// _0 = BinOp(_0 ADD _3748)
	var3749.lo = var46; var3749.hi = var46 < 0 ? -1 : 0;	// _3749 = Cast(_46 as u128)
	var0 = add128(var0, var3749);	// _0 = BinOp(_0 ADD _3749)
	var3750.lo = var484; var3750.hi = var484 < 0 ? -1 : 0;	// _3750 = Cast(_484 as u128)
	var0 = add128(var0, var3750);	// _0 = BinOp(_0 ADD _3750)
	var3751.lo = var485; var3751.hi = var485 < 0 ? -1 : 0;	// _3751 = Cast(_485 as u128)
	var0 = add128(var0, var3751);	// _0 = BinOp(_0 ADD _3751)
	var3752.lo = var486.lo; var3752.hi = var486.hi;	// _3752 = Cast(_486 as u128)
	var0 = add128(var0, var3752);	// _0 = BinOp(_0 ADD _3752)
	var3753.lo = var487; var3753.hi = var487 < 0 ? -1 : 0;	// _3753 = Cast(_487 as u128)
	var0 = add128(var0, var3753);	// _0 = BinOp(_0 ADD _3753)
	var3754.lo = var488.lo; var3754.hi = var488.hi;	// _3754 = Cast(_488 as u128)
	var0 = sub128(var0, var3754);	// _0 = BinOp(_0 SUB _3754)
	var3755.lo = var489; var3755.hi = var489 < 0 ? -1 : 0;	// _3755 = Cast(_489 as u128)
	var0 = add128(var0, var3755);	// _0 = BinOp(_0 ADD _3755)
	var3756.lo = var490; var3756.hi = var490 < 0 ? -1 : 0;	// _3756 = Cast(_490 as u128)
	var0 = add128(var0, var3756);	// _0 = BinOp(_0 ADD _3756)
	var3757.lo = var491; var3757.hi = var491 < 0 ? -1 : 0;	// _3757 = Cast(_491 as u128)
	var0 = add128(var0, var3757);	// _0 = BinOp(_0 ADD _3757)
	var7364.lo = var492; var7364.hi = var492 < 0 ? -1 : 0;	// _7364 = Cast(_492 as u128)
	sub128_o(var0, var7364, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7364, ), bb2433, bb399)
	var3758.lo = var47; var3758.hi = var47 < 0 ? -1 : 0;	// _3758 = Cast(_47 as u128)
	var0 = add128(var0, var3758);	// _0 = BinOp(_0 ADD _3758)
	var7365.lo = var493; var7365.hi = var493 < 0 ? -1 : 0;	// _7365 = Cast(_493 as u128)
	sub128_o(var0, var7365, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7365, ), bb2434, bb399)
	var3759.lo = var494; var3759.hi = var494 < 0 ? -1 : 0;	// _3759 = Cast(_494 as u128)
	var0 = add128(var0, var3759);	// _0 = BinOp(_0 ADD _3759)
	var7366.lo = var495; var7366.hi = var495 < 0 ? -1 : 0;	// _7366 = Cast(_495 as u128)
	sub128_o(var0, var7366, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7366, ), bb2435, bb399)
	var3760.lo = var496; var3760.hi = var496 < 0 ? -1 : 0;	// _3760 = Cast(_496 as u128)
	var0 = add128(var0, var3760);	// _0 = BinOp(_0 ADD _3760)
	var3761.lo = var497; var3761.hi = var497 < 0 ? -1 : 0;	// _3761 = Cast(_497 as u128)
	var0 = add128(var0, var3761);	// _0 = BinOp(_0 ADD _3761)
	var3762.lo = var498; var3762.hi = var498 < 0 ? -1 : 0;	// _3762 = Cast(_498 as u128)
	var0 = add128(var0, var3762);	// _0 = BinOp(_0 ADD _3762)
	var3763.lo = var499; var3763.hi = var499 < 0 ? -1 : 0;	// _3763 = Cast(_499 as u128)
	var0 = add128(var0, var3763);	// _0 = BinOp(_0 ADD _3763)
	var3764.lo = var500; var3764.hi = var500 < 0 ? -1 : 0;	// _3764 = Cast(_500 as u128)
	var0 = add128(var0, var3764);	// _0 = BinOp(_0 ADD _3764)
	var3765.lo = var48.lo; var3765.hi = var48.hi;	// _3765 = Cast(_48 as u128)
	var0 = add128(var0, var3765);	// _0 = BinOp(_0 ADD _3765)
	var7367.lo = var501; var7367.hi = var501 < 0 ? -1 : 0;	// _7367 = Cast(_501 as u128)
	sub128_o(var0, var7367, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7367, ), bb2436, bb399)
	var7368.lo = var502; var7368.hi = var502 < 0 ? -1 : 0;	// _7368 = Cast(_502 as u128)
	sub128_o(var0, var7368, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7368, ), bb2437, bb399)
	var7369.lo = var503; var7369.hi = var503 < 0 ? -1 : 0;	// _7369 = Cast(_503 as u128)
	sub128_o(var0, var7369, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7369, ), bb2438, bb399)
	var3766.lo = var504; var3766.hi = var504 < 0 ? -1 : 0;	// _3766 = Cast(_504 as u128)
	var0 = add128(var0, var3766);	// _0 = BinOp(_0 ADD _3766)
	var3767.lo = var505; var3767.hi = var505 < 0 ? -1 : 0;	// _3767 = Cast(_505 as u128)
	var0 = add128(var0, var3767);	// _0 = BinOp(_0 ADD _3767)
	var3768.lo = var506; var3768.hi = var506 < 0 ? -1 : 0;	// _3768 = Cast(_506 as u128)
	var0 = add128(var0, var3768);	// _0 = BinOp(_0 ADD _3768)
	var7370.lo = var507; var7370.hi = var507 < 0 ? -1 : 0;	// _7370 = Cast(_507 as u128)
	sub128_o(var0, var7370, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7370, ), bb2439, bb399)
	var3769.lo = var508; var3769.hi = var508 < 0 ? -1 : 0;	// _3769 = Cast(_508 as u128)
	var0 = add128(var0, var3769);	// _0 = BinOp(_0 ADD _3769)
	var3770.lo = var509.lo; var3770.hi = var509.hi;	// _3770 = Cast(_509 as u128)
	var0 = add128(var0, var3770);	// _0 = BinOp(_0 ADD _3770)
	var3771.lo = var510; var3771.hi = var510 < 0 ? -1 : 0;	// _3771 = Cast(_510 as u128)
	var0 = add128(var0, var3771);	// _0 = BinOp(_0 ADD _3771)
	var3772.lo = var49; var3772.hi = var49 < 0 ? -1 : 0;	// _3772 = Cast(_49 as u128)
	var0 = add128(var0, var3772);	// _0 = BinOp(_0 ADD _3772)
	var3773.lo = var511; var3773.hi = var511 < 0 ? -1 : 0;	// _3773 = Cast(_511 as u128)
	var0 = add128(var0, var3773);	// _0 = BinOp(_0 ADD _3773)
	var3774.lo = var512; var3774.hi = var512 < 0 ? -1 : 0;	// _3774 = Cast(_512 as u128)
	var0 = add128(var0, var3774);	// _0 = BinOp(_0 ADD _3774)
	var3775.lo = var513; var3775.hi = var513 < 0 ? -1 : 0;	// _3775 = Cast(_513 as u128)
	var0 = add128(var0, var3775);	// _0 = BinOp(_0 ADD _3775)
	var3776.lo = var514; var3776.hi = var514 < 0 ? -1 : 0;	// _3776 = Cast(_514 as u128)
	var0 = add128(var0, var3776);	// _0 = BinOp(_0 ADD _3776)
	var3777.lo = var515; var3777.hi = var515 < 0 ? -1 : 0;	// _3777 = Cast(_515 as u128)
	var0 = add128(var0, var3777);	// _0 = BinOp(_0 ADD _3777)
	var3778.lo = var516; var3778.hi = var516 < 0 ? -1 : 0;	// _3778 = Cast(_516 as u128)
	var0 = add128(var0, var3778);	// _0 = BinOp(_0 ADD _3778)
	var3779.lo = var517; var3779.hi = var517 < 0 ? -1 : 0;	// _3779 = Cast(_517 as u128)
	var0 = add128(var0, var3779);	// _0 = BinOp(_0 ADD _3779)
	var3780.lo = var518; var3780.hi = var518 < 0 ? -1 : 0;	// _3780 = Cast(_518 as u128)
	var0 = add128(var0, var3780);	// _0 = BinOp(_0 ADD _3780)
	var3781.lo = var519; var3781.hi = var519 < 0 ? -1 : 0;	// _3781 = Cast(_519 as u128)
	var0 = add128(var0, var3781);	// _0 = BinOp(_0 ADD _3781)
	var3782.lo = var50; var3782.hi = var50 < 0 ? -1 : 0;	// _3782 = Cast(_50 as u128)
	var0 = add128(var0, var3782);	// _0 = BinOp(_0 ADD _3782)
	var7371.lo = var520.lo; var7371.hi = var520.hi;	// _7371 = Cast(_520 as u128)
	sub128_o(var0, var7371, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7371, ), bb2440, bb399)
	var3783.lo = var521.lo; var3783.hi = var521.hi;	// _3783 = Cast(_521 as u128)
	var0 = add128(var0, var3783);	// _0 = BinOp(_0 ADD _3783)
	var3784.lo = var522; var3784.hi = var522 < 0 ? -1 : 0;	// _3784 = Cast(_522 as u128)
	var0 = add128(var0, var3784);	// _0 = BinOp(_0 ADD _3784)
	var3785.lo = var523; var3785.hi = var523 < 0 ? -1 : 0;	// _3785 = Cast(_523 as u128)
	var0 = add128(var0, var3785);	// _0 = BinOp(_0 ADD _3785)
	var3786.lo = var524; var3786.hi = var524 < 0 ? -1 : 0;	// _3786 = Cast(_524 as u128)
	var0 = add128(var0, var3786);	// _0 = BinOp(_0 ADD _3786)
	var7372.lo = var525; var7372.hi = var525 < 0 ? -1 : 0;	// _7372 = Cast(_525 as u128)
	sub128_o(var0, var7372, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7372, ), bb2441, bb399)
	var3787.lo = var526; var3787.hi = var526 < 0 ? -1 : 0;	// _3787 = Cast(_526 as u128)
	var0 = add128(var0, var3787);	// _0 = BinOp(_0 ADD _3787)
	var3788.lo = var527; var3788.hi = var527 < 0 ? -1 : 0;	// _3788 = Cast(_527 as u128)
	var0 = add128(var0, var3788);	// _0 = BinOp(_0 ADD _3788)
	var3789.lo = var528; var3789.hi = var528 < 0 ? -1 : 0;	// _3789 = Cast(_528 as u128)
	var0 = add128(var0, var3789);	// _0 = BinOp(_0 ADD _3789)
	var3790.lo = var529.lo; var3790.hi = var529.hi;	// _3790 = Cast(_529 as u128)
	var0 = add128(var0, var3790);	// _0 = BinOp(_0 ADD _3790)
	var3791.lo = var51; var3791.hi = var51 < 0 ? -1 : 0;	// _3791 = Cast(_51 as u128)
	var0 = add128(var0, var3791);	// _0 = BinOp(_0 ADD _3791)
	var3792.lo = var530; var3792.hi = var530 < 0 ? -1 : 0;	// _3792 = Cast(_530 as u128)
	var0 = add128(var0, var3792);	// _0 = BinOp(_0 ADD _3792)
	var0 = add128(var0, var531);	// _0 = BinOp(_0 ADD _531)
	var7373.lo = var532; var7373.hi = var532 < 0 ? -1 : 0;	// _7373 = Cast(_532 as u128)
	sub128_o(var0, var7373, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7373, ), bb2442, bb399)
	var3793.lo = var533; var3793.hi = var533 < 0 ? -1 : 0;	// _3793 = Cast(_533 as u128)
	var0 = add128(var0, var3793);	// _0 = BinOp(_0 ADD _3793)
	sub128_o(var0, var7374, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7374, ), bb2443, bb399)
	var3794.lo = var534; var3794.hi = var534 < 0 ? -1 : 0;	// _3794 = Cast(_534 as u128)
	var0 = add128(var0, var3794);	// _0 = BinOp(_0 ADD _3794)
	var3795.lo = var535; var3795.hi = var535 < 0 ? -1 : 0;	// _3795 = Cast(_535 as u128)
	var0 = add128(var0, var3795);	// _0 = BinOp(_0 ADD _3795)
	var3796.lo = var4; var3796.hi = var4 < 0 ? -1 : 0;	// _3796 = Cast(_4 as u128)
	var0 = add128(var0, var3796);	// _0 = BinOp(_0 ADD _3796)
	var3797.lo = var52; var3797.hi = var52 < 0 ? -1 : 0;	// _3797 = Cast(_52 as u128)
	var0 = add128(var0, var3797);	// _0 = BinOp(_0 ADD _3797)
	var3798.lo = var536; var3798.hi = var536 < 0 ? -1 : 0;	// _3798 = Cast(_536 as u128)
	var0 = add128(var0, var3798);	// _0 = BinOp(_0 ADD _3798)
	var3799.lo = var537; var3799.hi = var537 < 0 ? -1 : 0;	// _3799 = Cast(_537 as u128)
	var0 = add128(var0, var3799);	// _0 = BinOp(_0 ADD _3799)
	var3800.lo = var538; var3800.hi = var538 < 0 ? -1 : 0;	// _3800 = Cast(_538 as u128)
	var0 = add128(var0, var3800);	// _0 = BinOp(_0 ADD _3800)
	var7375.lo = var539; var7375.hi = var539 < 0 ? -1 : 0;	// _7375 = Cast(_539 as u128)
	sub128_o(var0, var7375, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7375, ), bb2444, bb399)
	var3801.lo = var540; var3801.hi = var540 < 0 ? -1 : 0;	// _3801 = Cast(_540 as u128)
	var0 = add128(var0, var3801);	// _0 = BinOp(_0 ADD _3801)
	var3802.lo = var541; var3802.hi = var541 < 0 ? -1 : 0;	// _3802 = Cast(_541 as u128)
	var0 = add128(var0, var3802);	// _0 = BinOp(_0 ADD _3802)
	var3803.lo = var542; var3803.hi = var542 < 0 ? -1 : 0;	// _3803 = Cast(_542 as u128)
	var0 = add128(var0, var3803);	// _0 = BinOp(_0 ADD _3803)
	var7376.lo = var543; var7376.hi = var543 < 0 ? -1 : 0;	// _7376 = Cast(_543 as u128)
	sub128_o(var0, var7376, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7376, ), bb2445, bb399)
	var3804.lo = var544; var3804.hi = var544 < 0 ? -1 : 0;	// _3804 = Cast(_544 as u128)
	var0 = add128(var0, var3804);	// _0 = BinOp(_0 ADD _3804)
	var3805.lo = var53; var3805.hi = var53 < 0 ? -1 : 0;	// _3805 = Cast(_53 as u128)
	var0 = add128(var0, var3805);	// _0 = BinOp(_0 ADD _3805)
	var3806.lo = var545; var3806.hi = var545 < 0 ? -1 : 0;	// _3806 = Cast(_545 as u128)
	var0 = add128(var0, var3806);	// _0 = BinOp(_0 ADD _3806)
	var7377.lo = var546; var7377.hi = var546 < 0 ? -1 : 0;	// _7377 = Cast(_546 as u128)
	sub128_o(var0, var7377, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7377, ), bb2446, bb399)
	var3807.lo = var54; var3807.hi = var54 < 0 ? -1 : 0;	// _3807 = Cast(_54 as u128)
	var0 = add128(var0, var3807);	// _0 = BinOp(_0 ADD _3807)
	var7378.lo = var55; var7378.hi = var55 < 0 ? -1 : 0;	// _7378 = Cast(_55 as u128)
	sub128_o(var0, var7378, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7378, ), bb2447, bb399)
	var7379.lo = var56; var7379.hi = var56 < 0 ? -1 : 0;	// _7379 = Cast(_56 as u128)
	sub128_o(var0, var7379, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7379, ), bb2448, bb399)
	var0 = sub128(var0, var57);	// _0 = BinOp(_0 SUB _57)
	var7380.lo = var59; var7380.hi = var59 < 0 ? -1 : 0;	// _7380 = Cast(_59 as u128)
	sub128_o(var0, var7380, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7380, ), bb2449, bb399)
	var7381.lo = var60; var7381.hi = var60 < 0 ? -1 : 0;	// _7381 = Cast(_60 as u128)
	sub128_o(var0, var7381, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7381, ), bb2450, bb399)
	var7382.lo = var5; var7382.hi = var5 < 0 ? -1 : 0;	// _7382 = Cast(_5 as u128)
	sub128_o(var0, var7382, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7382, ), bb2451, bb399)
	var3808.lo = var61; var3808.hi = var61 < 0 ? -1 : 0;	// _3808 = Cast(_61 as u128)
	var0 = add128(var0, var3808);	// _0 = BinOp(_0 ADD _3808)
	var3809.lo = var62; var3809.hi = var62 < 0 ? -1 : 0;	// _3809 = Cast(_62 as u128)
	var0 = add128(var0, var3809);	// _0 = BinOp(_0 ADD _3809)
	var3810.lo = var63; var3810.hi = var63 < 0 ? -1 : 0;	// _3810 = Cast(_63 as u128)
	var0 = add128(var0, var3810);	// _0 = BinOp(_0 ADD _3810)
	var7383.lo = var64; var7383.hi = var64 < 0 ? -1 : 0;	// _7383 = Cast(_64 as u128)
	sub128_o(var0, var7383, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7383, ), bb2452, bb399)
	var3811.lo = var65.lo; var3811.hi = var65.hi;	// _3811 = Cast(_65 as u128)
	var0 = add128(var0, var3811);	// _0 = BinOp(_0 ADD _3811)
	var3812.lo = var66; var3812.hi = var66 < 0 ? -1 : 0;	// _3812 = Cast(_66 as u128)
	var0 = add128(var0, var3812);	// _0 = BinOp(_0 ADD _3812)
	var3813.lo = var67; var3813.hi = var67 < 0 ? -1 : 0;	// _3813 = Cast(_67 as u128)
	var0 = add128(var0, var3813);	// _0 = BinOp(_0 ADD _3813)
	var3814.lo = var68; var3814.hi = var68 < 0 ? -1 : 0;	// _3814 = Cast(_68 as u128)
	var0 = add128(var0, var3814);	// _0 = BinOp(_0 ADD _3814)
	var3815.lo = var69; var3815.hi = var69 < 0 ? -1 : 0;	// _3815 = Cast(_69 as u128)
	var0 = add128(var0, var3815);	// _0 = BinOp(_0 ADD _3815)
	var7384.lo = var70; var7384.hi = var70 < 0 ? -1 : 0;	// _7384 = Cast(_70 as u128)
	sub128_o(var0, var7384, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _7384, ), bb2453, bb399)
	var3816.lo = var71; var3816.hi = var71 < 0 ? -1 : 0;	// _3816 = Cast(_71 as u128)
	var0 = add128(var0, var3816);	// _0 = BinOp(_0 ADD _3816)
	var3817.lo = var72; var3817.hi = var72 < 0 ? -1 : 0;	// _3817 = Cast(_72 as u128)
	var0 = add128(var0, var3817);	// _0 = BinOp(_0 ADD _3817)
	var3818.lo = var73; var3818.hi = var73 < 0 ? -1 : 0;	// _3818 = Cast(_73 as u128)
	var0 = add128(var0, var3818);	// _0 = BinOp(_0 ADD _3818)
	var3819.lo = var74; var3819.hi = var74 < 0 ? -1 : 0;	// _3819 = Cast(_74 as u128)
	var0 = add128(var0, var3819);	// _0 = BinOp(_0 ADD _3819)
	var3820.lo = var75; var3820.hi = var75 < 0 ? -1 : 0;	// _3820 = Cast(_75 as u128)
	var0 = add128(var0, var3820);	// _0 = BinOp(_0 ADD _3820)
	var3821.lo = var76; var3821.hi = var76 < 0 ? -1 : 0;	// _3821 = Cast(_76 as u128)
	var0 = add128(var0, var3821);	// _0 = BinOp(_0 ADD _3821)
	var3822.lo = var6; var3822.hi = var6 < 0 ? -1 : 0;	// _3822 = Cast(_6 as u128)
	var0 = add128(var0, var3822);	// _0 = BinOp(_0 ADD _3822)
	var3823.lo = var77; var3823.hi = var77 < 0 ? -1 : 0;	// _3823 = Cast(_77 as u128)
	var0 = add128(var0, var3823);	// _0 = BinOp(_0 ADD _3823)
	var3824.lo = var78; var3824.hi = var78 < 0 ? -1 : 0;	// _3824 = Cast(_78 as u128)
	var0 = add128(var0, var3824);	// _0 = BinOp(_0 ADD _3824)
	var3825.lo = var79; var3825.hi = var79 < 0 ? -1 : 0;	// _3825 = Cast(_79 as u128)
	var0 = add128(var0, var3825);	// _0 = BinOp(_0 ADD _3825)
	var3826.lo = var80; var3826.hi = var80 < 0 ? -1 : 0;	// _3826 = Cast(_80 as u128)
	var0 = add128(var0, var3826);	// _0 = BinOp(_0 ADD _3826)
	var3827.lo = var81; var3827.hi = var81 < 0 ? -1 : 0;	// _3827 = Cast(_81 as u128)
	var0 = add128(var0, var3827);	// _0 = BinOp(_0 ADD _3827)
	var0 = add128(var0, var82);	// _0 = BinOp(_0 ADD _82)
	var3828.lo = var83; var3828.hi = var83 < 0 ? -1 : 0;	// _3828 = Cast(_83 as u128)
	var0 = add128(var0, var3828);	// _0 = BinOp(_0 ADD _3828)
	var3829.lo = var84; var3829.hi = var84 < 0 ? -1 : 0;	// _3829 = Cast(_84 as u128)
	var0 = add128(var0, var3829);	// _0 = BinOp(_0 ADD _3829)
	var3830 = & var0;	// _3830 = Borrow(Shared, _0)
	var7387 = make_sliceptr(&ZRG2cD3binB_09FRAGMENTS0g.val, 0x2ull);	// _7387 = MakeDst(&::"bin#"::#0::FRAGMENTS, 0x2 usize)
	var3831 = ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gCi( var3830, ZRQCi2cE9core0_0_03fmt7Display0g_B0g );
	// ^ Call( _3831 = <::"core-0_0_0"::fmt::ArgumentV1/*S*/ /*- */>::new<u128,>( _3830, &<u128 as ::"core-0_0_0"::fmt::Display>::fmt, ), bb2454, bb399)
	var3832.DATA[0] = var3831;	// _3832 = Array(_3831)
	var3833 = & var3832;	// _3833 = Borrow(Shared, _3832)
	var7388 = make_sliceptr(var3833, 0x1ull);	// _7388 = MakeDst(_3833, 0x1 usize)
	memset(&var7386, 0, sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g ));	// _7386 = Variant(::"core-0_0_0"::option::Option<&[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],> #0, {})
	var7385._0 = var7387;
	var7385._1 = var7386;
	var7385._2 = var7388;	// _7385 = Struct(::"core-0_0_0"::fmt::Arguments, {_7387, _7386, _7388})
	ZRG3cD8std0_0_02io5stdio6_print0g( var7385 );
	// ^ Call( _3834 = ::"std-0_0_0"::io::stdio::_print( _7385, ), bb2455, bb399)
	/* ZST assign */
	return ;
	// ^ Return
}
// ::"std-0_0_0"::rt::lang_start
static intptr_t  ZRG2cD8std0_0_02rt10lang_start0g(
		t_ZRTF0T0 arg0,
		intptr_t arg1,
		uint8_t **arg2
		)
{
	intptr_t rv;
	struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 var0;	// ::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/
	struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *var1;	// &::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/
	TRAITOBJ_PTR var2;	// &dyn (::"core-0_0_0"::ops::function::Fn<(),Output{::"core-0_0_0"::ops::function::FnOnce<(),>}=i32,>+::"core-0_0_0"::marker::Sync+::"std-0_0_0"::panic::RefUnwindSafe+'_)
	var0._0 = arg0;	// _0 = Struct(::"std-0_0_0"::rt::closure#lang_start_0<(),>, {a0})
	var1 = & var0;	// _1 = Borrow(Shared, _0)
	var2 = make_traitobjptr(var1, &ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g.val);	// _2 = MakeDst(_1, &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::vtable#)
	rv = ZRG2cD8std0_0_02rt19lang_start_internal0g( var2, arg1, arg2 );
	// ^ Call( retval = ::"std-0_0_0"::rt::lang_start_internal( _2, a1, a2, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <isize /*- */>::overflowing_div
static TUP_2_ZRTCv_ZRTCw  ZRICv15overflowing_div0g(
		intptr_t arg0,
		intptr_t arg1
		)
{
	TUP_2_ZRTCv_ZRTCw rv;
	RUST_BOOL var0;	// bool
	intptr_t var1;	// isize
	var0 = arg0 == INT64_MIN;	// _0 = BinOp(a0 EQ -9223372036854775808 isize)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = arg1 == -1ll;	// _0 = BinOp(a1 EQ -1 isize)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = arg0 / arg1;	// _1 = BinOp(a0 DIV a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = arg0;
	rv._1 = true;	// retval = Tuple(a0, true)
	return rv;
	// ^ Return
}
// <isize /*- */>::overflowing_rem
static TUP_2_ZRTCv_ZRTCw  ZRICv15overflowing_rem0g(
		intptr_t arg0,
		intptr_t arg1
		)
{
	TUP_2_ZRTCv_ZRTCw rv;
	RUST_BOOL var0;	// bool
	intptr_t var1;	// isize
	var0 = arg0 == INT64_MIN;	// _0 = BinOp(a0 EQ -9223372036854775808 isize)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = arg1 == -1ll;	// _0 = BinOp(a1 EQ -1 isize)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = arg0 % arg1;	// _1 = BinOp(a0 MOD a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = 0ll;
	rv._1 = true;	// retval = Tuple(+0 isize, true)
	return rv;
	// ^ Return
}
// <i8 /*- */>::overflowing_div
static TUP_2_ZRTCb_ZRTCw  ZRICb15overflowing_div0g(
		int8_t arg0,
		int8_t arg1
		)
{
	TUP_2_ZRTCb_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int8_t var1;	// i8
	var0 = arg0 == -128;	// _0 = BinOp(a0 EQ -128 i8)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = arg1 == -1;	// _0 = BinOp(a1 EQ -1 i8)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = arg0 / arg1;	// _1 = BinOp(a0 DIV a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = arg0;
	rv._1 = true;	// retval = Tuple(a0, true)
	return rv;
	// ^ Return
}
// <i8 /*- */>::overflowing_rem
static TUP_2_ZRTCb_ZRTCw  ZRICb15overflowing_rem0g(
		int8_t arg0,
		int8_t arg1
		)
{
	TUP_2_ZRTCb_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int8_t var1;	// i8
	var0 = arg0 == -128;	// _0 = BinOp(a0 EQ -128 i8)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = arg1 == -1;	// _0 = BinOp(a1 EQ -1 i8)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = arg0 % arg1;	// _1 = BinOp(a0 MOD a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = 0;
	rv._1 = true;	// retval = Tuple(+0 i8, true)
	return rv;
	// ^ Return
}
// <i16 /*- */>::overflowing_div
static TUP_2_ZRTCd_ZRTCw  ZRICd15overflowing_div0g(
		int16_t arg0,
		int16_t arg1
		)
{
	TUP_2_ZRTCd_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int16_t var1;	// i16
	var0 = arg0 == -32768;	// _0 = BinOp(a0 EQ -32768 i16)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = arg1 == -1;	// _0 = BinOp(a1 EQ -1 i16)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = arg0 / arg1;	// _1 = BinOp(a0 DIV a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = arg0;
	rv._1 = true;	// retval = Tuple(a0, true)
	return rv;
	// ^ Return
}
// <i16 /*- */>::overflowing_rem
static TUP_2_ZRTCd_ZRTCw  ZRICd15overflowing_rem0g(
		int16_t arg0,
		int16_t arg1
		)
{
	TUP_2_ZRTCd_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int16_t var1;	// i16
	var0 = arg0 == -32768;	// _0 = BinOp(a0 EQ -32768 i16)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = arg1 == -1;	// _0 = BinOp(a1 EQ -1 i16)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = arg0 % arg1;	// _1 = BinOp(a0 MOD a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = 0;
	rv._1 = true;	// retval = Tuple(+0 i16, true)
	return rv;
	// ^ Return
}
// <i32 /*- */>::overflowing_div
static TUP_2_ZRTCf_ZRTCw  ZRICf15overflowing_div0g(
		int32_t arg0,
		int32_t arg1
		)
{
	TUP_2_ZRTCf_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int32_t var1;	// i32
	var0 = arg0 == -2147483648;	// _0 = BinOp(a0 EQ -2147483648 i32)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = arg1 == -1;	// _0 = BinOp(a1 EQ -1 i32)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = arg0 / arg1;	// _1 = BinOp(a0 DIV a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = arg0;
	rv._1 = true;	// retval = Tuple(a0, true)
	return rv;
	// ^ Return
}
// <i32 /*- */>::overflowing_rem
static TUP_2_ZRTCf_ZRTCw  ZRICf15overflowing_rem0g(
		int32_t arg0,
		int32_t arg1
		)
{
	TUP_2_ZRTCf_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int32_t var1;	// i32
	var0 = arg0 == -2147483648;	// _0 = BinOp(a0 EQ -2147483648 i32)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = arg1 == -1;	// _0 = BinOp(a1 EQ -1 i32)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = arg0 % arg1;	// _1 = BinOp(a0 MOD a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = 0;
	rv._1 = true;	// retval = Tuple(+0 i32, true)
	return rv;
	// ^ Return
}
// <i64 /*- */>::overflowing_div
static TUP_2_ZRTCh_ZRTCw  ZRICh15overflowing_div0g(
		int64_t arg0,
		int64_t arg1
		)
{
	TUP_2_ZRTCh_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int64_t var1;	// i64
	var0 = arg0 == INT64_MIN;	// _0 = BinOp(a0 EQ -9223372036854775808 i64)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = arg1 == -1ll;	// _0 = BinOp(a1 EQ -1 i64)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = arg0 / arg1;	// _1 = BinOp(a0 DIV a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = arg0;
	rv._1 = true;	// retval = Tuple(a0, true)
	return rv;
	// ^ Return
}
// <i64 /*- */>::overflowing_rem
static TUP_2_ZRTCh_ZRTCw  ZRICh15overflowing_rem0g(
		int64_t arg0,
		int64_t arg1
		)
{
	TUP_2_ZRTCh_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int64_t var1;	// i64
	var0 = arg0 == INT64_MIN;	// _0 = BinOp(a0 EQ -9223372036854775808 i64)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = arg1 == -1ll;	// _0 = BinOp(a1 EQ -1 i64)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = arg0 % arg1;	// _1 = BinOp(a0 MOD a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = 0ll;
	rv._1 = true;	// retval = Tuple(+0 i64, true)
	return rv;
	// ^ Return
}
// <i128 /*- */>::overflowing_div
static TUP_2_ZRTCj_ZRTCw  ZRICj15overflowing_div0g(
		int128_t arg0,
		int128_t arg1
		)
{
	TUP_2_ZRTCj_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int128_t var1;	// i128
	var0 = 0 == cmp128s(make128s_raw(9223372036854775808ull, 0ull), arg0);	// _0 = BinOp(a0 EQ --170141183460469231731687303715884105728 i128)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = 0 == cmp128s(make128s_raw(18446744073709551615ull, 18446744073709551615ull), arg1);	// _0 = BinOp(a1 EQ -1 i128)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = div128s(arg0, arg1);	// _1 = BinOp(a0 DIV a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = arg0;
	rv._1 = true;	// retval = Tuple(a0, true)
	return rv;
	// ^ Return
}
// <i128 /*- */>::overflowing_rem
static TUP_2_ZRTCj_ZRTCw  ZRICj15overflowing_rem0g(
		int128_t arg0,
		int128_t arg1
		)
{
	TUP_2_ZRTCj_ZRTCw rv;
	RUST_BOOL var0;	// bool
	int128_t var1;	// i128
	var0 = 0 == cmp128s(make128s_raw(9223372036854775808ull, 0ull), arg0);	// _0 = BinOp(a0 EQ --170141183460469231731687303715884105728 i128)
	if(var0) goto bb1; else goto bb2;
	// ^ If( _0 : 1, 2)
bb1:
	var0 = 0 == cmp128s(make128s_raw(18446744073709551615ull, 18446744073709551615ull), arg1);	// _0 = BinOp(a1 EQ -1 i128)
	if(var0) goto bb3; else goto bb2;
	// ^ If( _0 : 3, 2)
bb2:
	var1 = mod128s(arg0, arg1);	// _1 = BinOp(a0 MOD a1)
	;
	rv._0 = var1;
	rv._1 = false;	// retval = Tuple(_1, false)
	return rv;
	// ^ Return
bb3:
	;
	rv._0 = make128s_raw(0ull, 0ull);
	rv._1 = true;	// retval = Tuple(+0 i128, true)
	return rv;
	// ^ Return
}
// <::"core-0_0_0"::fmt::ArgumentV1/*S*/ /*- */>::new<u128,>
static struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gCi(
		uint128_t *arg0,
		t_ZRTF2BsCiBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g arg1
		)
{
	struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g rv;
	t_ZRTF2BsG2cE9core0_0_03fmt4Void0gBuG2c_A_B9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g var0;	// extern "Rust" fn(&::"core-0_0_0"::fmt::Void/*S*/, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
	struct s_ZRG2cE9core0_0_03fmt4Void0g *var1;	// &::"core-0_0_0"::fmt::Void/*S*/
	memcpy( &var0, &arg1, sizeof(t_ZRTF2BsCiBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g ));
	// ^ Call( _0 = "transmute"::<extern "Rust" fn(&u128, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/,extern "Rust" fn(&::"core-0_0_0"::fmt::Void/*S*/, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/,>( a1, ), bb1, bb3)
	var1 = (void*)arg0;
	// ^ Call( _1 = "transmute"::<&u128,&::"core-0_0_0"::fmt::Void/*S*/,>( a0, ), bb2, bb3)
	rv._0 = var1;
	rv._1 = var0;	// retval = Struct(::"core-0_0_0"::fmt::ArgumentV1, {_1, _0})
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ /*- */>::#drop_glue
static void  ZRIG2cD8std0_0_02rtH19closurelang_start_01gT0A9drop_glue0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0
		)
{
	tUNIT rv;
	/* ZST assign */
	return ;
	// ^ Return
}
// <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::call
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT04call0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		)
{
	int32_t rv;
	t_ZRTF0T0 var0;	// extern "Rust" fn() -> ()
	tUNIT var1 = {0};	// ()
	var0 = arg0->_0;	// _0 = Use(a0*.0)
	(var0)( );
	// ^ Call( _1 = (_0)( ), bb1, bb2)
	rv = 0;	// retval = Constant(+0 i32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(),>>::call_mut
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function5FnMut1gT08call_mut0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		)
{
	int32_t rv;
	t_ZRTF0T0 var0;	// extern "Rust" fn() -> ()
	tUNIT var1 = {0};	// ()
	var0 = arg0->_0;	// _0 = Use(a0*.0)
	(var0)( );
	// ^ Call( _1 = (_0)( ), bb1, bb2)
	rv = 0;	// retval = Constant(+0 i32)
	// ^ drop(a0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <() as ::"std-0_0_0"::process::Termination>::report
static int32_t  ZRQT02cD8std0_0_07process11Termination0g6report0g(
		tUNIT arg0
		)
{
	int32_t rv;
	rv = 0;	// retval = Constant(+0 i32)
	return rv;
	// ^ Return
}
int main(int argc, const char* argv[]) {
	return ZRG2cD8std0_0_02rt10lang_start0g(ZRG1cD3bin4main0g, argc, (uint8_t**)argv);
}
__thread jmp_buf* mrustc_panic_target;
__thread void* mrustc_panic_value;
int8_t* __rust_alloc(uintptr_t a0, uintptr_t a1) {
	extern int8_t* __rdl_alloc(uintptr_t a0, uintptr_t a1);
	return __rdl_alloc(a0, a1);
}
void __rust_dealloc(int8_t* a0, uintptr_t a1, uintptr_t a2) {
	extern void __rdl_dealloc(int8_t* a0, uintptr_t a1, uintptr_t a2);
	__rdl_dealloc(a0, a1, a2);
}
int8_t* __rust_realloc(int8_t* a0, uintptr_t a1, uintptr_t a2, uintptr_t a3) {
	extern int8_t* __rdl_realloc(int8_t* a0, uintptr_t a1, uintptr_t a2, uintptr_t a3);
	return __rdl_realloc(a0, a1, a2, a3);
}
int8_t* __rust_alloc_zeroed(uintptr_t a0, uintptr_t a1) {
	extern int8_t* __rdl_alloc_zeroed(uintptr_t a0, uintptr_t a1);
	return __rdl_alloc_zeroed(a0, a1);
}
struct s_ZRG2c4core5alloc6Layout0g_A { uintptr_t a, b; };
void oom_impl(struct s_ZRG2c4core5alloc6Layout0g_A l) { extern void ZRG2cD8std0_0_05alloc8rust_oom0g(struct s_ZRG2c4core5alloc6Layout0g_A l); ZRG2cD8std0_0_05alloc8rust_oom0g(l); }
uint32_t panic_impl(uintptr_t payload) {extern uint32_t ZRG2cD8std0_0_09panicking16rust_begin_panic0g(uintptr_t payload);return ZRG2cD8std0_0_09panicking16rust_begin_panic0g(payload);}
