/*
 * AUTOGENERATED by mrustc
 */
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <assert.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <setjmp.h>
typedef uint32_t RUST_CHAR;
typedef uint8_t RUST_BOOL;
typedef struct { void* PTR; size_t META; } SLICE_PTR;
typedef struct { void* PTR; void* META; } TRAITOBJ_PTR;
typedef struct { void (*drop)(void*); size_t size; size_t align; } VTABLE_HDR;
typedef struct { char _d; } tUNIT;
typedef char tBANG;
typedef struct { char _d; } tTYPEID;
static inline size_t ALIGN_TO(size_t s, size_t a) { return (s + a-1) / a * a; }

extern void _Unwind_Resume(void) __attribute__((noreturn));
#define ALIGNOF(t) __alignof__(t)
extern __thread jmp_buf*    mrustc_panic_target;
extern __thread void* mrustc_panic_value;
static inline uint64_t __builtin_clz64(uint64_t v) {
	return ( (v >> 32) != 0 ? __builtin_clz(v>>32) : 32 + __builtin_clz(v));
}
static inline uint64_t __builtin_ctz64(uint64_t v) {
	return ((v&0xFFFFFFFF) == 0 ? __builtin_ctz(v>>32) + 32 : __builtin_ctz(v));
}
static inline uint8_t __mrustc_atomicloop8(volatile uint8_t* slot, uint8_t param, int ordering, uint8_t (*cb)(uint8_t, uint8_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint8_t v = atomic_load_explicit((_Atomic uint8_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint8_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint16_t __mrustc_atomicloop16(volatile uint16_t* slot, uint16_t param, int ordering, uint16_t (*cb)(uint16_t, uint16_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint16_t v = atomic_load_explicit((_Atomic uint16_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint16_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint32_t __mrustc_atomicloop32(volatile uint32_t* slot, uint32_t param, int ordering, uint32_t (*cb)(uint32_t, uint32_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint32_t v = atomic_load_explicit((_Atomic uint32_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint32_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint64_t __mrustc_atomicloop64(volatile uint64_t* slot, uint64_t param, int ordering, uint64_t (*cb)(uint64_t, uint64_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint64_t v = atomic_load_explicit((_Atomic uint64_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint64_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
typedef struct { uint64_t lo, hi; } uint128_t;
typedef struct { uint64_t lo, hi; } int128_t;
static inline float make_float(int is_neg, int exp, uint32_t mantissa_bits) { float rv; uint32_t vi=(mantissa_bits&((1<<23)-1))|((exp+127)<<23);if(is_neg)vi|=1<<31; memcpy(&rv, &vi, 4); return rv; }
static inline double make_double(int is_neg, int exp, uint32_t mantissa_bits) { double rv; uint64_t vi=(mantissa_bits&((1ull<<52)-1))|((uint64_t)(exp+1023)<<52);if(is_neg)vi|=1ull<<63; memcpy(&rv, &vi, 4); return rv; }
static inline uint128_t make128_raw(uint64_t hi, uint64_t lo) { uint128_t rv = { lo, hi }; return rv; }
static inline uint128_t make128(uint64_t v) { uint128_t rv = { v, 0 }; return rv; }
static inline float cast128_float(uint128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint32_t mant = 0; return make_float(0, exp, mant); }
static inline double cast128_double(uint128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint64_t mant = 0; return make_double(0, exp, mant); }
static inline int cmp128(uint128_t a, uint128_t b) { if(a.hi != b.hi) return a.hi < b.hi ? -1 : 1; if(a.lo != b.lo) return a.lo < b.lo ? -1 : 1; return 0; }
static inline bool add128_o(uint128_t a, uint128_t b, uint128_t* o) { o->lo = a.lo + b.lo; o->hi = a.hi + b.hi + (o->lo < a.lo ? 1 : 0); return (o->hi < a.hi); }
static inline bool sub128_o(uint128_t a, uint128_t b, uint128_t* o) { o->lo = a.lo - b.lo; o->hi = a.hi - b.hi - (a.lo < b.lo ? 1 : 0); return (o->hi > a.hi); }
static inline bool mul128_o(uint128_t a, uint128_t b, uint128_t* o) { bool of = false; o->hi = 0; o->lo = 0; for(int i=0;i<128;i++){ uint64_t m = (1ull << (i % 64)); if(a.hi==0&&a.lo<m)   break; if(i>=64&&a.hi<m) break; if( m & (i >= 64 ? a.hi : a.lo) ) of |= add128_o(*o, b, o); b.hi = (b.hi << 1) | (b.lo >> 63); b.lo = (b.lo << 1); } return of;}
static inline bool div128_o(uint128_t a, uint128_t b, uint128_t* q, uint128_t* r) { if(a.hi == 0 && b.hi == 0) { if(q) { q->hi=0; q->lo = a.lo / b.lo; } if(r) { r->hi=0; r->lo = a.lo % b.lo; } return false; } if(cmp128(a, b) < 0) { if(q) { q->hi=0; q->lo=0; } if(r) *r = a; return false; } uint128_t a_div_2 = {(a.lo>>1)|(a.hi << 63), a.hi>>1}; int shift = 0; while( cmp128(a_div_2, b) >= 0 && shift < 128 ) { shift += 1; b.hi = (b.hi<<1)|(b.lo>>63); b.lo <<= 1; } if(shift == 128) return true; uint128_t mask = { /*lo=*/(shift >= 64 ? 0 : (1ull << shift)), /*hi=*/(shift < 64 ? 0 : 1ull << (shift-64)) }; shift ++; if(q) { q->hi = 0; q->lo = 0; } while(shift--) { if( cmp128(a, b) >= 0 ) { if(q) add128_o(*q, mask, q); sub128_o(a, b, &a); } mask.lo = (mask.lo >> 1) | (mask.hi << 63); mask.hi >>= 1; b.lo = (b.lo >> 1) | (b.hi << 63); b.hi >>= 1; } if(r) *r = a; return false;}
static inline uint128_t add128(uint128_t a, uint128_t b) { uint128_t v; add128_o(a, b, &v); return v; }
static inline uint128_t sub128(uint128_t a, uint128_t b) { uint128_t v; sub128_o(a, b, &v); return v; }
static inline uint128_t mul128(uint128_t a, uint128_t b) { uint128_t v; mul128_o(a, b, &v); return v; }
static inline uint128_t div128(uint128_t a, uint128_t b) { uint128_t v; div128_o(a, b, &v, NULL); return v; }
static inline uint128_t mod128(uint128_t a, uint128_t b) { uint128_t v; div128_o(a, b, NULL, &v); return v;}
static inline uint128_t and128(uint128_t a, uint128_t b) { uint128_t v = { a.lo & b.lo, a.hi & b.hi }; return v; }
static inline uint128_t or128 (uint128_t a, uint128_t b) { uint128_t v = { a.lo | b.lo, a.hi | b.hi }; return v; }
static inline uint128_t xor128(uint128_t a, uint128_t b) { uint128_t v = { a.lo ^ b.lo, a.hi ^ b.hi }; return v; }
static inline uint128_t shl128(uint128_t a, uint32_t b) { uint128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = a.lo << b; v.hi = (a.hi << b) | (a.lo >> (64 - b)); } else { v.hi = a.lo << (b - 64); v.lo = 0; } return v; }
static inline uint128_t shr128(uint128_t a, uint32_t b) { uint128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = (a.lo >> b)|(a.hi << (64 - b)); v.hi = a.hi >> b; } else { v.lo = a.hi >> (b - 64); v.hi = 0; } return v; }
static inline uint128_t popcount128(uint128_t a) { uint128_t v = { __builtin_popcountll(a.lo) + __builtin_popcountll(a.hi), 0 }; return v; }
static inline uint128_t __builtin_bswap128(uint128_t v) { uint128_t rv = { __builtin_bswap64(v.hi), __builtin_bswap64(v.lo) }; return rv; }
static inline uint128_t intrinsic_ctlz_u128(uint128_t v) {
	uint128_t rv = { (v.hi != 0 ? __builtin_clz64(v.hi) : (v.lo != 0 ? 64 + __builtin_clz64(v.lo) : 128)), 0 };
	return rv;
}
static inline uint128_t intrinsic_cttz_u128(uint128_t v) {
	uint128_t rv = { (v.lo == 0 ? (v.hi == 0 ? 128 : __builtin_ctz64(v.hi) + 64) : __builtin_ctz64(v.lo)), 0 };
	return rv;
}
static inline int128_t make128s_raw(uint64_t hi, uint64_t lo) { int128_t rv = { lo, hi }; return rv; }
static inline int128_t make128s(int64_t v) { int128_t rv = { v, (v < 0 ? -1 : 0) }; return rv; }
static inline int128_t neg128s(int128_t v) { int128_t rv = { ~v.lo+1, ~v.hi + (v.lo == 0) }; return rv; }
static inline float cast128s_float(int128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint32_t mant = 0; return make_float(0, exp, mant); }
static inline double cast128s_double(int128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint64_t mant = 0; return make_double(0, exp, mant); }
static inline int cmp128s(int128_t a, int128_t b) { if(a.hi != b.hi) return (int64_t)a.hi < (int64_t)b.hi ? -1 : 1; if(a.lo != b.lo) return a.lo < b.lo ? -1 : 1; return 0; }
static inline bool add128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna=a.hi>>63; bool sgnb=b.hi>>63; add128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); bool sgno = o->hi>>63; return (sgna==sgnb && sgno != sgna); }
static inline bool sub128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna=a.hi>>63; bool sgnb=b.hi>>63; sub128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); bool sgno = o->hi>>63; return (sgna!=sgnb && sgno != sgna); }
static inline bool mul128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna = (a.hi >> 63); bool sgnb = (b.hi >> 63); if(sgna) a = neg128s(a); if(sgnb) b = neg128s(b); bool rv = mul128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); if(sgnb != sgnb) *o = neg128s(*o); return rv; }
static inline bool div128s_o(int128_t a, int128_t b, int128_t* q, int128_t* r) { bool sgna = a.hi & (1ull<<63); bool sgnb = b.hi & (1ull<<63); if(sgna) { a.hi = ~a.hi; a.lo = ~a.lo; a.lo += 1; if(a.lo == 0) a.hi += 1; } if(sgnb) { b.hi = ~b.hi; b.lo = ~b.lo; b.lo += 1; if(b.lo == 0) b.hi += 1; } bool rv = div128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)q, (uint128_t*)r); if(sgnb != sgnb) { r->hi = ~r->hi; r->lo = ~r->lo; r->lo += 1; if(r->lo == 0) r->hi += 1; } return rv; }
static inline int128_t add128s(int128_t a, int128_t b) { int128_t v; add128s_o(a, b, &v); return v; }
static inline int128_t sub128s(int128_t a, int128_t b) { int128_t v; sub128s_o(a, b, &v); return v; }
static inline int128_t mul128s(int128_t a, int128_t b) { int128_t v; mul128s_o(a, b, &v); return v; }
static inline int128_t div128s(int128_t a, int128_t b) { int128_t v; div128s_o(a, b, &v, NULL); return v; }
static inline int128_t mod128s(int128_t a, int128_t b) { int128_t v; div128s_o(a, b, NULL, &v); return v; }
static inline int128_t and128s(int128_t a, int128_t b) { int128_t v = { a.lo & b.lo, a.hi & b.hi }; return v; }
static inline int128_t or128s (int128_t a, int128_t b) { int128_t v = { a.lo | b.lo, a.hi | b.hi }; return v; }
static inline int128_t xor128s(int128_t a, int128_t b) { int128_t v = { a.lo ^ b.lo, a.hi ^ b.hi }; return v; }
static inline int128_t shl128s(int128_t a, uint32_t b) { int128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = a.lo << b; v.hi = (a.hi << b) | (a.lo >> (64 - b)); } else { v.hi = a.lo << (b - 64); v.lo = 0; } return v; }
static inline int128_t shr128s(int128_t a, uint32_t b) { int128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = (a.lo >> b)|(a.hi << (64 - b)); v.hi = (int64_t)a.hi >> b; } else { v.lo = (int64_t)a.hi >> (b - 64); v.hi = (int64_t)a.hi < 0 ? -1 : 0; } return v; }

static inline int slice_cmp(SLICE_PTR l, SLICE_PTR r) {
	int rv = memcmp(l.PTR, r.PTR, l.META < r.META ? l.META : r.META);
	if(rv != 0) return rv;
	if(l.META < r.META) return -1;
	if(l.META > r.META) return 1;
	return 0;
}
static inline SLICE_PTR make_sliceptr(void* ptr, size_t s) { SLICE_PTR rv = { ptr, s }; return rv; }
static inline TRAITOBJ_PTR make_traitobjptr(void* ptr, void* vt) { TRAITOBJ_PTR rv = { ptr, vt }; return rv; }

static inline size_t mrustc_max(size_t a, size_t b) { return a < b ? b : a; }
static inline void noop_drop(tUNIT *p) { }

static inline size_t mrustc_string_search_linear(SLICE_PTR val, size_t count, SLICE_PTR* options) {
	for(size_t i = 0; i < count; i ++) {
		int cmp = slice_cmp(val, options[i]);
		if(cmp < 0) break;
		if(cmp == 0) return i;
	}
	return SIZE_MAX;
}
static const uint8_t __mrustc_revmap[16] = { 0, 8, 4,12, 2,10, 6,14,  1, 9, 5,13, 3, 7,15};
static inline uint8_t __mrustc_bitrev8(uint8_t v) { if(v==0||v==0xFF) return v; return __mrustc_revmap[v>>4]|(__mrustc_revmap[v&15]<<4); }
static inline uint16_t __mrustc_bitrev16(uint16_t v) { if(v==0) return 0; return ((uint16_t)__mrustc_bitrev8(v>>8))|((uint16_t)__mrustc_bitrev8(v)<<8); }
static inline uint32_t __mrustc_bitrev32(uint32_t v) { if(v==0) return 0; return ((uint32_t)__mrustc_bitrev16(v>>16))|((uint32_t)__mrustc_bitrev16(v)<<16); }
static inline uint64_t __mrustc_bitrev64(uint64_t v) { if(v==0) return 0; return ((uint64_t)__mrustc_bitrev32(v>>32))|((uint64_t)__mrustc_bitrev32(v)<<32); }
static inline uint128_t __mrustc_bitrev128(uint128_t v) { uint128_t rv = { __mrustc_bitrev64(v.hi), __mrustc_bitrev64(v.lo) }; return rv; }
static inline uint8_t __mrustc_op_umax8(uint8_t a, uint8_t b) { return (a > b ? a : b); }
static inline uint8_t __mrustc_op_umin8(uint8_t a, uint8_t b) { return (a < b ? a : b); }
static inline uint8_t __mrustc_op_imax8(uint8_t a, uint8_t b) { return ((int8_t)a > (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_imin8(uint8_t a, uint8_t b) { return ((int8_t)a < (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_and_not8(uint8_t a, uint8_t b) { return ~(a & b); }
static inline uint16_t __mrustc_op_umax16(uint16_t a, uint16_t b) { return (a > b ? a : b); }
static inline uint16_t __mrustc_op_umin16(uint16_t a, uint16_t b) { return (a < b ? a : b); }
static inline uint16_t __mrustc_op_imax16(uint16_t a, uint16_t b) { return ((int16_t)a > (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_imin16(uint16_t a, uint16_t b) { return ((int16_t)a < (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_and_not16(uint16_t a, uint16_t b) { return ~(a & b); }
static inline uint32_t __mrustc_op_umax32(uint32_t a, uint32_t b) { return (a > b ? a : b); }
static inline uint32_t __mrustc_op_umin32(uint32_t a, uint32_t b) { return (a < b ? a : b); }
static inline uint32_t __mrustc_op_imax32(uint32_t a, uint32_t b) { return ((int32_t)a > (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_imin32(uint32_t a, uint32_t b) { return ((int32_t)a < (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_and_not32(uint32_t a, uint32_t b) { return ~(a & b); }
static inline uint64_t __mrustc_op_umax64(uint64_t a, uint64_t b) { return (a > b ? a : b); }
static inline uint64_t __mrustc_op_umin64(uint64_t a, uint64_t b) { return (a < b ? a : b); }
static inline uint64_t __mrustc_op_imax64(uint64_t a, uint64_t b) { return ((int64_t)a > (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_imin64(uint64_t a, uint64_t b) { return ((int64_t)a < (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_and_not64(uint64_t a, uint64_t b) { return ~(a & b); }
struct s_ZRG2cE9core0_0_03fmt4Void0g;
struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g;
struct s_ZRG2cE9core0_0_03fmt9Formatter0g;
typedef struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  (*t_ZRTF2BsG2cE9core0_0_03fmt4Void0gBuG2c_A_B9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g )( struct s_ZRG2cE9core0_0_03fmt4Void0g *, struct s_ZRG2cE9core0_0_03fmt9Formatter0g * ); // extern "Rust" fn(&::"core-0_0_0"::fmt::Void/*S*/, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
// struct ::"core-0_0_0"::fmt::ArgumentV1
struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  {
	struct s_ZRG2cE9core0_0_03fmt4Void0g *_0; // &::"core-0_0_0"::fmt::Void/*S*/
	t_ZRTF2BsG2cE9core0_0_03fmt4Void0gBuG2c_A_B9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g _1; // extern "Rust" fn(&::"core-0_0_0"::fmt::Void/*S*/, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_03fmt10ArgumentV10g[ (sizeof(struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_03fmt10ArgumentV10g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g) == 8) ? 1 : -1 ];
typedef struct t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g  { struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  DATA[1]; } t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g ; // [::"core-0_0_0"::fmt::ArgumentV1/*S*/; 1]
// struct ::"core-0_0_0"::option::Option#Some<&[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>
struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g  {
	SLICE_PTR _0; // &[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/]
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g[ (sizeof(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g) == 16) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g) == 8) ? 1 : -1 ];
// enum ::"core-0_0_0"::option::Option<&[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>
struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g {
	struct {
		struct s_ZRG2cE9core0_0_06optionG10OptionSome1gBsSG4c_A3fmt2rt2v18Argument0g var_1;
	} DATA;};
typedef char sizeof_assert_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g[ (sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g) == 16) ? 1 : -1 ];
// struct ::"core-0_0_0"::fmt::Arguments
struct s_ZRG2cE9core0_0_03fmt9Arguments0g  {
	SLICE_PTR _0; // &[&str]
	struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g _1; // ::"core-0_0_0"::option::Option<&[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>/*E*/
	SLICE_PTR _2; // &[::"core-0_0_0"::fmt::ArgumentV1/*S*/]
} ;
typedef char sizeof_assert_ZRG2cE9core0_0_03fmt9Arguments0g[ (sizeof(struct s_ZRG2cE9core0_0_03fmt9Arguments0g) == 48) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_03fmt9Arguments0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt9Arguments0g) == 8) ? 1 : -1 ];
typedef void (*t_ZRTF0T0 )(void); // extern "Rust" fn() -> ()
// struct ::"std-0_0_0"::rt::closure#lang_start_0<(),>
struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0  {
	t_ZRTF0T0 _0; // extern "Rust" fn() -> ()
} ;
typedef char sizeof_assert_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0[ (sizeof(struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0) == 8) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0[ (ALIGNOF(struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0) == 8) ? 1 : -1 ];
typedef struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  (*t_ZRTF2BsCiBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g )( uint128_t *, struct s_ZRG2cE9core0_0_03fmt9Formatter0g * ); // extern "Rust" fn(&u128, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
// struct ::"core-0_0_0"::result::Result#Ok<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g  {
	uint8_t _1; // u8
	// ZST; // ()
} __attribute__((__aligned__(1),)) ;
typedef char sizeof_assert_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g[ (sizeof(struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
// struct ::"core-0_0_0"::fmt::Error
struct s_ZRG2cE9core0_0_03fmt5Error0g  {
	char _d;
} __attribute__((__aligned__(1),)) ;
typedef char alignof_assert_ZRG2cE9core0_0_03fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_03fmt5Error0g) == 1) ? 1 : -1 ];
// struct ::"core-0_0_0"::result::Result#Err<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g  {
	uint8_t _1; // u8
	// ZST; // ::"core-0_0_0"::fmt::Error/*S*/
} __attribute__((__aligned__(1),)) ;
typedef char sizeof_assert_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g[ (sizeof(struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g[ (ALIGNOF(struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
// enum ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>
struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g {
	union {
		struct s_ZRG2cE9core0_0_06resultG8ResultOk2gT0G2c_A3fmt5Error0g var_0;
		struct s_ZRG2cE9core0_0_06resultG9ResultErr2gT0G2c_A3fmt5Error0g var_1;
		uint8_t TAG;
	} DATA;
};
typedef char sizeof_assert_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g[ (sizeof(struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g) == 1) ? 1 : -1 ];
typedef struct t_ZRTA2BsCy  { SLICE_PTR  DATA[2]; } t_ZRTA2BsCy ; // [&str; 2]
typedef void (*t_ZRTF1PoT0T0 )( tUNIT * ); // extern "Rust" fn(*move (), ) -> ()
typedef int32_t  (*t_ZRTFeE8rustcall2BsT0T0Cf )( tUNIT *, tUNIT  ); // extern "rust-call" fn(&(), (), ) -> i32
typedef int32_t  (*t_ZRTFeE8rustcall2BuT0T0Cf )( tUNIT *, tUNIT  ); // extern "rust-call" fn(&mut (), (), ) -> i32
// struct ::"core-0_0_0"::ops::function::Fn#vtable<(),i32,>
struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf  {
	t_ZRTF1PoT0T0 _0; // extern "Rust" fn(*move (), ) -> ()
	uintptr_t _1; // usize
	uintptr_t _2; // usize
	t_ZRTFeE8rustcall2BsT0T0Cf _3; // extern "rust-call" fn(&(), (), ) -> i32
	t_ZRTFeE8rustcall2BuT0T0Cf _4; // extern "rust-call" fn(&mut (), (), ) -> i32
} ;
typedef char sizeof_assert_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf[ (sizeof(struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf) == 40) ? 1 : -1 ];
typedef char alignof_assert_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf[ (ALIGNOF(struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf) == 8) ? 1 : -1 ];
// PROTO extern "Rust" ::"bin#"::main
void  ZRG1cD3bin4main0g(void);
// PROTO extern "Rust" ::"std-0_0_0"::rt::lang_start
static intptr_t  ZRG2cD8std0_0_02rt10lang_start0g(
		t_ZRTF0T0 arg0,
		intptr_t arg1,
		uint8_t **arg2
		);
// PROTO extern "Rust" <::"core-0_0_0"::fmt::ArgumentV1/*S*/ /*- */>::new<u128,>
static struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gCi(
		uint128_t *arg0,
		t_ZRTF2BsCiBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g arg1
		);
// PROTO extern "Rust" <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ /*- */>::#drop_glue
static void  ZRIG2cD8std0_0_02rtH19closurelang_start_01gT0A9drop_glue0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0
		);
// PROTO extern "Rust" <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::call
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT04call0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		);
// PROTO extern "Rust" <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(),>>::call_mut
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function5FnMut1gT08call_mut0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		);
// PROTO extern "Rust" <() as ::"std-0_0_0"::process::Termination>::report
static int32_t  ZRQT02cD8std0_0_07process11Termination0g6report0g(
		tUNIT arg0
		);
// EXTERN extern "Rust" ::"std-0_0_0"::io::stdio::_print
extern void  ZRG3cD8std0_0_02io5stdio6_print0g(
		struct s_ZRG2cE9core0_0_03fmt9Arguments0g arg0
		);
// EXTERN extern "Rust" ::"std-0_0_0"::rt::lang_start_internal
extern intptr_t  ZRG2cD8std0_0_02rt19lang_start_internal0g(
		TRAITOBJ_PTR arg0,
		intptr_t arg1,
		uint8_t **arg2
		);
// EXTERN extern "Rust" <u128 as ::"core-0_0_0"::fmt::Display>::fmt
extern struct e_ZRG2cE9core0_0_06result6Result2gT0G2c_A3fmt5Error0g  ZRQCi2cE9core0_0_03fmt7Display0g_B0g(
		uint128_t *arg0,
		struct s_ZRG2cE9core0_0_03fmt9Formatter0g *arg1
		);
union u_static_ZRG2cD3binB_09FRAGMENTS0g{ t_ZRTA2BsCy val; uintptr_t raw[4]; } ZRG2cD3binB_09FRAGMENTS0g;	// static ::"bin#"::#0::FRAGMENTS : [&str; 2]
__attribute__((weak)) union u_static_ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g{ struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf val; uintptr_t raw[5]; } ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g;	// static <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::vtable# : ::"core-0_0_0"::ops::function::Fn#vtable<(),i32,>/*S*/
union u_static_ZRG2cD3binB_09FRAGMENTS0g ZRG2cD3binB_09FRAGMENTS0g = { .raw = {(uintptr_t)"",0x0ull,(uintptr_t)"\n",0x1ull} };	// static ::"bin#"::#0::FRAGMENTS : [&str; 2] = 0010000000000000 0000000000000000 0010000000000000 0100000000000000{@0x0+8 = "", @0x10+8 = "\n"}
union u_static_ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g = { .raw = {(uintptr_t)&ZRIG2cD8std0_0_02rtH19closurelang_start_01gT0A9drop_glue0g,0x8ull,0x8ull,(uintptr_t)&ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT04call0g,(uintptr_t)&ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function5FnMut1gT08call_mut0g} };	// static <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::vtable# : ::"core-0_0_0"::ops::function::Fn#vtable<(),i32,>/*S*/ = 0010000000000000 0800000000000000 0800000000000000 0010000000000000 0010000000000000{@0x0+8 = &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ /*- */>::#drop_glue, @0x18+8 = &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::call, @0x20+8 = &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(),>>::call_mut}
// ::"bin#"::main
void  ZRG1cD3bin4main0g(void)
{
	tUNIT rv;
	uint128_t var0;	// u128
	int8_t var1;	// i8
	int8_t var2;	// i8
	uint8_t var3;	// u8
	uint8_t var4;	// u8
	uint8_t var5;	// u8
	int8_t var6;	// i8
	uint8_t var7;	// u8
	uint8_t var8;	// u8
	uint8_t var9;	// u8
	uint8_t var10;	// u8
	int8_t var11;	// i8
	int8_t var12;	// i8
	uint8_t var13;	// u8
	uint8_t var14;	// u8
	uint8_t var15;	// u8
	int8_t var16;	// i8
	int8_t var17;	// i8
	uint8_t var18;	// u8
	int8_t var19;	// i8
	int8_t var20;	// i8
	uint8_t var21;	// u8
	int8_t var22;	// i8
	uint8_t var23;	// u8
	int8_t var24;	// i8
	uint8_t var25;	// u8
	int8_t var26;	// i8
	int8_t var27;	// i8
	uint8_t var28;	// u8
	int8_t var29;	// i8
	int8_t var30;	// i8
	int8_t var31;	// i8
	uint8_t var32;	// u8
	uint8_t var33;	// u8
	uint8_t var34;	// u8
	uint8_t var35;	// u8
	uint8_t var36;	// u8
	uint8_t var37;	// u8
	uint8_t var38;	// u8
	uint8_t var39;	// u8
	uint8_t var40;	// u8
	int8_t var41;	// i8
	int8_t var42;	// i8
	uint8_t var43;	// u8
	uint8_t var44;	// u8
	uint8_t var45;	// u8
	int8_t var46;	// i8
	int8_t var47;	// i8
	int8_t var48;	// i8
	uint8_t var49;	// u8
	int8_t var50;	// i8
	uint8_t var51;	// u8
	uint8_t var52;	// u8
	uint8_t var53;	// u8
	int8_t var54;	// i8
	int8_t var55;	// i8
	int8_t var56;	// i8
	uint8_t var57;	// u8
	int8_t var58;	// i8
	int8_t var59;	// i8
	uint8_t var60;	// u8
	int8_t var61;	// i8
	uint8_t var62;	// u8
	uint8_t var63;	// u8
	uint8_t var64;	// u8
	uint8_t var65;	// u8
	uint8_t var66;	// u8
	uint8_t var67;	// u8
	uint8_t var68;	// u8
	uint8_t var69;	// u8
	uint8_t var70;	// u8
	uint8_t var71;	// u8
	uint8_t var72;	// u8
	uint8_t var73;	// u8
	uint8_t var74;	// u8
	uint8_t var75;	// u8
	int8_t var76;	// i8
	int8_t var77;	// i8
	int8_t var78;	// i8
	uint8_t var79;	// u8
	uint8_t var80;	// u8
	uint8_t var81;	// u8
	uint8_t var82;	// u8
	uint8_t var83;	// u8
	int8_t var84;	// i8
	int8_t var85;	// i8
	int8_t var86;	// i8
	int8_t var87;	// i8
	uint8_t var88;	// u8
	int8_t var89;	// i8
	int8_t var90;	// i8
	int8_t var91;	// i8
	int8_t var92;	// i8
	int8_t var93;	// i8
	int8_t var94;	// i8
	int8_t var95;	// i8
	uint8_t var96;	// u8
	uint8_t var97;	// u8
	uint8_t var98;	// u8
	uint8_t var99;	// u8
	uint8_t var100;	// u8
	uint8_t var101;	// u8
	uint8_t var102;	// u8
	uint8_t var103;	// u8
	uint8_t var104;	// u8
	uint8_t var105;	// u8
	int8_t var106;	// i8
	int8_t var107;	// i8
	int8_t var108;	// i8
	int8_t var109;	// i8
	int8_t var110;	// i8
	int8_t var111;	// i8
	int8_t var112;	// i8
	int8_t var113;	// i8
	int8_t var114;	// i8
	int8_t var115;	// i8
	int8_t var116;	// i8
	uint8_t var117;	// u8
	uint8_t var118;	// u8
	uint8_t var119;	// u8
	uint8_t var120;	// u8
	uint8_t var121;	// u8
	uint8_t var122;	// u8
	uint8_t var123;	// u8
	uint8_t var124;	// u8
	uint8_t var125;	// u8
	uint8_t var126;	// u8
	uint8_t var127;	// u8
	uint8_t var128;	// u8
	uint8_t var129;	// u8
	uint8_t var130;	// u8
	int8_t var131;	// i8
	int8_t var132;	// i8
	int8_t var133;	// i8
	int8_t var134;	// i8
	int8_t var135;	// i8
	int8_t var136;	// i8
	int8_t var137;	// i8
	uint8_t var138;	// u8
	uint8_t var139;	// u8
	uint8_t var140;	// u8
	uint8_t var141;	// u8
	int8_t var142;	// i8
	int8_t var143;	// i8
	int8_t var144;	// i8
	int8_t var145;	// i8
	int8_t var146;	// i8
	int8_t var147;	// i8
	uint128_t var148;	// u128
	uint128_t var149;	// u128
	uint128_t var150;	// u128
	uint128_t var151;	// u128
	uint128_t var152;	// u128
	uint128_t var153;	// u128
	uint128_t var154;	// u128
	uint128_t var155;	// u128
	uint128_t var156;	// u128
	uint128_t var157;	// u128
	uint128_t var158;	// u128
	uint128_t var159;	// u128
	uint128_t var160;	// u128
	uint128_t var161;	// u128
	uint128_t var162;	// u128
	uint128_t var163;	// u128
	uint128_t var164;	// u128
	uint128_t var165;	// u128
	uint128_t var166;	// u128
	uint128_t var167;	// u128
	uint128_t var168;	// u128
	uint128_t var169;	// u128
	uint128_t var170;	// u128
	uint128_t var171;	// u128
	uint128_t var172;	// u128
	uint128_t var173;	// u128
	uint128_t var174;	// u128
	uint128_t var175;	// u128
	uint128_t var176;	// u128
	uint128_t var177;	// u128
	uint128_t var178;	// u128
	uint128_t var179;	// u128
	uint128_t var180;	// u128
	uint128_t var181;	// u128
	uint128_t var182;	// u128
	uint128_t var183;	// u128
	uint128_t var184;	// u128
	uint128_t var185;	// u128
	uint128_t var186;	// u128
	uint128_t var187;	// u128
	uint128_t var188;	// u128
	uint128_t var189;	// u128
	uint128_t var190;	// u128
	uint128_t var191;	// u128
	uint128_t var192;	// u128
	uint128_t var193;	// u128
	uint128_t var194;	// u128
	uint128_t var195;	// u128
	uint128_t var196;	// u128
	uint128_t var197;	// u128
	uint128_t var198;	// u128
	uint128_t var199;	// u128
	struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g var200;	// ::"core-0_0_0"::fmt::ArgumentV1/*S*/
	t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g var201;	// [::"core-0_0_0"::fmt::ArgumentV1/*S*/; 1]
	t_ZRTA1G2cE9core0_0_03fmt10ArgumentV10g *var202;	// &[::"core-0_0_0"::fmt::ArgumentV1/*S*/; 1]
	tUNIT var203 = {0};	// ()
	uint128_t *var204;	// &u128
	uint8_t var205;	// u8
	uint8_t var206;	// u8
	uint8_t var207;	// u8
	uint8_t var208;	// u8
	uint8_t var209;	// u8
	uint8_t var210;	// u8
	uint8_t var211;	// u8
	uint8_t var212;	// u8
	uint8_t var213;	// u8
	uint8_t var214;	// u8
	uint8_t var215;	// u8
	uint8_t var216;	// u8
	uint8_t var217;	// u8
	uint128_t var218;	// u128
	uint128_t var219;	// u128
	uint128_t var220;	// u128
	uint128_t var221;	// u128
	uint128_t var222;	// u128
	uint128_t var223;	// u128
	uint128_t var224;	// u128
	uint128_t var225;	// u128
	uint128_t var226;	// u128
	struct s_ZRG2cE9core0_0_03fmt9Arguments0g var227;	// ::"core-0_0_0"::fmt::Arguments/*S*/
	struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g var228;	// ::"core-0_0_0"::option::Option<&[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],>/*E*/
	SLICE_PTR var229;	// &[&str]
	SLICE_PTR var230;	// &[::"core-0_0_0"::fmt::ArgumentV1/*S*/]
	var0 = make128_raw(0ull, 0ull);	// _0 = Constant(0x0 u128)
	var1 = -126;	// _1 = Constant(-126 i8)
	var2 = -126;	// _2 = Constant(-126 i8)
	var3 = 0x1;	// _3 = Constant(0x1 u8)
	var4 = 0x57;	// _4 = Constant(0x57 u8)
	var205 = 0x1;	// _205 = Constant(0x1 u8)
	var62 = 0x58;	// _62 = Constant(0x58 u8)
	__builtin_sub_overflow(0x1, 0x87, &var64);
	// ^ Call( _64 = "overflowing_sub"::<u8,>( 0x1 u8, 0x87 u8, ), bb1, bb26)
	var63 = var64 / 0xb5;	// _63 = BinOp(_64 DIV 0xb5 u8)
	var206 = var62 + var63;	// _206 = BinOp(_62 ADD _63)
	__builtin_sub_overflow(var205, var206, &var5);
	// ^ Call( _5 = "overflowing_sub"::<u8,>( _205, _206, ), bb2, bb26)
	var6 = -71;	// _6 = Constant(-71 i8)
	var65 = 0xdb % var3;	// _65 = BinOp(0xdb u8 MOD _3)
	var7 = var65 % 0xf9;	// _7 = BinOp(_65 MOD 0xf9 u8)
	var67 = 0x1d * var7;	// _67 = BinOp(0x1d u8 MUL _7)
	var68 = var4 + 0x9b;	// _68 = BinOp(_4 ADD 0x9b u8)
	var66 = var67 + var68;	// _66 = BinOp(_67 ADD _68)
	__builtin_sub_overflow(var5, 0xd1, &var69);
	// ^ Call( _69 = "overflowing_sub"::<u8,>( _5, 0xd1 u8, ), bb3, bb26)
	var207 = var66 / var69;	// _207 = BinOp(_66 DIV _69)
	__builtin_sub_overflow(var207, 0xe6, &var8);
	// ^ Call( _8 = "overflowing_sub"::<u8,>( _207, 0xe6 u8, ), bb4, bb26)
	var9 = var7 % 0x8c;	// _9 = BinOp(_7 MOD 0x8c u8)
	var70 = 0xfd * var7;	// _70 = BinOp(0xfd u8 MUL _7)
	var73 = 0x59 / var4;	// _73 = BinOp(0x59 u8 DIV _4)
	var72 = var73 * var7;	// _72 = BinOp(_73 MUL _7)
	__builtin_sub_overflow(var8, 0xad, &var75);
	// ^ Call( _75 = "overflowing_sub"::<u8,>( _8, 0xad u8, ), bb5, bb26)
	var74 = var75 / 0xf7;	// _74 = BinOp(_75 DIV 0xf7 u8)
	var71 = var72 * var74;	// _71 = BinOp(_72 MUL _74)
	var10 = var70 * var71;	// _10 = BinOp(_70 MUL _71)
	var77 = 41 / var1;	// _77 = BinOp(+41 i8 DIV _1)
	var78 = -var77;	// _78 = UniOp(_77 NEG)
	var76 = var78 % -18;	// _76 = BinOp(_78 MOD -18 i8)
	var11 = -var76;	// _11 = UniOp(_76 NEG)
	var12 = 6;	// _12 = Constant(+6 i8)
	var79 = var8 + var9;	// _79 = BinOp(_8 ADD _9)
	var81 = var4 * 0x0;	// _81 = BinOp(_4 MUL 0x0 u8)
	var80 = var4 * var81;	// _80 = BinOp(_4 MUL _81)
	var13 = var79 * var80;	// _13 = BinOp(_79 MUL _80)
	var14 = var8;	// _14 = Use(_8)
	var82 = var5 / 0xb0;	// _82 = BinOp(_5 DIV 0xb0 u8)
	var15 = var82 + var3;	// _15 = BinOp(_82 ADD _3)
	var16 = -15;	// _16 = Constant(-15 i8)
	var17 = -14;	// _17 = Constant(-14 i8)
	__builtin_sub_overflow(var9, 0xec, &var83);
	// ^ Call( _83 = "overflowing_sub"::<u8,>( _9, 0xec u8, ), bb6, bb26)
	var18 = 0xac;	// _18 = Constant(0xac u8)
	var84 = 77 - var16;	// _84 = BinOp(+77 i8 SUB _16)
	var19 = -96 + var84;	// _19 = BinOp(-96 i8 ADD _84)
	var20 = 64;	// _20 = Constant(+64 i8)
	var21 = 0xac;	// _21 = Constant(0xac u8)
	var22 = 52;	// _22 = Constant(+52 i8)
	var23 = var5;	// _23 = Use(_5)
	var85 = var6 - -25;	// _85 = BinOp(_6 SUB -25 i8)
	var86 = -var85;	// _86 = UniOp(_85 NEG)
	var87 = -var86;	// _87 = UniOp(_86 NEG)
	var24 = -var87;	// _24 = UniOp(_87 NEG)
	var208 = var8 - 0x13;	// _208 = BinOp(_8 SUB 0x13 u8)
	__builtin_sub_overflow(var13, var208, &var209);
	// ^ Call( _209 = "overflowing_sub"::<u8,>( _13, _208, ), bb7, bb26)
	__builtin_sub_overflow(0xf5, var209, &var88);
	// ^ Call( _88 = "overflowing_sub"::<u8,>( 0xf5 u8, _209, ), bb8, bb26)
	var25 = var88 / var5;	// _25 = BinOp(_88 DIV _5)
	var90 = var17 * 34;	// _90 = BinOp(_17 MUL +34 i8)
	var91 = -var90;	// _91 = UniOp(_90 NEG)
	var89 = 17 + var91;	// _89 = BinOp(+17 i8 ADD _91)
	var26 = var24 % var89;	// _26 = BinOp(_24 MOD _89)
	var92 = -var16;	// _92 = UniOp(_16 NEG)
	var27 = var92 / -19;	// _27 = BinOp(_92 DIV -19 i8)
	var28 = var7;	// _28 = Use(_7)
	var29 = 69;	// _29 = Constant(+69 i8)
	var94 = 3 + var19;	// _94 = BinOp(+3 i8 ADD _19)
	var95 = -var94;	// _95 = UniOp(_94 NEG)
	var93 = var95 / -6;	// _93 = BinOp(_95 DIV -6 i8)
	var30 = -var93;	// _30 = UniOp(_93 NEG)
	var31 = 43;	// _31 = Constant(+43 i8)
	var210 = var3 * var7;	// _210 = BinOp(_3 MUL _7)
	__builtin_sub_overflow(var210, var15, &var97);
	// ^ Call( _97 = "overflowing_sub"::<u8,>( _210, _15, ), bb9, bb26)
	var96 = var97 / 0x64;	// _96 = BinOp(_97 DIV 0x64 u8)
	var32 = var96 % var3;	// _32 = BinOp(_96 MOD _3)
	var33 = 0x1b;	// _33 = Constant(0x1b u8)
	var34 = 0x6;	// _34 = Constant(0x6 u8)
	var99 = 0xb8 % var21;	// _99 = BinOp(0xb8 u8 MOD _21)
	var98 = 0x12 % var99;	// _98 = BinOp(0x12 u8 MOD _99)
	var101 = var23 * var10;	// _101 = BinOp(_23 MUL _10)
	var100 = var23 + var101;	// _100 = BinOp(_23 ADD _101)
	var212 = var98 % var100;	// _212 = BinOp(_98 MOD _100)
	var102 = var32 * var13;	// _102 = BinOp(_32 MUL _13)
	var211 = 0x22 + var102;	// _211 = BinOp(0x22 u8 ADD _102)
	__builtin_sub_overflow(var211, 0xcd, &var213);
	// ^ Call( _213 = "overflowing_sub"::<u8,>( _211, 0xcd u8, ), bb10, bb26)
	__builtin_sub_overflow(var212, var213, &var35);
	// ^ Call( _35 = "overflowing_sub"::<u8,>( _212, _213, ), bb11, bb26)
	var36 = var33;	// _36 = Use(_33)
	var37 = var5;	// _37 = Use(_5)
	var38 = 0x3;	// _38 = Constant(0x3 u8)
	var39 = 0x15;	// _39 = Constant(0x15 u8)
	var40 = var34;	// _40 = Use(_34)
	var41 = -55;	// _41 = Constant(-55 i8)
	var42 = var2 + var29;	// _42 = BinOp(_2 ADD _29)
	var103 = 0x6c * var13;	// _103 = BinOp(0x6c u8 MUL _13)
	var43 = 0x3f * var103;	// _43 = BinOp(0x3f u8 MUL _103)
	var104 = var5 - var4;	// _104 = BinOp(_5 SUB _4)
	var215 = var3 % var104;	// _215 = BinOp(_3 MOD _104)
	var214 = var33 - var15;	// _214 = BinOp(_33 SUB _15)
	__builtin_sub_overflow(var214, var33, &var216);
	// ^ Call( _216 = "overflowing_sub"::<u8,>( _214, _33, ), bb12, bb26)
	__builtin_sub_overflow(var215, var216, &var105);
	// ^ Call( _105 = "overflowing_sub"::<u8,>( _215, _216, ), bb13, bb26)
	var44 = var35 / var105;	// _44 = BinOp(_35 DIV _105)
	var45 = var40;	// _45 = Use(_40)
	var107 = var29 + -29;	// _107 = BinOp(_29 ADD -29 i8)
	var108 = -var107;	// _108 = UniOp(_107 NEG)
	var110 = var31 + var22;	// _110 = BinOp(_31 ADD _22)
	var109 = var19 - var110;	// _109 = BinOp(_19 SUB _110)
	var106 = var108 - var109;	// _106 = BinOp(_108 SUB _109)
	var46 = -var106;	// _46 = UniOp(_106 NEG)
	var47 = -81;	// _47 = Constant(-81 i8)
	var113 = var31 % -83;	// _113 = BinOp(_31 MOD -83 i8)
	var114 = var26 + var20;	// _114 = BinOp(_26 ADD _20)
	var112 = var113 - var114;	// _112 = BinOp(_113 SUB _114)
	var111 = var112 % 69;	// _111 = BinOp(_112 MOD +69 i8)
	var48 = var111 / 24;	// _48 = BinOp(_111 DIV +24 i8)
	var49 = var10;	// _49 = Use(_10)
	var115 = var48 / -30;	// _115 = BinOp(_48 DIV -30 i8)
	var116 = -var115;	// _116 = UniOp(_115 NEG)
	var50 = -var116;	// _50 = UniOp(_116 NEG)
	var119 = 0xb8 * var10;	// _119 = BinOp(0xb8 u8 MUL _10)
	var118 = 0xa4 * var119;	// _118 = BinOp(0xa4 u8 MUL _119)
	var121 = var43 * var7;	// _121 = BinOp(_43 MUL _7)
	var120 = 0x6e * var121;	// _120 = BinOp(0x6e u8 MUL _121)
	var117 = var118 * var120;	// _117 = BinOp(_118 MUL _120)
	var124 = var37 + var32;	// _124 = BinOp(_37 ADD _32)
	var123 = 0x7e / var124;	// _123 = BinOp(0x7e u8 DIV _124)
	var122 = 0x5b * var123;	// _122 = BinOp(0x5b u8 MUL _123)
	var51 = var117 - var122;	// _51 = BinOp(_117 SUB _122)
	var127 = var18 % 0xc8;	// _127 = BinOp(_18 MOD 0xc8 u8)
	var126 = var127 % var21;	// _126 = BinOp(_127 MOD _21)
	var125 = var10 * var126;	// _125 = BinOp(_10 MUL _126)
	var130 = 0xb1 / var37;	// _130 = BinOp(0xb1 u8 DIV _37)
	var129 = var130 % var18;	// _129 = BinOp(_130 MOD _18)
	var128 = var129 + var15;	// _128 = BinOp(_129 ADD _15)
	var52 = var125 * var128;	// _52 = BinOp(_125 MUL _128)
	var53 = 0x42;	// _53 = Constant(0x42 u8)
	var132 = var17 - -32;	// _132 = BinOp(_17 SUB -32 i8)
	var131 = -68 / var132;	// _131 = BinOp(-68 i8 DIV _132)
	var135 = var12 - -118;	// _135 = BinOp(_12 SUB -118 i8)
	var134 = var135 / 10;	// _134 = BinOp(_135 DIV +10 i8)
	var133 = var134 + var12;	// _133 = BinOp(_134 ADD _12)
	var54 = var131 - var133;	// _54 = BinOp(_131 SUB _133)
	var137 = -54 - var48;	// _137 = BinOp(-54 i8 SUB _48)
	var136 = 120 + var137;	// _136 = BinOp(+120 i8 ADD _137)
	var55 = -var136;	// _55 = UniOp(_136 NEG)
	var56 = var17 * var30;	// _56 = BinOp(_17 MUL _30)
	var57 = 0x23;	// _57 = Constant(0x23 u8)
	var139 = var8 / 0x41;	// _139 = BinOp(_8 DIV 0x41 u8)
	var140 = var34 - var43;	// _140 = BinOp(_34 SUB _43)
	var138 = var139 / var140;	// _138 = BinOp(_139 DIV _140)
	var217 = var138 % 0xba;	// _217 = BinOp(_138 MOD 0xba u8)
	__builtin_sub_overflow(var217, 0x6, &var141);
	// ^ Call( _141 = "overflowing_sub"::<u8,>( _217, 0x6 u8, ), bb14, bb26)
	var58 = 0;	// _58 = Constant(+0 i8)
	var59 = -22;	// _59 = Constant(-22 i8)
	var60 = 0xf6;	// _60 = Constant(0xf6 u8)
	var144 = var31 * var27;	// _144 = BinOp(_31 MUL _27)
	var143 = -71 - var144;	// _143 = BinOp(-71 i8 SUB _144)
	var142 = var143 - var42;	// _142 = BinOp(_143 SUB _42)
	var147 = -var2;	// _147 = UniOp(_2 NEG)
	var146 = var147 % -16;	// _146 = BinOp(_147 MOD -16 i8)
	var145 = var146 / -102;	// _145 = BinOp(_146 DIV -102 i8)
	var61 = var142 * var145;	// _61 = BinOp(_142 MUL _145)
	var148.lo = var1; var148.hi = var1 < 0 ? -1 : 0;	// _148 = Cast(_1 as u128)
	var0 = add128(var0, var148);	// _0 = BinOp(_0 ADD _148)
	var149.lo = var10; var149.hi = var10 < 0 ? -1 : 0;	// _149 = Cast(_10 as u128)
	var0 = add128(var0, var149);	// _0 = BinOp(_0 ADD _149)
	var150.lo = var11; var150.hi = var11 < 0 ? -1 : 0;	// _150 = Cast(_11 as u128)
	var0 = add128(var0, var150);	// _0 = BinOp(_0 ADD _150)
	var218.lo = var12; var218.hi = var12 < 0 ? -1 : 0;	// _218 = Cast(_12 as u128)
	sub128_o(var0, var218, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _218, ), bb15, bb26)
	var151.lo = var13; var151.hi = var13 < 0 ? -1 : 0;	// _151 = Cast(_13 as u128)
	var0 = add128(var0, var151);	// _0 = BinOp(_0 ADD _151)
	var152.lo = var14; var152.hi = var14 < 0 ? -1 : 0;	// _152 = Cast(_14 as u128)
	var0 = add128(var0, var152);	// _0 = BinOp(_0 ADD _152)
	var153.lo = var15; var153.hi = var15 < 0 ? -1 : 0;	// _153 = Cast(_15 as u128)
	var0 = add128(var0, var153);	// _0 = BinOp(_0 ADD _153)
	var219.lo = var16; var219.hi = var16 < 0 ? -1 : 0;	// _219 = Cast(_16 as u128)
	sub128_o(var0, var219, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _219, ), bb16, bb26)
	var220.lo = var17; var220.hi = var17 < 0 ? -1 : 0;	// _220 = Cast(_17 as u128)
	sub128_o(var0, var220, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _220, ), bb17, bb26)
	var154.lo = var18; var154.hi = var18 < 0 ? -1 : 0;	// _154 = Cast(_18 as u128)
	var0 = sub128(var0, var154);	// _0 = BinOp(_0 SUB _154)
	var221.lo = var19; var221.hi = var19 < 0 ? -1 : 0;	// _221 = Cast(_19 as u128)
	sub128_o(var0, var221, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _221, ), bb18, bb26)
	var222.lo = var2; var222.hi = var2 < 0 ? -1 : 0;	// _222 = Cast(_2 as u128)
	sub128_o(var0, var222, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _222, ), bb19, bb26)
	var155.lo = var20; var155.hi = var20 < 0 ? -1 : 0;	// _155 = Cast(_20 as u128)
	var0 = add128(var0, var155);	// _0 = BinOp(_0 ADD _155)
	var156.lo = var21; var156.hi = var21 < 0 ? -1 : 0;	// _156 = Cast(_21 as u128)
	var0 = sub128(var0, var156);	// _0 = BinOp(_0 SUB _156)
	var157.lo = var22; var157.hi = var22 < 0 ? -1 : 0;	// _157 = Cast(_22 as u128)
	var0 = add128(var0, var157);	// _0 = BinOp(_0 ADD _157)
	var158.lo = var23; var158.hi = var23 < 0 ? -1 : 0;	// _158 = Cast(_23 as u128)
	var0 = add128(var0, var158);	// _0 = BinOp(_0 ADD _158)
	var159.lo = var24; var159.hi = var24 < 0 ? -1 : 0;	// _159 = Cast(_24 as u128)
	var0 = sub128(var0, var159);	// _0 = BinOp(_0 SUB _159)
	var160.lo = var25; var160.hi = var25 < 0 ? -1 : 0;	// _160 = Cast(_25 as u128)
	var0 = add128(var0, var160);	// _0 = BinOp(_0 ADD _160)
	var161.lo = var26; var161.hi = var26 < 0 ? -1 : 0;	// _161 = Cast(_26 as u128)
	var0 = add128(var0, var161);	// _0 = BinOp(_0 ADD _161)
	var162.lo = var27; var162.hi = var27 < 0 ? -1 : 0;	// _162 = Cast(_27 as u128)
	var0 = add128(var0, var162);	// _0 = BinOp(_0 ADD _162)
	var163.lo = var28; var163.hi = var28 < 0 ? -1 : 0;	// _163 = Cast(_28 as u128)
	var0 = add128(var0, var163);	// _0 = BinOp(_0 ADD _163)
	var164.lo = var29; var164.hi = var29 < 0 ? -1 : 0;	// _164 = Cast(_29 as u128)
	var0 = sub128(var0, var164);	// _0 = BinOp(_0 SUB _164)
	var165.lo = var3; var165.hi = var3 < 0 ? -1 : 0;	// _165 = Cast(_3 as u128)
	var0 = add128(var0, var165);	// _0 = BinOp(_0 ADD _165)
	var166.lo = var30; var166.hi = var30 < 0 ? -1 : 0;	// _166 = Cast(_30 as u128)
	var0 = add128(var0, var166);	// _0 = BinOp(_0 ADD _166)
	var167.lo = var31; var167.hi = var31 < 0 ? -1 : 0;	// _167 = Cast(_31 as u128)
	var0 = add128(var0, var167);	// _0 = BinOp(_0 ADD _167)
	var168.lo = var32; var168.hi = var32 < 0 ? -1 : 0;	// _168 = Cast(_32 as u128)
	var0 = add128(var0, var168);	// _0 = BinOp(_0 ADD _168)
	var169.lo = var33; var169.hi = var33 < 0 ? -1 : 0;	// _169 = Cast(_33 as u128)
	var0 = add128(var0, var169);	// _0 = BinOp(_0 ADD _169)
	var170.lo = var34; var170.hi = var34 < 0 ? -1 : 0;	// _170 = Cast(_34 as u128)
	var0 = sub128(var0, var170);	// _0 = BinOp(_0 SUB _170)
	var171.lo = var35; var171.hi = var35 < 0 ? -1 : 0;	// _171 = Cast(_35 as u128)
	var0 = sub128(var0, var171);	// _0 = BinOp(_0 SUB _171)
	var172.lo = var36; var172.hi = var36 < 0 ? -1 : 0;	// _172 = Cast(_36 as u128)
	var0 = add128(var0, var172);	// _0 = BinOp(_0 ADD _172)
	var173.lo = var37; var173.hi = var37 < 0 ? -1 : 0;	// _173 = Cast(_37 as u128)
	var0 = sub128(var0, var173);	// _0 = BinOp(_0 SUB _173)
	var174.lo = var38; var174.hi = var38 < 0 ? -1 : 0;	// _174 = Cast(_38 as u128)
	var0 = add128(var0, var174);	// _0 = BinOp(_0 ADD _174)
	var175.lo = var39; var175.hi = var39 < 0 ? -1 : 0;	// _175 = Cast(_39 as u128)
	var0 = add128(var0, var175);	// _0 = BinOp(_0 ADD _175)
	var176.lo = var4; var176.hi = var4 < 0 ? -1 : 0;	// _176 = Cast(_4 as u128)
	var0 = add128(var0, var176);	// _0 = BinOp(_0 ADD _176)
	var177.lo = var40; var177.hi = var40 < 0 ? -1 : 0;	// _177 = Cast(_40 as u128)
	var0 = add128(var0, var177);	// _0 = BinOp(_0 ADD _177)
	var223.lo = var41; var223.hi = var41 < 0 ? -1 : 0;	// _223 = Cast(_41 as u128)
	sub128_o(var0, var223, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _223, ), bb20, bb26)
	var224.lo = var42; var224.hi = var42 < 0 ? -1 : 0;	// _224 = Cast(_42 as u128)
	sub128_o(var0, var224, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _224, ), bb21, bb26)
	var178.lo = var43; var178.hi = var43 < 0 ? -1 : 0;	// _178 = Cast(_43 as u128)
	var0 = add128(var0, var178);	// _0 = BinOp(_0 ADD _178)
	var179.lo = var44; var179.hi = var44 < 0 ? -1 : 0;	// _179 = Cast(_44 as u128)
	var0 = add128(var0, var179);	// _0 = BinOp(_0 ADD _179)
	var180.lo = var45; var180.hi = var45 < 0 ? -1 : 0;	// _180 = Cast(_45 as u128)
	var0 = add128(var0, var180);	// _0 = BinOp(_0 ADD _180)
	var181.lo = var46; var181.hi = var46 < 0 ? -1 : 0;	// _181 = Cast(_46 as u128)
	var0 = sub128(var0, var181);	// _0 = BinOp(_0 SUB _181)
	var182.lo = var47; var182.hi = var47 < 0 ? -1 : 0;	// _182 = Cast(_47 as u128)
	var0 = add128(var0, var182);	// _0 = BinOp(_0 ADD _182)
	var225.lo = var48; var225.hi = var48 < 0 ? -1 : 0;	// _225 = Cast(_48 as u128)
	sub128_o(var0, var225, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _225, ), bb22, bb26)
	var183.lo = var49; var183.hi = var49 < 0 ? -1 : 0;	// _183 = Cast(_49 as u128)
	var0 = add128(var0, var183);	// _0 = BinOp(_0 ADD _183)
	var184.lo = var5; var184.hi = var5 < 0 ? -1 : 0;	// _184 = Cast(_5 as u128)
	var0 = sub128(var0, var184);	// _0 = BinOp(_0 SUB _184)
	var185.lo = var50; var185.hi = var50 < 0 ? -1 : 0;	// _185 = Cast(_50 as u128)
	var0 = add128(var0, var185);	// _0 = BinOp(_0 ADD _185)
	var186.lo = var51; var186.hi = var51 < 0 ? -1 : 0;	// _186 = Cast(_51 as u128)
	var0 = add128(var0, var186);	// _0 = BinOp(_0 ADD _186)
	var187.lo = var52; var187.hi = var52 < 0 ? -1 : 0;	// _187 = Cast(_52 as u128)
	var0 = add128(var0, var187);	// _0 = BinOp(_0 ADD _187)
	var188.lo = var53; var188.hi = var53 < 0 ? -1 : 0;	// _188 = Cast(_53 as u128)
	var0 = add128(var0, var188);	// _0 = BinOp(_0 ADD _188)
	var189.lo = var54; var189.hi = var54 < 0 ? -1 : 0;	// _189 = Cast(_54 as u128)
	var0 = add128(var0, var189);	// _0 = BinOp(_0 ADD _189)
	var226.lo = var55; var226.hi = var55 < 0 ? -1 : 0;	// _226 = Cast(_55 as u128)
	sub128_o(var0, var226, &var0);
	// ^ Call( _0 = "overflowing_sub"::<u128,>( _0, _226, ), bb23, bb26)
	var190.lo = var56; var190.hi = var56 < 0 ? -1 : 0;	// _190 = Cast(_56 as u128)
	var0 = add128(var0, var190);	// _0 = BinOp(_0 ADD _190)
	var191.lo = var57; var191.hi = var57 < 0 ? -1 : 0;	// _191 = Cast(_57 as u128)
	var0 = add128(var0, var191);	// _0 = BinOp(_0 ADD _191)
	var192.lo = var58; var192.hi = var58 < 0 ? -1 : 0;	// _192 = Cast(_58 as u128)
	var0 = add128(var0, var192);	// _0 = BinOp(_0 ADD _192)
	var193.lo = var59; var193.hi = var59 < 0 ? -1 : 0;	// _193 = Cast(_59 as u128)
	var0 = sub128(var0, var193);	// _0 = BinOp(_0 SUB _193)
	var194.lo = var6; var194.hi = var6 < 0 ? -1 : 0;	// _194 = Cast(_6 as u128)
	var0 = add128(var0, var194);	// _0 = BinOp(_0 ADD _194)
	var195.lo = var60; var195.hi = var60 < 0 ? -1 : 0;	// _195 = Cast(_60 as u128)
	var0 = sub128(var0, var195);	// _0 = BinOp(_0 SUB _195)
	var196.lo = var61; var196.hi = var61 < 0 ? -1 : 0;	// _196 = Cast(_61 as u128)
	var0 = add128(var0, var196);	// _0 = BinOp(_0 ADD _196)
	var197.lo = var7; var197.hi = var7 < 0 ? -1 : 0;	// _197 = Cast(_7 as u128)
	var0 = add128(var0, var197);	// _0 = BinOp(_0 ADD _197)
	var198.lo = var8; var198.hi = var8 < 0 ? -1 : 0;	// _198 = Cast(_8 as u128)
	var0 = add128(var0, var198);	// _0 = BinOp(_0 ADD _198)
	var199.lo = var9; var199.hi = var9 < 0 ? -1 : 0;	// _199 = Cast(_9 as u128)
	var0 = add128(var0, var199);	// _0 = BinOp(_0 ADD _199)
	var204 = & var0;	// _204 = Borrow(Shared, _0)
	var229 = make_sliceptr(&ZRG2cD3binB_09FRAGMENTS0g.val, 0x2ull);	// _229 = MakeDst(&::"bin#"::#0::FRAGMENTS, 0x2 usize)
	var200 = ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gCi( var204, ZRQCi2cE9core0_0_03fmt7Display0g_B0g );
	// ^ Call( _200 = <::"core-0_0_0"::fmt::ArgumentV1/*S*/ /*- */>::new<u128,>( _204, &<u128 as ::"core-0_0_0"::fmt::Display>::fmt, ), bb24, bb26)
	var201.DATA[0] = var200;	// _201 = Array(_200)
	var202 = & var201;	// _202 = Borrow(Shared, _201)
	var230 = make_sliceptr(var202, 0x1ull);	// _230 = MakeDst(_202, 0x1 usize)
	memset(&var228, 0, sizeof(struct e_ZRG2cE9core0_0_06option6Option1gBsSG4c_A3fmt2rt2v18Argument0g ));	// _228 = Variant(::"core-0_0_0"::option::Option<&[::"core-0_0_0"::fmt::rt::v1::Argument/*S*/],> #0, {})
	var227._0 = var229;
	var227._1 = var228;
	var227._2 = var230;	// _227 = Struct(::"core-0_0_0"::fmt::Arguments, {_229, _228, _230})
	ZRG3cD8std0_0_02io5stdio6_print0g( var227 );
	// ^ Call( _203 = ::"std-0_0_0"::io::stdio::_print( _227, ), bb25, bb26)
	/* ZST assign */
	return ;
	// ^ Return
bb26: _Unwind_Resume(); // Diverge
}
// ::"std-0_0_0"::rt::lang_start
static intptr_t  ZRG2cD8std0_0_02rt10lang_start0g(
		t_ZRTF0T0 arg0,
		intptr_t arg1,
		uint8_t **arg2
		)
{
	intptr_t rv;
	struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 var0;	// ::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/
	struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *var1;	// &::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/
	TRAITOBJ_PTR var2;	// &dyn (::"core-0_0_0"::ops::function::Fn<(),Output{::"core-0_0_0"::ops::function::FnOnce<(),>}=i32,>+::"core-0_0_0"::marker::Sync+::"std-0_0_0"::panic::RefUnwindSafe+'_)
	var0._0 = arg0;	// _0 = Struct(::"std-0_0_0"::rt::closure#lang_start_0<(),>, {a0})
	var1 = & var0;	// _1 = Borrow(Shared, _0)
	var2 = make_traitobjptr(var1, &ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g.val);	// _2 = MakeDst(_1, &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::vtable#)
	rv = ZRG2cD8std0_0_02rt19lang_start_internal0g( var2, arg1, arg2 );
	// ^ Call( retval = ::"std-0_0_0"::rt::lang_start_internal( _2, a1, a2, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"core-0_0_0"::fmt::ArgumentV1/*S*/ /*- */>::new<u128,>
static struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g  ZRIG2cE9core0_0_03fmt10ArgumentV10g3new1gCi(
		uint128_t *arg0,
		t_ZRTF2BsCiBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g arg1
		)
{
	struct s_ZRG2cE9core0_0_03fmt10ArgumentV10g rv;
	t_ZRTF2BsG2cE9core0_0_03fmt4Void0gBuG2c_A_B9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g var0;	// extern "Rust" fn(&::"core-0_0_0"::fmt::Void/*S*/, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/
	struct s_ZRG2cE9core0_0_03fmt4Void0g *var1;	// &::"core-0_0_0"::fmt::Void/*S*/
	memcpy( &var0, &arg1, sizeof(t_ZRTF2BsCiBuG2cE9core0_0_03fmt9Formatter0gG2c_A6result6Result2gT0G2c_A_B5Error0g ));
	// ^ Call( _0 = "transmute"::<extern "Rust" fn(&u128, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/,extern "Rust" fn(&::"core-0_0_0"::fmt::Void/*S*/, &mut ::"core-0_0_0"::fmt::Formatter/*S*/, ) -> ::"core-0_0_0"::result::Result<(),::"core-0_0_0"::fmt::Error/*S*/,>/*E*/,>( a1, ), bb1, bb3)
	var1 = (void*)arg0;
	// ^ Call( _1 = "transmute"::<&u128,&::"core-0_0_0"::fmt::Void/*S*/,>( a0, ), bb2, bb3)
	rv._0 = var1;
	rv._1 = var0;	// retval = Struct(::"core-0_0_0"::fmt::ArgumentV1, {_1, _0})
	return rv;
	// ^ Return
bb3: _Unwind_Resume(); // Diverge
}
// <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ /*- */>::#drop_glue
static void  ZRIG2cD8std0_0_02rtH19closurelang_start_01gT0A9drop_glue0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0
		)
{
	tUNIT rv;
	/* ZST assign */
	return ;
	// ^ Return
}
// <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::call
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT04call0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		)
{
	int32_t rv;
	t_ZRTF0T0 var0;	// extern "Rust" fn() -> ()
	tUNIT var1 = {0};	// ()
	var0 = arg0->_0;	// _0 = Use(a0*.0)
	(var0)( );
	// ^ Call( _1 = (_0)( ), bb1, bb2)
	rv = 0;	// retval = Constant(+0 i32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(),>>::call_mut
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function5FnMut1gT08call_mut0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		)
{
	int32_t rv;
	t_ZRTF0T0 var0;	// extern "Rust" fn() -> ()
	tUNIT var1 = {0};	// ()
	var0 = arg0->_0;	// _0 = Use(a0*.0)
	(var0)( );
	// ^ Call( _1 = (_0)( ), bb1, bb2)
	rv = 0;	// retval = Constant(+0 i32)
	// ^ drop(a0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <() as ::"std-0_0_0"::process::Termination>::report
static int32_t  ZRQT02cD8std0_0_07process11Termination0g6report0g(
		tUNIT arg0
		)
{
	int32_t rv;
	rv = 0;	// retval = Constant(+0 i32)
	return rv;
	// ^ Return
}
int main(int argc, const char* argv[]) {
	return ZRG2cD8std0_0_02rt10lang_start0g(ZRG1cD3bin4main0g, argc, (uint8_t**)argv);
}
__thread jmp_buf* mrustc_panic_target;
__thread void* mrustc_panic_value;
int8_t* __rust_alloc(uintptr_t a0, uintptr_t a1) {
	extern int8_t* __rdl_alloc(uintptr_t a0, uintptr_t a1);
	return __rdl_alloc(a0, a1);
}
void __rust_dealloc(int8_t* a0, uintptr_t a1, uintptr_t a2) {
	extern void __rdl_dealloc(int8_t* a0, uintptr_t a1, uintptr_t a2);
	__rdl_dealloc(a0, a1, a2);
}
int8_t* __rust_realloc(int8_t* a0, uintptr_t a1, uintptr_t a2, uintptr_t a3) {
	extern int8_t* __rdl_realloc(int8_t* a0, uintptr_t a1, uintptr_t a2, uintptr_t a3);
	return __rdl_realloc(a0, a1, a2, a3);
}
int8_t* __rust_alloc_zeroed(uintptr_t a0, uintptr_t a1) {
	extern int8_t* __rdl_alloc_zeroed(uintptr_t a0, uintptr_t a1);
	return __rdl_alloc_zeroed(a0, a1);
}
struct s_ZRG2c4core5alloc6Layout0g_A { uintptr_t a, b; };
void oom_impl(struct s_ZRG2c4core5alloc6Layout0g_A l) { extern void ZRG2cD8std0_0_05alloc8rust_oom0g(struct s_ZRG2c4core5alloc6Layout0g_A l); ZRG2cD8std0_0_05alloc8rust_oom0g(l); }
uint32_t panic_impl(uintptr_t payload) {extern uint32_t ZRG2cD8std0_0_09panicking16rust_begin_panic0g(uintptr_t payload);return ZRG2cD8std0_0_09panicking16rust_begin_panic0g(payload);}
