/*
 * AUTOGENERATED by mrustc
 */
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <assert.h>
#include <stdatomic.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <setjmp.h>
typedef uint32_t RUST_CHAR;
typedef uint8_t RUST_BOOL;
typedef struct { void* PTR; size_t META; } SLICE_PTR;
typedef struct { void* PTR; void* META; } TRAITOBJ_PTR;
typedef struct { void (*drop)(void*); size_t size; size_t align; } VTABLE_HDR;
typedef struct { char _d; } tUNIT;
typedef char tBANG;
typedef struct { char _d; } tTYPEID;
static inline size_t ALIGN_TO(size_t s, size_t a) { return (s + a-1) / a * a; }

extern void _Unwind_Resume(void) __attribute__((noreturn));
#define ALIGNOF(t) __alignof__(t)
extern __thread jmp_buf*    mrustc_panic_target;
extern __thread void* mrustc_panic_value;
static inline uint64_t __builtin_clz64(uint64_t v) {
	return ( (v >> 32) != 0 ? __builtin_clz(v>>32) : 32 + __builtin_clz(v));
}
static inline uint64_t __builtin_ctz64(uint64_t v) {
	return ((v&0xFFFFFFFF) == 0 ? __builtin_ctz(v>>32) + 32 : __builtin_ctz(v));
}
static inline uint8_t __mrustc_atomicloop8(volatile uint8_t* slot, uint8_t param, int ordering, uint8_t (*cb)(uint8_t, uint8_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint8_t v = atomic_load_explicit((_Atomic uint8_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint8_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint16_t __mrustc_atomicloop16(volatile uint16_t* slot, uint16_t param, int ordering, uint16_t (*cb)(uint16_t, uint16_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint16_t v = atomic_load_explicit((_Atomic uint16_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint16_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint32_t __mrustc_atomicloop32(volatile uint32_t* slot, uint32_t param, int ordering, uint32_t (*cb)(uint32_t, uint32_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint32_t v = atomic_load_explicit((_Atomic uint32_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint32_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
static inline uint64_t __mrustc_atomicloop64(volatile uint64_t* slot, uint64_t param, int ordering, uint64_t (*cb)(uint64_t, uint64_t)) { int ordering_load = (ordering == memory_order_release || ordering == memory_order_acq_rel ? memory_order_relaxed : ordering); for(;;) { uint64_t v = atomic_load_explicit((_Atomic uint64_t*)slot, ordering_load); if( atomic_compare_exchange_strong_explicit((_Atomic uint64_t*)slot, &v, cb(v, param), ordering, ordering_load) ) return v; }}
typedef struct { uint64_t lo, hi; } uint128_t;
typedef struct { uint64_t lo, hi; } int128_t;
static inline float make_float(int is_neg, int exp, uint32_t mantissa_bits) { float rv; uint32_t vi=(mantissa_bits&((1<<23)-1))|((exp+127)<<23);if(is_neg)vi|=1<<31; memcpy(&rv, &vi, 4); return rv; }
static inline double make_double(int is_neg, int exp, uint32_t mantissa_bits) { double rv; uint64_t vi=(mantissa_bits&((1ull<<52)-1))|((uint64_t)(exp+1023)<<52);if(is_neg)vi|=1ull<<63; memcpy(&rv, &vi, 4); return rv; }
static inline uint128_t make128_raw(uint64_t hi, uint64_t lo) { uint128_t rv = { lo, hi }; return rv; }
static inline uint128_t make128(uint64_t v) { uint128_t rv = { v, 0 }; return rv; }
static inline float cast128_float(uint128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint32_t mant = 0; return make_float(0, exp, mant); }
static inline double cast128_double(uint128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint64_t mant = 0; return make_double(0, exp, mant); }
static inline int cmp128(uint128_t a, uint128_t b) { if(a.hi != b.hi) return a.hi < b.hi ? -1 : 1; if(a.lo != b.lo) return a.lo < b.lo ? -1 : 1; return 0; }
static inline bool add128_o(uint128_t a, uint128_t b, uint128_t* o) { o->lo = a.lo + b.lo; o->hi = a.hi + b.hi + (o->lo < a.lo ? 1 : 0); return (o->hi < a.hi); }
static inline bool sub128_o(uint128_t a, uint128_t b, uint128_t* o) { o->lo = a.lo - b.lo; o->hi = a.hi - b.hi - (a.lo < b.lo ? 1 : 0); return (o->hi > a.hi); }
static inline bool mul128_o(uint128_t a, uint128_t b, uint128_t* o) { bool of = false; o->hi = 0; o->lo = 0; for(int i=0;i<128;i++){ uint64_t m = (1ull << (i % 64)); if(a.hi==0&&a.lo<m)   break; if(i>=64&&a.hi<m) break; if( m & (i >= 64 ? a.hi : a.lo) ) of |= add128_o(*o, b, o); b.hi = (b.hi << 1) | (b.lo >> 63); b.lo = (b.lo << 1); } return of;}
static inline bool div128_o(uint128_t a, uint128_t b, uint128_t* q, uint128_t* r) { if(a.hi == 0 && b.hi == 0) { if(q) { q->hi=0; q->lo = a.lo / b.lo; } if(r) { r->hi=0; r->lo = a.lo % b.lo; } return false; } if(cmp128(a, b) < 0) { if(q) { q->hi=0; q->lo=0; } if(r) *r = a; return false; } uint128_t a_div_2 = {(a.lo>>1)|(a.hi << 63), a.hi>>1}; int shift = 0; while( cmp128(a_div_2, b) >= 0 && shift < 128 ) { shift += 1; b.hi = (b.hi<<1)|(b.lo>>63); b.lo <<= 1; } if(shift == 128) return true; uint128_t mask = { /*lo=*/(shift >= 64 ? 0 : (1ull << shift)), /*hi=*/(shift < 64 ? 0 : 1ull << (shift-64)) }; shift ++; if(q) { q->hi = 0; q->lo = 0; } while(shift--) { if( cmp128(a, b) >= 0 ) { if(q) add128_o(*q, mask, q); sub128_o(a, b, &a); } mask.lo = (mask.lo >> 1) | (mask.hi << 63); mask.hi >>= 1; b.lo = (b.lo >> 1) | (b.hi << 63); b.hi >>= 1; } if(r) *r = a; return false;}
static inline uint128_t add128(uint128_t a, uint128_t b) { uint128_t v; add128_o(a, b, &v); return v; }
static inline uint128_t sub128(uint128_t a, uint128_t b) { uint128_t v; sub128_o(a, b, &v); return v; }
static inline uint128_t mul128(uint128_t a, uint128_t b) { uint128_t v; mul128_o(a, b, &v); return v; }
static inline uint128_t div128(uint128_t a, uint128_t b) { uint128_t v; div128_o(a, b, &v, NULL); return v; }
static inline uint128_t mod128(uint128_t a, uint128_t b) { uint128_t v; div128_o(a, b, NULL, &v); return v;}
static inline uint128_t and128(uint128_t a, uint128_t b) { uint128_t v = { a.lo & b.lo, a.hi & b.hi }; return v; }
static inline uint128_t or128 (uint128_t a, uint128_t b) { uint128_t v = { a.lo | b.lo, a.hi | b.hi }; return v; }
static inline uint128_t xor128(uint128_t a, uint128_t b) { uint128_t v = { a.lo ^ b.lo, a.hi ^ b.hi }; return v; }
static inline uint128_t shl128(uint128_t a, uint32_t b) { uint128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = a.lo << b; v.hi = (a.hi << b) | (a.lo >> (64 - b)); } else { v.hi = a.lo << (b - 64); v.lo = 0; } return v; }
static inline uint128_t shr128(uint128_t a, uint32_t b) { uint128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = (a.lo >> b)|(a.hi << (64 - b)); v.hi = a.hi >> b; } else { v.lo = a.hi >> (b - 64); v.hi = 0; } return v; }
static inline uint128_t popcount128(uint128_t a) { uint128_t v = { __builtin_popcountll(a.lo) + __builtin_popcountll(a.hi), 0 }; return v; }
static inline uint128_t __builtin_bswap128(uint128_t v) { uint128_t rv = { __builtin_bswap64(v.hi), __builtin_bswap64(v.lo) }; return rv; }
static inline uint128_t intrinsic_ctlz_u128(uint128_t v) {
	uint128_t rv = { (v.hi != 0 ? __builtin_clz64(v.hi) : (v.lo != 0 ? 64 + __builtin_clz64(v.lo) : 128)), 0 };
	return rv;
}
static inline uint128_t intrinsic_cttz_u128(uint128_t v) {
	uint128_t rv = { (v.lo == 0 ? (v.hi == 0 ? 128 : __builtin_ctz64(v.hi) + 64) : __builtin_ctz64(v.lo)), 0 };
	return rv;
}
static inline int128_t make128s_raw(uint64_t hi, uint64_t lo) { int128_t rv = { lo, hi }; return rv; }
static inline int128_t make128s(int64_t v) { int128_t rv = { v, (v < 0 ? -1 : 0) }; return rv; }
static inline int128_t neg128s(int128_t v) { int128_t rv = { ~v.lo+1, ~v.hi + (v.lo == 0) }; return rv; }
static inline float cast128s_float(int128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint32_t mant = 0; return make_float(0, exp, mant); }
static inline double cast128s_double(int128_t v) { if(v.hi == 0) return v.lo; int exp = 0; uint64_t mant = 0; return make_double(0, exp, mant); }
static inline int cmp128s(int128_t a, int128_t b) { if(a.hi != b.hi) return (int64_t)a.hi < (int64_t)b.hi ? -1 : 1; if(a.lo != b.lo) return a.lo < b.lo ? -1 : 1; return 0; }
static inline bool add128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna=a.hi>>63; bool sgnb=b.hi>>63; add128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); bool sgno = o->hi>>63; return (sgna==sgnb && sgno != sgna); }
static inline bool sub128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna=a.hi>>63; bool sgnb=b.hi>>63; sub128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); bool sgno = o->hi>>63; return (sgna!=sgnb && sgno != sgna); }
static inline bool mul128s_o(int128_t a, int128_t b, int128_t* o) { bool sgna = (a.hi >> 63); bool sgnb = (b.hi >> 63); if(sgna) a = neg128s(a); if(sgnb) b = neg128s(b); bool rv = mul128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)o); if(sgnb != sgnb) *o = neg128s(*o); return rv; }
static inline bool div128s_o(int128_t a, int128_t b, int128_t* q, int128_t* r) { bool sgna = a.hi & (1ull<<63); bool sgnb = b.hi & (1ull<<63); if(sgna) { a.hi = ~a.hi; a.lo = ~a.lo; a.lo += 1; if(a.lo == 0) a.hi += 1; } if(sgnb) { b.hi = ~b.hi; b.lo = ~b.lo; b.lo += 1; if(b.lo == 0) b.hi += 1; } bool rv = div128_o(*(uint128_t*)&a, *(uint128_t*)&b, (uint128_t*)q, (uint128_t*)r); if(sgnb != sgnb) { r->hi = ~r->hi; r->lo = ~r->lo; r->lo += 1; if(r->lo == 0) r->hi += 1; } return rv; }
static inline int128_t add128s(int128_t a, int128_t b) { int128_t v; add128s_o(a, b, &v); return v; }
static inline int128_t sub128s(int128_t a, int128_t b) { int128_t v; sub128s_o(a, b, &v); return v; }
static inline int128_t mul128s(int128_t a, int128_t b) { int128_t v; mul128s_o(a, b, &v); return v; }
static inline int128_t div128s(int128_t a, int128_t b) { int128_t v; div128s_o(a, b, &v, NULL); return v; }
static inline int128_t mod128s(int128_t a, int128_t b) { int128_t v; div128s_o(a, b, NULL, &v); return v; }
static inline int128_t and128s(int128_t a, int128_t b) { int128_t v = { a.lo & b.lo, a.hi & b.hi }; return v; }
static inline int128_t or128s (int128_t a, int128_t b) { int128_t v = { a.lo | b.lo, a.hi | b.hi }; return v; }
static inline int128_t xor128s(int128_t a, int128_t b) { int128_t v = { a.lo ^ b.lo, a.hi ^ b.hi }; return v; }
static inline int128_t shl128s(int128_t a, uint32_t b) { int128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = a.lo << b; v.hi = (a.hi << b) | (a.lo >> (64 - b)); } else { v.hi = a.lo << (b - 64); v.lo = 0; } return v; }
static inline int128_t shr128s(int128_t a, uint32_t b) { int128_t v; if(b == 0) { return a; } else if(b < 64) { v.lo = (a.lo >> b)|(a.hi << (64 - b)); v.hi = (int64_t)a.hi >> b; } else { v.lo = (int64_t)a.hi >> (b - 64); v.hi = (int64_t)a.hi < 0 ? -1 : 0; } return v; }

static inline int slice_cmp(SLICE_PTR l, SLICE_PTR r) {
	int rv = memcmp(l.PTR, r.PTR, l.META < r.META ? l.META : r.META);
	if(rv != 0) return rv;
	if(l.META < r.META) return -1;
	if(l.META > r.META) return 1;
	return 0;
}
static inline SLICE_PTR make_sliceptr(void* ptr, size_t s) { SLICE_PTR rv = { ptr, s }; return rv; }
static inline TRAITOBJ_PTR make_traitobjptr(void* ptr, void* vt) { TRAITOBJ_PTR rv = { ptr, vt }; return rv; }

static inline size_t mrustc_max(size_t a, size_t b) { return a < b ? b : a; }
static inline void noop_drop(tUNIT *p) { }

static inline size_t mrustc_string_search_linear(SLICE_PTR val, size_t count, SLICE_PTR* options) {
	for(size_t i = 0; i < count; i ++) {
		int cmp = slice_cmp(val, options[i]);
		if(cmp < 0) break;
		if(cmp == 0) return i;
	}
	return SIZE_MAX;
}
static const uint8_t __mrustc_revmap[16] = { 0, 8, 4,12, 2,10, 6,14,  1, 9, 5,13, 3, 7,15};
static inline uint8_t __mrustc_bitrev8(uint8_t v) { if(v==0||v==0xFF) return v; return __mrustc_revmap[v>>4]|(__mrustc_revmap[v&15]<<4); }
static inline uint16_t __mrustc_bitrev16(uint16_t v) { if(v==0) return 0; return ((uint16_t)__mrustc_bitrev8(v>>8))|((uint16_t)__mrustc_bitrev8(v)<<8); }
static inline uint32_t __mrustc_bitrev32(uint32_t v) { if(v==0) return 0; return ((uint32_t)__mrustc_bitrev16(v>>16))|((uint32_t)__mrustc_bitrev16(v)<<16); }
static inline uint64_t __mrustc_bitrev64(uint64_t v) { if(v==0) return 0; return ((uint64_t)__mrustc_bitrev32(v>>32))|((uint64_t)__mrustc_bitrev32(v)<<32); }
static inline uint128_t __mrustc_bitrev128(uint128_t v) { uint128_t rv = { __mrustc_bitrev64(v.hi), __mrustc_bitrev64(v.lo) }; return rv; }
static inline uint8_t __mrustc_op_umax8(uint8_t a, uint8_t b) { return (a > b ? a : b); }
static inline uint8_t __mrustc_op_umin8(uint8_t a, uint8_t b) { return (a < b ? a : b); }
static inline uint8_t __mrustc_op_imax8(uint8_t a, uint8_t b) { return ((int8_t)a > (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_imin8(uint8_t a, uint8_t b) { return ((int8_t)a < (int8_t)b ? a : b); }
static inline uint8_t __mrustc_op_and_not8(uint8_t a, uint8_t b) { return ~(a & b); }
static inline uint16_t __mrustc_op_umax16(uint16_t a, uint16_t b) { return (a > b ? a : b); }
static inline uint16_t __mrustc_op_umin16(uint16_t a, uint16_t b) { return (a < b ? a : b); }
static inline uint16_t __mrustc_op_imax16(uint16_t a, uint16_t b) { return ((int16_t)a > (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_imin16(uint16_t a, uint16_t b) { return ((int16_t)a < (int16_t)b ? a : b); }
static inline uint16_t __mrustc_op_and_not16(uint16_t a, uint16_t b) { return ~(a & b); }
static inline uint32_t __mrustc_op_umax32(uint32_t a, uint32_t b) { return (a > b ? a : b); }
static inline uint32_t __mrustc_op_umin32(uint32_t a, uint32_t b) { return (a < b ? a : b); }
static inline uint32_t __mrustc_op_imax32(uint32_t a, uint32_t b) { return ((int32_t)a > (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_imin32(uint32_t a, uint32_t b) { return ((int32_t)a < (int32_t)b ? a : b); }
static inline uint32_t __mrustc_op_and_not32(uint32_t a, uint32_t b) { return ~(a & b); }
static inline uint64_t __mrustc_op_umax64(uint64_t a, uint64_t b) { return (a > b ? a : b); }
static inline uint64_t __mrustc_op_umin64(uint64_t a, uint64_t b) { return (a < b ? a : b); }
static inline uint64_t __mrustc_op_imax64(uint64_t a, uint64_t b) { return ((int64_t)a > (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_imin64(uint64_t a, uint64_t b) { return ((int64_t)a < (int64_t)b ? a : b); }
static inline uint64_t __mrustc_op_and_not64(uint64_t a, uint64_t b) { return ~(a & b); }
typedef struct t_ZRTA3Cf  { int32_t  DATA[3]; } t_ZRTA3Cf ; // [i32; 3]
// struct ::"bin#"::A
struct s_ZRG1cD3bin1A0g  {
	/*@0*/t_ZRTA3Cf _0; // [i32; 3]
} ;
typedef char sizeof_assert_ZRG1cD3bin1A0g[ (sizeof(struct s_ZRG1cD3bin1A0g) == 12) ? 1 : -1 ];
typedef char alignof_assert_ZRG1cD3bin1A0g[ (ALIGNOF(struct s_ZRG1cD3bin1A0g) == 4) ? 1 : -1 ];
typedef void (*t_ZRTF0T0 )(void); // extern "Rust" fn() -> ()
// struct ::"std-0_0_0"::rt::closure#lang_start_0<(),>
struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0  {
	/*@0*/t_ZRTF0T0 _0; // extern "Rust" fn() -> ()
} ;
typedef char sizeof_assert_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0[ (sizeof(struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0) == 8) ? 1 : -1 ];
typedef char alignof_assert_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0[ (ALIGNOF(struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0) == 8) ? 1 : -1 ];
typedef void (*t_ZRTF1PoT0T0 )( tUNIT * ); // extern "Rust" fn(*move (), ) -> ()
typedef int32_t  (*t_ZRTFeE8rustcall2BsT0T0Cf )( tUNIT *, tUNIT  ); // extern "rust-call" fn(&(), (), ) -> i32
typedef int32_t  (*t_ZRTFeE8rustcall2BuT0T0Cf )( tUNIT *, tUNIT  ); // extern "rust-call" fn(&mut (), (), ) -> i32
// struct ::"core-0_0_0"::ops::function::Fn#vtable<(),i32,>
struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf  {
	/*@0*/t_ZRTF1PoT0T0 _0; // extern "Rust" fn(*move (), ) -> ()
	/*@8*/uintptr_t _1; // usize
	/*@16*/uintptr_t _2; // usize
	/*@24*/t_ZRTFeE8rustcall2BsT0T0Cf _3; // extern "rust-call" fn(&(), (), ) -> i32
	/*@32*/t_ZRTFeE8rustcall2BuT0T0Cf _4; // extern "rust-call" fn(&mut (), (), ) -> i32
} ;
typedef char sizeof_assert_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf[ (sizeof(struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf) == 40) ? 1 : -1 ];
typedef char alignof_assert_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf[ (ALIGNOF(struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf) == 8) ? 1 : -1 ];
// PROTO extern "Rust" ::"bin#"::main
void  ZRG1cD3bin4main0g(void);
// PROTO extern "Rust" ::"std-0_0_0"::rt::lang_start
static intptr_t  ZRG2cD8std0_0_02rt10lang_start0g(
		t_ZRTF0T0 arg0,
		intptr_t arg1,
		uint8_t **arg2
		);
// PROTO extern "Rust" <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ /*- */>::#drop_glue
static void  ZRIG2cD8std0_0_02rtH19closurelang_start_01gT0A9drop_glue0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0
		);
// PROTO extern "Rust" <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::call
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT04call0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		);
// PROTO extern "Rust" <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(),>>::call_mut
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function5FnMut1gT08call_mut0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		);
// PROTO extern "Rust" <() as ::"std-0_0_0"::process::Termination>::report
static int32_t  ZRQT02cD8std0_0_07process11Termination0g6report0g(
		tUNIT arg0
		);
// EXTERN extern "Rust" ::"std-0_0_0"::rt::lang_start_internal
extern intptr_t  ZRG2cD8std0_0_02rt19lang_start_internal0g(
		TRAITOBJ_PTR arg0,
		intptr_t arg1,
		uint8_t **arg2
		);
__attribute__((weak)) union u_static_ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g{ struct s_ZRG3cE9core0_0_03ops8functionC8Fnvtable2gT0Cf val; uintptr_t raw[5]; } ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g;	// static <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::vtable# : ::"core-0_0_0"::ops::function::Fn#vtable<(),i32,>/*S*/
union u_static_ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g = { .raw = {(uintptr_t)&ZRIG2cD8std0_0_02rtH19closurelang_start_01gT0A9drop_glue0g,0x8ull,0x8ull,(uintptr_t)&ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT04call0g,(uintptr_t)&ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function5FnMut1gT08call_mut0g} };	// static <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::vtable# : ::"core-0_0_0"::ops::function::Fn#vtable<(),i32,>/*S*/ = 0010000000000000 0800000000000000 0800000000000000 0010000000000000 0010000000000000{@0x0+8 = &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ /*- */>::#drop_glue, @0x18+8 = &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::call, @0x20+8 = &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(),>>::call_mut}
// ::"bin#"::main
void  ZRG1cD3bin4main0g(void)
{
	tUNIT rv;
	struct s_ZRG1cD3bin1A0g var0;	// ::"bin#"::A/*S*/
	t_ZRTA3Cf var1;	// [i32; 3]
	var1.DATA[0] = 1;
	var1.DATA[1] = 2;
	var1.DATA[2] = 3;	// _1 = Array(+1 i32, +2 i32, +3 i32)
	var0._0 = var1;	// _0 = Struct(::"bin#"::A, {_1})
	// ^ drop(_0)
	/* ZST assign */
	return ;
	// ^ Return
}
// ::"std-0_0_0"::rt::lang_start
static intptr_t  ZRG2cD8std0_0_02rt10lang_start0g(
		t_ZRTF0T0 arg0,
		intptr_t arg1,
		uint8_t **arg2
		)
{
	intptr_t rv;
	struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 var0;	// ::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/
	struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *var1;	// &::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/
	TRAITOBJ_PTR var2;	// &dyn (::"core-0_0_0"::ops::function::Fn<(),Output{::"core-0_0_0"::ops::function::FnOnce<(),>}=i32,>+::"core-0_0_0"::marker::Sync+::"std-0_0_0"::panic::RefUnwindSafe+'_)
	var0._0 = arg0;	// _0 = Struct(::"std-0_0_0"::rt::closure#lang_start_0<(),>, {a0})
	var1 = & var0;	// _1 = Borrow(Shared, _0)
	var2 = make_traitobjptr(var1, &ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT0G6vtable0g.val);	// _2 = MakeDst(_1, &<::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::vtable#)
	rv = ZRG2cD8std0_0_02rt19lang_start_internal0g( var2, arg1, arg2 );
	// ^ Call( retval = ::"std-0_0_0"::rt::lang_start_internal( _2, a1, a2, ), bb1, bb2)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ /*- */>::#drop_glue
static void  ZRIG2cD8std0_0_02rtH19closurelang_start_01gT0A9drop_glue0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0
		)
{
	tUNIT rv;
	/* ZST assign */
	return ;
	// ^ Return
}
// <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::Fn<(),>>::call
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function2Fn1gT04call0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		)
{
	int32_t rv;
	t_ZRTF0T0 var0;	// extern "Rust" fn() -> ()
	tUNIT var1 = {0};	// ()
	var0 = arg0->_0;	// _0 = Use(a0*.0)
	(var0)( );
	// ^ Call( _1 = (_0)( ), bb1, bb2)
	rv = 0;	// retval = Constant(+0 i32)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <::"std-0_0_0"::rt::closure#lang_start_0<(),>/*S*/ as ::"core-0_0_0"::ops::function::FnMut<(),>>::call_mut
static int32_t  ZRQG2cD8std0_0_02rtH19closurelang_start_01gT03cE9core0_0_03ops8function5FnMut1gT08call_mut0g(
		struct s_ZRG2cD8std0_0_02rtH19closurelang_start_01gT0 *arg0,
		tUNIT arg1
		)
{
	int32_t rv;
	t_ZRTF0T0 var0;	// extern "Rust" fn() -> ()
	tUNIT var1 = {0};	// ()
	var0 = arg0->_0;	// _0 = Use(a0*.0)
	(var0)( );
	// ^ Call( _1 = (_0)( ), bb1, bb2)
	rv = 0;	// retval = Constant(+0 i32)
	// ^ drop(a0)
	return rv;
	// ^ Return
bb2: _Unwind_Resume(); // Diverge
}
// <() as ::"std-0_0_0"::process::Termination>::report
static int32_t  ZRQT02cD8std0_0_07process11Termination0g6report0g(
		tUNIT arg0
		)
{
	int32_t rv;
	rv = 0;	// retval = Constant(+0 i32)
	return rv;
	// ^ Return
}
int main(int argc, const char* argv[]) {
	return ZRG2cD8std0_0_02rt10lang_start0g(ZRG1cD3bin4main0g, argc, (uint8_t**)argv);
}
__thread jmp_buf* mrustc_panic_target;
__thread void* mrustc_panic_value;
int8_t* __rust_alloc(uintptr_t a0, uintptr_t a1) {
	extern int8_t* __rdl_alloc(uintptr_t a0, uintptr_t a1);
	return __rdl_alloc(a0, a1);
}
void __rust_dealloc(int8_t* a0, uintptr_t a1, uintptr_t a2) {
	extern void __rdl_dealloc(int8_t* a0, uintptr_t a1, uintptr_t a2);
	__rdl_dealloc(a0, a1, a2);
}
int8_t* __rust_realloc(int8_t* a0, uintptr_t a1, uintptr_t a2, uintptr_t a3) {
	extern int8_t* __rdl_realloc(int8_t* a0, uintptr_t a1, uintptr_t a2, uintptr_t a3);
	return __rdl_realloc(a0, a1, a2, a3);
}
int8_t* __rust_alloc_zeroed(uintptr_t a0, uintptr_t a1) {
	extern int8_t* __rdl_alloc_zeroed(uintptr_t a0, uintptr_t a1);
	return __rdl_alloc_zeroed(a0, a1);
}
struct s_ZRG2c4core5alloc6Layout0g_A { uintptr_t a, b; };
void oom_impl(struct s_ZRG2c4core5alloc6Layout0g_A l) { extern void ZRG2cD8std0_0_05alloc8rust_oom0g(struct s_ZRG2c4core5alloc6Layout0g_A l); ZRG2cD8std0_0_05alloc8rust_oom0g(l); }
uint32_t panic_impl(uintptr_t payload) {extern uint32_t ZRG2cD8std0_0_09panicking16rust_begin_panic0g(uintptr_t payload);return ZRG2cD8std0_0_09panicking16rust_begin_panic0g(payload);}
